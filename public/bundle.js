/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(4);
	module.exports = __webpack_require__(6);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(3))

/***/ },
/* 2 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery v2.2.4 | (c) jQuery Foundation | jquery.org/license */\n!function (a, b) {\n  \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && \"object\" == _typeof(module.exports) ? module.exports = a.document ? b(a, !0) : function (a) {\n    if (!a.document) throw new Error(\"jQuery requires a window with a document\");return b(a);\n  } : b(a);\n}(\"undefined\" != typeof window ? window : undefined, function (a, b) {\n  var c = [],\n      d = a.document,\n      e = c.slice,\n      f = c.concat,\n      g = c.push,\n      h = c.indexOf,\n      i = {},\n      j = i.toString,\n      k = i.hasOwnProperty,\n      l = {},\n      m = \"2.2.4\",\n      n = function n(a, b) {\n    return new n.fn.init(a, b);\n  },\n      o = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      p = /^-ms-/,\n      q = /-([\\da-z])/gi,\n      r = function r(a, b) {\n    return b.toUpperCase();\n  };n.fn = n.prototype = { jquery: m, constructor: n, selector: \"\", length: 0, toArray: function toArray() {\n      return e.call(this);\n    }, get: function get(a) {\n      return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this);\n    }, pushStack: function pushStack(a) {\n      var b = n.merge(this.constructor(), a);return b.prevObject = this, b.context = this.context, b;\n    }, each: function each(a) {\n      return n.each(this, a);\n    }, map: function map(a) {\n      return this.pushStack(n.map(this, function (b, c) {\n        return a.call(b, c, b);\n      }));\n    }, slice: function slice() {\n      return this.pushStack(e.apply(this, arguments));\n    }, first: function first() {\n      return this.eq(0);\n    }, last: function last() {\n      return this.eq(-1);\n    }, eq: function eq(a) {\n      var b = this.length,\n          c = +a + (0 > a ? b : 0);return this.pushStack(c >= 0 && b > c ? [this[c]] : []);\n    }, end: function end() {\n      return this.prevObject || this.constructor();\n    }, push: g, sort: c.sort, splice: c.splice }, n.extend = n.fn.extend = function () {\n    var a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g = arguments[0] || {},\n        h = 1,\n        i = arguments.length,\n        j = !1;for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == (typeof g === \"undefined\" ? \"undefined\" : _typeof(g)) || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) {\n      if (null != (a = arguments[h])) for (b in a) {\n        c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n      }\n    }return g;\n  }, n.extend({ expando: \"jQuery\" + (m + Math.random()).replace(/\\D/g, \"\"), isReady: !0, error: function error(a) {\n      throw new Error(a);\n    }, noop: function noop() {}, isFunction: function isFunction(a) {\n      return \"function\" === n.type(a);\n    }, isArray: Array.isArray, isWindow: function isWindow(a) {\n      return null != a && a === a.window;\n    }, isNumeric: function isNumeric(a) {\n      var b = a && a.toString();return !n.isArray(a) && b - parseFloat(b) + 1 >= 0;\n    }, isPlainObject: function isPlainObject(a) {\n      var b;if (\"object\" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1;if (a.constructor && !k.call(a, \"constructor\") && !k.call(a.constructor.prototype || {}, \"isPrototypeOf\")) return !1;for (b in a) {}return void 0 === b || k.call(a, b);\n    }, isEmptyObject: function isEmptyObject(a) {\n      var b;for (b in a) {\n        return !1;\n      }return !0;\n    }, type: function type(a) {\n      return null == a ? a + \"\" : \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) || \"function\" == typeof a ? i[j.call(a)] || \"object\" : typeof a === \"undefined\" ? \"undefined\" : _typeof(a);\n    }, globalEval: function globalEval(a) {\n      var b,\n          c = eval;a = n.trim(a), a && (1 === a.indexOf(\"use strict\") ? (b = d.createElement(\"script\"), b.text = a, d.head.appendChild(b).parentNode.removeChild(b)) : c(a));\n    }, camelCase: function camelCase(a) {\n      return a.replace(p, \"ms-\").replace(q, r);\n    }, nodeName: function nodeName(a, b) {\n      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();\n    }, each: function each(a, b) {\n      var c,\n          d = 0;if (s(a)) {\n        for (c = a.length; c > d; d++) {\n          if (b.call(a[d], d, a[d]) === !1) break;\n        }\n      } else for (d in a) {\n        if (b.call(a[d], d, a[d]) === !1) break;\n      }return a;\n    }, trim: function trim(a) {\n      return null == a ? \"\" : (a + \"\").replace(o, \"\");\n    }, makeArray: function makeArray(a, b) {\n      var c = b || [];return null != a && (s(Object(a)) ? n.merge(c, \"string\" == typeof a ? [a] : a) : g.call(c, a)), c;\n    }, inArray: function inArray(a, b, c) {\n      return null == b ? -1 : h.call(b, a, c);\n    }, merge: function merge(a, b) {\n      for (var c = +b.length, d = 0, e = a.length; c > d; d++) {\n        a[e++] = b[d];\n      }return a.length = e, a;\n    }, grep: function grep(a, b, c) {\n      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) {\n        d = !b(a[f], f), d !== h && e.push(a[f]);\n      }return e;\n    }, map: function map(a, b, c) {\n      var d,\n          e,\n          g = 0,\n          h = [];if (s(a)) for (d = a.length; d > g; g++) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      } else for (g in a) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      }return f.apply([], h);\n    }, guid: 1, proxy: function proxy(a, b) {\n      var c, d, f;return \"string\" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (d = e.call(arguments, 2), f = function f() {\n        return a.apply(b || this, d.concat(e.call(arguments)));\n      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0;\n    }, now: Date.now, support: l }), \"function\" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (a, b) {\n    i[\"[object \" + b + \"]\"] = b.toLowerCase();\n  });function s(a) {\n    var b = !!a && \"length\" in a && a.length,\n        c = n.type(a);return \"function\" === c || n.isWindow(a) ? !1 : \"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a;\n  }var t = function (a) {\n    var b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n,\n        o,\n        p,\n        q,\n        r,\n        s,\n        t,\n        u = \"sizzle\" + 1 * new Date(),\n        v = a.document,\n        w = 0,\n        x = 0,\n        y = ga(),\n        z = ga(),\n        A = ga(),\n        B = function B(a, b) {\n      return a === b && (l = !0), 0;\n    },\n        C = 1 << 31,\n        D = {}.hasOwnProperty,\n        E = [],\n        F = E.pop,\n        G = E.push,\n        H = E.push,\n        I = E.slice,\n        J = function J(a, b) {\n      for (var c = 0, d = a.length; d > c; c++) {\n        if (a[c] === b) return c;\n      }return -1;\n    },\n        K = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n        L = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        M = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n        N = \"\\\\[\" + L + \"*(\" + M + \")(?:\" + L + \"*([*^$|!~]?=)\" + L + \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + M + \"))|)\" + L + \"*\\\\]\",\n        O = \":(\" + M + \")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + N + \")*)|.*)\\\\)|)\",\n        P = new RegExp(L + \"+\", \"g\"),\n        Q = new RegExp(\"^\" + L + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + L + \"+$\", \"g\"),\n        R = new RegExp(\"^\" + L + \"*,\" + L + \"*\"),\n        S = new RegExp(\"^\" + L + \"*([>+~]|\" + L + \")\" + L + \"*\"),\n        T = new RegExp(\"=\" + L + \"*([^\\\\]'\\\"]*?)\" + L + \"*\\\\]\", \"g\"),\n        U = new RegExp(O),\n        V = new RegExp(\"^\" + M + \"$\"),\n        W = { ID: new RegExp(\"^#(\" + M + \")\"), CLASS: new RegExp(\"^\\\\.(\" + M + \")\"), TAG: new RegExp(\"^(\" + M + \"|[*])\"), ATTR: new RegExp(\"^\" + N), PSEUDO: new RegExp(\"^\" + O), CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + L + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + L + \"*(?:([+-]|)\" + L + \"*(\\\\d+)|))\" + L + \"*\\\\)|)\", \"i\"), bool: new RegExp(\"^(?:\" + K + \")$\", \"i\"), needsContext: new RegExp(\"^\" + L + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + L + \"*((?:-\\\\d)?\\\\d*)\" + L + \"*\\\\)|)(?=[^-]|$)\", \"i\") },\n        X = /^(?:input|select|textarea|button)$/i,\n        Y = /^h\\d$/i,\n        Z = /^[^{]+\\{\\s*\\[native \\w/,\n        $ = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        _ = /[+~]/,\n        aa = /'|\\\\/g,\n        ba = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + L + \"?|(\" + L + \")|.)\", \"ig\"),\n        ca = function ca(a, b, c) {\n      var d = \"0x\" + b - 65536;return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);\n    },\n        da = function da() {\n      m();\n    };try {\n      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;\n    } catch (ea) {\n      H = { apply: E.length ? function (a, b) {\n          G.apply(a, I.call(b));\n        } : function (a, b) {\n          var c = a.length,\n              d = 0;while (a[c++] = b[d++]) {}a.length = c - 1;\n        } };\n    }function fa(a, b, d, e) {\n      var f,\n          h,\n          j,\n          k,\n          l,\n          o,\n          r,\n          s,\n          w = b && b.ownerDocument,\n          x = b ? b.nodeType : 9;if (d = d || [], \"string\" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d;if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {\n        if (11 !== x && (o = $.exec(a))) if (f = o[1]) {\n          if (9 === x) {\n            if (!(j = b.getElementById(f))) return d;if (j.id === f) return d.push(j), d;\n          } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d;\n        } else {\n          if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d;if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d;\n        }if (c.qsa && !A[a + \" \"] && (!q || !q.test(a))) {\n          if (1 !== x) w = b, s = a;else if (\"object\" !== b.nodeName.toLowerCase()) {\n            (k = b.getAttribute(\"id\")) ? k = k.replace(aa, \"\\\\$&\") : b.setAttribute(\"id\", k = u), r = g(a), h = r.length, l = V.test(k) ? \"#\" + k : \"[id='\" + k + \"']\";while (h--) {\n              r[h] = l + \" \" + qa(r[h]);\n            }s = r.join(\",\"), w = _.test(a) && oa(b.parentNode) || b;\n          }if (s) try {\n            return H.apply(d, w.querySelectorAll(s)), d;\n          } catch (y) {} finally {\n            k === u && b.removeAttribute(\"id\");\n          }\n        }\n      }return i(a.replace(Q, \"$1\"), b, d, e);\n    }function ga() {\n      var a = [];function b(c, e) {\n        return a.push(c + \" \") > d.cacheLength && delete b[a.shift()], b[c + \" \"] = e;\n      }return b;\n    }function ha(a) {\n      return a[u] = !0, a;\n    }function ia(a) {\n      var b = n.createElement(\"div\");try {\n        return !!a(b);\n      } catch (c) {\n        return !1;\n      } finally {\n        b.parentNode && b.parentNode.removeChild(b), b = null;\n      }\n    }function ja(a, b) {\n      var c = a.split(\"|\"),\n          e = c.length;while (e--) {\n        d.attrHandle[c[e]] = b;\n      }\n    }function ka(a, b) {\n      var c = b && a,\n          d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);if (d) return d;if (c) while (c = c.nextSibling) {\n        if (c === b) return -1;\n      }return a ? 1 : -1;\n    }function la(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return \"input\" === c && b.type === a;\n      };\n    }function ma(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return (\"input\" === c || \"button\" === c) && b.type === a;\n      };\n    }function na(a) {\n      return ha(function (b) {\n        return b = +b, ha(function (c, d) {\n          var e,\n              f = a([], c.length, b),\n              g = f.length;while (g--) {\n            c[e = f[g]] && (c[e] = !(d[e] = c[e]));\n          }\n        });\n      });\n    }function oa(a) {\n      return a && \"undefined\" != typeof a.getElementsByTagName && a;\n    }c = fa.support = {}, f = fa.isXML = function (a) {\n      var b = a && (a.ownerDocument || a).documentElement;return b ? \"HTML\" !== b.nodeName : !1;\n    }, m = fa.setDocument = function (a) {\n      var b,\n          e,\n          g = a ? a.ownerDocument || a : v;return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener(\"unload\", da, !1) : e.attachEvent && e.attachEvent(\"onunload\", da)), c.attributes = ia(function (a) {\n        return a.className = \"i\", !a.getAttribute(\"className\");\n      }), c.getElementsByTagName = ia(function (a) {\n        return a.appendChild(n.createComment(\"\")), !a.getElementsByTagName(\"*\").length;\n      }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function (a) {\n        return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length;\n      }), c.getById ? (d.find.ID = function (a, b) {\n        if (\"undefined\" != typeof b.getElementById && p) {\n          var c = b.getElementById(a);return c ? [c] : [];\n        }\n      }, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          return a.getAttribute(\"id\") === b;\n        };\n      }) : (delete d.find.ID, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          var c = \"undefined\" != typeof a.getAttributeNode && a.getAttributeNode(\"id\");return c && c.value === b;\n        };\n      }), d.find.TAG = c.getElementsByTagName ? function (a, b) {\n        return \"undefined\" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;\n      } : function (a, b) {\n        var c,\n            d = [],\n            e = 0,\n            f = b.getElementsByTagName(a);if (\"*\" === a) {\n          while (c = f[e++]) {\n            1 === c.nodeType && d.push(c);\n          }return d;\n        }return f;\n      }, d.find.CLASS = c.getElementsByClassName && function (a, b) {\n        return \"undefined\" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0;\n      }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function (a) {\n        o.appendChild(a).innerHTML = \"<a id='\" + u + \"'></a><select id='\" + u + \"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\", a.querySelectorAll(\"[msallowcapture^='']\").length && q.push(\"[*^$]=\" + L + \"*(?:''|\\\"\\\")\"), a.querySelectorAll(\"[selected]\").length || q.push(\"\\\\[\" + L + \"*(?:value|\" + K + \")\"), a.querySelectorAll(\"[id~=\" + u + \"-]\").length || q.push(\"~=\"), a.querySelectorAll(\":checked\").length || q.push(\":checked\"), a.querySelectorAll(\"a#\" + u + \"+*\").length || q.push(\".#.+[+~]\");\n      }), ia(function (a) {\n        var b = n.createElement(\"input\");b.setAttribute(\"type\", \"hidden\"), a.appendChild(b).setAttribute(\"name\", \"D\"), a.querySelectorAll(\"[name=d]\").length && q.push(\"name\" + L + \"*[*^$|!~]?=\"), a.querySelectorAll(\":enabled\").length || q.push(\":enabled\", \":disabled\"), a.querySelectorAll(\"*,:x\"), q.push(\",.*:\");\n      })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function (a) {\n        c.disconnectedMatch = s.call(a, \"div\"), s.call(a, \"[s!='']:x\"), r.push(\"!=\", O);\n      }), q = q.length && new RegExp(q.join(\"|\")), r = r.length && new RegExp(r.join(\"|\")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function (a, b) {\n        var c = 9 === a.nodeType ? a.documentElement : a,\n            d = b && b.parentNode;return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));\n      } : function (a, b) {\n        if (b) while (b = b.parentNode) {\n          if (b === a) return !0;\n        }return !1;\n      }, B = b ? function (a, b) {\n        if (a === b) return l = !0, 0;var d = !a.compareDocumentPosition - !b.compareDocumentPosition;return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);\n      } : function (a, b) {\n        if (a === b) return l = !0, 0;var c,\n            d = 0,\n            e = a.parentNode,\n            f = b.parentNode,\n            g = [a],\n            h = [b];if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;if (e === f) return ka(a, b);c = a;while (c = c.parentNode) {\n          g.unshift(c);\n        }c = b;while (c = c.parentNode) {\n          h.unshift(c);\n        }while (g[d] === h[d]) {\n          d++;\n        }return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0;\n      }, n) : n;\n    }, fa.matches = function (a, b) {\n      return fa(a, null, null, b);\n    }, fa.matchesSelector = function (a, b) {\n      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, \"='$1']\"), c.matchesSelector && p && !A[b + \" \"] && (!r || !r.test(b)) && (!q || !q.test(b))) try {\n        var d = s.call(a, b);if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;\n      } catch (e) {}return fa(b, n, null, [a]).length > 0;\n    }, fa.contains = function (a, b) {\n      return (a.ownerDocument || a) !== n && m(a), t(a, b);\n    }, fa.attr = function (a, b) {\n      (a.ownerDocument || a) !== n && m(a);var e = d.attrHandle[b.toLowerCase()],\n          f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;\n    }, fa.error = function (a) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + a);\n    }, fa.uniqueSort = function (a) {\n      var b,\n          d = [],\n          e = 0,\n          f = 0;if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {\n        while (b = a[f++]) {\n          b === a[f] && (e = d.push(f));\n        }while (e--) {\n          a.splice(d[e], 1);\n        }\n      }return k = null, a;\n    }, e = fa.getText = function (a) {\n      var b,\n          c = \"\",\n          d = 0,\n          f = a.nodeType;if (f) {\n        if (1 === f || 9 === f || 11 === f) {\n          if (\"string\" == typeof a.textContent) return a.textContent;for (a = a.firstChild; a; a = a.nextSibling) {\n            c += e(a);\n          }\n        } else if (3 === f || 4 === f) return a.nodeValue;\n      } else while (b = a[d++]) {\n        c += e(b);\n      }return c;\n    }, d = fa.selectors = { cacheLength: 50, createPseudo: ha, match: W, attrHandle: {}, find: {}, relative: { \">\": { dir: \"parentNode\", first: !0 }, \" \": { dir: \"parentNode\" }, \"+\": { dir: \"previousSibling\", first: !0 }, \"~\": { dir: \"previousSibling\" } }, preFilter: { ATTR: function ATTR(a) {\n          return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || \"\").replace(ba, ca), \"~=\" === a[2] && (a[3] = \" \" + a[3] + \" \"), a.slice(0, 4);\n        }, CHILD: function CHILD(a) {\n          return a[1] = a[1].toLowerCase(), \"nth\" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * (\"even\" === a[3] || \"odd\" === a[3])), a[5] = +(a[7] + a[8] || \"odd\" === a[3])) : a[3] && fa.error(a[0]), a;\n        }, PSEUDO: function PSEUDO(a) {\n          var b,\n              c = !a[6] && a[2];return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || \"\" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(\")\", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));\n        } }, filter: { TAG: function TAG(a) {\n          var b = a.replace(ba, ca).toLowerCase();return \"*\" === a ? function () {\n            return !0;\n          } : function (a) {\n            return a.nodeName && a.nodeName.toLowerCase() === b;\n          };\n        }, CLASS: function CLASS(a) {\n          var b = y[a + \" \"];return b || (b = new RegExp(\"(^|\" + L + \")\" + a + \"(\" + L + \"|$)\")) && y(a, function (a) {\n            return b.test(\"string\" == typeof a.className && a.className || \"undefined\" != typeof a.getAttribute && a.getAttribute(\"class\") || \"\");\n          });\n        }, ATTR: function ATTR(a, b, c) {\n          return function (d) {\n            var e = fa.attr(d, a);return null == e ? \"!=\" === b : b ? (e += \"\", \"=\" === b ? e === c : \"!=\" === b ? e !== c : \"^=\" === b ? c && 0 === e.indexOf(c) : \"*=\" === b ? c && e.indexOf(c) > -1 : \"$=\" === b ? c && e.slice(-c.length) === c : \"~=\" === b ? (\" \" + e.replace(P, \" \") + \" \").indexOf(c) > -1 : \"|=\" === b ? e === c || e.slice(0, c.length + 1) === c + \"-\" : !1) : !0;\n          };\n        }, CHILD: function CHILD(a, b, c, d, e) {\n          var f = \"nth\" !== a.slice(0, 3),\n              g = \"last\" !== a.slice(-4),\n              h = \"of-type\" === b;return 1 === d && 0 === e ? function (a) {\n            return !!a.parentNode;\n          } : function (b, c, i) {\n            var j,\n                k,\n                l,\n                m,\n                n,\n                o,\n                p = f !== g ? \"nextSibling\" : \"previousSibling\",\n                q = b.parentNode,\n                r = h && b.nodeName.toLowerCase(),\n                s = !i && !h,\n                t = !1;if (q) {\n              if (f) {\n                while (p) {\n                  m = b;while (m = m[p]) {\n                    if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;\n                  }o = p = \"only\" === a && !o && \"nextSibling\";\n                }return !0;\n              }if (o = [g ? q.firstChild : q.lastChild], g && s) {\n                m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                  if (1 === m.nodeType && ++t && m === b) {\n                    k[a] = [w, n, t];break;\n                  }\n                }\n              } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;\n              }return t -= e, t === d || t % d === 0 && t / d >= 0;\n            }\n          };\n        }, PSEUDO: function PSEUDO(a, b) {\n          var c,\n              e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error(\"unsupported pseudo: \" + a);return e[u] ? e(b) : e.length > 1 ? (c = [a, a, \"\", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function (a, c) {\n            var d,\n                f = e(a, b),\n                g = f.length;while (g--) {\n              d = J(a, f[g]), a[d] = !(c[d] = f[g]);\n            }\n          }) : function (a) {\n            return e(a, 0, c);\n          }) : e;\n        } }, pseudos: { not: ha(function (a) {\n          var b = [],\n              c = [],\n              d = h(a.replace(Q, \"$1\"));return d[u] ? ha(function (a, b, c, e) {\n            var f,\n                g = d(a, null, e, []),\n                h = a.length;while (h--) {\n              (f = g[h]) && (a[h] = !(b[h] = f));\n            }\n          }) : function (a, e, f) {\n            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();\n          };\n        }), has: ha(function (a) {\n          return function (b) {\n            return fa(a, b).length > 0;\n          };\n        }), contains: ha(function (a) {\n          return a = a.replace(ba, ca), function (b) {\n            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;\n          };\n        }), lang: ha(function (a) {\n          return V.test(a || \"\") || fa.error(\"unsupported lang: \" + a), a = a.replace(ba, ca).toLowerCase(), function (b) {\n            var c;do {\n              if (c = p ? b.lang : b.getAttribute(\"xml:lang\") || b.getAttribute(\"lang\")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + \"-\");\n            } while ((b = b.parentNode) && 1 === b.nodeType);return !1;\n          };\n        }), target: function target(b) {\n          var c = a.location && a.location.hash;return c && c.slice(1) === b.id;\n        }, root: function root(a) {\n          return a === o;\n        }, focus: function focus(a) {\n          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);\n        }, enabled: function enabled(a) {\n          return a.disabled === !1;\n        }, disabled: function disabled(a) {\n          return a.disabled === !0;\n        }, checked: function checked(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && !!a.checked || \"option\" === b && !!a.selected;\n        }, selected: function selected(a) {\n          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;\n        }, empty: function empty(a) {\n          for (a = a.firstChild; a; a = a.nextSibling) {\n            if (a.nodeType < 6) return !1;\n          }return !0;\n        }, parent: function parent(a) {\n          return !d.pseudos.empty(a);\n        }, header: function header(a) {\n          return Y.test(a.nodeName);\n        }, input: function input(a) {\n          return X.test(a.nodeName);\n        }, button: function button(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && \"button\" === a.type || \"button\" === b;\n        }, text: function text(a) {\n          var b;return \"input\" === a.nodeName.toLowerCase() && \"text\" === a.type && (null == (b = a.getAttribute(\"type\")) || \"text\" === b.toLowerCase());\n        }, first: na(function () {\n          return [0];\n        }), last: na(function (a, b) {\n          return [b - 1];\n        }), eq: na(function (a, b, c) {\n          return [0 > c ? c + b : c];\n        }), even: na(function (a, b) {\n          for (var c = 0; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), odd: na(function (a, b) {\n          for (var c = 1; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), lt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; --d >= 0;) {\n            a.push(d);\n          }return a;\n        }), gt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; ++d < b;) {\n            a.push(d);\n          }return a;\n        }) } }, d.pseudos.nth = d.pseudos.eq;for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) {\n      d.pseudos[b] = la(b);\n    }for (b in { submit: !0, reset: !0 }) {\n      d.pseudos[b] = ma(b);\n    }function pa() {}pa.prototype = d.filters = d.pseudos, d.setFilters = new pa(), g = fa.tokenize = function (a, b) {\n      var c,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = z[a + \" \"];if (k) return b ? 0 : k.slice(0);h = a, i = [], j = d.preFilter;while (h) {\n        c && !(e = R.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(Q, \" \") }), h = h.slice(c.length));for (g in d.filter) {\n          !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length));\n        }if (!c) break;\n      }return b ? h.length : h ? fa.error(a) : z(a, i).slice(0);\n    };function qa(a) {\n      for (var b = 0, c = a.length, d = \"\"; c > b; b++) {\n        d += a[b].value;\n      }return d;\n    }function ra(a, b, c) {\n      var d = b.dir,\n          e = c && \"parentNode\" === d,\n          f = x++;return b.first ? function (b, c, f) {\n        while (b = b[d]) {\n          if (1 === b.nodeType || e) return a(b, c, f);\n        }\n      } : function (b, c, g) {\n        var h,\n            i,\n            j,\n            k = [w, f];if (g) {\n          while (b = b[d]) {\n            if ((1 === b.nodeType || e) && a(b, c, g)) return !0;\n          }\n        } else while (b = b[d]) {\n          if (1 === b.nodeType || e) {\n            if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2];if (i[d] = k, k[2] = a(b, c, g)) return !0;\n          }\n        }\n      };\n    }function sa(a) {\n      return a.length > 1 ? function (b, c, d) {\n        var e = a.length;while (e--) {\n          if (!a[e](b, c, d)) return !1;\n        }return !0;\n      } : a[0];\n    }function ta(a, b, c) {\n      for (var d = 0, e = b.length; e > d; d++) {\n        fa(a, b[d], c);\n      }return c;\n    }function ua(a, b, c, d, e) {\n      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) {\n        (f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));\n      }return g;\n    }function va(a, b, c, d, e, f) {\n      return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function (f, g, h, i) {\n        var j,\n            k,\n            l,\n            m = [],\n            n = [],\n            o = g.length,\n            p = f || ta(b || \"*\", h.nodeType ? [h] : h, []),\n            q = !a || !f && b ? p : ua(p, m, a, h, i),\n            r = c ? e || (f ? a : o || d) ? [] : g : q;if (c && c(q, r, h, i), d) {\n          j = ua(r, n), d(j, [], h, i), k = j.length;while (k--) {\n            (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));\n          }\n        }if (f) {\n          if (e || a) {\n            if (e) {\n              j = [], k = r.length;while (k--) {\n                (l = r[k]) && j.push(q[k] = l);\n              }e(null, r = [], j, i);\n            }k = r.length;while (k--) {\n              (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));\n            }\n          }\n        } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);\n      });\n    }function wa(a) {\n      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[\" \"], i = g ? 1 : 0, k = ra(function (a) {\n        return a === b;\n      }, h, !0), l = ra(function (a) {\n        return J(b, a) > -1;\n      }, h, !0), m = [function (a, c, d) {\n        var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));return b = null, e;\n      }]; f > i; i++) {\n        if (c = d.relative[a[i].type]) m = [ra(sa(m), c)];else {\n          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {\n            for (e = ++i; f > e; e++) {\n              if (d.relative[a[e].type]) break;\n            }return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({ value: \" \" === a[i - 2].type ? \"*\" : \"\" })).replace(Q, \"$1\"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a));\n          }m.push(c);\n        }\n      }return sa(m);\n    }function xa(a, b) {\n      var c = b.length > 0,\n          e = a.length > 0,\n          f = function f(_f, g, h, i, k) {\n        var l,\n            o,\n            q,\n            r = 0,\n            s = \"0\",\n            t = _f && [],\n            u = [],\n            v = j,\n            x = _f || e && d.find.TAG(\"*\", k),\n            y = w += null == v ? 1 : Math.random() || .1,\n            z = x.length;for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {\n          if (e && l) {\n            o = 0, g || l.ownerDocument === n || (m(l), h = !p);while (q = a[o++]) {\n              if (q(l, g || n, h)) {\n                i.push(l);break;\n              }\n            }k && (w = y);\n          }c && ((l = !q && l) && r--, _f && t.push(l));\n        }if (r += s, c && s !== r) {\n          o = 0;while (q = b[o++]) {\n            q(t, u, g, h);\n          }if (_f) {\n            if (r > 0) while (s--) {\n              t[s] || u[s] || (u[s] = F.call(i));\n            }u = ua(u);\n          }H.apply(i, u), k && !_f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i);\n        }return k && (w = y, j = v), t;\n      };return c ? ha(f) : f;\n    }return h = fa.compile = function (a, b) {\n      var c,\n          d = [],\n          e = [],\n          f = A[a + \" \"];if (!f) {\n        b || (b = g(a)), c = b.length;while (c--) {\n          f = wa(b[c]), f[u] ? d.push(f) : e.push(f);\n        }f = A(a, xa(e, d)), f.selector = a;\n      }return f;\n    }, i = fa.select = function (a, b, e, f) {\n      var i,\n          j,\n          k,\n          l,\n          m,\n          n = \"function\" == typeof a && a,\n          o = !f && g(a = n.selector || a);if (e = e || [], 1 === o.length) {\n        if (j = o[0] = o[0].slice(0), j.length > 2 && \"ID\" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {\n          if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e;n && (b = b.parentNode), a = a.slice(j.shift().value.length);\n        }i = W.needsContext.test(a) ? 0 : j.length;while (i--) {\n          if (k = j[i], d.relative[l = k.type]) break;if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) {\n            if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e;break;\n          }\n        }\n      }return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e;\n    }, c.sortStable = u.split(\"\").sort(B).join(\"\") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function (a) {\n      return 1 & a.compareDocumentPosition(n.createElement(\"div\"));\n    }), ia(function (a) {\n      return a.innerHTML = \"<a href='#'></a>\", \"#\" === a.firstChild.getAttribute(\"href\");\n    }) || ja(\"type|href|height|width\", function (a, b, c) {\n      return c ? void 0 : a.getAttribute(b, \"type\" === b.toLowerCase() ? 1 : 2);\n    }), c.attributes && ia(function (a) {\n      return a.innerHTML = \"<input/>\", a.firstChild.setAttribute(\"value\", \"\"), \"\" === a.firstChild.getAttribute(\"value\");\n    }) || ja(\"value\", function (a, b, c) {\n      return c || \"input\" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;\n    }), ia(function (a) {\n      return null == a.getAttribute(\"disabled\");\n    }) || ja(K, function (a, b, c) {\n      var d;return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;\n    }), fa;\n  }(a);n.find = t, n.expr = t.selectors, n.expr[\":\"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;var u = function u(a, b, c) {\n    var d = [],\n        e = void 0 !== c;while ((a = a[b]) && 9 !== a.nodeType) {\n      if (1 === a.nodeType) {\n        if (e && n(a).is(c)) break;d.push(a);\n      }\n    }return d;\n  },\n      v = function v(a, b) {\n    for (var c = []; a; a = a.nextSibling) {\n      1 === a.nodeType && a !== b && c.push(a);\n    }return c;\n  },\n      w = n.expr.match.needsContext,\n      x = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      y = /^.[^:#\\[\\.,]*$/;function z(a, b, c) {\n    if (n.isFunction(b)) return n.grep(a, function (a, d) {\n      return !!b.call(a, d, a) !== c;\n    });if (b.nodeType) return n.grep(a, function (a) {\n      return a === b !== c;\n    });if (\"string\" == typeof b) {\n      if (y.test(b)) return n.filter(b, a, c);b = n.filter(b, a);\n    }return n.grep(a, function (a) {\n      return h.call(b, a) > -1 !== c;\n    });\n  }n.filter = function (a, b, c) {\n    var d = b[0];return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {\n      return 1 === a.nodeType;\n    }));\n  }, n.fn.extend({ find: function find(a) {\n      var b,\n          c = this.length,\n          d = [],\n          e = this;if (\"string\" != typeof a) return this.pushStack(n(a).filter(function () {\n        for (b = 0; c > b; b++) {\n          if (n.contains(e[b], this)) return !0;\n        }\n      }));for (b = 0; c > b; b++) {\n        n.find(a, e[b], d);\n      }return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + \" \" + a : a, d;\n    }, filter: function filter(a) {\n      return this.pushStack(z(this, a || [], !1));\n    }, not: function not(a) {\n      return this.pushStack(z(this, a || [], !0));\n    }, is: function is(a) {\n      return !!z(this, \"string\" == typeof a && w.test(a) ? n(a) : a || [], !1).length;\n    } });var A,\n      B = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      C = n.fn.init = function (a, b, c) {\n    var e, f;if (!a) return this;if (c = c || A, \"string\" == typeof a) {\n      if (e = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);if (e[1]) {\n        if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b)) for (e in b) {\n          n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);\n        }return this;\n      }return f = d.getElementById(e[2]), f && f.parentNode && (this.length = 1, this[0] = f), this.context = d, this.selector = a, this;\n    }return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this));\n  };C.prototype = n.fn, A = n(d);var D = /^(?:parents|prev(?:Until|All))/,\n      E = { children: !0, contents: !0, next: !0, prev: !0 };n.fn.extend({ has: function has(a) {\n      var b = n(a, this),\n          c = b.length;return this.filter(function () {\n        for (var a = 0; c > a; a++) {\n          if (n.contains(this, b[a])) return !0;\n        }\n      });\n    }, closest: function closest(a, b) {\n      for (var c, d = 0, e = this.length, f = [], g = w.test(a) || \"string\" != typeof a ? n(a, b || this.context) : 0; e > d; d++) {\n        for (c = this[d]; c && c !== b; c = c.parentNode) {\n          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {\n            f.push(c);break;\n          }\n        }\n      }return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f);\n    }, index: function index(a) {\n      return a ? \"string\" == typeof a ? h.call(n(a), this[0]) : h.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n    }, add: function add(a, b) {\n      return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b))));\n    }, addBack: function addBack(a) {\n      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));\n    } });function F(a, b) {\n    while ((a = a[b]) && 1 !== a.nodeType) {}return a;\n  }n.each({ parent: function parent(a) {\n      var b = a.parentNode;return b && 11 !== b.nodeType ? b : null;\n    }, parents: function parents(a) {\n      return u(a, \"parentNode\");\n    }, parentsUntil: function parentsUntil(a, b, c) {\n      return u(a, \"parentNode\", c);\n    }, next: function next(a) {\n      return F(a, \"nextSibling\");\n    }, prev: function prev(a) {\n      return F(a, \"previousSibling\");\n    }, nextAll: function nextAll(a) {\n      return u(a, \"nextSibling\");\n    }, prevAll: function prevAll(a) {\n      return u(a, \"previousSibling\");\n    }, nextUntil: function nextUntil(a, b, c) {\n      return u(a, \"nextSibling\", c);\n    }, prevUntil: function prevUntil(a, b, c) {\n      return u(a, \"previousSibling\", c);\n    }, siblings: function siblings(a) {\n      return v((a.parentNode || {}).firstChild, a);\n    }, children: function children(a) {\n      return v(a.firstChild);\n    }, contents: function contents(a) {\n      return a.contentDocument || n.merge([], a.childNodes);\n    } }, function (a, b) {\n    n.fn[a] = function (c, d) {\n      var e = n.map(this, b, c);return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || n.uniqueSort(e), D.test(a) && e.reverse()), this.pushStack(e);\n    };\n  });var G = /\\S+/g;function H(a) {\n    var b = {};return n.each(a.match(G) || [], function (a, c) {\n      b[c] = !0;\n    }), b;\n  }n.Callbacks = function (a) {\n    a = \"string\" == typeof a ? H(a) : n.extend({}, a);var b,\n        c,\n        d,\n        e,\n        f = [],\n        g = [],\n        h = -1,\n        i = function i() {\n      for (e = a.once, d = b = !0; g.length; h = -1) {\n        c = g.shift();while (++h < f.length) {\n          f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1);\n        }\n      }a.memory || (c = !1), b = !1, e && (f = c ? [] : \"\");\n    },\n        j = { add: function add() {\n        return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {\n          n.each(b, function (b, c) {\n            n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && \"string\" !== n.type(c) && d(c);\n          });\n        }(arguments), c && !b && i()), this;\n      }, remove: function remove() {\n        return n.each(arguments, function (a, b) {\n          var c;while ((c = n.inArray(b, f, c)) > -1) {\n            f.splice(c, 1), h >= c && h--;\n          }\n        }), this;\n      }, has: function has(a) {\n        return a ? n.inArray(a, f) > -1 : f.length > 0;\n      }, empty: function empty() {\n        return f && (f = []), this;\n      }, disable: function disable() {\n        return e = g = [], f = c = \"\", this;\n      }, disabled: function disabled() {\n        return !f;\n      }, lock: function lock() {\n        return e = g = [], c || (f = c = \"\"), this;\n      }, locked: function locked() {\n        return !!e;\n      }, fireWith: function fireWith(a, c) {\n        return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this;\n      }, fire: function fire() {\n        return j.fireWith(this, arguments), this;\n      }, fired: function fired() {\n        return !!d;\n      } };return j;\n  }, n.extend({ Deferred: function Deferred(a) {\n      var b = [[\"resolve\", \"done\", n.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", n.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", n.Callbacks(\"memory\")]],\n          c = \"pending\",\n          d = { state: function state() {\n          return c;\n        }, always: function always() {\n          return e.done(arguments).fail(arguments), this;\n        }, then: function then() {\n          var a = arguments;return n.Deferred(function (c) {\n            n.each(b, function (b, f) {\n              var g = n.isFunction(a[b]) && a[b];e[f[1]](function () {\n                var a = g && g.apply(this, arguments);a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + \"With\"](this === d ? c.promise() : this, g ? [a] : arguments);\n              });\n            }), a = null;\n          }).promise();\n        }, promise: function promise(a) {\n          return null != a ? n.extend(a, d) : d;\n        } },\n          e = {};return d.pipe = d.then, n.each(b, function (a, f) {\n        var g = f[2],\n            h = f[3];d[f[1]] = g.add, h && g.add(function () {\n          c = h;\n        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {\n          return e[f[0] + \"With\"](this === e ? d : this, arguments), this;\n        }, e[f[0] + \"With\"] = g.fireWith;\n      }), d.promise(e), a && a.call(e, e), e;\n    }, when: function when(a) {\n      var b = 0,\n          c = e.call(arguments),\n          d = c.length,\n          f = 1 !== d || a && n.isFunction(a.promise) ? d : 0,\n          g = 1 === f ? a : n.Deferred(),\n          h = function h(a, b, c) {\n        return function (d) {\n          b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);\n        };\n      },\n          i,\n          j,\n          k;if (d > 1) for (i = new Array(d), j = new Array(d), k = new Array(d); d > b; b++) {\n        c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f;\n      }return f || g.resolveWith(k, c), g.promise();\n    } });var I;n.fn.ready = function (a) {\n    return n.ready.promise().done(a), this;\n  }, n.extend({ isReady: !1, readyWait: 1, holdReady: function holdReady(a) {\n      a ? n.readyWait++ : n.ready(!0);\n    }, ready: function ready(a) {\n      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler(\"ready\"), n(d).off(\"ready\"))));\n    } });function J() {\n    d.removeEventListener(\"DOMContentLoaded\", J), a.removeEventListener(\"load\", J), n.ready();\n  }n.ready.promise = function (b) {\n    return I || (I = n.Deferred(), \"complete\" === d.readyState || \"loading\" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(n.ready) : (d.addEventListener(\"DOMContentLoaded\", J), a.addEventListener(\"load\", J))), I.promise(b);\n  }, n.ready.promise();var K = function K(a, b, c, d, e, f, g) {\n    var h = 0,\n        i = a.length,\n        j = null == c;if (\"object\" === n.type(c)) {\n      e = !0;for (h in c) {\n        K(a, b, h, c[h], !0, f, g);\n      }\n    } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function b(a, _b, c) {\n      return j.call(n(a), c);\n    })), b)) for (; i > h; h++) {\n      b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n    }return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;\n  },\n      L = function L(a) {\n    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;\n  };function M() {\n    this.expando = n.expando + M.uid++;\n  }M.uid = 1, M.prototype = { register: function register(a, b) {\n      var c = b || {};return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, { value: c, writable: !0, configurable: !0 }), a[this.expando];\n    }, cache: function cache(a) {\n      if (!L(a)) return {};var b = a[this.expando];return b || (b = {}, L(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, { value: b, configurable: !0 }))), b;\n    }, set: function set(a, b, c) {\n      var d,\n          e = this.cache(a);if (\"string\" == typeof b) e[b] = c;else for (d in b) {\n        e[d] = b[d];\n      }return e;\n    }, get: function get(a, b) {\n      return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b];\n    }, access: function access(a, b, c) {\n      var d;return void 0 === b || b && \"string\" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b);\n    }, remove: function remove(a, b) {\n      var c,\n          d,\n          e,\n          f = a[this.expando];if (void 0 !== f) {\n        if (void 0 === b) this.register(a);else {\n          n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(G) || [])), c = d.length;while (c--) {\n            delete f[d[c]];\n          }\n        }(void 0 === b || n.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando]);\n      }\n    }, hasData: function hasData(a) {\n      var b = a[this.expando];return void 0 !== b && !n.isEmptyObject(b);\n    } };var N = new M(),\n      O = new M(),\n      P = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      Q = /[A-Z]/g;function R(a, b, c) {\n    var d;if (void 0 === c && 1 === a.nodeType) if (d = \"data-\" + b.replace(Q, \"-$&\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n      try {\n        c = \"true\" === c ? !0 : \"false\" === c ? !1 : \"null\" === c ? null : +c + \"\" === c ? +c : P.test(c) ? n.parseJSON(c) : c;\n      } catch (e) {}O.set(a, b, c);\n    } else c = void 0;return c;\n  }n.extend({ hasData: function hasData(a) {\n      return O.hasData(a) || N.hasData(a);\n    }, data: function data(a, b, c) {\n      return O.access(a, b, c);\n    }, removeData: function removeData(a, b) {\n      O.remove(a, b);\n    }, _data: function _data(a, b, c) {\n      return N.access(a, b, c);\n    }, _removeData: function _removeData(a, b) {\n      N.remove(a, b);\n    } }), n.fn.extend({ data: function data(a, b) {\n      var c,\n          d,\n          e,\n          f = this[0],\n          g = f && f.attributes;if (void 0 === a) {\n        if (this.length && (e = O.get(f), 1 === f.nodeType && !N.get(f, \"hasDataAttrs\"))) {\n          c = g.length;while (c--) {\n            g[c] && (d = g[c].name, 0 === d.indexOf(\"data-\") && (d = n.camelCase(d.slice(5)), R(f, d, e[d])));\n          }N.set(f, \"hasDataAttrs\", !0);\n        }return e;\n      }return \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? this.each(function () {\n        O.set(this, a);\n      }) : K(this, function (b) {\n        var c, d;if (f && void 0 === b) {\n          if (c = O.get(f, a) || O.get(f, a.replace(Q, \"-$&\").toLowerCase()), void 0 !== c) return c;if (d = n.camelCase(a), c = O.get(f, d), void 0 !== c) return c;if (c = R(f, d, void 0), void 0 !== c) return c;\n        } else d = n.camelCase(a), this.each(function () {\n          var c = O.get(this, d);O.set(this, d, b), a.indexOf(\"-\") > -1 && void 0 !== c && O.set(this, a, b);\n        });\n      }, null, b, arguments.length > 1, null, !0);\n    }, removeData: function removeData(a) {\n      return this.each(function () {\n        O.remove(this, a);\n      });\n    } }), n.extend({ queue: function queue(a, b, c) {\n      var d;return a ? (b = (b || \"fx\") + \"queue\", d = N.get(a, b), c && (!d || n.isArray(c) ? d = N.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0;\n    }, dequeue: function dequeue(a, b) {\n      b = b || \"fx\";var c = n.queue(a, b),\n          d = c.length,\n          e = c.shift(),\n          f = n._queueHooks(a, b),\n          g = function g() {\n        n.dequeue(a, b);\n      };\"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();\n    }, _queueHooks: function _queueHooks(a, b) {\n      var c = b + \"queueHooks\";return N.get(a, c) || N.access(a, c, { empty: n.Callbacks(\"once memory\").add(function () {\n          N.remove(a, [b + \"queue\", c]);\n        }) });\n    } }), n.fn.extend({ queue: function queue(a, b) {\n      var c = 2;return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {\n        var c = n.queue(this, a, b);n._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && n.dequeue(this, a);\n      });\n    }, dequeue: function dequeue(a) {\n      return this.each(function () {\n        n.dequeue(this, a);\n      });\n    }, clearQueue: function clearQueue(a) {\n      return this.queue(a || \"fx\", []);\n    }, promise: function promise(a, b) {\n      var c,\n          d = 1,\n          e = n.Deferred(),\n          f = this,\n          g = this.length,\n          h = function h() {\n        --d || e.resolveWith(f, [f]);\n      };\"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";while (g--) {\n        c = N.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n      }return h(), e.promise(b);\n    } });var S = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n      T = new RegExp(\"^(?:([+-])=|)(\" + S + \")([a-z%]*)$\", \"i\"),\n      U = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n      V = function V(a, b) {\n    return a = b || a, \"none\" === n.css(a, \"display\") || !n.contains(a.ownerDocument, a);\n  };function W(a, b, c, d) {\n    var e,\n        f = 1,\n        g = 20,\n        h = d ? function () {\n      return d.cur();\n    } : function () {\n      return n.css(a, b, \"\");\n    },\n        i = h(),\n        j = c && c[3] || (n.cssNumber[b] ? \"\" : \"px\"),\n        k = (n.cssNumber[b] || \"px\" !== j && +i) && T.exec(n.css(a, b));if (k && k[3] !== j) {\n      j = j || k[3], c = c || [], k = +i || 1;do {\n        f = f || \".5\", k /= f, n.style(a, b, k + j);\n      } while (f !== (f = h() / i) && 1 !== f && --g);\n    }return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e;\n  }var X = /^(?:checkbox|radio)$/i,\n      Y = /<([\\w:-]+)/,\n      Z = /^$|\\/(?:java|ecma)script/i,\n      $ = { option: [1, \"<select multiple='multiple'>\", \"</select>\"], thead: [1, \"<table>\", \"</table>\"], col: [2, \"<table><colgroup>\", \"</colgroup></table>\"], tr: [2, \"<table><tbody>\", \"</tbody></table>\"], td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"], _default: [0, \"\", \"\"] };$.optgroup = $.option, $.tbody = $.tfoot = $.colgroup = $.caption = $.thead, $.th = $.td;function _(a, b) {\n    var c = \"undefined\" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : \"undefined\" != typeof a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [];return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c;\n  }function aa(a, b) {\n    for (var c = 0, d = a.length; d > c; c++) {\n      N.set(a[c], \"globalEval\", !b || N.get(b[c], \"globalEval\"));\n    }\n  }var ba = /<|&#?\\w+;/;function ca(a, b, c, d, e) {\n    for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], o = 0, p = a.length; p > o; o++) {\n      if (f = a[o], f || 0 === f) if (\"object\" === n.type(f)) n.merge(m, f.nodeType ? [f] : f);else if (ba.test(f)) {\n        g = g || l.appendChild(b.createElement(\"div\")), h = (Y.exec(f) || [\"\", \"\"])[1].toLowerCase(), i = $[h] || $._default, g.innerHTML = i[1] + n.htmlPrefilter(f) + i[2], k = i[0];while (k--) {\n          g = g.lastChild;\n        }n.merge(m, g.childNodes), g = l.firstChild, g.textContent = \"\";\n      } else m.push(b.createTextNode(f));\n    }l.textContent = \"\", o = 0;while (f = m[o++]) {\n      if (d && n.inArray(f, d) > -1) e && e.push(f);else if (j = n.contains(f.ownerDocument, f), g = _(l.appendChild(f), \"script\"), j && aa(g), c) {\n        k = 0;while (f = g[k++]) {\n          Z.test(f.type || \"\") && c.push(f);\n        }\n      }\n    }return l;\n  }!function () {\n    var a = d.createDocumentFragment(),\n        b = a.appendChild(d.createElement(\"div\")),\n        c = d.createElement(\"input\");c.setAttribute(\"type\", \"radio\"), c.setAttribute(\"checked\", \"checked\"), c.setAttribute(\"name\", \"t\"), b.appendChild(c), l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;\n  }();var da = /^key/,\n      ea = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      fa = /^([^.]*)(?:\\.(.+)|)/;function ga() {\n    return !0;\n  }function ha() {\n    return !1;\n  }function ia() {\n    try {\n      return d.activeElement;\n    } catch (a) {}\n  }function ja(a, b, c, d, e, f) {\n    var g, h;if (\"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b))) {\n      \"string\" != typeof c && (d = d || c, c = void 0);for (h in b) {\n        ja(a, h, c, d, b[h], f);\n      }return a;\n    }if (null == d && null == e ? (e = c, d = c = void 0) : null == e && (\"string\" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = ha;else if (!e) return a;return 1 === f && (g = e, e = function e(a) {\n      return n().off(a), g.apply(this, arguments);\n    }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function () {\n      n.event.add(this, b, e, d, c);\n    });\n  }n.event = { global: {}, add: function add(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.get(a);if (r) {\n        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) {\n          return \"undefined\" != typeof n && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0;\n        }), b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test(e), namespace: p.join(\".\") }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0);\n        }\n      }\n    }, remove: function remove(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.hasData(a) && N.get(a);if (r && (i = r.events)) {\n        b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          if (h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o) {\n            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + p.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;while (f--) {\n              k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n            }g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]);\n          } else for (o in i) {\n            n.event.remove(a, o + b[j], c, d, !0);\n          }\n        }n.isEmptyObject(i) && N.remove(a, \"handle events\");\n      }\n    }, dispatch: function dispatch(a) {\n      a = n.event.fix(a);var b,\n          c,\n          d,\n          f,\n          g,\n          h = [],\n          i = e.call(arguments),\n          j = (N.get(this, \"events\") || {})[a.type] || [],\n          k = n.event.special[a.type] || {};if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n        h = n.event.handlers.call(this, a, j), b = 0;while ((f = h[b++]) && !a.isPropagationStopped()) {\n          a.currentTarget = f.elem, c = 0;while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) {\n            a.rnamespace && !a.rnamespace.test(g.namespace) || (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation()));\n          }\n        }return k.postDispatch && k.postDispatch.call(this, a), a.result;\n      }\n    }, handlers: function handlers(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g = [],\n          h = b.delegateCount,\n          i = a.target;if (h && i.nodeType && (\"click\" !== a.type || isNaN(a.button) || a.button < 1)) for (; i !== this; i = i.parentNode || this) {\n        if (1 === i.nodeType && (i.disabled !== !0 || \"click\" !== a.type)) {\n          for (d = [], c = 0; h > c; c++) {\n            f = b[c], e = f.selector + \" \", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f);\n          }d.length && g.push({ elem: i, handlers: d });\n        }\n      }return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g;\n    }, props: \"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"), fixHooks: {}, keyHooks: { props: \"char charCode key keyCode\".split(\" \"), filter: function filter(a, b) {\n        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;\n      } }, mouseHooks: { props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"), filter: function filter(a, b) {\n        var c,\n            e,\n            f,\n            g = b.button;return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e.clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a;\n      } }, fix: function fix(a) {\n      if (a[n.expando]) return a;var b,\n          c,\n          e,\n          f = a.type,\n          g = a,\n          h = this.fixHooks[f];h || (this.fixHooks[f] = h = ea.test(f) ? this.mouseHooks : da.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length;while (b--) {\n        c = e[b], a[c] = g[c];\n      }return a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter ? h.filter(a, g) : a;\n    }, special: { load: { noBubble: !0 }, focus: { trigger: function trigger() {\n          return this !== ia() && this.focus ? (this.focus(), !1) : void 0;\n        }, delegateType: \"focusin\" }, blur: { trigger: function trigger() {\n          return this === ia() && this.blur ? (this.blur(), !1) : void 0;\n        }, delegateType: \"focusout\" }, click: { trigger: function trigger() {\n          return \"checkbox\" === this.type && this.click && n.nodeName(this, \"input\") ? (this.click(), !1) : void 0;\n        }, _default: function _default(a) {\n          return n.nodeName(a.target, \"a\");\n        } }, beforeunload: { postDispatch: function postDispatch(a) {\n          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);\n        } } } }, n.removeEvent = function (a, b, c) {\n    a.removeEventListener && a.removeEventListener(b, c);\n  }, n.Event = function (a, b) {\n    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ga : ha) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b);\n  }, n.Event.prototype = { constructor: n.Event, isDefaultPrevented: ha, isPropagationStopped: ha, isImmediatePropagationStopped: ha, isSimulated: !1, preventDefault: function preventDefault() {\n      var a = this.originalEvent;this.isDefaultPrevented = ga, a && !this.isSimulated && a.preventDefault();\n    }, stopPropagation: function stopPropagation() {\n      var a = this.originalEvent;this.isPropagationStopped = ga, a && !this.isSimulated && a.stopPropagation();\n    }, stopImmediatePropagation: function stopImmediatePropagation() {\n      var a = this.originalEvent;this.isImmediatePropagationStopped = ga, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation();\n    } }, n.each({ mouseenter: \"mouseover\", mouseleave: \"mouseout\", pointerenter: \"pointerover\", pointerleave: \"pointerout\" }, function (a, b) {\n    n.event.special[a] = { delegateType: b, bindType: b, handle: function handle(a) {\n        var c,\n            d = this,\n            e = a.relatedTarget,\n            f = a.handleObj;return e && (e === d || n.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;\n      } };\n  }), n.fn.extend({ on: function on(a, b, c, d) {\n      return ja(this, a, b, c, d);\n    }, one: function one(a, b, c, d) {\n      return ja(this, a, b, c, d, 1);\n    }, off: function off(a, b, c) {\n      var d, e;if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;if (\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a))) {\n        for (e in a) {\n          this.off(e, b, a[e]);\n        }return this;\n      }return b !== !1 && \"function\" != typeof b || (c = b, b = void 0), c === !1 && (c = ha), this.each(function () {\n        n.event.remove(this, a, c, b);\n      });\n    } });var ka = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n      la = /<script|<style|<link/i,\n      ma = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      na = /^true\\/(.*)/,\n      oa = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function pa(a, b) {\n    return n.nodeName(a, \"table\") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a;\n  }function qa(a) {\n    return a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a;\n  }function ra(a) {\n    var b = na.exec(a.type);return b ? a.type = b[1] : a.removeAttribute(\"type\"), a;\n  }function sa(a, b) {\n    var c, d, e, f, g, h, i, j;if (1 === b.nodeType) {\n      if (N.hasData(a) && (f = N.access(a), g = N.set(b, f), j = f.events)) {\n        delete g.handle, g.events = {};for (e in j) {\n          for (c = 0, d = j[e].length; d > c; c++) {\n            n.event.add(b, e, j[e][c]);\n          }\n        }\n      }O.hasData(a) && (h = O.access(a), i = n.extend({}, h), O.set(b, i));\n    }\n  }function ta(a, b) {\n    var c = b.nodeName.toLowerCase();\"input\" === c && X.test(a.type) ? b.checked = a.checked : \"input\" !== c && \"textarea\" !== c || (b.defaultValue = a.defaultValue);\n  }function ua(a, b, c, d) {\n    b = f.apply([], b);var e,\n        g,\n        h,\n        i,\n        j,\n        k,\n        m = 0,\n        o = a.length,\n        p = o - 1,\n        q = b[0],\n        r = n.isFunction(q);if (r || o > 1 && \"string\" == typeof q && !l.checkClone && ma.test(q)) return a.each(function (e) {\n      var f = a.eq(e);r && (b[0] = q.call(this, e, f.html())), ua(f, b, c, d);\n    });if (o && (e = ca(b, a[0].ownerDocument, !1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) {\n      for (h = n.map(_(e, \"script\"), qa), i = h.length; o > m; m++) {\n        j = e, m !== p && (j = n.clone(j, !0, !0), i && n.merge(h, _(j, \"script\"))), c.call(a[m], j, m);\n      }if (i) for (k = h[h.length - 1].ownerDocument, n.map(h, ra), m = 0; i > m; m++) {\n        j = h[m], Z.test(j.type || \"\") && !N.access(j, \"globalEval\") && n.contains(k, j) && (j.src ? n._evalUrl && n._evalUrl(j.src) : n.globalEval(j.textContent.replace(oa, \"\")));\n      }\n    }return a;\n  }function va(a, b, c) {\n    for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]); f++) {\n      c || 1 !== d.nodeType || n.cleanData(_(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && aa(_(d, \"script\")), d.parentNode.removeChild(d));\n    }return a;\n  }n.extend({ htmlPrefilter: function htmlPrefilter(a) {\n      return a.replace(ka, \"<$1></$2>\");\n    }, clone: function clone(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h = a.cloneNode(!0),\n          i = n.contains(a.ownerDocument, a);if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (g = _(h), f = _(a), d = 0, e = f.length; e > d; d++) {\n        ta(f[d], g[d]);\n      }if (b) if (c) for (f = f || _(a), g = g || _(h), d = 0, e = f.length; e > d; d++) {\n        sa(f[d], g[d]);\n      } else sa(a, h);return g = _(h, \"script\"), g.length > 0 && aa(g, !i && _(a, \"script\")), h;\n    }, cleanData: function cleanData(a) {\n      for (var b, c, d, e = n.event.special, f = 0; void 0 !== (c = a[f]); f++) {\n        if (L(c)) {\n          if (b = c[N.expando]) {\n            if (b.events) for (d in b.events) {\n              e[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);\n            }c[N.expando] = void 0;\n          }c[O.expando] && (c[O.expando] = void 0);\n        }\n      }\n    } }), n.fn.extend({ domManip: ua, detach: function detach(a) {\n      return va(this, a, !0);\n    }, remove: function remove(a) {\n      return va(this, a);\n    }, text: function text(a) {\n      return K(this, function (a) {\n        return void 0 === a ? n.text(this) : this.empty().each(function () {\n          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a);\n        });\n      }, null, a, arguments.length);\n    }, append: function append() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.appendChild(a);\n        }\n      });\n    }, prepend: function prepend() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.insertBefore(a, b.firstChild);\n        }\n      });\n    }, before: function before() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this);\n      });\n    }, after: function after() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);\n      });\n    }, empty: function empty() {\n      for (var a, b = 0; null != (a = this[b]); b++) {\n        1 === a.nodeType && (n.cleanData(_(a, !1)), a.textContent = \"\");\n      }return this;\n    }, clone: function clone(a, b) {\n      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {\n        return n.clone(this, a, b);\n      });\n    }, html: function html(a) {\n      return K(this, function (a) {\n        var b = this[0] || {},\n            c = 0,\n            d = this.length;if (void 0 === a && 1 === b.nodeType) return b.innerHTML;if (\"string\" == typeof a && !la.test(a) && !$[(Y.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n          a = n.htmlPrefilter(a);try {\n            for (; d > c; c++) {\n              b = this[c] || {}, 1 === b.nodeType && (n.cleanData(_(b, !1)), b.innerHTML = a);\n            }b = 0;\n          } catch (e) {}\n        }b && this.empty().append(a);\n      }, null, a, arguments.length);\n    }, replaceWith: function replaceWith() {\n      var a = [];return ua(this, arguments, function (b) {\n        var c = this.parentNode;n.inArray(this, a) < 0 && (n.cleanData(_(this)), c && c.replaceChild(b, this));\n      }, a);\n    } }), n.each({ appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\" }, function (a, b) {\n    n.fn[a] = function (a) {\n      for (var c, d = [], e = n(a), f = e.length - 1, h = 0; f >= h; h++) {\n        c = h === f ? this : this.clone(!0), n(e[h])[b](c), g.apply(d, c.get());\n      }return this.pushStack(d);\n    };\n  });var wa,\n      xa = { HTML: \"block\", BODY: \"block\" };function ya(a, b) {\n    var c = n(b.createElement(a)).appendTo(b.body),\n        d = n.css(c[0], \"display\");return c.detach(), d;\n  }function za(a) {\n    var b = d,\n        c = xa[a];return c || (c = ya(a, b), \"none\" !== c && c || (wa = (wa || n(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement), b = wa[0].contentDocument, b.write(), b.close(), c = ya(a, b), wa.detach()), xa[a] = c), c;\n  }var Aa = /^margin/,\n      Ba = new RegExp(\"^(\" + S + \")(?!px)[a-z%]+$\", \"i\"),\n      Ca = function Ca(b) {\n    var c = b.ownerDocument.defaultView;return c && c.opener || (c = a), c.getComputedStyle(b);\n  },\n      Da = function Da(a, b, c, d) {\n    var e,\n        f,\n        g = {};for (f in b) {\n      g[f] = a.style[f], a.style[f] = b[f];\n    }e = c.apply(a, d || []);for (f in b) {\n      a.style[f] = g[f];\n    }return e;\n  },\n      Ea = d.documentElement;!function () {\n    var b,\n        c,\n        e,\n        f,\n        g = d.createElement(\"div\"),\n        h = d.createElement(\"div\");if (h.style) {\n      (function () {\n        var i = function i() {\n          h.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%\", h.innerHTML = \"\", Ea.appendChild(g);var d = a.getComputedStyle(h);b = \"1%\" !== d.top, f = \"2px\" === d.marginLeft, c = \"4px\" === d.width, h.style.marginRight = \"50%\", e = \"4px\" === d.marginRight, Ea.removeChild(g);\n        };\n\n        h.style.backgroundClip = \"content-box\", h.cloneNode(!0).style.backgroundClip = \"\", l.clearCloneStyle = \"content-box\" === h.style.backgroundClip, g.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute\", g.appendChild(h);n.extend(l, { pixelPosition: function pixelPosition() {\n            return i(), b;\n          }, boxSizingReliable: function boxSizingReliable() {\n            return null == c && i(), c;\n          }, pixelMarginRight: function pixelMarginRight() {\n            return null == c && i(), e;\n          }, reliableMarginLeft: function reliableMarginLeft() {\n            return null == c && i(), f;\n          }, reliableMarginRight: function reliableMarginRight() {\n            var b,\n                c = h.appendChild(d.createElement(\"div\"));return c.style.cssText = h.style.cssText = \"-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\", c.style.marginRight = c.style.width = \"0\", h.style.width = \"1px\", Ea.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), Ea.removeChild(g), h.removeChild(c), b;\n          } });\n      })();\n    }\n  }();function Fa(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.style;return c = c || Ca(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, \"\" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Ba.test(g) && Aa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + \"\" : g;\n  }function Ga(a, b) {\n    return { get: function get() {\n        return a() ? void delete this.get : (this.get = b).apply(this, arguments);\n      } };\n  }var Ha = /^(none|table(?!-c[ea]).+)/,\n      Ia = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n      Ja = { letterSpacing: \"0\", fontWeight: \"400\" },\n      Ka = [\"Webkit\", \"O\", \"Moz\", \"ms\"],\n      La = d.createElement(\"div\").style;function Ma(a) {\n    if (a in La) return a;var b = a[0].toUpperCase() + a.slice(1),\n        c = Ka.length;while (c--) {\n      if (a = Ka[c] + b, a in La) return a;\n    }\n  }function Na(a, b, c) {\n    var d = T.exec(b);return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || \"px\") : b;\n  }function Oa(a, b, c, d, e) {\n    for (var f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0, g = 0; 4 > f; f += 2) {\n      \"margin\" === c && (g += n.css(a, c + U[f], !0, e)), d ? (\"content\" === c && (g -= n.css(a, \"padding\" + U[f], !0, e)), \"margin\" !== c && (g -= n.css(a, \"border\" + U[f] + \"Width\", !0, e))) : (g += n.css(a, \"padding\" + U[f], !0, e), \"padding\" !== c && (g += n.css(a, \"border\" + U[f] + \"Width\", !0, e)));\n    }return g;\n  }function Pa(a, b, c) {\n    var d = !0,\n        e = \"width\" === b ? a.offsetWidth : a.offsetHeight,\n        f = Ca(a),\n        g = \"border-box\" === n.css(a, \"boxSizing\", !1, f);if (0 >= e || null == e) {\n      if (e = Fa(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ba.test(e)) return e;d = g && (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;\n    }return e + Oa(a, b, c || (g ? \"border\" : \"content\"), d, f) + \"px\";\n  }function Qa(a, b) {\n    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) {\n      d = a[g], d.style && (f[g] = N.get(d, \"olddisplay\"), c = d.style.display, b ? (f[g] || \"none\" !== c || (d.style.display = \"\"), \"\" === d.style.display && V(d) && (f[g] = N.access(d, \"olddisplay\", za(d.nodeName)))) : (e = V(d), \"none\" === c && e || N.set(d, \"olddisplay\", e ? c : n.css(d, \"display\"))));\n    }for (g = 0; h > g; g++) {\n      d = a[g], d.style && (b && \"none\" !== d.style.display && \"\" !== d.style.display || (d.style.display = b ? f[g] || \"\" : \"none\"));\n    }return a;\n  }n.extend({ cssHooks: { opacity: { get: function get(a, b) {\n          if (b) {\n            var c = Fa(a, \"opacity\");return \"\" === c ? \"1\" : c;\n          }\n        } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { \"float\": \"cssFloat\" }, style: function style(a, b, c, d) {\n      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n        var e,\n            f,\n            g,\n            h = n.camelCase(b),\n            i = a.style;return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c === \"undefined\" ? \"undefined\" : _typeof(c), \"string\" === f && (e = T.exec(c)) && e[1] && (c = W(a, b, e), f = \"number\"), null != c && c === c && (\"number\" === f && (c += e && e[3] || (n.cssNumber[h] ? \"\" : \"px\")), l.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (i[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);\n      }\n    }, css: function css(a, b, c, d) {\n      var e,\n          f,\n          g,\n          h = n.camelCase(b);return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Fa(a, b, d)), \"normal\" === e && b in Ja && (e = Ja[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e;\n    } }), n.each([\"height\", \"width\"], function (a, b) {\n    n.cssHooks[b] = { get: function get(a, c, d) {\n        return c ? Ha.test(n.css(a, \"display\")) && 0 === a.offsetWidth ? Da(a, Ia, function () {\n          return Pa(a, b, d);\n        }) : Pa(a, b, d) : void 0;\n      }, set: function set(a, c, d) {\n        var e,\n            f = d && Ca(a),\n            g = d && Oa(a, b, d, \"border-box\" === n.css(a, \"boxSizing\", !1, f), f);return g && (e = T.exec(c)) && \"px\" !== (e[3] || \"px\") && (a.style[b] = c, c = n.css(a, b)), Na(a, c, g);\n      } };\n  }), n.cssHooks.marginLeft = Ga(l.reliableMarginLeft, function (a, b) {\n    return b ? (parseFloat(Fa(a, \"marginLeft\")) || a.getBoundingClientRect().left - Da(a, { marginLeft: 0 }, function () {\n      return a.getBoundingClientRect().left;\n    })) + \"px\" : void 0;\n  }), n.cssHooks.marginRight = Ga(l.reliableMarginRight, function (a, b) {\n    return b ? Da(a, { display: \"inline-block\" }, Fa, [a, \"marginRight\"]) : void 0;\n  }), n.each({ margin: \"\", padding: \"\", border: \"Width\" }, function (a, b) {\n    n.cssHooks[a + b] = { expand: function expand(c) {\n        for (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; 4 > d; d++) {\n          e[a + U[d] + b] = f[d] || f[d - 2] || f[0];\n        }return e;\n      } }, Aa.test(a) || (n.cssHooks[a + b].set = Na);\n  }), n.fn.extend({ css: function css(a, b) {\n      return K(this, function (a, b, c) {\n        var d,\n            e,\n            f = {},\n            g = 0;if (n.isArray(b)) {\n          for (d = Ca(a), e = b.length; e > g; g++) {\n            f[b[g]] = n.css(a, b[g], !1, d);\n          }return f;\n        }return void 0 !== c ? n.style(a, b, c) : n.css(a, b);\n      }, a, b, arguments.length > 1);\n    }, show: function show() {\n      return Qa(this, !0);\n    }, hide: function hide() {\n      return Qa(this);\n    }, toggle: function toggle(a) {\n      return \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function () {\n        V(this) ? n(this).show() : n(this).hide();\n      });\n    } });function Ra(a, b, c, d, e) {\n    return new Ra.prototype.init(a, b, c, d, e);\n  }n.Tween = Ra, Ra.prototype = { constructor: Ra, init: function init(a, b, c, d, e, f) {\n      this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? \"\" : \"px\");\n    }, cur: function cur() {\n      var a = Ra.propHooks[this.prop];return a && a.get ? a.get(this) : Ra.propHooks._default.get(this);\n    }, run: function run(a) {\n      var b,\n          c = Ra.propHooks[this.prop];return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ra.propHooks._default.set(this), this;\n    } }, Ra.prototype.init.prototype = Ra.prototype, Ra.propHooks = { _default: { get: function get(a) {\n        var b;return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, \"\"), b && \"auto\" !== b ? b : 0);\n      }, set: function set(a) {\n        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit);\n      } } }, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = { set: function set(a) {\n      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);\n    } }, n.easing = { linear: function linear(a) {\n      return a;\n    }, swing: function swing(a) {\n      return .5 - Math.cos(a * Math.PI) / 2;\n    }, _default: \"swing\" }, n.fx = Ra.prototype.init, n.fx.step = {};var Sa,\n      Ta,\n      Ua = /^(?:toggle|show|hide)$/,\n      Va = /queueHooks$/;function Wa() {\n    return a.setTimeout(function () {\n      Sa = void 0;\n    }), Sa = n.now();\n  }function Xa(a, b) {\n    var c,\n        d = 0,\n        e = { height: a };for (b = b ? 1 : 0; 4 > d; d += 2 - b) {\n      c = U[d], e[\"margin\" + c] = e[\"padding\" + c] = a;\n    }return b && (e.opacity = e.width = a), e;\n  }function Ya(a, b, c) {\n    for (var d, e = (_a.tweeners[b] || []).concat(_a.tweeners[\"*\"]), f = 0, g = e.length; g > f; f++) {\n      if (d = e[f].call(c, b, a)) return d;\n    }\n  }function Za(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l = this,\n        m = {},\n        o = a.style,\n        p = a.nodeType && V(a),\n        q = N.get(a, \"fxshow\");c.queue || (h = n._queueHooks(a, \"fx\"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {\n      h.unqueued || i();\n    }), h.unqueued++, l.always(function () {\n      l.always(function () {\n        h.unqueued--, n.queue(a, \"fx\").length || h.empty.fire();\n      });\n    })), 1 === a.nodeType && (\"height\" in b || \"width\" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, \"display\"), k = \"none\" === j ? N.get(a, \"olddisplay\") || za(a.nodeName) : j, \"inline\" === k && \"none\" === n.css(a, \"float\") && (o.display = \"inline-block\")), c.overflow && (o.overflow = \"hidden\", l.always(function () {\n      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];\n    }));for (d in b) {\n      if (e = b[d], Ua.exec(e)) {\n        if (delete b[d], f = f || \"toggle\" === e, e === (p ? \"hide\" : \"show\")) {\n          if (\"show\" !== e || !q || void 0 === q[d]) continue;p = !0;\n        }m[d] = q && q[d] || n.style(a, d);\n      } else j = void 0;\n    }if (n.isEmptyObject(m)) \"inline\" === (\"none\" === j ? za(a.nodeName) : j) && (o.display = j);else {\n      q ? \"hidden\" in q && (p = q.hidden) : q = N.access(a, \"fxshow\", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function () {\n        n(a).hide();\n      }), l.done(function () {\n        var b;N.remove(a, \"fxshow\");for (b in m) {\n          n.style(a, b, m[b]);\n        }\n      });for (d in m) {\n        g = Ya(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = \"width\" === d || \"height\" === d ? 1 : 0));\n      }\n    }\n  }function $a(a, b) {\n    var c, d, e, f, g;for (c in a) {\n      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && \"expand\" in g) {\n        f = g.expand(f), delete a[d];for (c in f) {\n          c in a || (a[c] = f[c], b[c] = e);\n        }\n      } else b[d] = e;\n    }\n  }function _a(a, b, c) {\n    var d,\n        e,\n        f = 0,\n        g = _a.prefilters.length,\n        h = n.Deferred().always(function () {\n      delete i.elem;\n    }),\n        i = function i() {\n      if (e) return !1;for (var b = Sa || Wa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) {\n        j.tweens[g].run(f);\n      }return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);\n    },\n        j = h.promise({ elem: a, props: n.extend({}, b), opts: n.extend(!0, { specialEasing: {}, easing: n.easing._default }, c), originalProperties: b, originalOptions: c, startTime: Sa || Wa(), duration: c.duration, tweens: [], createTween: function createTween(b, c) {\n        var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);return j.tweens.push(d), d;\n      }, stop: function stop(b) {\n        var c = 0,\n            d = b ? j.tweens.length : 0;if (e) return this;for (e = !0; d > c; c++) {\n          j.tweens[c].run(1);\n        }return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this;\n      } }),\n        k = j.props;for ($a(k, j.opts.specialEasing); g > f; f++) {\n      if (d = _a.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d;\n    }return n.map(k, Ya, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);\n  }n.Animation = n.extend(_a, { tweeners: { \"*\": [function (a, b) {\n        var c = this.createTween(a, b);return W(c.elem, a, T.exec(b), c), c;\n      }] }, tweener: function tweener(a, b) {\n      n.isFunction(a) ? (b = a, a = [\"*\"]) : a = a.match(G);for (var c, d = 0, e = a.length; e > d; d++) {\n        c = a[d], _a.tweeners[c] = _a.tweeners[c] || [], _a.tweeners[c].unshift(b);\n      }\n    }, prefilters: [Za], prefilter: function prefilter(a, b) {\n      b ? _a.prefilters.unshift(a) : _a.prefilters.push(a);\n    } }), n.speed = function (a, b, c) {\n    var d = a && \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? n.extend({}, a) : { complete: c || !c && b || n.isFunction(a) && a, duration: a, easing: c && b || b && !n.isFunction(b) && b };return d.duration = n.fx.off ? 0 : \"number\" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, null != d.queue && d.queue !== !0 || (d.queue = \"fx\"), d.old = d.complete, d.complete = function () {\n      n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue);\n    }, d;\n  }, n.fn.extend({ fadeTo: function fadeTo(a, b, c, d) {\n      return this.filter(V).css(\"opacity\", 0).show().end().animate({ opacity: b }, a, c, d);\n    }, animate: function animate(a, b, c, d) {\n      var e = n.isEmptyObject(a),\n          f = n.speed(b, c, d),\n          g = function g() {\n        var b = _a(this, n.extend({}, a), f);(e || N.get(this, \"finish\")) && b.stop(!0);\n      };return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);\n    }, stop: function stop(a, b, c) {\n      var d = function d(a) {\n        var b = a.stop;delete a.stop, b(c);\n      };return \"string\" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || \"fx\", []), this.each(function () {\n        var b = !0,\n            e = null != a && a + \"queueHooks\",\n            f = n.timers,\n            g = N.get(this);if (e) g[e] && g[e].stop && d(g[e]);else for (e in g) {\n          g[e] && g[e].stop && Va.test(e) && d(g[e]);\n        }for (e = f.length; e--;) {\n          f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n        }!b && c || n.dequeue(this, a);\n      });\n    }, finish: function finish(a) {\n      return a !== !1 && (a = a || \"fx\"), this.each(function () {\n        var b,\n            c = N.get(this),\n            d = c[a + \"queue\"],\n            e = c[a + \"queueHooks\"],\n            f = n.timers,\n            g = d ? d.length : 0;for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) {\n          f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n        }for (b = 0; g > b; b++) {\n          d[b] && d[b].finish && d[b].finish.call(this);\n        }delete c.finish;\n      });\n    } }), n.each([\"toggle\", \"show\", \"hide\"], function (a, b) {\n    var c = n.fn[b];n.fn[b] = function (a, d, e) {\n      return null == a || \"boolean\" == typeof a ? c.apply(this, arguments) : this.animate(Xa(b, !0), a, d, e);\n    };\n  }), n.each({ slideDown: Xa(\"show\"), slideUp: Xa(\"hide\"), slideToggle: Xa(\"toggle\"), fadeIn: { opacity: \"show\" }, fadeOut: { opacity: \"hide\" }, fadeToggle: { opacity: \"toggle\" } }, function (a, b) {\n    n.fn[a] = function (a, c, d) {\n      return this.animate(b, a, c, d);\n    };\n  }), n.timers = [], n.fx.tick = function () {\n    var a,\n        b = 0,\n        c = n.timers;for (Sa = n.now(); b < c.length; b++) {\n      a = c[b], a() || c[b] !== a || c.splice(b--, 1);\n    }c.length || n.fx.stop(), Sa = void 0;\n  }, n.fx.timer = function (a) {\n    n.timers.push(a), a() ? n.fx.start() : n.timers.pop();\n  }, n.fx.interval = 13, n.fx.start = function () {\n    Ta || (Ta = a.setInterval(n.fx.tick, n.fx.interval));\n  }, n.fx.stop = function () {\n    a.clearInterval(Ta), Ta = null;\n  }, n.fx.speeds = { slow: 600, fast: 200, _default: 400 }, n.fn.delay = function (b, c) {\n    return b = n.fx ? n.fx.speeds[b] || b : b, c = c || \"fx\", this.queue(c, function (c, d) {\n      var e = a.setTimeout(c, b);d.stop = function () {\n        a.clearTimeout(e);\n      };\n    });\n  }, function () {\n    var a = d.createElement(\"input\"),\n        b = d.createElement(\"select\"),\n        c = b.appendChild(d.createElement(\"option\"));a.type = \"checkbox\", l.checkOn = \"\" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = d.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", l.radioValue = \"t\" === a.value;\n  }();var ab,\n      bb = n.expr.attrHandle;n.fn.extend({ attr: function attr(a, b) {\n      return K(this, n.attr, a, b, arguments.length > 1);\n    }, removeAttr: function removeAttr(a) {\n      return this.each(function () {\n        n.removeAttr(this, a);\n      });\n    } }), n.extend({ attr: function attr(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return \"undefined\" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ab : void 0)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + \"\"), c) : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d));\n    }, attrHooks: { type: { set: function set(a, b) {\n          if (!l.radioValue && \"radio\" === b && n.nodeName(a, \"input\")) {\n            var c = a.value;return a.setAttribute(\"type\", b), c && (a.value = c), b;\n          }\n        } } }, removeAttr: function removeAttr(a, b) {\n      var c,\n          d,\n          e = 0,\n          f = b && b.match(G);if (f && 1 === a.nodeType) while (c = f[e++]) {\n        d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c);\n      }\n    } }), ab = { set: function set(a, b, c) {\n      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;\n    } }, n.each(n.expr.match.bool.source.match(/\\w+/g), function (a, b) {\n    var c = bb[b] || n.find.attr;bb[b] = function (a, b, d) {\n      var e, f;return d || (f = bb[b], bb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bb[b] = f), e;\n    };\n  });var cb = /^(?:input|select|textarea|button)$/i,\n      db = /^(?:a|area)$/i;n.fn.extend({ prop: function prop(a, b) {\n      return K(this, n.prop, a, b, arguments.length > 1);\n    }, removeProp: function removeProp(a) {\n      return this.each(function () {\n        delete this[n.propFix[a] || a];\n      });\n    } }), n.extend({ prop: function prop(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b];\n    }, propHooks: { tabIndex: { get: function get(a) {\n          var b = n.find.attr(a, \"tabindex\");return b ? parseInt(b, 10) : cb.test(a.nodeName) || db.test(a.nodeName) && a.href ? 0 : -1;\n        } } }, propFix: { \"for\": \"htmlFor\", \"class\": \"className\" } }), l.optSelected || (n.propHooks.selected = { get: function get(a) {\n      var b = a.parentNode;return b && b.parentNode && b.parentNode.selectedIndex, null;\n    }, set: function set(a) {\n      var b = a.parentNode;b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex);\n    } }), n.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    n.propFix[this.toLowerCase()] = this;\n  });var eb = /[\\t\\r\\n\\f]/g;function fb(a) {\n    return a.getAttribute && a.getAttribute(\"class\") || \"\";\n  }n.fn.extend({ addClass: function addClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).addClass(a.call(this, b, fb(this)));\n      });if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              d.indexOf(\" \" + f + \" \") < 0 && (d += f + \" \");\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, removeClass: function removeClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).removeClass(a.call(this, b, fb(this)));\n      });if (!arguments.length) return this.attr(\"class\", \"\");if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              while (d.indexOf(\" \" + f + \" \") > -1) {\n                d = d.replace(\" \" + f + \" \", \" \");\n              }\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, toggleClass: function toggleClass(a, b) {\n      var c = typeof a === \"undefined\" ? \"undefined\" : _typeof(a);return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function (c) {\n        n(this).toggleClass(a.call(this, c, fb(this), b), b);\n      }) : this.each(function () {\n        var b, d, e, f;if (\"string\" === c) {\n          d = 0, e = n(this), f = a.match(G) || [];while (b = f[d++]) {\n            e.hasClass(b) ? e.removeClass(b) : e.addClass(b);\n          }\n        } else void 0 !== a && \"boolean\" !== c || (b = fb(this), b && N.set(this, \"__className__\", b), this.setAttribute && this.setAttribute(\"class\", b || a === !1 ? \"\" : N.get(this, \"__className__\") || \"\"));\n      });\n    }, hasClass: function hasClass(a) {\n      var b,\n          c,\n          d = 0;b = \" \" + a + \" \";while (c = this[d++]) {\n        if (1 === c.nodeType && (\" \" + fb(c) + \" \").replace(eb, \" \").indexOf(b) > -1) return !0;\n      }return !1;\n    } });var gb = /\\r/g,\n      hb = /[\\x20\\t\\r\\n\\f]+/g;n.fn.extend({ val: function val(a) {\n      var b,\n          c,\n          d,\n          e = this[0];{\n        if (arguments.length) return d = n.isFunction(a), this.each(function (c) {\n          var e;1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : n.isArray(e) && (e = n.map(e, function (a) {\n            return null == a ? \"\" : a + \"\";\n          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e));\n        });if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(gb, \"\") : null == c ? \"\" : c);\n      }\n    } }), n.extend({ valHooks: { option: { get: function get(a) {\n          var b = n.find.attr(a, \"value\");return null != b ? b : n.trim(n.text(a)).replace(hb, \" \");\n        } }, select: { get: function get(a) {\n          for (var b, c, d = a.options, e = a.selectedIndex, f = \"select-one\" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) {\n            if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute(\"disabled\")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, \"optgroup\"))) {\n              if (b = n(c).val(), f) return b;g.push(b);\n            }\n          }return g;\n        }, set: function set(a, b) {\n          var c,\n              d,\n              e = a.options,\n              f = n.makeArray(b),\n              g = e.length;while (g--) {\n            d = e[g], (d.selected = n.inArray(n.valHooks.option.get(d), f) > -1) && (c = !0);\n          }return c || (a.selectedIndex = -1), f;\n        } } } }), n.each([\"radio\", \"checkbox\"], function () {\n    n.valHooks[this] = { set: function set(a, b) {\n        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0;\n      } }, l.checkOn || (n.valHooks[this].get = function (a) {\n      return null === a.getAttribute(\"value\") ? \"on\" : a.value;\n    });\n  });var ib = /^(?:focusinfocus|focusoutblur)$/;n.extend(n.event, { trigger: function trigger(b, c, e, f) {\n      var g,\n          h,\n          i,\n          j,\n          l,\n          m,\n          o,\n          p = [e || d],\n          q = k.call(b, \"type\") ? b.type : b,\n          r = k.call(b, \"namespace\") ? b.namespace.split(\".\") : [];if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !ib.test(q + n.event.triggered) && (q.indexOf(\".\") > -1 && (r = q.split(\".\"), q = r.shift(), r.sort()), l = q.indexOf(\":\") < 0 && \"on\" + q, b = b[n.expando] ? b : new n.Event(q, \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join(\".\"), b.rnamespace = b.namespace ? new RegExp(\"(^|\\\\.)\" + r.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, f || !o.trigger || o.trigger.apply(e, c) !== !1)) {\n        if (!f && !o.noBubble && !n.isWindow(e)) {\n          for (j = o.delegateType || q, ib.test(j + q) || (h = h.parentNode); h; h = h.parentNode) {\n            p.push(h), i = h;\n          }i === (e.ownerDocument || d) && p.push(i.defaultView || i.parentWindow || a);\n        }g = 0;while ((h = p[g++]) && !b.isPropagationStopped()) {\n          b.type = g > 1 ? j : o.bindType || q, m = (N.get(h, \"events\") || {})[b.type] && N.get(h, \"handle\"), m && m.apply(h, c), m = l && h[l], m && m.apply && L(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());\n        }return b.type = q, f || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !L(e) || l && n.isFunction(e[q]) && !n.isWindow(e) && (i = e[l], i && (e[l] = null), n.event.triggered = q, e[q](), n.event.triggered = void 0, i && (e[l] = i)), b.result;\n      }\n    }, simulate: function simulate(a, b, c) {\n      var d = n.extend(new n.Event(), c, { type: a, isSimulated: !0 });n.event.trigger(d, null, b);\n    } }), n.fn.extend({ trigger: function trigger(a, b) {\n      return this.each(function () {\n        n.event.trigger(a, b, this);\n      });\n    }, triggerHandler: function triggerHandler(a, b) {\n      var c = this[0];return c ? n.event.trigger(a, b, c, !0) : void 0;\n    } }), n.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function (a, b) {\n    n.fn[b] = function (a, c) {\n      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);\n    };\n  }), n.fn.extend({ hover: function hover(a, b) {\n      return this.mouseenter(a).mouseleave(b || a);\n    } }), l.focusin = \"onfocusin\" in a, l.focusin || n.each({ focus: \"focusin\", blur: \"focusout\" }, function (a, b) {\n    var c = function c(a) {\n      n.event.simulate(b, a.target, n.event.fix(a));\n    };n.event.special[b] = { setup: function setup() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b);e || d.addEventListener(a, c, !0), N.access(d, b, (e || 0) + 1);\n      }, teardown: function teardown() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b) - 1;e ? N.access(d, b, e) : (d.removeEventListener(a, c, !0), N.remove(d, b));\n      } };\n  });var jb = a.location,\n      kb = n.now(),\n      lb = /\\?/;n.parseJSON = function (a) {\n    return JSON.parse(a + \"\");\n  }, n.parseXML = function (b) {\n    var c;if (!b || \"string\" != typeof b) return null;try {\n      c = new a.DOMParser().parseFromString(b, \"text/xml\");\n    } catch (d) {\n      c = void 0;\n    }return c && !c.getElementsByTagName(\"parsererror\").length || n.error(\"Invalid XML: \" + b), c;\n  };var mb = /#.*$/,\n      nb = /([?&])_=[^&]*/,\n      ob = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n      pb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      qb = /^(?:GET|HEAD)$/,\n      rb = /^\\/\\//,\n      sb = {},\n      tb = {},\n      ub = \"*/\".concat(\"*\"),\n      vb = d.createElement(\"a\");vb.href = jb.href;function wb(a) {\n    return function (b, c) {\n      \"string\" != typeof b && (c = b, b = \"*\");var d,\n          e = 0,\n          f = b.toLowerCase().match(G) || [];if (n.isFunction(c)) while (d = f[e++]) {\n        \"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);\n      }\n    };\n  }function xb(a, b, c, d) {\n    var e = {},\n        f = a === tb;function g(h) {\n      var i;return e[h] = !0, n.each(a[h] || [], function (a, h) {\n        var j = h(b, c, d);return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);\n      }), i;\n    }return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\");\n  }function yb(a, b) {\n    var c,\n        d,\n        e = n.ajaxSettings.flatOptions || {};for (c in b) {\n      void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n    }return d && n.extend(!0, a, d), a;\n  }function zb(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.contents,\n        i = a.dataTypes;while (\"*\" === i[0]) {\n      i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n    }if (d) for (e in h) {\n      if (h[e] && h[e].test(d)) {\n        i.unshift(e);break;\n      }\n    }if (i[0] in c) f = i[0];else {\n      for (e in c) {\n        if (!i[0] || a.converters[e + \" \" + i[0]]) {\n          f = e;break;\n        }g || (g = e);\n      }f = f || g;\n    }return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;\n  }function Ab(a, b, c, d) {\n    var e,\n        f,\n        g,\n        h,\n        i,\n        j = {},\n        k = a.dataTypes.slice();if (k[1]) for (g in a.converters) {\n      j[g.toLowerCase()] = a.converters[g];\n    }f = k.shift();while (f) {\n      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if (\"*\" === f) f = i;else if (\"*\" !== i && i !== f) {\n        if (g = j[i + \" \" + f] || j[\"* \" + f], !g) for (e in j) {\n          if (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));break;\n          }\n        }if (g !== !0) if (g && a[\"throws\"]) b = g(b);else try {\n          b = g(b);\n        } catch (l) {\n          return { state: \"parsererror\", error: g ? l : \"No conversion from \" + i + \" to \" + f };\n        }\n      }\n    }return { state: \"success\", data: b };\n  }n.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: jb.href, type: \"GET\", isLocal: pb.test(jb.protocol), global: !0, processData: !0, async: !0, contentType: \"application/x-www-form-urlencoded; charset=UTF-8\", accepts: { \"*\": ub, text: \"text/plain\", html: \"text/html\", xml: \"application/xml, text/xml\", json: \"application/json, text/javascript\" }, contents: { xml: /\\bxml\\b/, html: /\\bhtml/, json: /\\bjson\\b/ }, responseFields: { xml: \"responseXML\", text: \"responseText\", json: \"responseJSON\" }, converters: { \"* text\": String, \"text html\": !0, \"text json\": n.parseJSON, \"text xml\": n.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function ajaxSetup(a, b) {\n      return b ? yb(yb(a, n.ajaxSettings), b) : yb(n.ajaxSettings, a);\n    }, ajaxPrefilter: wb(sb), ajaxTransport: wb(tb), ajax: function ajax(b, c) {\n      \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (c = b, b = void 0), c = c || {};var e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m = n.ajaxSetup({}, c),\n          o = m.context || m,\n          p = m.context && (o.nodeType || o.jquery) ? n(o) : n.event,\n          q = n.Deferred(),\n          r = n.Callbacks(\"once memory\"),\n          s = m.statusCode || {},\n          t = {},\n          u = {},\n          v = 0,\n          w = \"canceled\",\n          x = { readyState: 0, getResponseHeader: function getResponseHeader(a) {\n          var b;if (2 === v) {\n            if (!h) {\n              h = {};while (b = ob.exec(g)) {\n                h[b[1].toLowerCase()] = b[2];\n              }\n            }b = h[a.toLowerCase()];\n          }return null == b ? null : b;\n        }, getAllResponseHeaders: function getAllResponseHeaders() {\n          return 2 === v ? g : null;\n        }, setRequestHeader: function setRequestHeader(a, b) {\n          var c = a.toLowerCase();return v || (a = u[c] = u[c] || a, t[a] = b), this;\n        }, overrideMimeType: function overrideMimeType(a) {\n          return v || (m.mimeType = a), this;\n        }, statusCode: function statusCode(a) {\n          var b;if (a) if (2 > v) for (b in a) {\n            s[b] = [s[b], a[b]];\n          } else x.always(a[x.status]);return this;\n        }, abort: function abort(a) {\n          var b = a || w;return e && e.abort(b), z(0, b), this;\n        } };if (q.promise(x).complete = r.add, x.success = x.done, x.error = x.fail, m.url = ((b || m.url || jb.href) + \"\").replace(mb, \"\").replace(rb, jb.protocol + \"//\"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim(m.dataType || \"*\").toLowerCase().match(G) || [\"\"], null == m.crossDomain) {\n        j = d.createElement(\"a\");try {\n          j.href = m.url, j.href = j.href, m.crossDomain = vb.protocol + \"//\" + vb.host != j.protocol + \"//\" + j.host;\n        } catch (y) {\n          m.crossDomain = !0;\n        }\n      }if (m.data && m.processData && \"string\" != typeof m.data && (m.data = n.param(m.data, m.traditional)), xb(sb, m, c, x), 2 === v) return x;k = n.event && m.global, k && 0 === n.active++ && n.event.trigger(\"ajaxStart\"), m.type = m.type.toUpperCase(), m.hasContent = !qb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (lb.test(f) ? \"&\" : \"?\") + m.data, delete m.data), m.cache === !1 && (m.url = nb.test(f) ? f.replace(nb, \"$1_=\" + kb++) : f + (lb.test(f) ? \"&\" : \"?\") + \"_=\" + kb++)), m.ifModified && (n.lastModified[f] && x.setRequestHeader(\"If-Modified-Since\", n.lastModified[f]), n.etag[f] && x.setRequestHeader(\"If-None-Match\", n.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && x.setRequestHeader(\"Content-Type\", m.contentType), x.setRequestHeader(\"Accept\", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + (\"*\" !== m.dataTypes[0] ? \", \" + ub + \"; q=0.01\" : \"\") : m.accepts[\"*\"]);for (l in m.headers) {\n        x.setRequestHeader(l, m.headers[l]);\n      }if (m.beforeSend && (m.beforeSend.call(o, x, m) === !1 || 2 === v)) return x.abort();w = \"abort\";for (l in { success: 1, error: 1, complete: 1 }) {\n        x[l](m[l]);\n      }if (e = xb(tb, m, c, x)) {\n        if (x.readyState = 1, k && p.trigger(\"ajaxSend\", [x, m]), 2 === v) return x;m.async && m.timeout > 0 && (i = a.setTimeout(function () {\n          x.abort(\"timeout\");\n        }, m.timeout));try {\n          v = 1, e.send(t, z);\n        } catch (y) {\n          if (!(2 > v)) throw y;z(-1, y);\n        }\n      } else z(-1, \"No Transport\");function z(b, c, d, h) {\n        var j,\n            l,\n            t,\n            u,\n            w,\n            y = c;2 !== v && (v = 2, i && a.clearTimeout(i), e = void 0, g = h || \"\", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (u = zb(m, x, d)), u = Ab(m, u, x, j), j ? (m.ifModified && (w = x.getResponseHeader(\"Last-Modified\"), w && (n.lastModified[f] = w), w = x.getResponseHeader(\"etag\"), w && (n.etag[f] = w)), 204 === b || \"HEAD\" === m.type ? y = \"nocontent\" : 304 === b ? y = \"notmodified\" : (y = u.state, l = u.data, t = u.error, j = !t)) : (t = y, !b && y || (y = \"error\", 0 > b && (b = 0))), x.status = b, x.statusText = (c || y) + \"\", j ? q.resolveWith(o, [l, y, x]) : q.rejectWith(o, [x, y, t]), x.statusCode(s), s = void 0, k && p.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [x, m, j ? l : t]), r.fireWith(o, [x, y]), k && (p.trigger(\"ajaxComplete\", [x, m]), --n.active || n.event.trigger(\"ajaxStop\")));\n      }return x;\n    }, getJSON: function getJSON(a, b, c) {\n      return n.get(a, b, c, \"json\");\n    }, getScript: function getScript(a, b) {\n      return n.get(a, void 0, b, \"script\");\n    } }), n.each([\"get\", \"post\"], function (a, b) {\n    n[b] = function (a, c, d, e) {\n      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({ url: a, type: b, dataType: e, data: c, success: d }, n.isPlainObject(a) && a));\n    };\n  }), n._evalUrl = function (a) {\n    return n.ajax({ url: a, type: \"GET\", dataType: \"script\", async: !1, global: !1, \"throws\": !0 });\n  }, n.fn.extend({ wrapAll: function wrapAll(a) {\n      var b;return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapAll(a.call(this, b));\n      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {\n        var a = this;while (a.firstElementChild) {\n          a = a.firstElementChild;\n        }return a;\n      }).append(this)), this);\n    }, wrapInner: function wrapInner(a) {\n      return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapInner(a.call(this, b));\n      }) : this.each(function () {\n        var b = n(this),\n            c = b.contents();c.length ? c.wrapAll(a) : b.append(a);\n      });\n    }, wrap: function wrap(a) {\n      var b = n.isFunction(a);return this.each(function (c) {\n        n(this).wrapAll(b ? a.call(this, c) : a);\n      });\n    }, unwrap: function unwrap() {\n      return this.parent().each(function () {\n        n.nodeName(this, \"body\") || n(this).replaceWith(this.childNodes);\n      }).end();\n    } }), n.expr.filters.hidden = function (a) {\n    return !n.expr.filters.visible(a);\n  }, n.expr.filters.visible = function (a) {\n    return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0;\n  };var Bb = /%20/g,\n      Cb = /\\[\\]$/,\n      Db = /\\r?\\n/g,\n      Eb = /^(?:submit|button|image|reset|file)$/i,\n      Fb = /^(?:input|select|textarea|keygen)/i;function Gb(a, b, c, d) {\n    var e;if (n.isArray(b)) n.each(b, function (b, e) {\n      c || Cb.test(a) ? d(a, e) : Gb(a + \"[\" + (\"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && null != e ? b : \"\") + \"]\", e, c, d);\n    });else if (c || \"object\" !== n.type(b)) d(a, b);else for (e in b) {\n      Gb(a + \"[\" + e + \"]\", b[e], c, d);\n    }\n  }n.param = function (a, b) {\n    var c,\n        d = [],\n        e = function e(a, b) {\n      b = n.isFunction(b) ? b() : null == b ? \"\" : b, d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(b);\n    };if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () {\n      e(this.name, this.value);\n    });else for (c in a) {\n      Gb(c, a[c], b, e);\n    }return d.join(\"&\").replace(Bb, \"+\");\n  }, n.fn.extend({ serialize: function serialize() {\n      return n.param(this.serializeArray());\n    }, serializeArray: function serializeArray() {\n      return this.map(function () {\n        var a = n.prop(this, \"elements\");return a ? n.makeArray(a) : this;\n      }).filter(function () {\n        var a = this.type;return this.name && !n(this).is(\":disabled\") && Fb.test(this.nodeName) && !Eb.test(a) && (this.checked || !X.test(a));\n      }).map(function (a, b) {\n        var c = n(this).val();return null == c ? null : n.isArray(c) ? n.map(c, function (a) {\n          return { name: b.name, value: a.replace(Db, \"\\r\\n\") };\n        }) : { name: b.name, value: c.replace(Db, \"\\r\\n\") };\n      }).get();\n    } }), n.ajaxSettings.xhr = function () {\n    try {\n      return new a.XMLHttpRequest();\n    } catch (b) {}\n  };var Hb = { 0: 200, 1223: 204 },\n      Ib = n.ajaxSettings.xhr();l.cors = !!Ib && \"withCredentials\" in Ib, l.ajax = Ib = !!Ib, n.ajaxTransport(function (b) {\n    var _c, d;return l.cors || Ib && !b.crossDomain ? { send: function send(e, f) {\n        var g,\n            h = b.xhr();if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (g in b.xhrFields) {\n          h[g] = b.xhrFields[g];\n        }b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e[\"X-Requested-With\"] || (e[\"X-Requested-With\"] = \"XMLHttpRequest\");for (g in e) {\n          h.setRequestHeader(g, e[g]);\n        }_c = function c(a) {\n          return function () {\n            _c && (_c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, \"abort\" === a ? h.abort() : \"error\" === a ? \"number\" != typeof h.status ? f(0, \"error\") : f(h.status, h.statusText) : f(Hb[h.status] || h.status, h.statusText, \"text\" !== (h.responseType || \"text\") || \"string\" != typeof h.responseText ? { binary: h.response } : { text: h.responseText }, h.getAllResponseHeaders()));\n          };\n        }, h.onload = _c(), d = h.onerror = _c(\"error\"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function () {\n          4 === h.readyState && a.setTimeout(function () {\n            _c && d();\n          });\n        }, _c = _c(\"abort\");try {\n          h.send(b.hasContent && b.data || null);\n        } catch (i) {\n          if (_c) throw i;\n        }\n      }, abort: function abort() {\n        _c && _c();\n      } } : void 0;\n  }), n.ajaxSetup({ accepts: { script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\" }, contents: { script: /\\b(?:java|ecma)script\\b/ }, converters: { \"text script\": function textScript(a) {\n        return n.globalEval(a), a;\n      } } }), n.ajaxPrefilter(\"script\", function (a) {\n    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\");\n  }), n.ajaxTransport(\"script\", function (a) {\n    if (a.crossDomain) {\n      var b, _c2;return { send: function send(e, f) {\n          b = n(\"<script>\").prop({ charset: a.scriptCharset, src: a.url }).on(\"load error\", _c2 = function c(a) {\n            b.remove(), _c2 = null, a && f(\"error\" === a.type ? 404 : 200, a.type);\n          }), d.head.appendChild(b[0]);\n        }, abort: function abort() {\n          _c2 && _c2();\n        } };\n    }\n  });var Jb = [],\n      Kb = /(=)\\?(?=&|$)|\\?\\?/;n.ajaxSetup({ jsonp: \"callback\", jsonpCallback: function jsonpCallback() {\n      var a = Jb.pop() || n.expando + \"_\" + kb++;return this[a] = !0, a;\n    } }), n.ajaxPrefilter(\"json jsonp\", function (b, c, d) {\n    var e,\n        f,\n        g,\n        h = b.jsonp !== !1 && (Kb.test(b.url) ? \"url\" : \"string\" == typeof b.data && 0 === (b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Kb.test(b.data) && \"data\");return h || \"jsonp\" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Kb, \"$1\" + e) : b.jsonp !== !1 && (b.url += (lb.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function () {\n      return g || n.error(e + \" was not called\"), g[0];\n    }, b.dataTypes[0] = \"json\", f = a[e], a[e] = function () {\n      g = arguments;\n    }, d.always(function () {\n      void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Jb.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0;\n    }), \"script\") : void 0;\n  }), n.parseHTML = function (a, b, c) {\n    if (!a || \"string\" != typeof a) return null;\"boolean\" == typeof b && (c = b, b = !1), b = b || d;var e = x.exec(a),\n        f = !c && [];return e ? [b.createElement(e[1])] : (e = ca([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes));\n  };var Lb = n.fn.load;n.fn.load = function (a, b, c) {\n    if (\"string\" != typeof a && Lb) return Lb.apply(this, arguments);var d,\n        e,\n        f,\n        g = this,\n        h = a.indexOf(\" \");return h > -1 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (e = \"POST\"), g.length > 0 && n.ajax({ url: a, type: e || \"GET\", dataType: \"html\", data: b }).done(function (a) {\n      f = arguments, g.html(d ? n(\"<div>\").append(n.parseHTML(a)).find(d) : a);\n    }).always(c && function (a, b) {\n      g.each(function () {\n        c.apply(this, f || [a.responseText, b, a]);\n      });\n    }), this;\n  }, n.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (a, b) {\n    n.fn[b] = function (a) {\n      return this.on(b, a);\n    };\n  }), n.expr.filters.animated = function (a) {\n    return n.grep(n.timers, function (b) {\n      return a === b.elem;\n    }).length;\n  };function Mb(a) {\n    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;\n  }n.offset = { setOffset: function setOffset(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = n.css(a, \"position\"),\n          l = n(a),\n          m = {};\"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = n.css(a, \"top\"), i = n.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m);\n    } }, n.fn.extend({ offset: function offset(a) {\n      if (arguments.length) return void 0 === a ? this : this.each(function (b) {\n        n.offset.setOffset(this, a, b);\n      });var b,\n          c,\n          d = this[0],\n          e = { top: 0, left: 0 },\n          f = d && d.ownerDocument;if (f) return b = f.documentElement, n.contains(b, d) ? (e = d.getBoundingClientRect(), c = Mb(f), { top: e.top + c.pageYOffset - b.clientTop, left: e.left + c.pageXOffset - b.clientLeft }) : e;\n    }, position: function position() {\n      if (this[0]) {\n        var a,\n            b,\n            c = this[0],\n            d = { top: 0, left: 0 };return \"fixed\" === n.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], \"html\") || (d = a.offset()), d.top += n.css(a[0], \"borderTopWidth\", !0), d.left += n.css(a[0], \"borderLeftWidth\", !0)), { top: b.top - d.top - n.css(c, \"marginTop\", !0), left: b.left - d.left - n.css(c, \"marginLeft\", !0) };\n      }\n    }, offsetParent: function offsetParent() {\n      return this.map(function () {\n        var a = this.offsetParent;while (a && \"static\" === n.css(a, \"position\")) {\n          a = a.offsetParent;\n        }return a || Ea;\n      });\n    } }), n.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (a, b) {\n    var c = \"pageYOffset\" === b;n.fn[a] = function (d) {\n      return K(this, function (a, d, e) {\n        var f = Mb(a);return void 0 === e ? f ? f[b] : a[d] : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e);\n      }, a, d, arguments.length);\n    };\n  }), n.each([\"top\", \"left\"], function (a, b) {\n    n.cssHooks[b] = Ga(l.pixelPosition, function (a, c) {\n      return c ? (c = Fa(a, b), Ba.test(c) ? n(a).position()[b] + \"px\" : c) : void 0;\n    });\n  }), n.each({ Height: \"height\", Width: \"width\" }, function (a, b) {\n    n.each({ padding: \"inner\" + a, content: b, \"\": \"outer\" + a }, function (c, d) {\n      n.fn[d] = function (d, e) {\n        var f = arguments.length && (c || \"boolean\" != typeof d),\n            g = c || (d === !0 || e === !0 ? \"margin\" : \"border\");return K(this, function (b, c, d) {\n          var e;return n.isWindow(b) ? b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body[\"scroll\" + a], e[\"scroll\" + a], b.body[\"offset\" + a], e[\"offset\" + a], e[\"client\" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g);\n        }, b, f ? d : void 0, f, null);\n      };\n    });\n  }), n.fn.extend({ bind: function bind(a, b, c) {\n      return this.on(a, null, b, c);\n    }, unbind: function unbind(a, b) {\n      return this.off(a, null, b);\n    }, delegate: function delegate(a, b, c, d) {\n      return this.on(b, a, c, d);\n    }, undelegate: function undelegate(a, b, c) {\n      return 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c);\n    }, size: function size() {\n      return this.length;\n    } }), n.fn.andSelf = n.fn.addBack, \"function\" == typeof define && define.amd && define(\"jquery\", [], function () {\n    return n;\n  });var Nb = a.jQuery,\n      Ob = a.$;return n.noConflict = function (b) {\n    return a.$ === n && (a.$ = Ob), b && a.jQuery === n && (a.jQuery = Nb), n;\n  }, b || (a.jQuery = a.$ = n), n;\n});"

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(5))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}!function(t){\"use strict\";function e(t){if(void 0===Function.prototype.name){var e=/function\\s([^(]{1,})\\(/,i=e.exec(t.toString());return i&&i.length>1?i[1].trim():\"\";}return void 0===t.prototype?t.constructor.name:t.prototype.constructor.name;}function i(t){return!!/true/.test(t)||!/false/.test(t)&&(isNaN(1*t)?t:parseFloat(t));}function n(t){return t.replace(/([a-z])([A-Z])/g,\"$1-$2\").toLowerCase();}var s=\"6.2.4\",o={version:s,_plugins:{},_uuids:[],rtl:function rtl(){return\"rtl\"===t(\"html\").attr(\"dir\");},plugin:function plugin(t,i){var s=i||e(t),o=n(s);this._plugins[o]=this[s]=t;},registerPlugin:function registerPlugin(t,i){var s=i?n(i):e(t.constructor).toLowerCase();t.uuid=this.GetYoDigits(6,s),t.$element.attr(\"data-\"+s)||t.$element.attr(\"data-\"+s,t.uuid),t.$element.data(\"zfPlugin\")||t.$element.data(\"zfPlugin\",t),t.$element.trigger(\"init.zf.\"+s),this._uuids.push(t.uuid);},unregisterPlugin:function unregisterPlugin(t){var i=n(e(t.$element.data(\"zfPlugin\").constructor));this._uuids.splice(this._uuids.indexOf(t.uuid),1),t.$element.removeAttr(\"data-\"+i).removeData(\"zfPlugin\").trigger(\"destroyed.zf.\"+i);for(var s in t){t[s]=null;}},reInit:function reInit(e){var i=e instanceof t;try{if(i)e.each(function(){t(this).data(\"zfPlugin\")._init();});else{var s=typeof e===\"undefined\"?\"undefined\":_typeof(e),o=this,a={object:function object(e){e.forEach(function(e){e=n(e),t(\"[data-\"+e+\"]\").foundation(\"_init\");});},string:function string(){e=n(e),t(\"[data-\"+e+\"]\").foundation(\"_init\");},undefined:function undefined(){this.object(Object.keys(o._plugins));}};a[s](e);}}catch(r){console.error(r);}finally{return e;}},GetYoDigits:function GetYoDigits(t,e){return t=t||6,Math.round(Math.pow(36,t+1)-Math.random()*Math.pow(36,t)).toString(36).slice(1)+(e?\"-\"+e:\"\");},reflow:function reflow(e,n){\"undefined\"==typeof n?n=Object.keys(this._plugins):\"string\"==typeof n&&(n=[n]);var s=this;t.each(n,function(n,o){var a=s._plugins[o],r=t(e).find(\"[data-\"+o+\"]\").addBack(\"[data-\"+o+\"]\");r.each(function(){var e=t(this),n={};if(e.data(\"zfPlugin\"))return void console.warn(\"Tried to initialize \"+o+\" on an element that already has a Foundation plugin.\");if(e.attr(\"data-options\")){e.attr(\"data-options\").split(\";\").forEach(function(t,e){var s=t.split(\":\").map(function(t){return t.trim();});s[0]&&(n[s[0]]=i(s[1]));});}try{e.data(\"zfPlugin\",new a(t(this),n));}catch(s){console.error(s);}finally{return;}});});},getFnName:e,transitionend:function transitionend(t){var e,i={transition:\"transitionend\",WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"otransitionend\"},n=document.createElement(\"div\");for(var s in i){\"undefined\"!=typeof n.style[s]&&(e=i[s]);}return e?e:(e=setTimeout(function(){t.triggerHandler(\"transitionend\",[t]);},1),\"transitionend\");}};o.util={throttle:function throttle(t,e){var i=null;return function(){var n=this,s=arguments;null===i&&(i=setTimeout(function(){t.apply(n,s),i=null;},e));};}};var a=function a(i){var n=typeof i===\"undefined\"?\"undefined\":_typeof(i),s=t(\"meta.foundation-mq\"),a=t(\".no-js\");if(s.length||t('<meta class=\"foundation-mq\">').appendTo(document.head),a.length&&a.removeClass(\"no-js\"),\"undefined\"===n)o.MediaQuery._init(),o.reflow(this);else{if(\"string\"!==n)throw new TypeError(\"We're sorry, \"+n+\" is not a valid parameter. You must use a string representing the method you wish to invoke.\");var r=Array.prototype.slice.call(arguments,1),l=this.data(\"zfPlugin\");if(void 0===l||void 0===l[i])throw new ReferenceError(\"We're sorry, '\"+i+\"' is not an available method for \"+(l?e(l):\"this element\")+\".\");1===this.length?l[i].apply(l,r):this.each(function(e,n){l[i].apply(t(n).data(\"zfPlugin\"),r);});}return this;};window.Foundation=o,t.fn.foundation=a,function(){Date.now&&window.Date.now||(window.Date.now=Date.now=function(){return new Date().getTime();});for(var t=[\"webkit\",\"moz\"],e=0;e<t.length&&!window.requestAnimationFrame;++e){var i=t[e];window.requestAnimationFrame=window[i+\"RequestAnimationFrame\"],window.cancelAnimationFrame=window[i+\"CancelAnimationFrame\"]||window[i+\"CancelRequestAnimationFrame\"];}if(/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent)||!window.requestAnimationFrame||!window.cancelAnimationFrame){var n=0;window.requestAnimationFrame=function(t){var e=Date.now(),i=Math.max(n+16,e);return setTimeout(function(){t(n=i);},i-e);},window.cancelAnimationFrame=clearTimeout;}window.performance&&window.performance.now||(window.performance={start:Date.now(),now:function now(){return Date.now()-this.start;}});}(),Function.prototype.bind||(Function.prototype.bind=function(t){if(\"function\"!=typeof this)throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");var e=Array.prototype.slice.call(arguments,1),i=this,n=function n(){},s=function s(){return i.apply(this instanceof n?this:t,e.concat(Array.prototype.slice.call(arguments)));};return this.prototype&&(n.prototype=this.prototype),s.prototype=new n(),s;});}(jQuery),!function(t){function e(t,e,n,s){var o,a,r,l,u=i(t);if(e){var d=i(e);a=u.offset.top+u.height<=d.height+d.offset.top,o=u.offset.top>=d.offset.top,r=u.offset.left>=d.offset.left,l=u.offset.left+u.width<=d.width+d.offset.left;}else a=u.offset.top+u.height<=u.windowDims.height+u.windowDims.offset.top,o=u.offset.top>=u.windowDims.offset.top,r=u.offset.left>=u.windowDims.offset.left,l=u.offset.left+u.width<=u.windowDims.width;var h=[a,o,r,l];return n?r===l==!0:s?o===a==!0:h.indexOf(!1)===-1;}function i(t,e){if(t=t.length?t[0]:t,t===window||t===document)throw new Error(\"I'm sorry, Dave. I'm afraid I can't do that.\");var i=t.getBoundingClientRect(),n=t.parentNode.getBoundingClientRect(),s=document.body.getBoundingClientRect(),o=window.pageYOffset,a=window.pageXOffset;return{width:i.width,height:i.height,offset:{top:i.top+o,left:i.left+a},parentDims:{width:n.width,height:n.height,offset:{top:n.top+o,left:n.left+a}},windowDims:{width:s.width,height:s.height,offset:{top:o,left:a}}};}function n(t,e,n,s,o,a){var r=i(t),l=e?i(e):null;switch(n){case\"top\":return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left,top:l.offset.top-(r.height+s)};case\"left\":return{left:l.offset.left-(r.width+o),top:l.offset.top};case\"right\":return{left:l.offset.left+l.width+o,top:l.offset.top};case\"center top\":return{left:l.offset.left+l.width/2-r.width/2,top:l.offset.top-(r.height+s)};case\"center bottom\":return{left:a?o:l.offset.left+l.width/2-r.width/2,top:l.offset.top+l.height+s};case\"center left\":return{left:l.offset.left-(r.width+o),top:l.offset.top+l.height/2-r.height/2};case\"center right\":return{left:l.offset.left+l.width+o+1,top:l.offset.top+l.height/2-r.height/2};case\"center\":return{left:r.windowDims.offset.left+r.windowDims.width/2-r.width/2,top:r.windowDims.offset.top+r.windowDims.height/2-r.height/2};case\"reveal\":return{left:(r.windowDims.width-r.width)/2,top:r.windowDims.offset.top+s};case\"reveal full\":return{left:r.windowDims.offset.left,top:r.windowDims.offset.top};case\"left bottom\":return{left:l.offset.left,top:l.offset.top+l.height};case\"right bottom\":return{left:l.offset.left+l.width+o-r.width,top:l.offset.top+l.height};default:return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left+o,top:l.offset.top+l.height+s};}}Foundation.Box={ImNotTouchingYou:e,GetDimensions:i,GetOffsets:n};}(jQuery),!function(t){function e(t){var e={};for(var i in t){e[t[i]]=t[i];}return e;}var i={9:\"TAB\",13:\"ENTER\",27:\"ESCAPE\",32:\"SPACE\",37:\"ARROW_LEFT\",38:\"ARROW_UP\",39:\"ARROW_RIGHT\",40:\"ARROW_DOWN\"},n={},s={keys:e(i),parseKey:function parseKey(t){var e=i[t.which||t.keyCode]||String.fromCharCode(t.which).toUpperCase();return t.shiftKey&&(e=\"SHIFT_\"+e),t.ctrlKey&&(e=\"CTRL_\"+e),t.altKey&&(e=\"ALT_\"+e),e;},handleKey:function handleKey(e,i,s){var o,a,r,l=n[i],u=this.parseKey(e);if(!l)return console.warn(\"Component not defined!\");if(o=\"undefined\"==typeof l.ltr?l:Foundation.rtl()?t.extend({},l.ltr,l.rtl):t.extend({},l.rtl,l.ltr),a=o[u],r=s[a],r&&\"function\"==typeof r){var d=r.apply();(s.handled||\"function\"==typeof s.handled)&&s.handled(d);}else(s.unhandled||\"function\"==typeof s.unhandled)&&s.unhandled();},findFocusable:function findFocusable(e){return e.find(\"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]\").filter(function(){return!(!t(this).is(\":visible\")||t(this).attr(\"tabindex\")<0);});},register:function register(t,e){n[t]=e;}};Foundation.Keyboard=s;}(jQuery),!function(t){function e(t){var e={};return\"string\"!=typeof t?e:(t=t.trim().slice(1,-1))?e=t.split(\"&\").reduce(function(t,e){var i=e.replace(/\\+/g,\" \").split(\"=\"),n=i[0],s=i[1];return n=decodeURIComponent(n),s=void 0===s?null:decodeURIComponent(s),t.hasOwnProperty(n)?Array.isArray(t[n])?t[n].push(s):t[n]=[t[n],s]:t[n]=s,t;},{}):e;}var i={queries:[],current:\"\",_init:function _init(){var i,n=this,s=t(\".foundation-mq\").css(\"font-family\");i=e(s);for(var o in i){i.hasOwnProperty(o)&&n.queries.push({name:o,value:\"only screen and (min-width: \"+i[o]+\")\"});}this.current=this._getCurrentSize(),this._watcher();},atLeast:function atLeast(t){var e=this.get(t);return!!e&&window.matchMedia(e).matches;},get:function get(t){for(var e in this.queries){if(this.queries.hasOwnProperty(e)){var i=this.queries[e];if(t===i.name)return i.value;}}return null;},_getCurrentSize:function _getCurrentSize(){for(var t,e=0;e<this.queries.length;e++){var i=this.queries[e];window.matchMedia(i.value).matches&&(t=i);}return\"object\"==(typeof t===\"undefined\"?\"undefined\":_typeof(t))?t.name:t;},_watcher:function _watcher(){var e=this;t(window).on(\"resize.zf.mediaquery\",function(){var i=e._getCurrentSize(),n=e.current;i!==n&&(e.current=i,t(window).trigger(\"changed.zf.mediaquery\",[i,n]));});}};Foundation.MediaQuery=i,window.matchMedia||(window.matchMedia=function(){\"use strict\";var t=window.styleMedia||window.media;if(!t){var e=document.createElement(\"style\"),i=document.getElementsByTagName(\"script\")[0],n=null;e.type=\"text/css\",e.id=\"matchmediajs-test\",i&&i.parentNode&&i.parentNode.insertBefore(e,i),n=\"getComputedStyle\"in window&&window.getComputedStyle(e,null)||e.currentStyle,t={matchMedium:function matchMedium(t){var i=\"@media \"+t+\"{ #matchmediajs-test { width: 1px; } }\";return e.styleSheet?e.styleSheet.cssText=i:e.textContent=i,\"1px\"===n.width;}};}return function(e){return{matches:t.matchMedium(e||\"all\"),media:e||\"all\"};};}()),Foundation.MediaQuery=i;}(jQuery),!function(t){function e(t,e,i){function n(r){a||(a=window.performance.now()),o=r-a,i.apply(e),o<t?s=window.requestAnimationFrame(n,e):(window.cancelAnimationFrame(s),e.trigger(\"finished.zf.animate\",[e]).triggerHandler(\"finished.zf.animate\",[e]));}var s,o,a=null;s=window.requestAnimationFrame(n);}function i(e,i,o,a){function r(){e||i.hide(),l(),a&&a.apply(i);}function l(){i[0].style.transitionDuration=0,i.removeClass(u+\" \"+d+\" \"+o);}if(i=t(i).eq(0),i.length){var u=e?n[0]:n[1],d=e?s[0]:s[1];l(),i.addClass(o).css(\"transition\",\"none\"),requestAnimationFrame(function(){i.addClass(u),e&&i.show();}),requestAnimationFrame(function(){i[0].offsetWidth,i.css(\"transition\",\"\").addClass(d);}),i.one(Foundation.transitionend(i),r);}}var n=[\"mui-enter\",\"mui-leave\"],s=[\"mui-enter-active\",\"mui-leave-active\"],o={animateIn:function animateIn(t,e,n){i(!0,t,e,n);},animateOut:function animateOut(t,e,n){i(!1,t,e,n);}};Foundation.Move=e,Foundation.Motion=o;}(jQuery),!function(t){var e={Feather:function Feather(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"zf\";e.attr(\"role\",\"menubar\");var n=e.find(\"li\").attr({role:\"menuitem\"}),s=\"is-\"+i+\"-submenu\",o=s+\"-item\",a=\"is-\"+i+\"-submenu-parent\";e.find(\"a:first\").attr(\"tabindex\",0),n.each(function(){var e=t(this),i=e.children(\"ul\");i.length&&(e.addClass(a).attr({\"aria-haspopup\":!0,\"aria-expanded\":!1,\"aria-label\":e.children(\"a:first\").text()}),i.addClass(\"submenu \"+s).attr({\"data-submenu\":\"\",\"aria-hidden\":!0,role:\"menu\"})),e.parent(\"[data-submenu]\").length&&e.addClass(\"is-submenu-item \"+o);});},Burn:function Burn(t,e){var i=(t.find(\"li\").removeAttr(\"tabindex\"),\"is-\"+e+\"-submenu\"),n=i+\"-item\",s=\"is-\"+e+\"-submenu-parent\";t.find(\">li, .menu, .menu > li\").removeClass(i+\" \"+n+\" \"+s+\" is-submenu-item submenu is-active\").removeAttr(\"data-submenu\").css(\"display\",\"\");}};Foundation.Nest=e;}(jQuery),!function(t){function e(t,e,i){var n,s,o=this,a=e.duration,r=Object.keys(t.data())[0]||\"timer\",l=-1;this.isPaused=!1,this.restart=function(){l=-1,clearTimeout(s),this.start();},this.start=function(){this.isPaused=!1,clearTimeout(s),l=l<=0?a:l,t.data(\"paused\",!1),n=Date.now(),s=setTimeout(function(){e.infinite&&o.restart(),i&&\"function\"==typeof i&&i();},l),t.trigger(\"timerstart.zf.\"+r);},this.pause=function(){this.isPaused=!0,clearTimeout(s),t.data(\"paused\",!0);var e=Date.now();l-=e-n,t.trigger(\"timerpaused.zf.\"+r);};}function i(e,i){function n(){s--,0===s&&i();}var s=e.length;0===s&&i(),e.each(function(){this.complete?n():\"undefined\"!=typeof this.naturalWidth&&this.naturalWidth>0?n():t(this).one(\"load\",function(){n();});});}Foundation.Timer=e,Foundation.onImagesLoaded=i;}(jQuery),function(t){function e(){this.removeEventListener(\"touchmove\",i),this.removeEventListener(\"touchend\",e),u=!1;}function i(i){if(t.spotSwipe.preventDefault&&i.preventDefault(),u){var n,s=i.touches[0].pageX,a=(i.touches[0].pageY,o-s);l=new Date().getTime()-r,Math.abs(a)>=t.spotSwipe.moveThreshold&&l<=t.spotSwipe.timeThreshold&&(n=a>0?\"left\":\"right\"),n&&(i.preventDefault(),e.call(this),t(this).trigger(\"swipe\",n).trigger(\"swipe\"+n));}}function n(t){1==t.touches.length&&(o=t.touches[0].pageX,a=t.touches[0].pageY,u=!0,r=new Date().getTime(),this.addEventListener(\"touchmove\",i,!1),this.addEventListener(\"touchend\",e,!1));}function s(){this.addEventListener&&this.addEventListener(\"touchstart\",n,!1);}t.spotSwipe={version:\"1.0.0\",enabled:\"ontouchstart\"in document.documentElement,preventDefault:!1,moveThreshold:75,timeThreshold:200};var o,a,r,l,u=!1;t.event.special.swipe={setup:s},t.each([\"left\",\"up\",\"down\",\"right\"],function(){t.event.special[\"swipe\"+this]={setup:function setup(){t(this).on(\"swipe\",t.noop);}};});}(jQuery),!function(t){t.fn.addTouch=function(){this.each(function(i,n){t(n).bind(\"touchstart touchmove touchend touchcancel\",function(){e(event);});});var e=function e(t){var e,i=t.changedTouches,n=i[0],s={touchstart:\"mousedown\",touchmove:\"mousemove\",touchend:\"mouseup\"},o=s[t.type];\"MouseEvent\"in window&&\"function\"==typeof window.MouseEvent?e=new window.MouseEvent(o,{bubbles:!0,cancelable:!0,screenX:n.screenX,screenY:n.screenY,clientX:n.clientX,clientY:n.clientY}):(e=document.createEvent(\"MouseEvent\"),e.initMouseEvent(o,!0,!0,window,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null)),n.target.dispatchEvent(e);};};}(jQuery),!function(t){function e(){o(),n(),s(),i();}function i(e){var i=t(\"[data-yeti-box]\"),n=[\"dropdown\",\"tooltip\",\"reveal\"];if(e&&(\"string\"==typeof e?n.push(e):\"object\"==(typeof e===\"undefined\"?\"undefined\":_typeof(e))&&\"string\"==typeof e[0]?n.concat(e):console.error(\"Plugin names must be strings\")),i.length){var s=n.map(function(t){return\"closeme.zf.\"+t;}).join(\" \");t(window).off(s).on(s,function(e,i){var n=e.namespace.split(\".\")[0],s=t(\"[data-\"+n+\"]\").not('[data-yeti-box=\"'+i+'\"]');s.each(function(){var e=t(this);e.triggerHandler(\"close.zf.trigger\",[e]);});});}}function n(e){var i=void 0,n=t(\"[data-resize]\");n.length&&t(window).off(\"resize.zf.trigger\").on(\"resize.zf.trigger\",function(s){i&&clearTimeout(i),i=setTimeout(function(){a||n.each(function(){t(this).triggerHandler(\"resizeme.zf.trigger\");}),n.attr(\"data-events\",\"resize\");},e||10);});}function s(e){var i=void 0,n=t(\"[data-scroll]\");n.length&&t(window).off(\"scroll.zf.trigger\").on(\"scroll.zf.trigger\",function(s){i&&clearTimeout(i),i=setTimeout(function(){a||n.each(function(){t(this).triggerHandler(\"scrollme.zf.trigger\");}),n.attr(\"data-events\",\"scroll\");},e||10);});}function o(){if(!a)return!1;var e=document.querySelectorAll(\"[data-resize], [data-scroll], [data-mutate]\"),i=function i(e){var i=t(e[0].target);switch(i.attr(\"data-events\")){case\"resize\":i.triggerHandler(\"resizeme.zf.trigger\",[i]);break;case\"scroll\":i.triggerHandler(\"scrollme.zf.trigger\",[i,window.pageYOffset]);break;default:return!1;}};if(e.length)for(var n=0;n<=e.length-1;n++){var s=new a(i);s.observe(e[n],{attributes:!0,childList:!1,characterData:!1,subtree:!1,attributeFilter:[\"data-events\"]});}}var a=function(){for(var t=[\"WebKit\",\"Moz\",\"O\",\"Ms\",\"\"],e=0;e<t.length;e++){if(t[e]+\"MutationObserver\"in window)return window[t[e]+\"MutationObserver\"];}return!1;}(),r=function r(e,i){e.data(i).split(\" \").forEach(function(n){t(\"#\"+n)[\"close\"===i?\"trigger\":\"triggerHandler\"](i+\".zf.trigger\",[e]);});};t(document).on(\"click.zf.trigger\",\"[data-open]\",function(){r(t(this),\"open\");}),t(document).on(\"click.zf.trigger\",\"[data-close]\",function(){var e=t(this).data(\"close\");e?r(t(this),\"close\"):t(this).trigger(\"close.zf.trigger\");}),t(document).on(\"click.zf.trigger\",\"[data-toggle]\",function(){r(t(this),\"toggle\");}),t(document).on(\"close.zf.trigger\",\"[data-closable]\",function(e){e.stopPropagation();var i=t(this).data(\"closable\");\"\"!==i?Foundation.Motion.animateOut(t(this),i,function(){t(this).trigger(\"closed.zf\");}):t(this).fadeOut().trigger(\"closed.zf\");}),t(document).on(\"focus.zf.trigger blur.zf.trigger\",\"[data-toggle-focus]\",function(){var e=t(this).data(\"toggle-focus\");t(\"#\"+e).triggerHandler(\"toggle.zf.trigger\",[t(this)]);}),t(window).on(\"load\",function(){e();}),Foundation.IHearYou=e;}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Abide\");}return _createClass(e,[{key:\"_init\",value:function value(){this.$inputs=this.$element.find(\"input, textarea, select\"),this._events();}},{key:\"_events\",value:function value(){var e=this;this.$element.off(\".abide\").on(\"reset.zf.abide\",function(){e.resetForm();}).on(\"submit.zf.abide\",function(){return e.validateForm();}),\"fieldChange\"===this.options.validateOn&&this.$inputs.off(\"change.zf.abide\").on(\"change.zf.abide\",function(i){e.validateInput(t(i.target));}),this.options.liveValidate&&this.$inputs.off(\"input.zf.abide\").on(\"input.zf.abide\",function(i){e.validateInput(t(i.target));});}},{key:\"_reflow\",value:function value(){this._init();}},{key:\"requiredCheck\",value:function value(t){if(!t.attr(\"required\"))return!0;var e=!0;switch(t[0].type){case\"checkbox\":e=t[0].checked;break;case\"select\":case\"select-one\":case\"select-multiple\":var i=t.find(\"option:selected\");i.length&&i.val()||(e=!1);break;default:t.val()&&t.val().length||(e=!1);}return e;}},{key:\"findFormError\",value:function value(t){var e=t.siblings(this.options.formErrorSelector);return e.length||(e=t.parent().find(this.options.formErrorSelector)),e;}},{key:\"findLabel\",value:function value(t){var e=t[0].id,i=this.$element.find('label[for=\"'+e+'\"]');return i.length?i:t.closest(\"label\");}},{key:\"findRadioLabels\",value:function value(e){var i=this,n=e.map(function(e,n){var s=n.id,o=i.$element.find('label[for=\"'+s+'\"]');return o.length||(o=t(n).closest(\"label\")),o[0];});return t(n);}},{key:\"addErrorClasses\",value:function value(t){var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.addClass(this.options.labelErrorClass),i.length&&i.addClass(this.options.formErrorClass),t.addClass(this.options.inputErrorClass).attr(\"data-invalid\",\"\");}},{key:\"removeRadioErrorClasses\",value:function value(t){var e=this.$element.find(':radio[name=\"'+t+'\"]'),i=this.findRadioLabels(e),n=this.findFormError(e);i.length&&i.removeClass(this.options.labelErrorClass),n.length&&n.removeClass(this.options.formErrorClass),e.removeClass(this.options.inputErrorClass).removeAttr(\"data-invalid\");}},{key:\"removeErrorClasses\",value:function value(t){if(\"radio\"==t[0].type)return this.removeRadioErrorClasses(t.attr(\"name\"));var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.removeClass(this.options.labelErrorClass),i.length&&i.removeClass(this.options.formErrorClass),t.removeClass(this.options.inputErrorClass).removeAttr(\"data-invalid\");}},{key:\"validateInput\",value:function value(t){var e=this.requiredCheck(t),i=!1,n=!0,s=t.attr(\"data-validator\"),o=!0;if(t.is(\"[data-abide-ignore]\")||t.is('[type=\"hidden\"]'))return!0;switch(t[0].type){case\"radio\":i=this.validateRadio(t.attr(\"name\"));break;case\"checkbox\":i=e;break;case\"select\":case\"select-one\":case\"select-multiple\":i=e;break;default:i=this.validateText(t);}s&&(n=this.matchValidation(t,s,t.attr(\"required\"))),t.attr(\"data-equalto\")&&(o=this.options.validators.equalTo(t));var a=[e,i,n,o].indexOf(!1)===-1,r=(a?\"valid\":\"invalid\")+\".zf.abide\";return this[a?\"removeErrorClasses\":\"addErrorClasses\"](t),t.trigger(r,[t]),a;}},{key:\"validateForm\",value:function value(){var e=[],i=this;this.$inputs.each(function(){e.push(i.validateInput(t(this)));});var n=e.indexOf(!1)===-1;return this.$element.find(\"[data-abide-error]\").css(\"display\",n?\"none\":\"block\"),this.$element.trigger((n?\"formvalid\":\"forminvalid\")+\".zf.abide\",[this.$element]),n;}},{key:\"validateText\",value:function value(t,e){e=e||t.attr(\"pattern\")||t.attr(\"type\");var i=t.val(),n=!1;return i.length?n=this.options.patterns.hasOwnProperty(e)?this.options.patterns[e].test(i):e===t.attr(\"type\")||new RegExp(e).test(i):t.prop(\"required\")||(n=!0),n;}},{key:\"validateRadio\",value:function value(e){var i=this.$element.find(':radio[name=\"'+e+'\"]'),n=!1,s=!1;return i.each(function(e,i){t(i).attr(\"required\")&&(s=!0);}),s||(n=!0),n||i.each(function(e,i){t(i).prop(\"checked\")&&(n=!0);}),n;}},{key:\"matchValidation\",value:function value(t,e,i){var n=this;i=!!i;var s=e.split(\" \").map(function(e){return n.options.validators[e](t,i,t.parent());});return s.indexOf(!1)===-1;}},{key:\"resetForm\",value:function value(){var e=this.$element,i=this.options;t(\".\"+i.labelErrorClass,e).not(\"small\").removeClass(i.labelErrorClass),t(\".\"+i.inputErrorClass,e).not(\"small\").removeClass(i.inputErrorClass),t(i.formErrorSelector+\".\"+i.formErrorClass).removeClass(i.formErrorClass),e.find(\"[data-abide-error]\").css(\"display\",\"none\"),t(\":input\",e).not(\":button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]\").val(\"\").removeAttr(\"data-invalid\"),t(\":input:radio\",e).not(\"[data-abide-ignore]\").prop(\"checked\",!1).removeAttr(\"data-invalid\"),t(\":input:checkbox\",e).not(\"[data-abide-ignore]\").prop(\"checked\",!1).removeAttr(\"data-invalid\"),e.trigger(\"formreset.zf.abide\",[e]);}},{key:\"destroy\",value:function value(){var e=this;this.$element.off(\".abide\").find(\"[data-abide-error]\").css(\"display\",\"none\"),this.$inputs.off(\".abide\").each(function(){e.removeErrorClasses(t(this));}),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={validateOn:\"fieldChange\",labelErrorClass:\"is-invalid-label\",inputErrorClass:\"is-invalid-input\",formErrorSelector:\".form-error\",formErrorClass:\"is-visible\",liveValidate:!1,patterns:{alpha:/^[a-zA-Z]+$/,alpha_numeric:/^[a-zA-Z0-9]+$/,integer:/^[-+]?\\d+$/,number:/^[-+]?\\d*(?:[\\.\\,]\\d+)?$/,card:/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$/,cvv:/^([0-9]){3,4}$/,email:/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,url:/^(https?|ftp|file|ssh):\\/\\/(((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/,domain:/^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,8}$/,datetime:/^([0-2][0-9]{3})\\-([0-1][0-9])\\-([0-3][0-9])T([0-5][0-9])\\:([0-5][0-9])\\:([0-5][0-9])(Z|([\\-\\+]([0-1][0-9])\\:00))$/,date:/(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,time:/^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,dateISO:/^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}$/,month_day_year:/^(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.]\\d{4}$/,day_month_year:/^(0[1-9]|[12][0-9]|3[01])[- \\/.](0[1-9]|1[012])[- \\/.]\\d{4}$/,color:/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/},validators:{equalTo:function equalTo(e,i,n){return t(\"#\"+e.attr(\"data-equalto\")).val()===e.val();}}},Foundation.plugin(e,\"Abide\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Accordion\"),Foundation.Keyboard.register(\"Accordion\",{ENTER:\"toggle\",SPACE:\"toggle\",ARROW_DOWN:\"next\",ARROW_UP:\"previous\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$element.attr(\"role\",\"tablist\"),this.$tabs=this.$element.children(\"li, [data-accordion-item]\"),this.$tabs.each(function(e,i){var n=t(i),s=n.children(\"[data-tab-content]\"),o=s[0].id||Foundation.GetYoDigits(6,\"accordion\"),a=i.id||o+\"-label\";n.find(\"a:first\").attr({\"aria-controls\":o,role:\"tab\",id:a,\"aria-expanded\":!1,\"aria-selected\":!1}),s.attr({role:\"tabpanel\",\"aria-labelledby\":a,\"aria-hidden\":!0,id:o});});var e=this.$element.find(\".is-active\").children(\"[data-tab-content]\");e.length&&this.down(e,!0),this._events();}},{key:\"_events\",value:function value(){var e=this;this.$tabs.each(function(){var i=t(this),n=i.children(\"[data-tab-content]\");n.length&&i.children(\"a\").off(\"click.zf.accordion keydown.zf.accordion\").on(\"click.zf.accordion\",function(t){t.preventDefault(),e.toggle(n);}).on(\"keydown.zf.accordion\",function(t){Foundation.Keyboard.handleKey(t,\"Accordion\",{toggle:function toggle(){e.toggle(n);},next:function next(){var t=i.next().find(\"a\").focus();e.options.multiExpand||t.trigger(\"click.zf.accordion\");},previous:function previous(){var t=i.prev().find(\"a\").focus();e.options.multiExpand||t.trigger(\"click.zf.accordion\");},handled:function handled(){t.preventDefault(),t.stopPropagation();}});});});}},{key:\"toggle\",value:function value(t){t.parent().hasClass(\"is-active\")?this.up(t):this.down(t);}},{key:\"down\",value:function value(e,i){var n=this;if(e.attr(\"aria-hidden\",!1).parent(\"[data-tab-content]\").addBack().parent().addClass(\"is-active\"),!this.options.multiExpand&&!i){var s=this.$element.children(\".is-active\").children(\"[data-tab-content]\");s.length&&this.up(s.not(e));}e.slideDown(this.options.slideSpeed,function(){n.$element.trigger(\"down.zf.accordion\",[e]);}),t(\"#\"+e.attr(\"aria-labelledby\")).attr({\"aria-expanded\":!0,\"aria-selected\":!0});}},{key:\"up\",value:function value(e){var i=e.parent().siblings(),n=this;(this.options.allowAllClosed||i.hasClass(\"is-active\"))&&e.parent().hasClass(\"is-active\")&&(e.slideUp(n.options.slideSpeed,function(){n.$element.trigger(\"up.zf.accordion\",[e]);}),e.attr(\"aria-hidden\",!0).parent().removeClass(\"is-active\"),t(\"#\"+e.attr(\"aria-labelledby\")).attr({\"aria-expanded\":!1,\"aria-selected\":!1}));}},{key:\"destroy\",value:function value(){this.$element.find(\"[data-tab-content]\").stop(!0).slideUp(0).css(\"display\",\"\"),this.$element.find(\"a\").off(\".zf.accordion\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={slideSpeed:250,multiExpand:!1,allowAllClosed:!1},Foundation.plugin(e,\"Accordion\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"accordion\"),this._init(),Foundation.registerPlugin(this,\"AccordionMenu\"),Foundation.Keyboard.register(\"AccordionMenu\",{ENTER:\"toggle\",SPACE:\"toggle\",ARROW_RIGHT:\"open\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"close\",ESCAPE:\"closeAll\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$element.find(\"[data-submenu]\").not(\".is-active\").slideUp(0),this.$element.attr({role:\"menu\",\"aria-multiselectable\":this.options.multiOpen}),this.$menuLinks=this.$element.find(\".is-accordion-submenu-parent\"),this.$menuLinks.each(function(){var e=this.id||Foundation.GetYoDigits(6,\"acc-menu-link\"),i=t(this),n=i.children(\"[data-submenu]\"),s=n[0].id||Foundation.GetYoDigits(6,\"acc-menu\"),o=n.hasClass(\"is-active\");i.attr({\"aria-controls\":s,\"aria-expanded\":o,role:\"menuitem\",id:e}),n.attr({\"aria-labelledby\":e,\"aria-hidden\":!o,role:\"menu\",id:s});});var e=this.$element.find(\".is-active\");if(e.length){var i=this;e.each(function(){i.down(t(this));});}this._events();}},{key:\"_events\",value:function value(){var e=this;this.$element.find(\"li\").each(function(){var i=t(this).children(\"[data-submenu]\");i.length&&t(this).children(\"a\").off(\"click.zf.accordionMenu\").on(\"click.zf.accordionMenu\",function(t){t.preventDefault(),e.toggle(i);});}).on(\"keydown.zf.accordionmenu\",function(i){var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\"),r=o.children(\"[data-submenu]\");a.each(function(e){if(t(this).is(o))return n=a.eq(Math.max(0,e-1)).find(\"a\").first(),s=a.eq(Math.min(e+1,a.length-1)).find(\"a\").first(),t(this).children(\"[data-submenu]:visible\").length&&(s=o.find(\"li:first-child\").find(\"a\").first()),t(this).is(\":first-child\")?n=o.parents(\"li\").first().find(\"a\").first():n.parents(\"li\").first().children(\"[data-submenu]:visible\").length&&(n=n.parents(\"li\").find(\"li:last-child\").find(\"a\").first()),void(t(this).is(\":last-child\")&&(s=o.parents(\"li\").first().next(\"li\").find(\"a\").first()));}),Foundation.Keyboard.handleKey(i,\"AccordionMenu\",{open:function open(){r.is(\":hidden\")&&(e.down(r),r.find(\"li\").first().find(\"a\").first().focus());},close:function close(){r.length&&!r.is(\":hidden\")?e.up(r):o.parent(\"[data-submenu]\").length&&(e.up(o.parent(\"[data-submenu]\")),o.parents(\"li\").first().find(\"a\").first().focus());},up:function up(){return n.focus(),!0;},down:function down(){return s.focus(),!0;},toggle:function toggle(){o.children(\"[data-submenu]\").length&&e.toggle(o.children(\"[data-submenu]\"));},closeAll:function closeAll(){e.hideAll();},handled:function handled(t){t&&i.preventDefault(),i.stopImmediatePropagation();}});});}},{key:\"hideAll\",value:function value(){this.$element.find(\"[data-submenu]\").slideUp(this.options.slideSpeed);}},{key:\"toggle\",value:function value(t){t.is(\":animated\")||(t.is(\":hidden\")?this.down(t):this.up(t));}},{key:\"down\",value:function value(t){var e=this;this.options.multiOpen||this.up(this.$element.find(\".is-active\").not(t.parentsUntil(this.$element).add(t))),t.addClass(\"is-active\").attr({\"aria-hidden\":!1}).parent(\".is-accordion-submenu-parent\").attr({\"aria-expanded\":!0}),t.slideDown(e.options.slideSpeed,function(){e.$element.trigger(\"down.zf.accordionMenu\",[t]);});}},{key:\"up\",value:function value(t){var e=this;t.slideUp(e.options.slideSpeed,function(){e.$element.trigger(\"up.zf.accordionMenu\",[t]);});var i=t.find(\"[data-submenu]\").slideUp(0).addBack().attr(\"aria-hidden\",!0);i.parent(\".is-accordion-submenu-parent\").attr(\"aria-expanded\",!1);}},{key:\"destroy\",value:function value(){this.$element.find(\"[data-submenu]\").slideDown(0).css(\"display\",\"\"),this.$element.find(\"a\").off(\"click.zf.accordionMenu\"),Foundation.Nest.Burn(this.$element,\"accordion\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={slideSpeed:250,multiOpen:!0},Foundation.plugin(e,\"AccordionMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"drilldown\"),this._init(),Foundation.registerPlugin(this,\"Drilldown\"),Foundation.Keyboard.register(\"Drilldown\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"previous\",ESCAPE:\"close\",TAB:\"down\",SHIFT_TAB:\"up\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$submenuAnchors=this.$element.find(\"li.is-drilldown-submenu-parent\").children(\"a\"),this.$submenus=this.$submenuAnchors.parent(\"li\").children(\"[data-submenu]\"),this.$menuItems=this.$element.find(\"li\").not(\".js-drilldown-back\").attr(\"role\",\"menuitem\").find(\"a\"),this._prepareMenu(),this._keyboardEvents();}},{key:\"_prepareMenu\",value:function value(){var e=this;this.$submenuAnchors.each(function(){var i=t(this),n=i.parent();e.options.parentLink&&i.clone().prependTo(n.children(\"[data-submenu]\")).wrap('<li class=\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\" role=\"menu-item\"></li>'),i.data(\"savedHref\",i.attr(\"href\")).removeAttr(\"href\").attr(\"tabindex\",0),i.children(\"[data-submenu]\").attr({\"aria-hidden\":!0,tabindex:0,role:\"menu\"}),e._events(i);}),this.$submenus.each(function(){var i=t(this),n=i.find(\".js-drilldown-back\");n.length||i.prepend(e.options.backButton),e._back(i);}),this.$element.parent().hasClass(\"is-drilldown\")||(this.$wrapper=t(this.options.wrapper).addClass(\"is-drilldown\"),this.$wrapper=this.$element.wrap(this.$wrapper).parent().css(this._getMaxDims()));}},{key:\"_events\",value:function value(e){var i=this;e.off(\"click.zf.drilldown\").on(\"click.zf.drilldown\",function(n){if(t(n.target).parentsUntil(\"ul\",\"li\").hasClass(\"is-drilldown-submenu-parent\")&&(n.stopImmediatePropagation(),n.preventDefault()),i._show(e.parent(\"li\")),i.options.closeOnClick){var s=t(\"body\");s.off(\".zf.drilldown\").on(\"click.zf.drilldown\",function(e){e.target===i.$element[0]||t.contains(i.$element[0],e.target)||(e.preventDefault(),i._hideAll(),s.off(\".zf.drilldown\"));});}});}},{key:\"_keyboardEvents\",value:function value(){var e=this;this.$menuItems.add(this.$element.find(\".js-drilldown-back > a\")).on(\"keydown.zf.drilldown\",function(i){var n,s,o=t(this),a=o.parent(\"li\").parent(\"ul\").children(\"li\").children(\"a\");a.each(function(e){if(t(this).is(o))return n=a.eq(Math.max(0,e-1)),void(s=a.eq(Math.min(e+1,a.length-1)));}),Foundation.Keyboard.handleKey(i,\"Drilldown\",{next:function next(){if(o.is(e.$submenuAnchors))return e._show(o.parent(\"li\")),o.parent(\"li\").one(Foundation.transitionend(o),function(){o.parent(\"li\").find(\"ul li a\").filter(e.$menuItems).first().focus();}),!0;},previous:function previous(){return e._hide(o.parent(\"li\").parent(\"ul\")),o.parent(\"li\").parent(\"ul\").one(Foundation.transitionend(o),function(){setTimeout(function(){o.parent(\"li\").parent(\"ul\").parent(\"li\").children(\"a\").first().focus();},1);}),!0;},up:function up(){return n.focus(),!0;},down:function down(){return s.focus(),!0;},close:function close(){e._back();},open:function open(){return o.is(e.$menuItems)?o.is(e.$submenuAnchors)?(e._show(o.parent(\"li\")),o.parent(\"li\").one(Foundation.transitionend(o),function(){o.parent(\"li\").find(\"ul li a\").filter(e.$menuItems).first().focus();}),!0):void 0:(e._hide(o.parent(\"li\").parent(\"ul\")),o.parent(\"li\").parent(\"ul\").one(Foundation.transitionend(o),function(){setTimeout(function(){o.parent(\"li\").parent(\"ul\").parent(\"li\").children(\"a\").first().focus();},1);}),!0);},handled:function handled(t){t&&i.preventDefault(),i.stopImmediatePropagation();}});});}},{key:\"_hideAll\",value:function value(){var t=this.$element.find(\".is-drilldown-submenu.is-active\").addClass(\"is-closing\");t.one(Foundation.transitionend(t),function(e){t.removeClass(\"is-active is-closing\");}),this.$element.trigger(\"closed.zf.drilldown\");}},{key:\"_back\",value:function value(t){var e=this;t.off(\"click.zf.drilldown\"),t.children(\".js-drilldown-back\").on(\"click.zf.drilldown\",function(i){i.stopImmediatePropagation(),e._hide(t);var n=t.parent(\"li\").parent(\"ul\").parent(\"li\");n.length&&e._show(n);});}},{key:\"_menuLinkEvents\",value:function value(){var t=this;this.$menuItems.not(\".is-drilldown-submenu-parent\").off(\"click.zf.drilldown\").on(\"click.zf.drilldown\",function(e){setTimeout(function(){t._hideAll();},0);});}},{key:\"_show\",value:function value(t){t.attr(\"aria-expanded\",!0),t.children(\"[data-submenu]\").addClass(\"is-active\").attr(\"aria-hidden\",!1),this.$element.trigger(\"open.zf.drilldown\",[t]);}},{key:\"_hide\",value:function value(t){t.parent(\"li\").attr(\"aria-expanded\",!1),t.attr(\"aria-hidden\",!0).addClass(\"is-closing\").one(Foundation.transitionend(t),function(){t.removeClass(\"is-active is-closing\"),t.blur();}),t.trigger(\"hide.zf.drilldown\",[t]);}},{key:\"_getMaxDims\",value:function value(){var t=0,e={};return this.$submenus.add(this.$element).each(function(e,i){var n=i.getBoundingClientRect().height;n>t&&(t=n);}),e[\"min-height\"]=t+\"px\",e[\"max-width\"]=this.$element[0].getBoundingClientRect().width+\"px\",e;}},{key:\"destroy\",value:function value(){this._hideAll(),Foundation.Nest.Burn(this.$element,\"drilldown\"),this.$element.unwrap().find(\".js-drilldown-back, .is-submenu-parent-item\").remove().end().find(\".is-active, .is-closing, .is-drilldown-submenu\").removeClass(\"is-active is-closing is-drilldown-submenu\").end().find(\"[data-submenu]\").removeAttr(\"aria-hidden tabindex role\"),this.$submenuAnchors.each(function(){t(this).off(\".zf.drilldown\");}),this.$element.find(\"a\").each(function(){var e=t(this);e.removeAttr(\"tabindex\"),e.data(\"savedHref\")&&e.attr(\"href\",e.data(\"savedHref\")).removeData(\"savedHref\");}),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={backButton:'<li class=\"js-drilldown-back\"><a tabindex=\"0\">Back</a></li>',wrapper:\"<div></div>\",parentLink:!1,closeOnClick:!1},Foundation.plugin(e,\"Drilldown\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Dropdown\"),Foundation.Keyboard.register(\"Dropdown\",{ENTER:\"open\",SPACE:\"open\",ESCAPE:\"close\",TAB:\"tab_forward\",SHIFT_TAB:\"tab_backward\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"id\");this.$anchor=t(t('[data-toggle=\"'+e+'\"]').length?'[data-toggle=\"'+e+'\"]':'[data-open=\"'+e+'\"]'),this.$anchor.attr({\"aria-controls\":e,\"data-is-focus\":!1,\"data-yeti-box\":e,\"aria-haspopup\":!0,\"aria-expanded\":!1}),this.options.positionClass=this.getPositionClass(),this.counter=4,this.usedPositions=[],this.$element.attr({\"aria-hidden\":\"true\",\"data-yeti-box\":e,\"data-resize\":e,\"aria-labelledby\":this.$anchor[0].id||Foundation.GetYoDigits(6,\"dd-anchor\")}),this._events();}},{key:\"getPositionClass\",value:function value(){var t=this.$element[0].className.match(/(top|left|right|bottom)/g);t=t?t[0]:\"\";var e=/float-(\\S+)/.exec(this.$anchor[0].className);e=e?e[1]:\"\";var i=e?e+\" \"+t:t;return i;}},{key:\"_reposition\",value:function value(t){this.usedPositions.push(t?t:\"bottom\"),!t&&this.usedPositions.indexOf(\"top\")<0?this.$element.addClass(\"top\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):\"left\"===t&&this.usedPositions.indexOf(\"right\")<0?this.$element.removeClass(t).addClass(\"right\"):\"right\"===t&&this.usedPositions.indexOf(\"left\")<0?this.$element.removeClass(t).addClass(\"left\"):!t&&this.usedPositions.indexOf(\"top\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.$element.addClass(\"left\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.$element.removeClass(t).addClass(\"left\"):\"left\"===t&&this.usedPositions.indexOf(\"right\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):\"right\"===t&&this.usedPositions.indexOf(\"left\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):this.$element.removeClass(t),this.classChanged=!0,this.counter--;}},{key:\"_setPosition\",value:function value(){if(\"false\"===this.$anchor.attr(\"aria-expanded\"))return!1;var t=this.getPositionClass(),e=Foundation.Box.GetDimensions(this.$element),i=(Foundation.Box.GetDimensions(this.$anchor),\"left\"===t?\"left\":\"right\"===t?\"left\":\"top\"),n=\"top\"===i?\"height\":\"width\";\"height\"===n?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.$element))return this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,\"center bottom\",this.options.vOffset,this.options.hOffset,!0)).css({width:e.windowDims.width-2*this.options.hOffset,height:\"auto\"}),this.classChanged=!0,!1;for(this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,t,this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.$element,!1,!0)&&this.counter;){this._reposition(t),this._setPosition();}}},{key:\"_events\",value:function value(){var e=this;this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"resizeme.zf.trigger\":this._setPosition.bind(this)}),this.options.hover&&(this.$anchor.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\",function(){t('body[data-whatinput=\"mouse\"]').is(\"*\")&&(clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.open(),e.$anchor.data(\"hover\",!0);},e.options.hoverDelay));}).on(\"mouseleave.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data(\"hover\",!1);},e.options.hoverDelay);}),this.options.hoverPane&&this.$element.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\",function(){clearTimeout(e.timeout);}).on(\"mouseleave.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data(\"hover\",!1);},e.options.hoverDelay);})),this.$anchor.add(this.$element).on(\"keydown.zf.dropdown\",function(i){var n=t(this),s=Foundation.Keyboard.findFocusable(e.$element);Foundation.Keyboard.handleKey(i,\"Dropdown\",{tab_forward:function tab_forward(){e.$element.find(\":focus\").is(s.eq(-1))&&(e.options.trapFocus?(s.eq(0).focus(),i.preventDefault()):e.close());},tab_backward:function tab_backward(){(e.$element.find(\":focus\").is(s.eq(0))||e.$element.is(\":focus\"))&&(e.options.trapFocus?(s.eq(-1).focus(),i.preventDefault()):e.close());},open:function open(){n.is(e.$anchor)&&(e.open(),e.$element.attr(\"tabindex\",-1).focus(),i.preventDefault());},close:function close(){e.close(),e.$anchor.focus();}});});}},{key:\"_addBodyHandler\",value:function value(){var e=t(document.body).not(this.$element),i=this;e.off(\"click.zf.dropdown\").on(\"click.zf.dropdown\",function(t){i.$anchor.is(t.target)||i.$anchor.find(t.target).length||i.$element.find(t.target).length||(i.close(),e.off(\"click.zf.dropdown\"));});}},{key:\"open\",value:function value(){if(this.$element.trigger(\"closeme.zf.dropdown\",this.$element.attr(\"id\")),this.$anchor.addClass(\"hover\").attr({\"aria-expanded\":!0}),this._setPosition(),this.$element.addClass(\"is-open\").attr({\"aria-hidden\":!1}),this.options.autoFocus){var t=Foundation.Keyboard.findFocusable(this.$element);t.length&&t.eq(0).focus();}this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger(\"show.zf.dropdown\",[this.$element]);}},{key:\"close\",value:function value(){if(!this.$element.hasClass(\"is-open\"))return!1;if(this.$element.removeClass(\"is-open\").attr({\"aria-hidden\":!0}),this.$anchor.removeClass(\"hover\").attr(\"aria-expanded\",!1),this.classChanged){var t=this.getPositionClass();t&&this.$element.removeClass(t),this.$element.addClass(this.options.positionClass).css({height:\"\",width:\"\"}),this.classChanged=!1,this.counter=4,this.usedPositions.length=0;}this.$element.trigger(\"hide.zf.dropdown\",[this.$element]);}},{key:\"toggle\",value:function value(){if(this.$element.hasClass(\"is-open\")){if(this.$anchor.data(\"hover\"))return;this.close();}else this.open();}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.trigger\").hide(),this.$anchor.off(\".zf.dropdown\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={hoverDelay:250,hover:!1,hoverPane:!1,vOffset:1,hOffset:1,positionClass:\"\",trapFocus:!1,autoFocus:!1,closeOnClick:!1},Foundation.plugin(e,\"Dropdown\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"dropdown\"),this._init(),Foundation.registerPlugin(this,\"DropdownMenu\"),Foundation.Keyboard.register(\"DropdownMenu\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"previous\",ESCAPE:\"close\"});}return _createClass(e,[{key:\"_init\",value:function value(){var t=this.$element.find(\"li.is-dropdown-submenu-parent\");this.$element.children(\".is-dropdown-submenu-parent\").children(\".is-dropdown-submenu\").addClass(\"first-sub\"),this.$menuItems=this.$element.find('[role=\"menuitem\"]'),this.$tabs=this.$element.children('[role=\"menuitem\"]'),this.$tabs.find(\"ul.is-dropdown-submenu\").addClass(this.options.verticalClass),this.$element.hasClass(this.options.rightClass)||\"right\"===this.options.alignment||Foundation.rtl()||this.$element.parents(\".top-bar-right\").is(\"*\")?(this.options.alignment=\"right\",t.addClass(\"opens-left\")):t.addClass(\"opens-right\"),this.changed=!1,this._events();}},{key:\"_isVertical\",value:function value(){return\"block\"===this.$tabs.css(\"display\");}},{key:\"_events\",value:function value(){var e=this,i=\"ontouchstart\"in window||\"undefined\"!=typeof window.ontouchstart,n=\"is-dropdown-submenu-parent\",s=function s(_s){var o=t(_s.target).parentsUntil(\"ul\",\".\"+n),a=o.hasClass(n),r=\"true\"===o.attr(\"data-is-click\"),l=o.children(\".is-dropdown-submenu\");if(!a)return void(e.options.closeOnClickInside&&e._hide(o));if(r){if(!e.options.closeOnClick||!e.options.clickOpen&&!i||e.options.forceFollow&&i)return;_s.stopImmediatePropagation(),_s.preventDefault(),e._hide(o);}else _s.preventDefault(),_s.stopImmediatePropagation(),e._show(l),o.add(o.parentsUntil(e.$element,\".\"+n)).attr(\"data-is-click\",!0);};(this.options.clickOpen||i)&&this.$menuItems.on(\"click.zf.dropdownmenu touchstart.zf.dropdownmenu\",s),this.options.disableHover||this.$menuItems.on(\"mouseenter.zf.dropdownmenu\",function(i){var s=t(this),o=s.hasClass(n);o&&(clearTimeout(e.delay),e.delay=setTimeout(function(){e._show(s.children(\".is-dropdown-submenu\"));},e.options.hoverDelay));}).on(\"mouseleave.zf.dropdownmenu\",function(i){var s=t(this),o=s.hasClass(n);if(o&&e.options.autoclose){if(\"true\"===s.attr(\"data-is-click\")&&e.options.clickOpen)return!1;clearTimeout(e.delay),e.delay=setTimeout(function(){e._hide(s);},e.options.closingTime);}}),this.$menuItems.on(\"keydown.zf.dropdownmenu\",function(i){var n,s,o=t(i.target).parentsUntil(\"ul\",'[role=\"menuitem\"]'),a=e.$tabs.index(o)>-1,r=a?e.$tabs:o.siblings(\"li\").add(o);r.each(function(e){if(t(this).is(o))return n=r.eq(e-1),void(s=r.eq(e+1));});var l=function l(){o.is(\":last-child\")||(s.children(\"a:first\").focus(),i.preventDefault());},u=function u(){n.children(\"a:first\").focus(),i.preventDefault();},d=function d(){var t=o.children(\"ul.is-dropdown-submenu\");t.length&&(e._show(t),o.find(\"li > a:first\").focus(),i.preventDefault());},h=function h(){var t=o.parent(\"ul\").parent(\"li\");t.children(\"a:first\").focus(),e._hide(t),i.preventDefault();},c={open:d,close:function close(){e._hide(e.$element),e.$menuItems.find(\"a:first\").focus(),i.preventDefault();},handled:function handled(){i.stopImmediatePropagation();}};a?e._isVertical()?Foundation.rtl()?t.extend(c,{down:l,up:u,next:h,previous:d}):t.extend(c,{down:l,up:u,next:d,previous:h}):Foundation.rtl()?t.extend(c,{next:u,previous:l,down:d,up:h}):t.extend(c,{next:l,previous:u,down:d,up:h}):Foundation.rtl()?t.extend(c,{next:h,previous:d,down:l,up:u}):t.extend(c,{next:d,previous:h,down:l,up:u}),Foundation.Keyboard.handleKey(i,\"DropdownMenu\",c);});}},{key:\"_addBodyHandler\",value:function value(){var e=t(document.body),i=this;e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\").on(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\",function(t){var n=i.$element.find(t.target);n.length||(i._hide(),e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\"));});}},{key:\"_show\",value:function value(e){var i=this.$tabs.index(this.$tabs.filter(function(i,n){return t(n).find(e).length>0;})),n=e.parent(\"li.is-dropdown-submenu-parent\").siblings(\"li.is-dropdown-submenu-parent\");this._hide(n,i),e.css(\"visibility\",\"hidden\").addClass(\"js-dropdown-active\").attr({\"aria-hidden\":!1}).parent(\"li.is-dropdown-submenu-parent\").addClass(\"is-active\").attr({\"aria-expanded\":!0});var s=Foundation.Box.ImNotTouchingYou(e,null,!0);if(!s){var o=\"left\"===this.options.alignment?\"-right\":\"-left\",a=e.parent(\".is-dropdown-submenu-parent\");a.removeClass(\"opens\"+o).addClass(\"opens-\"+this.options.alignment),s=Foundation.Box.ImNotTouchingYou(e,null,!0),s||a.removeClass(\"opens-\"+this.options.alignment).addClass(\"opens-inner\"),this.changed=!0;}e.css(\"visibility\",\"\"),this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger(\"show.zf.dropdownmenu\",[e]);}},{key:\"_hide\",value:function value(t,e){var i;i=t&&t.length?t:void 0!==e?this.$tabs.not(function(t,i){return t===e;}):this.$element;var n=i.hasClass(\"is-active\")||i.find(\".is-active\").length>0;if(n){if(i.find(\"li.is-active\").add(i).attr({\"aria-expanded\":!1,\"data-is-click\":!1}).removeClass(\"is-active\"),i.find(\"ul.js-dropdown-active\").attr({\"aria-hidden\":!0}).removeClass(\"js-dropdown-active\"),this.changed||i.find(\"opens-inner\").length){var s=\"left\"===this.options.alignment?\"right\":\"left\";i.find(\"li.is-dropdown-submenu-parent\").add(i).removeClass(\"opens-inner opens-\"+this.options.alignment).addClass(\"opens-\"+s),this.changed=!1;}this.$element.trigger(\"hide.zf.dropdownmenu\",[i]);}}},{key:\"destroy\",value:function value(){this.$menuItems.off(\".zf.dropdownmenu\").removeAttr(\"data-is-click\").removeClass(\"is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner\"),t(document.body).off(\".zf.dropdownmenu\"),Foundation.Nest.Burn(this.$element,\"dropdown\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={disableHover:!1,autoclose:!0,hoverDelay:50,clickOpen:!1,closingTime:500,alignment:\"left\",closeOnClick:!0,closeOnClickInside:!0,verticalClass:\"vertical\",rightClass:\"align-right\",forceFollow:!0},Foundation.plugin(e,\"DropdownMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Equalizer\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"data-equalizer\")||\"\",i=this.$element.find('[data-equalizer-watch=\"'+e+'\"]');this.$watched=i.length?i:this.$element.find(\"[data-equalizer-watch]\"),this.$element.attr(\"data-resize\",e||Foundation.GetYoDigits(6,\"eq\")),this.hasNested=this.$element.find(\"[data-equalizer]\").length>0,this.isNested=this.$element.parentsUntil(document.body,\"[data-equalizer]\").length>0,this.isOn=!1,this._bindHandler={onResizeMeBound:this._onResizeMe.bind(this),onPostEqualizedBound:this._onPostEqualized.bind(this)};var n,s=this.$element.find(\"img\");this.options.equalizeOn?(n=this._checkMQ(),t(window).on(\"changed.zf.mediaquery\",this._checkMQ.bind(this))):this._events(),(void 0!==n&&n===!1||void 0===n)&&(s.length?Foundation.onImagesLoaded(s,this._reflow.bind(this)):this._reflow());}},{key:\"_pauseEvents\",value:function value(){this.isOn=!1,this.$element.off({\".zf.equalizer\":this._bindHandler.onPostEqualizedBound,\"resizeme.zf.trigger\":this._bindHandler.onResizeMeBound});}},{key:\"_onResizeMe\",value:function value(t){this._reflow();}},{key:\"_onPostEqualized\",value:function value(t){t.target!==this.$element[0]&&this._reflow();}},{key:\"_events\",value:function value(){this._pauseEvents(),this.hasNested?this.$element.on(\"postequalized.zf.equalizer\",this._bindHandler.onPostEqualizedBound):this.$element.on(\"resizeme.zf.trigger\",this._bindHandler.onResizeMeBound),this.isOn=!0;}},{key:\"_checkMQ\",value:function value(){var t=!Foundation.MediaQuery.atLeast(this.options.equalizeOn);return t?this.isOn&&(this._pauseEvents(),this.$watched.css(\"height\",\"auto\")):this.isOn||this._events(),t;}},{key:\"_killswitch\",value:function value(){}},{key:\"_reflow\",value:function value(){return!this.options.equalizeOnStack&&this._isStacked()?(this.$watched.css(\"height\",\"auto\"),!1):void(this.options.equalizeByRow?this.getHeightsByRow(this.applyHeightByRow.bind(this)):this.getHeights(this.applyHeight.bind(this)));}},{key:\"_isStacked\",value:function value(){return this.$watched[0].getBoundingClientRect().top!==this.$watched[1].getBoundingClientRect().top;}},{key:\"getHeights\",value:function value(t){for(var e=[],i=0,n=this.$watched.length;i<n;i++){this.$watched[i].style.height=\"auto\",e.push(this.$watched[i].offsetHeight);}t(e);}},{key:\"getHeightsByRow\",value:function value(e){var i=this.$watched.length?this.$watched.first().offset().top:0,n=[],s=0;n[s]=[];for(var o=0,a=this.$watched.length;o<a;o++){this.$watched[o].style.height=\"auto\";var r=t(this.$watched[o]).offset().top;r!=i&&(s++,n[s]=[],i=r),n[s].push([this.$watched[o],this.$watched[o].offsetHeight]);}for(var l=0,u=n.length;l<u;l++){var d=t(n[l]).map(function(){return this[1];}).get(),h=Math.max.apply(null,d);n[l].push(h);}e(n);}},{key:\"applyHeight\",value:function value(t){var e=Math.max.apply(null,t);this.$element.trigger(\"preequalized.zf.equalizer\"),this.$watched.css(\"height\",e),this.$element.trigger(\"postequalized.zf.equalizer\");}},{key:\"applyHeightByRow\",value:function value(e){this.$element.trigger(\"preequalized.zf.equalizer\");for(var i=0,n=e.length;i<n;i++){var s=e[i].length,o=e[i][s-1];if(s<=2)t(e[i][0][0]).css({height:\"auto\"});else{this.$element.trigger(\"preequalizedrow.zf.equalizer\");for(var a=0,r=s-1;a<r;a++){t(e[i][a][0]).css({height:o});}this.$element.trigger(\"postequalizedrow.zf.equalizer\");}}this.$element.trigger(\"postequalized.zf.equalizer\");}},{key:\"destroy\",value:function value(){this._pauseEvents(),this.$watched.css(\"height\",\"auto\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={equalizeOnStack:!1,equalizeByRow:!1,equalizeOn:\"\"},Foundation.plugin(e,\"Equalizer\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,n),this.rules=[],this.currentPath=\"\",this._init(),this._events(),Foundation.registerPlugin(this,\"Interchange\");}return _createClass(e,[{key:\"_init\",value:function value(){this._addBreakpoints(),this._generateRules(),this._reflow();}},{key:\"_events\",value:function value(){t(window).on(\"resize.zf.interchange\",Foundation.util.throttle(this._reflow.bind(this),50));}},{key:\"_reflow\",value:function value(){var t;for(var e in this.rules){if(this.rules.hasOwnProperty(e)){var i=this.rules[e];window.matchMedia(i.query).matches&&(t=i);}}t&&this.replace(t.path);}},{key:\"_addBreakpoints\",value:function value(){for(var t in Foundation.MediaQuery.queries){if(Foundation.MediaQuery.queries.hasOwnProperty(t)){var i=Foundation.MediaQuery.queries[t];e.SPECIAL_QUERIES[i.name]=i.value;}}}},{key:\"_generateRules\",value:function value(t){var i,n=[];i=this.options.rules?this.options.rules:this.$element.data(\"interchange\").match(/\\[.*?\\]/g);for(var s in i){if(i.hasOwnProperty(s)){var o=i[s].slice(1,-1).split(\", \"),a=o.slice(0,-1).join(\"\"),r=o[o.length-1];e.SPECIAL_QUERIES[r]&&(r=e.SPECIAL_QUERIES[r]),n.push({path:a,query:r});}}this.rules=n;}},{key:\"replace\",value:function value(e){if(this.currentPath!==e){var i=this,n=\"replaced.zf.interchange\";\"IMG\"===this.$element[0].nodeName?this.$element.attr(\"src\",e).on(\"load\",function(){i.currentPath=e;}).trigger(n):e.match(/\\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)?this.$element.css({\"background-image\":\"url(\"+e+\")\"}).trigger(n):t.get(e,function(s){i.$element.html(s).trigger(n),t(s).foundation(),i.currentPath=e;});}}},{key:\"destroy\",value:function value(){}}]),e;}();e.defaults={rules:null},e.SPECIAL_QUERIES={landscape:\"screen and (orientation: landscape)\",portrait:\"screen and (orientation: portrait)\",retina:\"only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)\"},Foundation.plugin(e,\"Interchange\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Magellan\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element[0].id||Foundation.GetYoDigits(6,\"magellan\");this.$targets=t(\"[data-magellan-target]\"),this.$links=this.$element.find(\"a\"),this.$element.attr({\"data-resize\":e,\"data-scroll\":e,id:e}),this.$active=t(),this.scrollPos=parseInt(window.pageYOffset,10),this._events();}},{key:\"calcPoints\",value:function value(){var e=this,i=document.body,n=document.documentElement;this.points=[],this.winHeight=Math.round(Math.max(window.innerHeight,n.clientHeight)),this.docHeight=Math.round(Math.max(i.scrollHeight,i.offsetHeight,n.clientHeight,n.scrollHeight,n.offsetHeight)),this.$targets.each(function(){var i=t(this),n=Math.round(i.offset().top-e.options.threshold);i.targetPoint=n,e.points.push(n);});}},{key:\"_events\",value:function value(){var e=this;t(\"html, body\"),{duration:e.options.animationDuration,easing:e.options.animationEasing};t(window).one(\"load\",function(){e.options.deepLinking&&location.hash&&e.scrollToLoc(location.hash),e.calcPoints(),e._updateActive();}),this.$element.on({\"resizeme.zf.trigger\":this.reflow.bind(this),\"scrollme.zf.trigger\":this._updateActive.bind(this)}).on(\"click.zf.magellan\",'a[href^=\"#\"]',function(t){t.preventDefault();var i=this.getAttribute(\"href\");e.scrollToLoc(i);});}},{key:\"scrollToLoc\",value:function value(e){if(!t(e).length)return!1;var i=Math.round(t(e).offset().top-this.options.threshold/2-this.options.barOffset);t(\"html, body\").stop(!0).animate({scrollTop:i},this.options.animationDuration,this.options.animationEasing);}},{key:\"reflow\",value:function value(){this.calcPoints(),this._updateActive();}},{key:\"_updateActive\",value:function value(){var t,e=parseInt(window.pageYOffset,10);if(e+this.winHeight===this.docHeight)t=this.points.length-1;else if(e<this.points[0])t=0;else{var i=this.scrollPos<e,n=this,s=this.points.filter(function(t,s){return i?t-n.options.barOffset<=e:t-n.options.barOffset-n.options.threshold<=e;});t=s.length?s.length-1:0;}if(this.$active.removeClass(this.options.activeClass),this.$active=this.$links.filter('[href=\"#'+this.$targets.eq(t).data(\"magellan-target\")+'\"]').addClass(this.options.activeClass),this.options.deepLinking){var o=this.$active[0].getAttribute(\"href\");window.history.pushState?window.history.pushState(null,null,o):window.location.hash=o;}this.scrollPos=e,this.$element.trigger(\"update.zf.magellan\",[this.$active]);}},{key:\"destroy\",value:function value(){if(this.$element.off(\".zf.trigger .zf.magellan\").find(\".\"+this.options.activeClass).removeClass(this.options.activeClass),this.options.deepLinking){var t=this.$active[0].getAttribute(\"href\");window.location.hash.replace(t,\"\");}Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={animationDuration:500,animationEasing:\"linear\",threshold:50,activeClass:\"active\",deepLinking:!1,barOffset:0},Foundation.plugin(e,\"Magellan\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.$lastTrigger=t(),this.$triggers=t(),this._init(),this._events(),Foundation.registerPlugin(this,\"OffCanvas\"),Foundation.Keyboard.register(\"OffCanvas\",{ESCAPE:\"close\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"id\");if(this.$element.attr(\"aria-hidden\",\"true\"),this.$triggers=t(document).find('[data-open=\"'+e+'\"], [data-close=\"'+e+'\"], [data-toggle=\"'+e+'\"]').attr(\"aria-expanded\",\"false\").attr(\"aria-controls\",e),this.options.closeOnClick)if(t(\".js-off-canvas-exit\").length)this.$exiter=t(\".js-off-canvas-exit\");else{var i=document.createElement(\"div\");i.setAttribute(\"class\",\"js-off-canvas-exit\"),t(\"[data-off-canvas-content]\").append(i),this.$exiter=t(i);}this.options.isRevealed=this.options.isRevealed||new RegExp(this.options.revealClass,\"g\").test(this.$element[0].className),this.options.isRevealed&&(this.options.revealOn=this.options.revealOn||this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split(\"-\")[2],this._setMQChecker()),this.options.transitionTime||(this.options.transitionTime=1e3*parseFloat(window.getComputedStyle(t(\"[data-off-canvas-wrapper]\")[0]).transitionDuration));}},{key:\"_events\",value:function value(){this.$element.off(\".zf.trigger .zf.offcanvas\").on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"keydown.zf.offcanvas\":this._handleKeyboard.bind(this)}),this.options.closeOnClick&&this.$exiter.length&&this.$exiter.on({\"click.zf.offcanvas\":this.close.bind(this)});}},{key:\"_setMQChecker\",value:function value(){var e=this;t(window).on(\"changed.zf.mediaquery\",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)?e.reveal(!0):e.reveal(!1);}).one(\"load.zf.offcanvas\",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)&&e.reveal(!0);});}},{key:\"reveal\",value:function value(t){var e=this.$element.find(\"[data-close]\");t?(this.close(),this.isRevealed=!0,this.$element.off(\"open.zf.trigger toggle.zf.trigger\"),e.length&&e.hide()):(this.isRevealed=!1,this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this)}),e.length&&e.show());}},{key:\"open\",value:function value(e,i){if(!this.$element.hasClass(\"is-open\")&&!this.isRevealed){var n=this;t(document.body);this.options.forceTop&&t(\"body\").scrollTop(0);var s=t(\"[data-off-canvas-wrapper]\");s.addClass(\"is-off-canvas-open is-open-\"+n.options.position),n.$element.addClass(\"is-open\"),this.$triggers.attr(\"aria-expanded\",\"true\"),this.$element.attr(\"aria-hidden\",\"false\").trigger(\"opened.zf.offcanvas\"),this.options.closeOnClick&&this.$exiter.addClass(\"is-visible\"),i&&(this.$lastTrigger=i),this.options.autoFocus&&s.one(Foundation.transitionend(s),function(){n.$element.hasClass(\"is-open\")&&(n.$element.attr(\"tabindex\",\"-1\"),n.$element.focus());}),this.options.trapFocus&&s.one(Foundation.transitionend(s),function(){n.$element.hasClass(\"is-open\")&&(n.$element.attr(\"tabindex\",\"-1\"),n.trapFocus());});}}},{key:\"_trapFocus\",value:function value(){var t=Foundation.Keyboard.findFocusable(this.$element),e=t.eq(0),i=t.eq(-1);t.off(\".zf.offcanvas\").on(\"keydown.zf.offcanvas\",function(t){var n=Foundation.Keyboard.parseKey(t);\"TAB\"===n&&t.target===i[0]&&(t.preventDefault(),e.focus()),\"SHIFT_TAB\"===n&&t.target===e[0]&&(t.preventDefault(),i.focus());});}},{key:\"close\",value:function value(e){if(this.$element.hasClass(\"is-open\")&&!this.isRevealed){var i=this;t(\"[data-off-canvas-wrapper]\").removeClass(\"is-off-canvas-open is-open-\"+i.options.position),i.$element.removeClass(\"is-open\"),this.$element.attr(\"aria-hidden\",\"true\").trigger(\"closed.zf.offcanvas\"),this.options.closeOnClick&&this.$exiter.removeClass(\"is-visible\"),this.$triggers.attr(\"aria-expanded\",\"false\"),this.options.trapFocus&&t(\"[data-off-canvas-content]\").removeAttr(\"tabindex\");}}},{key:\"toggle\",value:function value(t,e){this.$element.hasClass(\"is-open\")?this.close(t,e):this.open(t,e);}},{key:\"_handleKeyboard\",value:function value(t){var e=this;Foundation.Keyboard.handleKey(t,\"OffCanvas\",{close:function close(){return e.close(),e.$lastTrigger.focus(),!0;},handled:function handled(){t.stopPropagation(),t.preventDefault();}});}},{key:\"destroy\",value:function value(){this.close(),this.$element.off(\".zf.trigger .zf.offcanvas\"),this.$exiter.off(\".zf.offcanvas\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={closeOnClick:!0,transitionTime:0,position:\"left\",forceTop:!0,isRevealed:!1,revealOn:null,autoFocus:!0,revealClass:\"reveal-for-\",trapFocus:!1},Foundation.plugin(e,\"OffCanvas\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Orbit\"),Foundation.Keyboard.register(\"Orbit\",{ltr:{ARROW_RIGHT:\"next\",ARROW_LEFT:\"previous\"},rtl:{ARROW_LEFT:\"next\",ARROW_RIGHT:\"previous\"}});}return _createClass(e,[{key:\"_init\",value:function value(){this.$wrapper=this.$element.find(\".\"+this.options.containerClass),this.$slides=this.$element.find(\".\"+this.options.slideClass);var t=this.$element.find(\"img\"),e=this.$slides.filter(\".is-active\");e.length||this.$slides.eq(0).addClass(\"is-active\"),this.options.useMUI||this.$slides.addClass(\"no-motionui\"),t.length?Foundation.onImagesLoaded(t,this._prepareForOrbit.bind(this)):this._prepareForOrbit(),this.options.bullets&&this._loadBullets(),this._events(),this.options.autoPlay&&this.$slides.length>1&&this.geoSync(),this.options.accessible&&this.$wrapper.attr(\"tabindex\",0);}},{key:\"_loadBullets\",value:function value(){this.$bullets=this.$element.find(\".\"+this.options.boxOfBullets).find(\"button\");}},{key:\"geoSync\",value:function value(){var t=this;this.timer=new Foundation.Timer(this.$element,{duration:this.options.timerDelay,infinite:!1},function(){t.changeSlide(!0);}),this.timer.start();}},{key:\"_prepareForOrbit\",value:function value(){var t=this;this._setWrapperHeight(function(e){t._setSlideHeight(e);});}},{key:\"_setWrapperHeight\",value:function value(e){var i,n=0,s=0;this.$slides.each(function(){i=this.getBoundingClientRect().height,t(this).attr(\"data-slide\",s),s&&t(this).css({position:\"relative\",display:\"none\"}),n=i>n?i:n,s++;}),s===this.$slides.length&&(this.$wrapper.css({height:n}),e(n));}},{key:\"_setSlideHeight\",value:function value(e){this.$slides.each(function(){t(this).css(\"max-height\",e);});}},{key:\"_events\",value:function value(){var e=this;if(this.$slides.length>1){if(this.options.swipe&&this.$slides.off(\"swipeleft.zf.orbit swiperight.zf.orbit\").on(\"swipeleft.zf.orbit\",function(t){t.preventDefault(),e.changeSlide(!0);}).on(\"swiperight.zf.orbit\",function(t){t.preventDefault(),e.changeSlide(!1);}),this.options.autoPlay&&(this.$slides.on(\"click.zf.orbit\",function(){e.$element.data(\"clickedOn\",!e.$element.data(\"clickedOn\")),e.timer[e.$element.data(\"clickedOn\")?\"pause\":\"start\"]();}),this.options.pauseOnHover&&this.$element.on(\"mouseenter.zf.orbit\",function(){e.timer.pause();}).on(\"mouseleave.zf.orbit\",function(){e.$element.data(\"clickedOn\")||e.timer.start();})),this.options.navButtons){var i=this.$element.find(\".\"+this.options.nextClass+\", .\"+this.options.prevClass);i.attr(\"tabindex\",0).on(\"click.zf.orbit touchend.zf.orbit\",function(i){i.preventDefault(),e.changeSlide(t(this).hasClass(e.options.nextClass));});}this.options.bullets&&this.$bullets.on(\"click.zf.orbit touchend.zf.orbit\",function(){if(/is-active/g.test(this.className))return!1;var i=t(this).data(\"slide\"),n=i>e.$slides.filter(\".is-active\").data(\"slide\"),s=e.$slides.eq(i);e.changeSlide(n,s,i);}),this.options.accessible&&this.$wrapper.add(this.$bullets).on(\"keydown.zf.orbit\",function(i){Foundation.Keyboard.handleKey(i,\"Orbit\",{next:function next(){e.changeSlide(!0);},previous:function previous(){e.changeSlide(!1);},handled:function handled(){t(i.target).is(e.$bullets)&&e.$bullets.filter(\".is-active\").focus();}});});}}},{key:\"changeSlide\",value:function value(t,e,i){var n=this.$slides.filter(\".is-active\").eq(0);if(/mui/g.test(n[0].className))return!1;var s,o=this.$slides.first(),a=this.$slides.last(),r=t?\"Right\":\"Left\",l=t?\"Left\":\"Right\",u=this;s=e?e:t?this.options.infiniteWrap?n.next(\".\"+this.options.slideClass).length?n.next(\".\"+this.options.slideClass):o:n.next(\".\"+this.options.slideClass):this.options.infiniteWrap?n.prev(\".\"+this.options.slideClass).length?n.prev(\".\"+this.options.slideClass):a:n.prev(\".\"+this.options.slideClass),s.length&&(this.$element.trigger(\"beforeslidechange.zf.orbit\",[n,s]),this.options.bullets&&(i=i||this.$slides.index(s),this._updateBullets(i)),this.options.useMUI?(Foundation.Motion.animateIn(s.addClass(\"is-active\").css({position:\"absolute\",top:0}),this.options[\"animInFrom\"+r],function(){s.css({position:\"relative\",display:\"block\"}).attr(\"aria-live\",\"polite\");}),Foundation.Motion.animateOut(n.removeClass(\"is-active\"),this.options[\"animOutTo\"+l],function(){n.removeAttr(\"aria-live\"),u.options.autoPlay&&!u.timer.isPaused&&u.timer.restart();})):(n.removeClass(\"is-active is-in\").removeAttr(\"aria-live\").hide(),s.addClass(\"is-active is-in\").attr(\"aria-live\",\"polite\").show(),this.options.autoPlay&&!this.timer.isPaused&&this.timer.restart()),this.$element.trigger(\"slidechange.zf.orbit\",[s]));}},{key:\"_updateBullets\",value:function value(t){var e=this.$element.find(\".\"+this.options.boxOfBullets).find(\".is-active\").removeClass(\"is-active\").blur(),i=e.find(\"span:last\").detach();this.$bullets.eq(t).addClass(\"is-active\").append(i);}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.orbit\").find(\"*\").off(\".zf.orbit\").end().hide(),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={bullets:!0,navButtons:!0,animInFromRight:\"slide-in-right\",animOutToRight:\"slide-out-right\",animInFromLeft:\"slide-in-left\",animOutToLeft:\"slide-out-left\",autoPlay:!0,timerDelay:5e3,infiniteWrap:!0,swipe:!0,pauseOnHover:!0,accessible:!0,containerClass:\"orbit-container\",slideClass:\"orbit-slide\",boxOfBullets:\"orbit-bullets\",nextClass:\"orbit-next\",prevClass:\"orbit-previous\",useMUI:!0},Foundation.plugin(e,\"Orbit\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.rules=this.$element.data(\"responsive-menu\"),this.currentMq=null,this.currentPlugin=null,this._init(),this._events(),Foundation.registerPlugin(this,\"ResponsiveMenu\");}return _createClass(e,[{key:\"_init\",value:function value(){if(\"string\"==typeof this.rules){for(var e={},n=this.rules.split(\" \"),s=0;s<n.length;s++){var o=n[s].split(\"-\"),a=o.length>1?o[0]:\"small\",r=o.length>1?o[1]:o[0];null!==i[r]&&(e[a]=i[r]);}this.rules=e;}t.isEmptyObject(this.rules)||this._checkMediaQueries();}},{key:\"_events\",value:function value(){var e=this;t(window).on(\"changed.zf.mediaquery\",function(){e._checkMediaQueries();});}},{key:\"_checkMediaQueries\",value:function value(){var e,n=this;t.each(this.rules,function(t){Foundation.MediaQuery.atLeast(t)&&(e=t);}),e&&(this.currentPlugin instanceof this.rules[e].plugin||(t.each(i,function(t,e){n.$element.removeClass(e.cssClass);}),this.$element.addClass(this.rules[e].cssClass),this.currentPlugin&&this.currentPlugin.destroy(),this.currentPlugin=new this.rules[e].plugin(this.$element,{})));}},{key:\"destroy\",value:function value(){this.currentPlugin.destroy(),t(window).off(\".zf.ResponsiveMenu\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={};var i={dropdown:{cssClass:\"dropdown\",plugin:Foundation._plugins[\"dropdown-menu\"]||null},drilldown:{cssClass:\"drilldown\",plugin:Foundation._plugins.drilldown||null},accordion:{cssClass:\"accordion-menu\",plugin:Foundation._plugins[\"accordion-menu\"]||null}};Foundation.plugin(e,\"ResponsiveMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),this._events(),Foundation.registerPlugin(this,\"ResponsiveToggle\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.data(\"responsive-toggle\");e||console.error(\"Your tab bar needs an ID of a Menu as the value of data-tab-bar.\"),this.$targetMenu=t(\"#\"+e),this.$toggler=this.$element.find(\"[data-toggle]\"),this._update();}},{key:\"_events\",value:function value(){this._updateMqHandler=this._update.bind(this),t(window).on(\"changed.zf.mediaquery\",this._updateMqHandler),this.$toggler.on(\"click.zf.responsiveToggle\",this.toggleMenu.bind(this));}},{key:\"_update\",value:function value(){Foundation.MediaQuery.atLeast(this.options.hideFor)?(this.$element.hide(),this.$targetMenu.show()):(this.$element.show(),this.$targetMenu.hide());}},{key:\"toggleMenu\",value:function value(){Foundation.MediaQuery.atLeast(this.options.hideFor)||(this.$targetMenu.toggle(0),this.$element.trigger(\"toggled.zf.responsiveToggle\"));}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.responsiveToggle\"),this.$toggler.off(\".zf.responsiveToggle\"),t(window).off(\"changed.zf.mediaquery\",this._updateMqHandler),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={hideFor:\"medium\"},Foundation.plugin(e,\"ResponsiveToggle\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(){return /iP(ad|hone|od).*OS/.test(window.navigator.userAgent);}function i(){return /Android/.test(window.navigator.userAgent);}function n(){return e()||i();}var s=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Reveal\"),Foundation.Keyboard.register(\"Reveal\",{ENTER:\"open\",SPACE:\"open\",ESCAPE:\"close\",TAB:\"tab_forward\",SHIFT_TAB:\"tab_backward\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.id=this.$element.attr(\"id\"),this.isActive=!1,this.cached={mq:Foundation.MediaQuery.current},this.isMobile=n(),this.$anchor=t(t('[data-open=\"'+this.id+'\"]').length?'[data-open=\"'+this.id+'\"]':'[data-toggle=\"'+this.id+'\"]'),this.$anchor.attr({\"aria-controls\":this.id,\"aria-haspopup\":!0,tabindex:0}),(this.options.fullScreen||this.$element.hasClass(\"full\"))&&(this.options.fullScreen=!0,this.options.overlay=!1),this.options.overlay&&!this.$overlay&&(this.$overlay=this._makeOverlay(this.id)),this.$element.attr({role:\"dialog\",\"aria-hidden\":!0,\"data-yeti-box\":this.id,\"data-resize\":this.id}),this.$overlay?this.$element.detach().appendTo(this.$overlay):(this.$element.detach().appendTo(t(\"body\")),this.$element.addClass(\"without-overlay\")),this._events(),this.options.deepLink&&window.location.hash===\"#\"+this.id&&t(window).one(\"load.zf.reveal\",this.open.bind(this));}},{key:\"_makeOverlay\",value:function value(e){var i=t(\"<div></div>\").addClass(\"reveal-overlay\").appendTo(\"body\");return i;}},{key:\"_updatePosition\",value:function value(){var e,i,n=this.$element.outerWidth(),s=t(window).width(),o=this.$element.outerHeight(),a=t(window).height();e=\"auto\"===this.options.hOffset?parseInt((s-n)/2,10):parseInt(this.options.hOffset,10),i=\"auto\"===this.options.vOffset?o>a?parseInt(Math.min(100,a/10),10):parseInt((a-o)/4,10):parseInt(this.options.vOffset,10),this.$element.css({top:i+\"px\"}),this.$overlay&&\"auto\"===this.options.hOffset||(this.$element.css({left:e+\"px\"}),this.$element.css({margin:\"0px\"}));}},{key:\"_events\",value:function value(){var e=this,i=this;this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":function closeZfTrigger(n,s){if(n.target===i.$element[0]||t(n.target).parents(\"[data-closable]\")[0]===s)return e.close.apply(e);},\"toggle.zf.trigger\":this.toggle.bind(this),\"resizeme.zf.trigger\":function resizemeZfTrigger(){i._updatePosition();}}),this.$anchor.length&&this.$anchor.on(\"keydown.zf.reveal\",function(t){13!==t.which&&32!==t.which||(t.stopPropagation(),t.preventDefault(),i.open());}),this.options.closeOnClick&&this.options.overlay&&this.$overlay.off(\".zf.reveal\").on(\"click.zf.reveal\",function(e){e.target!==i.$element[0]&&!t.contains(i.$element[0],e.target)&&t.contains(document,e.target)&&i.close();}),this.options.deepLink&&t(window).on(\"popstate.zf.reveal:\"+this.id,this._handleState.bind(this));}},{key:\"_handleState\",value:function value(t){window.location.hash!==\"#\"+this.id||this.isActive?this.close():this.open();}},{key:\"open\",value:function value(){var e=this;if(this.options.deepLink){var i=\"#\"+this.id;window.history.pushState?window.history.pushState(null,null,i):window.location.hash=i;}if(this.isActive=!0,this.$element.css({visibility:\"hidden\"}).show().scrollTop(0),this.options.overlay&&this.$overlay.css({visibility:\"hidden\"}).show(),this._updatePosition(),this.$element.hide().css({visibility:\"\"}),this.$overlay&&(this.$overlay.css({visibility:\"\"}).hide(),this.$element.hasClass(\"fast\")?this.$overlay.addClass(\"fast\"):this.$element.hasClass(\"slow\")&&this.$overlay.addClass(\"slow\")),this.options.multipleOpened||this.$element.trigger(\"closeme.zf.reveal\",this.id),this.options.animationIn){var n;!function(){var t=function t(){n.$element.attr({\"aria-hidden\":!1,tabindex:-1}).focus();};n=e,e.options.overlay&&Foundation.Motion.animateIn(e.$overlay,\"fade-in\"),Foundation.Motion.animateIn(e.$element,e.options.animationIn,function(){e.focusableElements=Foundation.Keyboard.findFocusable(e.$element),t();});}();}else this.options.overlay&&this.$overlay.show(0),this.$element.show(this.options.showDelay);this.$element.attr({\"aria-hidden\":!1,tabindex:-1}).focus(),this.$element.trigger(\"open.zf.reveal\"),this.isMobile?(this.originalScrollPos=window.pageYOffset,t(\"html, body\").addClass(\"is-reveal-open\")):t(\"body\").addClass(\"is-reveal-open\"),setTimeout(function(){e._extraHandlers();},0);}},{key:\"_extraHandlers\",value:function value(){var e=this;this.focusableElements=Foundation.Keyboard.findFocusable(this.$element),this.options.overlay||!this.options.closeOnClick||this.options.fullScreen||t(\"body\").on(\"click.zf.reveal\",function(i){i.target!==e.$element[0]&&!t.contains(e.$element[0],i.target)&&t.contains(document,i.target)&&e.close();}),this.options.closeOnEsc&&t(window).on(\"keydown.zf.reveal\",function(t){Foundation.Keyboard.handleKey(t,\"Reveal\",{close:function close(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus());}});}),this.$element.on(\"keydown.zf.reveal\",function(i){var n=t(this);Foundation.Keyboard.handleKey(i,\"Reveal\",{tab_forward:function tab_forward(){return e.focusableElements=Foundation.Keyboard.findFocusable(e.$element),e.$element.find(\":focus\").is(e.focusableElements.eq(-1))?(e.focusableElements.eq(0).focus(),!0):0===e.focusableElements.length||void 0;},tab_backward:function tab_backward(){return e.focusableElements=Foundation.Keyboard.findFocusable(e.$element),e.$element.find(\":focus\").is(e.focusableElements.eq(0))||e.$element.is(\":focus\")?(e.focusableElements.eq(-1).focus(),!0):0===e.focusableElements.length||void 0;},open:function open(){e.$element.find(\":focus\").is(e.$element.find(\"[data-close]\"))?setTimeout(function(){e.$anchor.focus();},1):n.is(e.focusableElements)&&e.open();},close:function close(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus());},handled:function handled(t){t&&i.preventDefault();}});});}},{key:\"close\",value:function value(){function e(){i.isMobile?(t(\"html, body\").removeClass(\"is-reveal-open\"),i.originalScrollPos&&(t(\"body\").scrollTop(i.originalScrollPos),i.originalScrollPos=null)):t(\"body\").removeClass(\"is-reveal-open\"),i.$element.attr(\"aria-hidden\",!0),i.$element.trigger(\"closed.zf.reveal\");}if(!this.isActive||!this.$element.is(\":visible\"))return!1;var i=this;this.options.animationOut?(this.options.overlay?Foundation.Motion.animateOut(this.$overlay,\"fade-out\",e):e(),Foundation.Motion.animateOut(this.$element,this.options.animationOut)):(this.options.overlay?this.$overlay.hide(0,e):e(),this.$element.hide(this.options.hideDelay)),this.options.closeOnEsc&&t(window).off(\"keydown.zf.reveal\"),!this.options.overlay&&this.options.closeOnClick&&t(\"body\").off(\"click.zf.reveal\"),this.$element.off(\"keydown.zf.reveal\"),this.options.resetOnClose&&this.$element.html(this.$element.html()),this.isActive=!1,i.options.deepLink&&(window.history.replaceState?window.history.replaceState(\"\",document.title,window.location.pathname):window.location.hash=\"\");}},{key:\"toggle\",value:function value(){this.isActive?this.close():this.open();}},{key:\"destroy\",value:function value(){this.options.overlay&&(this.$element.appendTo(t(\"body\")),this.$overlay.hide().off().remove()),this.$element.hide().off(),this.$anchor.off(\".zf\"),t(window).off(\".zf.reveal:\"+this.id),Foundation.unregisterPlugin(this);}}]),e;}();s.defaults={animationIn:\"\",animationOut:\"\",showDelay:0,hideDelay:0,closeOnClick:!0,closeOnEsc:!0,multipleOpened:!1,vOffset:\"auto\",hOffset:\"auto\",fullScreen:!1,btmOffsetPct:10,overlay:!0,resetOnClose:!1,deepLink:!1},Foundation.plugin(s,\"Reveal\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(t,e){return t/e;}function i(t,e,i,n){return Math.abs(t.position()[e]+t[n]()/2-i);}var n=function(){function n(e,i){_classCallCheck(this,n),this.$element=e,this.options=t.extend({},n.defaults,this.$element.data(),i),this._init(),Foundation.registerPlugin(this,\"Slider\"),Foundation.Keyboard.register(\"Slider\",{ltr:{ARROW_RIGHT:\"increase\",ARROW_UP:\"increase\",ARROW_DOWN:\"decrease\",ARROW_LEFT:\"decrease\",SHIFT_ARROW_RIGHT:\"increase_fast\",SHIFT_ARROW_UP:\"increase_fast\",SHIFT_ARROW_DOWN:\"decrease_fast\",SHIFT_ARROW_LEFT:\"decrease_fast\"},rtl:{ARROW_LEFT:\"increase\",ARROW_RIGHT:\"decrease\",SHIFT_ARROW_LEFT:\"increase_fast\",SHIFT_ARROW_RIGHT:\"decrease_fast\"}});}return _createClass(n,[{key:\"_init\",value:function value(){this.inputs=this.$element.find(\"input\"),this.handles=this.$element.find(\"[data-slider-handle]\"),this.$handle=this.handles.eq(0),this.$input=this.inputs.length?this.inputs.eq(0):t(\"#\"+this.$handle.attr(\"aria-controls\")),this.$fill=this.$element.find(\"[data-slider-fill]\").css(this.options.vertical?\"height\":\"width\",0);var e=!1,i=this;(this.options.disabled||this.$element.hasClass(this.options.disabledClass))&&(this.options.disabled=!0,this.$element.addClass(this.options.disabledClass)),this.inputs.length||(this.inputs=t().add(this.$input),this.options.binding=!0),this._setInitAttr(0),this._events(this.$handle),this.handles[1]&&(this.options.doubleSided=!0,this.$handle2=this.handles.eq(1),this.$input2=this.inputs.length>1?this.inputs.eq(1):t(\"#\"+this.$handle2.attr(\"aria-controls\")),this.inputs[1]||(this.inputs=this.inputs.add(this.$input2)),e=!0,this._setHandlePos(this.$handle,this.options.initialStart,!0,function(){i._setHandlePos(i.$handle2,i.options.initialEnd,!0);}),this._setInitAttr(1),this._events(this.$handle2)),e||this._setHandlePos(this.$handle,this.options.initialStart,!0);}},{key:\"_setHandlePos\",value:function value(t,i,n,s){if(!this.$element.hasClass(this.options.disabledClass)){i=parseFloat(i),i<this.options.start?i=this.options.start:i>this.options.end&&(i=this.options.end);var o=this.options.doubleSided;if(o)if(0===this.handles.index(t)){var a=parseFloat(this.$handle2.attr(\"aria-valuenow\"));i=i>=a?a-this.options.step:i;}else{var r=parseFloat(this.$handle.attr(\"aria-valuenow\"));i=i<=r?r+this.options.step:i;}this.options.vertical&&!n&&(i=this.options.end-i);var l=this,u=this.options.vertical,d=u?\"height\":\"width\",h=u?\"top\":\"left\",c=t[0].getBoundingClientRect()[d],f=this.$element[0].getBoundingClientRect()[d],p=e(i-this.options.start,this.options.end-this.options.start).toFixed(2),m=(f-c)*p,v=(100*e(m,f)).toFixed(this.options.decimal);i=parseFloat(i.toFixed(this.options.decimal));var g={};if(this._setValues(t,i),o){var w,y=0===this.handles.index(t),b=~~(100*e(c,f));if(y)g[h]=v+\"%\",w=parseFloat(this.$handle2[0].style[h])-v+b,s&&\"function\"==typeof s&&s();else{var $=parseFloat(this.$handle[0].style[h]);w=v-(isNaN($)?this.options.initialStart/((this.options.end-this.options.start)/100):$)+b;}g[\"min-\"+d]=w+\"%\";}this.$element.one(\"finished.zf.animate\",function(){l.$element.trigger(\"moved.zf.slider\",[t]);});var C=this.$element.data(\"dragging\")?1e3/60:this.options.moveTime;Foundation.Move(C,t,function(){t.css(h,v+\"%\"),l.options.doubleSided?l.$fill.css(g):l.$fill.css(d,100*p+\"%\");}),clearTimeout(l.timeout),l.timeout=setTimeout(function(){l.$element.trigger(\"changed.zf.slider\",[t]);},l.options.changedDelay);}}},{key:\"_setInitAttr\",value:function value(t){var e=this.inputs.eq(t).attr(\"id\")||Foundation.GetYoDigits(6,\"slider\");this.inputs.eq(t).attr({id:e,max:this.options.end,min:this.options.start,step:this.options.step}),this.handles.eq(t).attr({role:\"slider\",\"aria-controls\":e,\"aria-valuemax\":this.options.end,\"aria-valuemin\":this.options.start,\"aria-valuenow\":0===t?this.options.initialStart:this.options.initialEnd,\"aria-orientation\":this.options.vertical?\"vertical\":\"horizontal\",tabindex:0});}},{key:\"_setValues\",value:function value(t,e){var i=this.options.doubleSided?this.handles.index(t):0;this.inputs.eq(i).val(e),t.attr(\"aria-valuenow\",e);}},{key:\"_handleEvent\",value:function value(n,s,o){var a,r;if(o)a=this._adjustValue(null,o),r=!0;else{n.preventDefault();var l=this,u=this.options.vertical,d=u?\"height\":\"width\",h=u?\"top\":\"left\",c=u?n.pageY:n.pageX,f=(this.$handle[0].getBoundingClientRect()[d]/2,this.$element[0].getBoundingClientRect()[d]),p=u?t(window).scrollTop():t(window).scrollLeft(),m=this.$element.offset()[h];n.clientY===n.pageY&&(c+=p);var v,g=c-m;v=g<0?0:g>f?f:g;var w=e(v,f);if(a=(this.options.end-this.options.start)*w+this.options.start,Foundation.rtl()&&!this.options.vertical&&(a=this.options.end-a),a=l._adjustValue(null,a),r=!1,!s){var y=i(this.$handle,h,v,d),b=i(this.$handle2,h,v,d);s=y<=b?this.$handle:this.$handle2;}}this._setHandlePos(s,a,r);}},{key:\"_adjustValue\",value:function value(t,e){var i,n,s,o,a=this.options.step,r=parseFloat(a/2);return i=t?parseFloat(t.attr(\"aria-valuenow\")):e,n=i%a,s=i-n,o=s+a,0===n?i:i=i>=s+r?o:s;}},{key:\"_events\",value:function value(e){var i,n=this;if(this.inputs.off(\"change.zf.slider\").on(\"change.zf.slider\",function(e){var i=n.inputs.index(t(this));n._handleEvent(e,n.handles.eq(i),t(this).val());}),this.options.clickSelect&&this.$element.off(\"click.zf.slider\").on(\"click.zf.slider\",function(e){return!n.$element.data(\"dragging\")&&void(t(e.target).is(\"[data-slider-handle]\")||(n.options.doubleSided?n._handleEvent(e):n._handleEvent(e,n.$handle)));}),this.options.draggable){this.handles.addTouch();var s=t(\"body\");e.off(\"mousedown.zf.slider\").on(\"mousedown.zf.slider\",function(o){e.addClass(\"is-dragging\"),n.$fill.addClass(\"is-dragging\"),n.$element.data(\"dragging\",!0),i=t(o.currentTarget),s.on(\"mousemove.zf.slider\",function(t){t.preventDefault(),n._handleEvent(t,i);}).on(\"mouseup.zf.slider\",function(t){n._handleEvent(t,i),e.removeClass(\"is-dragging\"),n.$fill.removeClass(\"is-dragging\"),n.$element.data(\"dragging\",!1),s.off(\"mousemove.zf.slider mouseup.zf.slider\");});}).on(\"selectstart.zf.slider touchmove.zf.slider\",function(t){t.preventDefault();});}e.off(\"keydown.zf.slider\").on(\"keydown.zf.slider\",function(e){var i,s=t(this),o=n.options.doubleSided?n.handles.index(s):0,a=parseFloat(n.inputs.eq(o).val());Foundation.Keyboard.handleKey(e,\"Slider\",{decrease:function decrease(){i=a-n.options.step;},increase:function increase(){i=a+n.options.step;},decrease_fast:function decrease_fast(){i=a-10*n.options.step;},increase_fast:function increase_fast(){i=a+10*n.options.step;},handled:function handled(){e.preventDefault(),n._setHandlePos(s,i,!0);}});});}},{key:\"destroy\",value:function value(){this.handles.off(\".zf.slider\"),this.inputs.off(\".zf.slider\"),this.$element.off(\".zf.slider\"),Foundation.unregisterPlugin(this);}}]),n;}();n.defaults={start:0,end:100,step:1,initialStart:0,initialEnd:100,binding:!1,clickSelect:!0,vertical:!1,draggable:!0,disabled:!1,doubleSided:!1,decimal:2,moveTime:200,disabledClass:\"disabled\",invertVertical:!1,changedDelay:500},Foundation.plugin(n,\"Slider\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(t){return parseInt(window.getComputedStyle(document.body,null).fontSize,10)*t;}var i=function(){function i(e,n){_classCallCheck(this,i),this.$element=e,this.options=t.extend({},i.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Sticky\");}return _createClass(i,[{key:\"_init\",value:function value(){var e=this.$element.parent(\"[data-sticky-container]\"),i=this.$element[0].id||Foundation.GetYoDigits(6,\"sticky\"),n=this;e.length||(this.wasWrapped=!0),this.$container=e.length?e:t(this.options.container).wrapInner(this.$element),this.$container.addClass(this.options.containerClass),this.$element.addClass(this.options.stickyClass).attr({\"data-resize\":i}),this.scrollCount=this.options.checkEvery,this.isStuck=!1,t(window).one(\"load.zf.sticky\",function(){n.containerHeight=\"none\"==n.$element.css(\"display\")?0:n.$element[0].getBoundingClientRect().height,n.$container.css(\"height\",n.containerHeight),n.elemHeight=n.containerHeight,\"\"!==n.options.anchor?n.$anchor=t(\"#\"+n.options.anchor):n._parsePoints(),n._setSizes(function(){n._calc(!1);}),n._events(i.split(\"-\").reverse().join(\"-\"));});}},{key:\"_parsePoints\",value:function value(){for(var e=\"\"==this.options.topAnchor?1:this.options.topAnchor,i=\"\"==this.options.btmAnchor?document.documentElement.scrollHeight:this.options.btmAnchor,n=[e,i],s={},o=0,a=n.length;o<a&&n[o];o++){var r;if(\"number\"==typeof n[o])r=n[o];else{var l=n[o].split(\":\"),u=t(\"#\"+l[0]);r=u.offset().top,l[1]&&\"bottom\"===l[1].toLowerCase()&&(r+=u[0].getBoundingClientRect().height);}s[o]=r;}this.points=s;}},{key:\"_events\",value:function value(e){var i=this,n=this.scrollListener=\"scroll.zf.\"+e;this.isOn||(this.canStick&&(this.isOn=!0,t(window).off(n).on(n,function(t){0===i.scrollCount?(i.scrollCount=i.options.checkEvery,i._setSizes(function(){i._calc(!1,window.pageYOffset);})):(i.scrollCount--,i._calc(!1,window.pageYOffset));})),this.$element.off(\"resizeme.zf.trigger\").on(\"resizeme.zf.trigger\",function(t,s){i._setSizes(function(){i._calc(!1),i.canStick?i.isOn||i._events(e):i.isOn&&i._pauseListeners(n);});}));}},{key:\"_pauseListeners\",value:function value(e){this.isOn=!1,t(window).off(e),this.$element.trigger(\"pause.zf.sticky\");}},{key:\"_calc\",value:function value(t,e){return t&&this._setSizes(),this.canStick?(e||(e=window.pageYOffset),void(e>=this.topPoint?e<=this.bottomPoint?this.isStuck||this._setSticky():this.isStuck&&this._removeSticky(!1):this.isStuck&&this._removeSticky(!0))):(this.isStuck&&this._removeSticky(!0),!1);}},{key:\"_setSticky\",value:function value(){var t=this,e=this.options.stickTo,i=\"top\"===e?\"marginTop\":\"marginBottom\",n=\"top\"===e?\"bottom\":\"top\",s={};s[i]=this.options[i]+\"em\",s[e]=0,s[n]=\"auto\",s.left=this.$container.offset().left+parseInt(window.getComputedStyle(this.$container[0])[\"padding-left\"],10),this.isStuck=!0,this.$element.removeClass(\"is-anchored is-at-\"+n).addClass(\"is-stuck is-at-\"+e).css(s).trigger(\"sticky.zf.stuckto:\"+e),this.$element.on(\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\",function(){t._setSizes();});}},{key:\"_removeSticky\",value:function value(t){var e=this.options.stickTo,i=\"top\"===e,n={},s=(this.points?this.points[1]-this.points[0]:this.anchorHeight)-this.elemHeight,o=i?\"marginTop\":\"marginBottom\",a=t?\"top\":\"bottom\";n[o]=0,n.bottom=\"auto\",t?n.top=0:n.top=s,n.left=\"\",this.isStuck=!1,this.$element.removeClass(\"is-stuck is-at-\"+e).addClass(\"is-anchored is-at-\"+a).css(n).trigger(\"sticky.zf.unstuckfrom:\"+a);}},{key:\"_setSizes\",value:function value(t){this.canStick=Foundation.MediaQuery.atLeast(this.options.stickyOn),this.canStick||t&&\"function\"==typeof t&&t();var e=this.$container[0].getBoundingClientRect().width,i=window.getComputedStyle(this.$container[0]),n=parseInt(i[\"padding-right\"],10);this.$anchor&&this.$anchor.length?this.anchorHeight=this.$anchor[0].getBoundingClientRect().height:this._parsePoints(),this.$element.css({\"max-width\":e-n+\"px\"});var s=this.$element[0].getBoundingClientRect().height||this.containerHeight;if(\"none\"==this.$element.css(\"display\")&&(s=0),this.containerHeight=s,this.$container.css({height:s}),this.elemHeight=s,this.isStuck)this.$element.css({left:this.$container.offset().left+parseInt(i[\"padding-left\"],10)});else if(this.$element.hasClass(\"is-at-bottom\")){var o=(this.points?this.points[1]-this.$container.offset().top:this.anchorHeight)-this.elemHeight;this.$element.css(\"top\",o);}this._setBreakPoints(s,function(){t&&\"function\"==typeof t&&t();});}},{key:\"_setBreakPoints\",value:function value(t,i){if(!this.canStick){if(!i||\"function\"!=typeof i)return!1;i();}var n=e(this.options.marginTop),s=e(this.options.marginBottom),o=this.points?this.points[0]:this.$anchor.offset().top,a=this.points?this.points[1]:o+this.anchorHeight,r=window.innerHeight;\"top\"===this.options.stickTo?(o-=n,a-=t+n):\"bottom\"===this.options.stickTo&&(o-=r-(t+s),a-=r-s),this.topPoint=o,this.bottomPoint=a,i&&\"function\"==typeof i&&i();}},{key:\"destroy\",value:function value(){this._removeSticky(!0),this.$element.removeClass(this.options.stickyClass+\" is-anchored is-at-top\").css({height:\"\",top:\"\",bottom:\"\",\"max-width\":\"\"}).off(\"resizeme.zf.trigger\"),this.$anchor&&this.$anchor.length&&this.$anchor.off(\"change.zf.sticky\"),t(window).off(this.scrollListener),this.wasWrapped?this.$element.unwrap():this.$container.removeClass(this.options.containerClass).css({height:\"\"}),Foundation.unregisterPlugin(this);}}]),i;}();i.defaults={container:\"<div data-sticky-container></div>\",stickTo:\"top\",anchor:\"\",topAnchor:\"\",btmAnchor:\"\",marginTop:1,marginBottom:1,stickyOn:\"medium\",stickyClass:\"sticky\",containerClass:\"sticky-container\",checkEvery:-1},Foundation.plugin(i,\"Sticky\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Tabs\"),Foundation.Keyboard.register(\"Tabs\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"previous\",ARROW_DOWN:\"next\",ARROW_LEFT:\"previous\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this;if(this.$tabTitles=this.$element.find(\".\"+this.options.linkClass),this.$tabContent=t('[data-tabs-content=\"'+this.$element[0].id+'\"]'),this.$tabTitles.each(function(){var i=t(this),n=i.find(\"a\"),s=i.hasClass(\"is-active\"),o=n[0].hash.slice(1),a=n[0].id?n[0].id:o+\"-label\",r=t(\"#\"+o);i.attr({role:\"presentation\"}),n.attr({role:\"tab\",\"aria-controls\":o,\"aria-selected\":s,id:a}),r.attr({role:\"tabpanel\",\"aria-hidden\":!s,\"aria-labelledby\":a}),s&&e.options.autoFocus&&n.focus();}),this.options.matchHeight){var i=this.$tabContent.find(\"img\");i.length?Foundation.onImagesLoaded(i,this._setHeight.bind(this)):this._setHeight();}this._events();}},{key:\"_events\",value:function value(){this._addKeyHandler(),this._addClickHandler(),this._setHeightMqHandler=null,this.options.matchHeight&&(this._setHeightMqHandler=this._setHeight.bind(this),t(window).on(\"changed.zf.mediaquery\",this._setHeightMqHandler));}},{key:\"_addClickHandler\",value:function value(){var e=this;this.$element.off(\"click.zf.tabs\").on(\"click.zf.tabs\",\".\"+this.options.linkClass,function(i){i.preventDefault(),i.stopPropagation(),t(this).hasClass(\"is-active\")||e._handleTabChange(t(this));});}},{key:\"_addKeyHandler\",value:function value(){var e=this;e.$element.find(\"li:first-of-type\"),e.$element.find(\"li:last-of-type\");this.$tabTitles.off(\"keydown.zf.tabs\").on(\"keydown.zf.tabs\",function(i){if(9!==i.which){var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\");a.each(function(i){if(t(this).is(o))return void(e.options.wrapOnKeys?(n=0===i?a.last():a.eq(i-1),s=i===a.length-1?a.first():a.eq(i+1)):(n=a.eq(Math.max(0,i-1)),s=a.eq(Math.min(i+1,a.length-1))));}),Foundation.Keyboard.handleKey(i,\"Tabs\",{open:function open(){o.find('[role=\"tab\"]').focus(),e._handleTabChange(o);},previous:function previous(){n.find('[role=\"tab\"]').focus(),e._handleTabChange(n);},next:function next(){s.find('[role=\"tab\"]').focus(),e._handleTabChange(s);},handled:function handled(){i.stopPropagation(),i.preventDefault();}});}});}},{key:\"_handleTabChange\",value:function value(e){var i=e.find('[role=\"tab\"]'),n=i[0].hash,s=this.$tabContent.find(n),o=this.$element.find(\".\"+this.options.linkClass+\".is-active\").removeClass(\"is-active\").find('[role=\"tab\"]').attr({\"aria-selected\":\"false\"});t(\"#\"+o.attr(\"aria-controls\")).removeClass(\"is-active\").attr({\"aria-hidden\":\"true\"}),e.addClass(\"is-active\"),i.attr({\"aria-selected\":\"true\"}),s.addClass(\"is-active\").attr({\"aria-hidden\":\"false\"}),this.$element.trigger(\"change.zf.tabs\",[e]);}},{key:\"selectTab\",value:function value(t){var e;e=\"object\"==(typeof t===\"undefined\"?\"undefined\":_typeof(t))?t[0].id:t,e.indexOf(\"#\")<0&&(e=\"#\"+e);var i=this.$tabTitles.find('[href=\"'+e+'\"]').parent(\".\"+this.options.linkClass);this._handleTabChange(i);}},{key:\"_setHeight\",value:function value(){var e=0;this.$tabContent.find(\".\"+this.options.panelClass).css(\"height\",\"\").each(function(){var i=t(this),n=i.hasClass(\"is-active\");n||i.css({visibility:\"hidden\",display:\"block\"});var s=this.getBoundingClientRect().height;n||i.css({visibility:\"\",display:\"\"}),e=s>e?s:e;}).css(\"height\",e+\"px\");}},{key:\"destroy\",value:function value(){this.$element.find(\".\"+this.options.linkClass).off(\".zf.tabs\").hide().end().find(\".\"+this.options.panelClass).hide(),this.options.matchHeight&&null!=this._setHeightMqHandler&&t(window).off(\"changed.zf.mediaquery\",this._setHeightMqHandler),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={autoFocus:!1,wrapOnKeys:!0,matchHeight:!1,linkClass:\"tabs-title\",panelClass:\"tabs-panel\"},Foundation.plugin(e,\"Tabs\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,i.data(),n),this.className=\"\",this._init(),this._events(),Foundation.registerPlugin(this,\"Toggler\");}return _createClass(e,[{key:\"_init\",value:function value(){var e;this.options.animate?(e=this.options.animate.split(\" \"),this.animationIn=e[0],this.animationOut=e[1]||null):(e=this.$element.data(\"toggler\"),this.className=\".\"===e[0]?e.slice(1):e);var i=this.$element[0].id;t('[data-open=\"'+i+'\"], [data-close=\"'+i+'\"], [data-toggle=\"'+i+'\"]').attr(\"aria-controls\",i),this.$element.attr(\"aria-expanded\",!this.$element.is(\":hidden\"));}},{key:\"_events\",value:function value(){this.$element.off(\"toggle.zf.trigger\").on(\"toggle.zf.trigger\",this.toggle.bind(this));}},{key:\"toggle\",value:function value(){this[this.options.animate?\"_toggleAnimate\":\"_toggleClass\"]();}},{key:\"_toggleClass\",value:function value(){this.$element.toggleClass(this.className);var t=this.$element.hasClass(this.className);t?this.$element.trigger(\"on.zf.toggler\"):this.$element.trigger(\"off.zf.toggler\"),this._updateARIA(t);}},{key:\"_toggleAnimate\",value:function value(){var t=this;this.$element.is(\":hidden\")?Foundation.Motion.animateIn(this.$element,this.animationIn,function(){t._updateARIA(!0),this.trigger(\"on.zf.toggler\");}):Foundation.Motion.animateOut(this.$element,this.animationOut,function(){t._updateARIA(!1),this.trigger(\"off.zf.toggler\");});}},{key:\"_updateARIA\",value:function value(t){this.$element.attr(\"aria-expanded\",!!t);}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.toggler\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={animate:!1},Foundation.plugin(e,\"Toggler\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.isActive=!1,this.isClick=!1,this._init(),Foundation.registerPlugin(this,\"Tooltip\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"aria-describedby\")||Foundation.GetYoDigits(6,\"tooltip\");this.options.positionClass=this.options.positionClass||this._getPositionClass(this.$element),this.options.tipText=this.options.tipText||this.$element.attr(\"title\"),this.template=this.options.template?t(this.options.template):this._buildTemplate(e),this.template.appendTo(document.body).text(this.options.tipText).hide(),this.$element.attr({title:\"\",\"aria-describedby\":e,\"data-yeti-box\":e,\"data-toggle\":e,\"data-resize\":e}).addClass(this.options.triggerClass),this.usedPositions=[],this.counter=4,this.classChanged=!1,this._events();}},{key:\"_getPositionClass\",value:function value(t){if(!t)return\"\";var e=t[0].className.match(/\\b(top|left|right)\\b/g);return e=e?e[0]:\"\";}},{key:\"_buildTemplate\",value:function value(e){var i=(this.options.tooltipClass+\" \"+this.options.positionClass+\" \"+this.options.templateClasses).trim(),n=t(\"<div></div>\").addClass(i).attr({role:\"tooltip\",\"aria-hidden\":!0,\"data-is-active\":!1,\"data-is-focus\":!1,id:e});return n;}},{key:\"_reposition\",value:function value(t){this.usedPositions.push(t?t:\"bottom\"),!t&&this.usedPositions.indexOf(\"top\")<0?this.template.addClass(\"top\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):\"left\"===t&&this.usedPositions.indexOf(\"right\")<0?this.template.removeClass(t).addClass(\"right\"):\"right\"===t&&this.usedPositions.indexOf(\"left\")<0?this.template.removeClass(t).addClass(\"left\"):!t&&this.usedPositions.indexOf(\"top\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.template.addClass(\"left\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.template.removeClass(t).addClass(\"left\"):\"left\"===t&&this.usedPositions.indexOf(\"right\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):\"right\"===t&&this.usedPositions.indexOf(\"left\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):this.template.removeClass(t),this.classChanged=!0,this.counter--;}},{key:\"_setPosition\",value:function value(){var t=this._getPositionClass(this.template),e=Foundation.Box.GetDimensions(this.template),i=Foundation.Box.GetDimensions(this.$element),n=\"left\"===t?\"left\":\"right\"===t?\"left\":\"top\",s=\"top\"===n?\"height\":\"width\";\"height\"===s?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.template))return this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,\"center bottom\",this.options.vOffset,this.options.hOffset,!0)).css({width:i.windowDims.width-2*this.options.hOffset,height:\"auto\"}),!1;for(this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,\"center \"+(t||\"bottom\"),this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.template)&&this.counter;){this._reposition(t),this._setPosition();}}},{key:\"show\",value:function value(){if(\"all\"!==this.options.showOn&&!Foundation.MediaQuery.atLeast(this.options.showOn))return!1;var t=this;this.template.css(\"visibility\",\"hidden\").show(),this._setPosition(),this.$element.trigger(\"closeme.zf.tooltip\",this.template.attr(\"id\")),this.template.attr({\"data-is-active\":!0,\"aria-hidden\":!1}),t.isActive=!0,this.template.stop().hide().css(\"visibility\",\"\").fadeIn(this.options.fadeInDuration,function(){}),this.$element.trigger(\"show.zf.tooltip\");}},{key:\"hide\",value:function value(){var t=this;this.template.stop().attr({\"aria-hidden\":!0,\"data-is-active\":!1}).fadeOut(this.options.fadeOutDuration,function(){t.isActive=!1,t.isClick=!1,t.classChanged&&(t.template.removeClass(t._getPositionClass(t.template)).addClass(t.options.positionClass),t.usedPositions=[],t.counter=4,t.classChanged=!1);}),this.$element.trigger(\"hide.zf.tooltip\");}},{key:\"_events\",value:function value(){var t=this,e=(this.template,!1);this.options.disableHover||this.$element.on(\"mouseenter.zf.tooltip\",function(e){t.isActive||(t.timeout=setTimeout(function(){t.show();},t.options.hoverDelay));}).on(\"mouseleave.zf.tooltip\",function(i){clearTimeout(t.timeout),(!e||t.isClick&&!t.options.clickOpen)&&t.hide();}),this.options.clickOpen?this.$element.on(\"mousedown.zf.tooltip\",function(e){e.stopImmediatePropagation(),t.isClick||(t.isClick=!0,!t.options.disableHover&&t.$element.attr(\"tabindex\")||t.isActive||t.show());}):this.$element.on(\"mousedown.zf.tooltip\",function(e){e.stopImmediatePropagation(),t.isClick=!0;}),this.options.disableForTouch||this.$element.on(\"tap.zf.tooltip touchend.zf.tooltip\",function(e){t.isActive?t.hide():t.show();}),this.$element.on({\"close.zf.trigger\":this.hide.bind(this)}),this.$element.on(\"focus.zf.tooltip\",function(i){return e=!0,t.isClick?(t.options.clickOpen||(e=!1),!1):void t.show();}).on(\"focusout.zf.tooltip\",function(i){e=!1,t.isClick=!1,t.hide();}).on(\"resizeme.zf.trigger\",function(){t.isActive&&t._setPosition();});}},{key:\"toggle\",value:function value(){this.isActive?this.hide():this.show();}},{key:\"destroy\",value:function value(){this.$element.attr(\"title\",this.template.text()).off(\".zf.trigger .zf.tootip\").removeAttr(\"aria-describedby\").removeAttr(\"data-yeti-box\").removeAttr(\"data-toggle\").removeAttr(\"data-resize\"),this.template.remove(),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={disableForTouch:!1,hoverDelay:200,fadeInDuration:150,fadeOutDuration:150,disableHover:!1,templateClasses:\"\",tooltipClass:\"tooltip\",triggerClass:\"has-tip\",showOn:\"small\",template:\"\",tipText:\"\",touchCloseText:\"Tap to close.\",clickOpen:!0,positionClass:\"\",vOffset:10,hOffset:12},Foundation.plugin(e,\"Tooltip\");}(jQuery);"

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(39);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _reactRouter = __webpack_require__(185);
	
	var _Main = __webpack_require__(240);
	
	var _Main2 = _interopRequireDefault(_Main);
	
	var _Timer = __webpack_require__(242);
	
	var _Timer2 = _interopRequireDefault(_Timer);
	
	var _Countdown = __webpack_require__(243);
	
	var _Countdown2 = _interopRequireDefault(_Countdown);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Load Foundation
	__webpack_require__(246);
	$(document).foundation();
	
	// App styles
	__webpack_require__(250);
	
	_reactDom2.default.render(_react2.default.createElement(
	    _reactRouter.Router,
	    { history: _reactRouter.hashHistory },
	    _react2.default.createElement(
	        _reactRouter.Route,
	        { path: '/', component: _Main2.default },
	        _react2.default.createElement(_reactRouter.Route, { path: 'countdown', component: _Countdown2.default }),
	        _react2.default.createElement(_reactRouter.IndexRoute, { component: _Timer2.default })
	    )
	), document.getElementById('app'));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = jQuery;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(9);

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var ReactChildren = __webpack_require__(12);
	var ReactComponent = __webpack_require__(25);
	var ReactPureComponent = __webpack_require__(28);
	var ReactClass = __webpack_require__(29);
	var ReactDOMFactories = __webpack_require__(31);
	var ReactElement = __webpack_require__(16);
	var ReactPropTypes = __webpack_require__(36);
	var ReactVersion = __webpack_require__(37);
	
	var onlyChild = __webpack_require__(38);
	var warning = __webpack_require__(18);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(32);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var __spread = _assign;
	
	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function __spread() {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function createMixin(mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc'); // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(13);
	var ReactElement = __webpack_require__(16);
	
	var emptyFunction = __webpack_require__(19);
	var traverseAllChildren = __webpack_require__(22);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func,
	      context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result,
	      keyPrefix = bookKeeping.keyPrefix,
	      func = bookKeeping.func,
	      context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(14);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 14 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _assign = __webpack_require__(11);
	
	var ReactCurrentOwner = __webpack_require__(17);
	
	var warning = __webpack_require__(18);
	var canDefineProperty = __webpack_require__(20);
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	var REACT_ELEMENT_TYPE = __webpack_require__(21);
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	var specialPropKeyWarningShown, specialPropRefWarningShown;
	
	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}
	
	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}
	
	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function warnAboutAccessingKey() {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}
	
	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function warnAboutAccessingRef() {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}
	
	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }
	
	  return element;
	};
	
	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (Object.freeze) {
	        Object.freeze(childArray);
	      }
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = _assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }
	
	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 17 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(19);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };
	
	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }
	
	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }
	
	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }
	
	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 19 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    // $FlowFixMe https://github.com/facebook/flow/issues/285
	    Object.defineProperty({}, 'x', { get: function get() {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 21 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	module.exports = REACT_ELEMENT_TYPE;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(14);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(21);
	
	var getIteratorFn = __webpack_require__(23);
	var invariant = __webpack_require__(15);
	var KeyEscapeUtils = __webpack_require__(24);
	var warning = __webpack_require__(18);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 23 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 24 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(14);
	
	var ReactNoopUpdateQueue = __webpack_require__(26);
	
	var canDefineProperty = __webpack_require__(20);
	var emptyObject = __webpack_require__(27);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var warning = __webpack_require__(18);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var ReactComponent = __webpack_require__(25);
	var ReactNoopUpdateQueue = __webpack_require__(26);
	
	var emptyObject = __webpack_require__(27);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;
	
	module.exports = ReactPureComponent;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(14),
	    _assign = __webpack_require__(11);
	
	var ReactComponent = __webpack_require__(25);
	var ReactElement = __webpack_require__(16);
	var ReactPropTypeLocationNames = __webpack_require__(30);
	var ReactNoopUpdateQueue = __webpack_require__(26);
	
	var emptyObject = __webpack_require__(27);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var MIXINS_KEY = 'mixins';
	
	// Helper function to allow the creation of anonymous functions which do not
	// have .name set to the name of the variable being assigned to.
	function identity(fn) {
	  return fn;
	}
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	
	var injectedMixins = [];
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: 'DEFINE_MANY',
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: 'DEFINE_MANY',
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: 'DEFINE_MANY',
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: 'DEFINE_MANY',
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: 'DEFINE_MANY',
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: 'DEFINE_MANY_MERGED',
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: 'DEFINE_MANY_MERGED',
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: 'DEFINE_MANY_MERGED',
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: 'DEFINE_ONCE',
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: 'DEFINE_MANY',
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: 'DEFINE_MANY',
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: 'DEFINE_ONCE',
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: 'DEFINE_MANY',
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: 'DEFINE_MANY',
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: 'OVERRIDE_BASE'
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function displayName(Constructor, _displayName) {
	    Constructor.displayName = _displayName;
	  },
	  mixins: function mixins(Constructor, _mixins) {
	    if (_mixins) {
	      for (var i = 0; i < _mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, _mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _childContextTypes, 'childContext');
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
	  },
	  contextTypes: function contextTypes(Constructor, _contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _contextTypes, 'context');
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = _getDefaultProps;
	    }
	  },
	  propTypes: function propTypes(Constructor, _propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _propTypes, 'prop');
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
	  },
	  statics: function statics(Constructor, _statics) {
	    mixStaticSpecIntoComponent(Constructor, _statics);
	  },
	  autobind: function autobind() {} };
	
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}
	
	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec === 'undefined' ? 'undefined' : _typeof(spec);
	      var isMixinValid = typeofSpec === 'object' && spec !== null;
	
	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }
	
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;
	
	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === 'DEFINE_MANY_MERGED') {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === 'DEFINE_MANY') {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function replaceState(newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted() {
	    return this.updater.isMounted(this);
	  }
	};
	
	var ReactClassComponent = function ReactClassComponent() {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function createClass(spec) {
	    // To keep our warnings more understandable, we'll use a little hack here to
	    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
	    // unnecessarily identify a class without displayName as 'Constructor'.
	    var Constructor = identity(function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;
	
	      this.state = initialState;
	    });
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function injectMixin(mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(16);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(32);
	  createDOMFactory = ReactElementValidator.createFactory;
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),
	
	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactComponentTreeHook = __webpack_require__(33);
	var ReactElement = __webpack_require__(16);
	
	var checkReactTypeSpec = __webpack_require__(34);
	
	var canDefineProperty = __webpack_require__(20);
	var getIteratorFn = __webpack_require__(23);
	var warning = __webpack_require__(18);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();
	
	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});
	
	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function createElement(type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function createFactory(type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function cloneElement(element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(14);
	
	var ReactCurrentOwner = __webpack_require__(17);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}
	
	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);
	
	var setItem;
	var getItem;
	var removeItem;
	var getItemIDs;
	var addRoot;
	var removeRoot;
	var getRootIDs;
	
	if (canUseCollections) {
	  var itemMap = new Map();
	  var rootIDSet = new Set();
	
	  setItem = function setItem(id, item) {
	    itemMap.set(id, item);
	  };
	  getItem = function getItem(id) {
	    return itemMap.get(id);
	  };
	  removeItem = function removeItem(id) {
	    itemMap['delete'](id);
	  };
	  getItemIDs = function getItemIDs() {
	    return Array.from(itemMap.keys());
	  };
	
	  addRoot = function addRoot(id) {
	    rootIDSet.add(id);
	  };
	  removeRoot = function removeRoot(id) {
	    rootIDSet['delete'](id);
	  };
	  getRootIDs = function getRootIDs() {
	    return Array.from(rootIDSet.keys());
	  };
	} else {
	  var itemByKey = {};
	  var rootByKey = {};
	
	  // Use non-numeric keys to prevent V8 performance issues:
	  // https://github.com/facebook/react/pull/7232
	  var getKeyFromID = function getKeyFromID(id) {
	    return '.' + id;
	  };
	  var getIDFromKey = function getIDFromKey(key) {
	    return parseInt(key.substr(1), 10);
	  };
	
	  setItem = function setItem(id, item) {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  };
	  getItem = function getItem(id) {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  };
	  removeItem = function removeItem(id) {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  };
	  getItemIDs = function getItemIDs() {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  };
	
	  addRoot = function addRoot(id) {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  };
	  removeRoot = function removeRoot(id) {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  };
	  getRootIDs = function getRootIDs() {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  };
	}
	
	var unmountedIDs = [];
	
	function purgeDeep(id) {
	  var item = getItem(id);
	  if (item) {
	    var childIDs = item.childIDs;
	
	    removeItem(id);
	    childIDs.forEach(purgeDeep);
	  }
	}
	
	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}
	
	function _getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}
	
	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}
	
	var ReactComponentTreeHook = {
	  onSetChildren: function onSetChildren(id, nextChildIDs) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.childIDs = nextChildIDs;
	
	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = getItem(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || _typeof(nextChild.element) !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent id is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function onBeforeMountComponent(id, element, parentID) {
	    var item = {
	      element: element,
	      parentID: parentID,
	      text: null,
	      childIDs: [],
	      isMounted: false,
	      updateCount: 0
	    };
	    setItem(id, item);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(id, element) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function onMountComponent(id) {
	    var item = getItem(id);
	    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function onUpdateComponent(id) {
	    var item = getItem(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function onUnmountComponent(id) {
	    var item = getItem(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function purgeUnmountedComponents() {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }
	
	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function isMounted(id) {
	    var item = getItem(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function getCurrentStackAddendum(topElement) {
	    var info = '';
	    if (topElement) {
	      var name = _getDisplayName(topElement);
	      var owner = topElement._owner;
	      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
	    }
	
	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;
	
	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function getStackAddendumByID(id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function getChildIDs(id) {
	    var item = getItem(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function getDisplayName(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return _getDisplayName(element);
	  },
	  getElement: function getElement(id) {
	    var item = getItem(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function getOwnerID(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function getParentID(id) {
	    var item = getItem(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function getSource(id) {
	    var item = getItem(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function getText(id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function getUpdateCount(id) {
	    var item = getItem(id);
	    return item ? item.updateCount : 0;
	  },
	
	  getRootIDs: getRootIDs,
	  getRegisteredIDs: getItemIDs
	};
	
	module.exports = ReactComponentTreeHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(14);
	
	var ReactPropTypeLocationNames = __webpack_require__(30);
	var ReactPropTypesSecret = __webpack_require__(35);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(33);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 35 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(16);
	var ReactPropTypeLocationNames = __webpack_require__(30);
	var ReactPropTypesSecret = __webpack_require__(35);
	
	var emptyFunction = __webpack_require__(19);
	var getIteratorFn = __webpack_require__(23);
	var warning = __webpack_require__(18);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/
	
	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;
	
	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        if (props[propName] === null) {
	          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	        }
	        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }
	
	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }
	
	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }
	
	  return false;
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 37 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	module.exports = '15.4.1';

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	'use strict';
	
	var _prodInvariant = __webpack_require__(14);
	
	var ReactElement = __webpack_require__(16);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(40);

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDefaultInjection = __webpack_require__(45);
	var ReactMount = __webpack_require__(173);
	var ReactReconciler = __webpack_require__(66);
	var ReactUpdates = __webpack_require__(63);
	var ReactVersion = __webpack_require__(178);
	
	var findDOMNode = __webpack_require__(179);
	var getHostComponentFromComposite = __webpack_require__(180);
	var renderSubtreeIntoContainer = __webpack_require__(181);
	var warning = __webpack_require__(18);
	
	ReactDefaultInjection.inject();
	
	var ReactDOM = {
	  findDOMNode: findDOMNode,
	  render: ReactMount.render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    ComponentTree: {
	      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
	      getNodeFromInstance: function getNodeFromInstance(inst) {
	        // inst is an internal instance (but could be a composite)
	        if (inst._renderedComponent) {
	          inst = getHostComponentFromComposite(inst);
	        }
	        if (inst) {
	          return ReactDOMComponentTree.getNodeFromInstance(inst);
	        } else {
	          return null;
	        }
	      }
	    },
	    Mount: ReactMount,
	    Reconciler: ReactReconciler
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(55);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        // Firefox does not have the issue with devtools loaded over file://
	        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
	        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    var testFunc = function testFn() {};
	    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
	        break;
	      }
	    }
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactInstrumentation = __webpack_require__(69);
	  var ReactDOMUnknownPropertyHook = __webpack_require__(182);
	  var ReactDOMNullInputValuePropHook = __webpack_require__(183);
	  var ReactDOMInvalidARIAHook = __webpack_require__(184);
	
	  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
	  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
	}
	
	module.exports = ReactDOM;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var DOMProperty = __webpack_require__(43);
	var ReactDOMComponentFlags = __webpack_require__(44);
	
	var invariant = __webpack_require__(15);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var Flags = ReactDOMComponentFlags;
	
	var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);
	
	/**
	 * Drill down (through composites and empty components) until we get a host or
	 * host text component.
	 *
	 * This is pretty polymorphic but unavoidable with the current structure we have
	 * for `_renderedChildren`.
	 */
	function getRenderedHostOrTextFromComponent(component) {
	  var rendered;
	  while (rendered = component._renderedComponent) {
	    component = rendered;
	  }
	  return component;
	}
	
	/**
	 * Populate `_hostNode` on the rendered host/text component with the given
	 * DOM node. The passed `inst` can be a composite.
	 */
	function precacheNode(inst, node) {
	  var hostInst = getRenderedHostOrTextFromComponent(inst);
	  hostInst._hostNode = node;
	  node[internalInstanceKey] = hostInst;
	}
	
	function uncacheNode(inst) {
	  var node = inst._hostNode;
	  if (node) {
	    delete node[internalInstanceKey];
	    inst._hostNode = null;
	  }
	}
	
	/**
	 * Populate `_hostNode` on each child of `inst`, assuming that the children
	 * match up with the DOM (element) children of `node`.
	 *
	 * We cache entire levels at once to avoid an n^2 problem where we access the
	 * children of a node sequentially and have to walk from the start to our target
	 * node every time.
	 *
	 * Since we update `_renderedChildren` and the actual DOM at (slightly)
	 * different times, we could race here and see a newer `_renderedChildren` than
	 * the DOM nodes we see. To avoid this, ReactMultiChild calls
	 * `prepareToManageChildren` before we change `_renderedChildren`, at which
	 * time the container's child nodes are always cached (until it unmounts).
	 */
	function precacheChildNodes(inst, node) {
	  if (inst._flags & Flags.hasCachedChildNodes) {
	    return;
	  }
	  var children = inst._renderedChildren;
	  var childNode = node.firstChild;
	  outer: for (var name in children) {
	    if (!children.hasOwnProperty(name)) {
	      continue;
	    }
	    var childInst = children[name];
	    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
	    if (childID === 0) {
	      // We're currently unmounting this child in ReactMultiChild; skip it.
	      continue;
	    }
	    // We assume the child nodes are in the same order as the child instances.
	    for (; childNode !== null; childNode = childNode.nextSibling) {
	      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
	        precacheNode(childInst, childNode);
	        continue outer;
	      }
	    }
	    // We reached the end of the DOM children without finding an ID match.
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
	  }
	  inst._flags |= Flags.hasCachedChildNodes;
	}
	
	/**
	 * Given a DOM node, return the closest ReactDOMComponent or
	 * ReactDOMTextComponent instance ancestor.
	 */
	function getClosestInstanceFromNode(node) {
	  if (node[internalInstanceKey]) {
	    return node[internalInstanceKey];
	  }
	
	  // Walk up the tree until we find an ancestor whose instance we have cached.
	  var parents = [];
	  while (!node[internalInstanceKey]) {
	    parents.push(node);
	    if (node.parentNode) {
	      node = node.parentNode;
	    } else {
	      // Top of the tree. This node must not be part of a React tree (or is
	      // unmounted, potentially).
	      return null;
	    }
	  }
	
	  var closest;
	  var inst;
	  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
	    closest = inst;
	    if (parents.length) {
	      precacheChildNodes(inst, node);
	    }
	  }
	
	  return closest;
	}
	
	/**
	 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
	 * instance, or null if the node was not rendered by this React.
	 */
	function getInstanceFromNode(node) {
	  var inst = getClosestInstanceFromNode(node);
	  if (inst != null && inst._hostNode === node) {
	    return inst;
	  } else {
	    return null;
	  }
	}
	
	/**
	 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
	 * DOM node.
	 */
	function getNodeFromInstance(inst) {
	  // Without this first invariant, passing a non-DOM-component triggers the next
	  // invariant for a missing parent, which is super confusing.
	  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  if (inst._hostNode) {
	    return inst._hostNode;
	  }
	
	  // Walk up the tree until we find an ancestor whose DOM node we have cached.
	  var parents = [];
	  while (!inst._hostNode) {
	    parents.push(inst);
	    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
	    inst = inst._hostParent;
	  }
	
	  // Now parents contains each ancestor that does *not* have a cached native
	  // node, and `inst` is the deepest ancestor that does.
	  for (; parents.length; inst = parents.pop()) {
	    precacheChildNodes(inst, inst._hostNode);
	  }
	
	  return inst._hostNode;
	}
	
	var ReactDOMComponentTree = {
	  getClosestInstanceFromNode: getClosestInstanceFromNode,
	  getInstanceFromNode: getInstanceFromNode,
	  getNodeFromInstance: getNodeFromInstance,
	  precacheChildNodes: precacheChildNodes,
	  precacheNode: precacheNode,
	  uncacheNode: uncacheNode
	};
	
	module.exports = ReactDOMComponentTree;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 42 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	'use strict';
	
	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */
	
	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;
	
	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;
	
	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }
	
	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';
	
	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame
	
	  throw error;
	}
	
	module.exports = reactProdInvariant;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_PROPERTY: 0x1,
	  HAS_BOOLEAN_VALUE: 0x4,
	  HAS_NUMERIC_VALUE: 0x8,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	
	/* eslint-disable max-len */
	var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
	/* eslint-enable max-len */
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	  ROOT_ATTRIBUTE_NAME: 'data-reactroot',
	
	  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
	  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   *
	   * autofocus is predefined, because adding it to the property whitelist
	   * causes unintended side effects.
	   *
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function isCustomAttribute(attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 44 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentFlags = {
	  hasCachedChildNodes: 1 << 0
	};
	
	module.exports = ReactDOMComponentFlags;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = __webpack_require__(46);
	var BeforeInputEventPlugin = __webpack_require__(47);
	var ChangeEventPlugin = __webpack_require__(62);
	var DefaultEventPluginOrder = __webpack_require__(79);
	var EnterLeaveEventPlugin = __webpack_require__(80);
	var HTMLDOMPropertyConfig = __webpack_require__(85);
	var ReactComponentBrowserEnvironment = __webpack_require__(86);
	var ReactDOMComponent = __webpack_require__(99);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMEmptyComponent = __webpack_require__(144);
	var ReactDOMTreeTraversal = __webpack_require__(145);
	var ReactDOMTextComponent = __webpack_require__(146);
	var ReactDefaultBatchingStrategy = __webpack_require__(147);
	var ReactEventListener = __webpack_require__(148);
	var ReactInjection = __webpack_require__(151);
	var ReactReconcileTransaction = __webpack_require__(152);
	var SVGDOMPropertyConfig = __webpack_require__(160);
	var SelectEventPlugin = __webpack_require__(161);
	var SimpleEventPlugin = __webpack_require__(162);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
	  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
	    return new ReactDOMEmptyComponent(instantiate);
	  });
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	}
	
	module.exports = {
	  inject: inject
	};

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ARIADOMPropertyConfig = {
	  Properties: {
	    // Global States and Properties
	    'aria-current': 0, // state
	    'aria-details': 0,
	    'aria-disabled': 0, // state
	    'aria-hidden': 0, // state
	    'aria-invalid': 0, // state
	    'aria-keyshortcuts': 0,
	    'aria-label': 0,
	    'aria-roledescription': 0,
	    // Widget Attributes
	    'aria-autocomplete': 0,
	    'aria-checked': 0,
	    'aria-expanded': 0,
	    'aria-haspopup': 0,
	    'aria-level': 0,
	    'aria-modal': 0,
	    'aria-multiline': 0,
	    'aria-multiselectable': 0,
	    'aria-orientation': 0,
	    'aria-placeholder': 0,
	    'aria-pressed': 0,
	    'aria-readonly': 0,
	    'aria-required': 0,
	    'aria-selected': 0,
	    'aria-sort': 0,
	    'aria-valuemax': 0,
	    'aria-valuemin': 0,
	    'aria-valuenow': 0,
	    'aria-valuetext': 0,
	    // Live Region Attributes
	    'aria-atomic': 0,
	    'aria-busy': 0,
	    'aria-live': 0,
	    'aria-relevant': 0,
	    // Drag-and-Drop Attributes
	    'aria-dropeffect': 0,
	    'aria-grabbed': 0,
	    // Relationship Attributes
	    'aria-activedescendant': 0,
	    'aria-colcount': 0,
	    'aria-colindex': 0,
	    'aria-colspan': 0,
	    'aria-controls': 0,
	    'aria-describedby': 0,
	    'aria-errormessage': 0,
	    'aria-flowto': 0,
	    'aria-labelledby': 0,
	    'aria-owns': 0,
	    'aria-posinset': 0,
	    'aria-rowcount': 0,
	    'aria-rowindex': 0,
	    'aria-rowspan': 0,
	    'aria-setsize': 0
	  },
	  DOMAttributeNames: {},
	  DOMPropertyNames: {}
	};
	
	module.exports = ARIADOMPropertyConfig;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventPropagators = __webpack_require__(48);
	var ExecutionEnvironment = __webpack_require__(55);
	var FallbackCompositionState = __webpack_require__(56);
	var SyntheticCompositionEvent = __webpack_require__(59);
	var SyntheticInputEvent = __webpack_require__(61);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: 'onBeforeInput',
	      captured: 'onBeforeInputCapture'
	    },
	    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionEnd',
	      captured: 'onCompositionEndCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionStart',
	      captured: 'onCompositionStartCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: 'onCompositionUpdate',
	      captured: 'onCompositionUpdateCapture'
	    },
	    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case 'topCompositionStart':
	      return eventTypes.compositionStart;
	    case 'topCompositionEnd':
	      return eventTypes.compositionEnd;
	    case 'topCompositionUpdate':
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topKeyUp':
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case 'topKeyDown':
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case 'topKeyPress':
	    case 'topMouseDown':
	    case 'topBlur':
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case 'topCompositionEnd':
	      return getDataFromCustomEvent(nativeEvent);
	    case 'topKeyPress':
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case 'topTextInput':
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  // If composition event is available, we extract a string only at
	  // compositionevent, otherwise extract it at fallback events.
	  if (currentComposition) {
	    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case 'topPaste':
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case 'topKeyPress':
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case 'topCompositionEnd':
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(49);
	var EventPluginUtils = __webpack_require__(51);
	
	var accumulateInto = __webpack_require__(53);
	var forEachAccumulated = __webpack_require__(54);
	var warning = __webpack_require__(18);
	
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(inst, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(inst, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(inst, phase, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
	  }
	  var listener = listenerAtPhase(inst, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    var targetInst = event._targetInst;
	    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
	    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(inst, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(inst, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event._targetInst, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, from, to) {
	  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42);
	
	var EventPluginRegistry = __webpack_require__(50);
	var EventPluginUtils = __webpack_require__(51);
	var ReactErrorUtils = __webpack_require__(52);
	
	var accumulateInto = __webpack_require__(53);
	var forEachAccumulated = __webpack_require__(54);
	var invariant = __webpack_require__(15);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	var getDictionaryKey = function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	};
	
	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}
	
	function shouldPreventMouseEvent(name, type, props) {
	  switch (name) {
	    case 'onClick':
	    case 'onClickCapture':
	    case 'onDoubleClick':
	    case 'onDoubleClickCapture':
	    case 'onMouseDown':
	    case 'onMouseDownCapture':
	    case 'onMouseMove':
	    case 'onMouseMoveCapture':
	    case 'onMouseUp':
	    case 'onMouseUpCapture':
	      return !!(props.disabled && isInteractive(type));
	    default:
	      return false;
	  }
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {function} listener The callback to store.
	   */
	  putListener: function putListener(inst, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : _prodInvariant('94', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : void 0;
	
	    var key = getDictionaryKey(inst);
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[key] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(inst, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function getListener(inst, registrationName) {
	    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
	    // live here; needs to be moved to a better place soon
	    var bankForRegistrationName = listenerBank[registrationName];
	    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
	      return null;
	    }
	    var key = getDictionaryKey(inst);
	    return bankForRegistrationName && bankForRegistrationName[key];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function deleteListener(inst, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(inst, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      var key = getDictionaryKey(inst);
	      delete bankForRegistrationName[key];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {object} inst The instance, which is the source of events.
	   */
	  deleteAllListeners: function deleteAllListeners(inst) {
	    var key = getDictionaryKey(inst);
	    for (var registrationName in listenerBank) {
	      if (!listenerBank.hasOwnProperty(registrationName)) {
	        continue;
	      }
	
	      if (!listenerBank[registrationName][key]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(inst, registrationName);
	      }
	
	      delete listenerBank[registrationName][key];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function enqueueEvents(events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function processEventQueue(simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function __purge() {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function __getListenerBank() {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var eventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!eventPluginOrder) {
	    // Wait until an `eventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var pluginModule = namesToPlugins[pluginName];
	    var pluginIndex = eventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
	    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
	    var publishedEvents = pluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, pluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
	  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
	
	  if (process.env.NODE_ENV !== 'production') {
	    var lowerCasedName = registrationName.toLowerCase();
	    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;
	
	    if (registrationName === 'onDoubleClick') {
	      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
	    }
	  }
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Mapping from lowercase registration names to the properly cased version,
	   * used to warn in the case of missing event handlers. Available
	   * only in __DEV__.
	   * @type {Object}
	   */
	  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
	  // Trust the developer to only use possibleRegistrationNames in __DEV__
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function injectEventPluginOrder(injectedEventPluginOrder) {
	    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
	    // Clone the ordering so it cannot be dynamically mutated.
	    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var pluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
	        namesToPlugins[pluginName] = pluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    if (dispatchConfig.phasedRegistrationNames !== undefined) {
	      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
	      // that it is not undefined.
	      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	
	      for (var phase in phasedRegistrationNames) {
	        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
	          continue;
	        }
	        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
	        if (pluginModule) {
	          return pluginModule;
	        }
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function _resetEventPlugins() {
	    eventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
	      for (var lowerCasedName in possibleRegistrationNames) {
	        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
	          delete possibleRegistrationNames[lowerCasedName];
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactErrorUtils = __webpack_require__(52);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `ComponentTree`: [required] Module that can convert between React instances
	 *   and actual node references.
	 */
	var ComponentTree;
	var TreeTraversal;
	var injection = {
	  injectComponentTree: function injectComponentTree(Injected) {
	    ComponentTree = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
	    }
	  },
	  injectTreeTraversal: function injectTreeTraversal(Injected) {
	    TreeTraversal = Injected;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
	    }
	  }
	};
	
	function isEndish(topLevelType) {
	  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
	}
	function isStartish(topLevelType) {
	  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function validateEventDispatches(event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchInstances = event._dispatchInstances;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    var instancesIsArr = Array.isArray(dispatchInstances);
	    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {*} inst Internal component instance
	 */
	function executeDispatch(event, simulated, listener, inst) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
	  }
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchInstances = event._dispatchInstances;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and Instances are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchInstances[i])) {
	        return dispatchInstances[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchInstances)) {
	      return dispatchInstances;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchInstances = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchInstance = event._dispatchInstances;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
	  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
	  var res = dispatchListener ? dispatchListener(event) : null;
	  event.currentTarget = null;
	  event._dispatchListeners = null;
	  event._dispatchInstances = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getInstanceFromNode: function getInstanceFromNode(node) {
	    return ComponentTree.getInstanceFromNode(node);
	  },
	  getNodeFromInstance: function getNodeFromInstance(node) {
	    return ComponentTree.getNodeFromInstance(node);
	  },
	  isAncestor: function isAncestor(a, b) {
	    return TreeTraversal.isAncestor(a, b);
	  },
	  getLowestCommonAncestor: function getLowestCommonAncestor(a, b) {
	    return TreeTraversal.getLowestCommonAncestor(a, b);
	  },
	  getParentInstance: function getParentInstance(inst) {
	    return TreeTraversal.getParentInstance(inst);
	  },
	  traverseTwoPhase: function traverseTwoPhase(target, fn, arg) {
	    return TreeTraversal.traverseTwoPhase(target, fn, arg);
	  },
	  traverseEnterLeave: function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a) {
	  try {
	    func(a);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function rethrowCaughtError() {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
	      var boundFunc = func.bind(null, a);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      // $FlowFixMe https://github.com/facebook/flow/issues/2336
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;
	
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  if (Array.isArray(current)) {
	    if (Array.isArray(next)) {
	      current.push.apply(current, next);
	      return current;
	    }
	    current.push(next);
	    return current;
	  }
	
	  if (Array.isArray(next)) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 54 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	}
	
	module.exports = forEachAccumulated;

/***/ },
/* 55 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var PooledClass = __webpack_require__(57);
	
	var getTextContentAccessor = __webpack_require__(58);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	_assign(FallbackCompositionState.prototype, {
	  destructor: function destructor() {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function getText() {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function getData() {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  // Casting as any so that flow ignores the actual implementation and trusts
	  // it to match the type we declared
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var PooledClass = __webpack_require__(57);
	
	var emptyFunction = __webpack_require__(19);
	var warning = __webpack_require__(18);
	
	var didWarnForAddedNewProperty = false;
	var isProxySupported = typeof Proxy === 'function';
	
	var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function timeStamp(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {*} targetInst Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @param {DOMEventTarget} nativeEventTarget Target node.
	 */
	function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
	  if (process.env.NODE_ENV !== 'production') {
	    // these have a getter/setter for warnings
	    delete this.nativeEvent;
	    delete this.preventDefault;
	    delete this.stopPropagation;
	  }
	
	  this.dispatchConfig = dispatchConfig;
	  this._targetInst = targetInst;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      delete this[propName]; // this has a getter/setter for warnings
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	  return this;
	}
	
	_assign(SyntheticEvent.prototype, {
	
	  preventDefault: function preventDefault() {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else if (typeof event.returnValue !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function stopPropagation() {
	    var event = this.nativeEvent;
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else if (typeof event.cancelBubble !== 'unknown') {
	      // eslint-disable-line valid-typeof
	      // The ChangeEventPlugin registers a "propertychange" event for
	      // IE. This event does not support bubbling or cancelling, and
	      // any references to cancelBubble throw "Member not found".  A
	      // typeof check of "unknown" circumvents this issue (and is also
	      // IE specific).
	      event.cancelBubble = true;
	    }
	
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function persist() {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function destructor() {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      if (process.env.NODE_ENV !== 'production') {
	        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
	      } else {
	        this[propName] = null;
	      }
	    }
	    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
	      this[shouldBeReleasedProperties[i]] = null;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
	      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
	      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
	    }
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	if (process.env.NODE_ENV !== 'production') {
	  if (isProxySupported) {
	    /*eslint-disable no-func-assign */
	    SyntheticEvent = new Proxy(SyntheticEvent, {
	      construct: function construct(target, args) {
	        return this.apply(target, Object.create(target.prototype), args);
	      },
	      apply: function apply(constructor, that, args) {
	        return new Proxy(constructor.apply(that, args), {
	          set: function set(target, prop, value) {
	            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
	              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
	              didWarnForAddedNewProperty = true;
	            }
	            target[prop] = value;
	            return true;
	          }
	        });
	      }
	    });
	    /*eslint-enable no-func-assign */
	  }
	}
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var E = function E() {};
	  E.prototype = Super.prototype;
	  var prototype = new E();
	
	  _assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = _assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	
	/**
	  * Helper to nullify syntheticEvent instance properties when destructing
	  *
	  * @param {object} SyntheticEvent
	  * @param {String} propName
	  * @return {object} defineProperty object
	  */
	function getPooledWarningPropertyDefinition(propName, getVal) {
	  var isFunction = typeof getVal === 'function';
	  return {
	    configurable: true,
	    set: set,
	    get: get
	  };
	
	  function set(val) {
	    var action = isFunction ? 'setting the method' : 'setting the property';
	    warn(action, 'This is effectively a no-op');
	    return val;
	  }
	
	  function get() {
	    var action = isFunction ? 'accessing the method' : 'accessing the property';
	    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
	    warn(action, result);
	    return getVal;
	  }
	
	  function warn(action, result) {
	    var warningCondition = false;
	    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(49);
	var EventPropagators = __webpack_require__(48);
	var ExecutionEnvironment = __webpack_require__(55);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	var SyntheticEvent = __webpack_require__(60);
	
	var getEventTarget = __webpack_require__(76);
	var isEventSupported = __webpack_require__(77);
	var isTextInputElement = __webpack_require__(78);
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: 'onChange',
	      captured: 'onChangeCapture'
	    },
	    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementInst = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementInst = null;
	}
	
	function getTargetInstForChangeEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topChange') {
	    return targetInst;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events.
	  // IE10+ fire input events to often, such when a placeholder
	  // changes or when an input with a placeholder is focused.
	  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
	}
	
	/**
	 * (For IE <=11) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function get() {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function set(val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For IE <=11) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetInst) {
	  activeElement = target;
	  activeElementInst = targetInst;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  if (activeElement.attachEvent) {
	    activeElement.attachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.addEventListener('propertychange', handlePropertyChange, false);
	  }
	}
	
	/**
	 * (For IE <=11) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	
	  if (activeElement.detachEvent) {
	    activeElement.detachEvent('onpropertychange', handlePropertyChange);
	  } else {
	    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
	  }
	
	  activeElement = null;
	  activeElementInst = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For IE <=11) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetInstForInputEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topInput') {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return targetInst;
	  }
	}
	
	function handleEventsForInputEventIE(topLevelType, target, targetInst) {
	  if (topLevelType === 'topFocus') {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9-11, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(target, targetInst);
	  } else if (topLevelType === 'topBlur') {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetInstForInputEventIE(topLevelType, targetInst) {
	  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementInst;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetInstForClickEvent(topLevelType, targetInst) {
	  if (topLevelType === 'topClick') {
	    return targetInst;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    var getTargetInstFunc, handleEventFunc;
	    if (shouldUseChangeEvent(targetNode)) {
	      if (doesChangeEventBubble) {
	        getTargetInstFunc = getTargetInstForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(targetNode)) {
	      if (isInputEventSupported) {
	        getTargetInstFunc = getTargetInstForInputEvent;
	      } else {
	        getTargetInstFunc = getTargetInstForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(targetNode)) {
	      getTargetInstFunc = getTargetInstForClickEvent;
	    }
	
	    if (getTargetInstFunc) {
	      var inst = getTargetInstFunc(topLevelType, targetInst);
	      if (inst) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, targetNode, targetInst);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var CallbackQueue = __webpack_require__(64);
	var PooledClass = __webpack_require__(57);
	var ReactFeatureFlags = __webpack_require__(65);
	var ReactReconciler = __webpack_require__(66);
	var Transaction = __webpack_require__(75);
	
	var invariant = __webpack_require__(15);
	
	var dirtyComponents = [];
	var updateBatchNumber = 0;
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
	}
	
	var NESTED_UPDATES = {
	  initialize: function initialize() {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function close() {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function initialize() {
	    this.callbackQueue.reset();
	  },
	  close: function close() {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */true);
	}
	
	_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function destructor() {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function perform(method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  // Any updates enqueued while reconciling must be performed after this entire
	  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
	  // C, B could update twice in a single batch if C's render enqueues an update
	  // to B (since B would have already updated, we should skip it, and the only
	  // way we can know to do so is by checking the batch counter).
	  updateBatchNumber++;
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    var markerName;
	    if (ReactFeatureFlags.logTopLevelRenders) {
	      var namedComponent = component;
	      // Duck type TopLevelWrapper. This is probably always true.
	      if (component._currentElement.type.isReactTopLevelWrapper) {
	        namedComponent = component._renderedComponent;
	      }
	      markerName = 'React update: ' + namedComponent.getName();
	      console.time(markerName);
	    }
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);
	
	    if (markerName) {
	      console.timeEnd(markerName);
	    }
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function flushBatchedUpdates() {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	  if (component._updateBatchNumber == null) {
	    component._updateBatchNumber = updateBatchNumber + 1;
	  }
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var PooledClass = __webpack_require__(57);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	
	var CallbackQueue = function () {
	  function CallbackQueue(arg) {
	    _classCallCheck(this, CallbackQueue);
	
	    this._callbacks = null;
	    this._contexts = null;
	    this._arg = arg;
	  }
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	
	  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._callbacks.push(callback);
	    this._contexts = this._contexts || [];
	    this._contexts.push(context);
	  };
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	
	  CallbackQueue.prototype.notifyAll = function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    var arg = this._arg;
	    if (callbacks && contexts) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i], arg);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  };
	
	  CallbackQueue.prototype.checkpoint = function checkpoint() {
	    return this._callbacks ? this._callbacks.length : 0;
	  };
	
	  CallbackQueue.prototype.rollback = function rollback(len) {
	    if (this._callbacks && this._contexts) {
	      this._callbacks.length = len;
	      this._contexts.length = len;
	    }
	  };
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	
	  CallbackQueue.prototype.reset = function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  };
	
	  /**
	   * `PooledClass` looks for this.
	   */
	
	  CallbackQueue.prototype.destructor = function destructor() {
	    this.reset();
	  };
	
	  return CallbackQueue;
	}();
	
	module.exports = PooledClass.addPoolingTo(CallbackQueue);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 65 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactFeatureFlags = {
	  // When true, call console.time() before and .timeEnd() after each top-level
	  // render (both initial renders and updates). Useful when looking at prod-mode
	  // timeline profiles in Chrome, for example.
	  logTopLevelRenders: false
	};
	
	module.exports = ReactFeatureFlags;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(67);
	var ReactInstrumentation = __webpack_require__(69);
	
	var warning = __webpack_require__(18);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} the containing host component instance
	   * @param {?object} info about the host container
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
	  ) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
	      }
	    }
	    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
	      }
	    }
	    return markup;
	  },
	
	  /**
	   * Returns a value that can be passed to
	   * ReactComponentEnvironment.replaceNodeWithMarkup.
	   */
	  getHostNode: function getHostNode(internalInstance) {
	    return internalInstance.getHostNode();
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(internalInstance, safely) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
	      }
	    }
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent(safely);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
	      }
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction, updateBatchNumber) {
	    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
	      // The component's enqueued batch number should always be the current
	      // batch or the following one.
	      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
	      return;
	    }
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
	      }
	    }
	    internalInstance.performUpdateIfNecessary(transaction);
	    if (process.env.NODE_ENV !== 'production') {
	      if (internalInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactOwner = __webpack_require__(68);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevRef = null;
	  var prevOwner = null;
	  if (prevElement !== null && (typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement)) === 'object') {
	    prevRef = prevElement.ref;
	    prevOwner = prevElement._owner;
	  }
	
	  var nextRef = null;
	  var nextOwner = null;
	  if (nextElement !== null && (typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement)) === 'object') {
	    nextRef = nextElement.ref;
	    nextOwner = nextElement._owner;
	  }
	
	  return prevRef !== nextRef ||
	  // If owner changes but we have an unchanged function ref, don't update refs
	  typeof nextRef === 'string' && nextOwner !== prevOwner;
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid owner.
	 * @final
	 */
	function isValidOwner(object) {
	  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	}
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
	    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
	    var ownerPublicInstance = owner.getPublicInstance();
	    // Check that `component`'s owner is still alive and that `component` is still the current ref
	    // because we do not want to detach the ref if another component stole it.
	    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// Trust the developer to only use ReactInstrumentation with a __DEV__ check
	
	var debugTool = null;
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactDebugTool = __webpack_require__(70);
	  debugTool = ReactDebugTool;
	}
	
	module.exports = { debugTool: debugTool };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactInvalidSetStateWarningHook = __webpack_require__(71);
	var ReactHostOperationHistoryHook = __webpack_require__(72);
	var ReactComponentTreeHook = __webpack_require__(33);
	var ExecutionEnvironment = __webpack_require__(55);
	
	var performanceNow = __webpack_require__(73);
	var warning = __webpack_require__(18);
	
	var hooks = [];
	var didHookThrowForEvent = {};
	
	function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
	  try {
	    fn.call(context, arg1, arg2, arg3, arg4, arg5);
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
	    didHookThrowForEvent[event] = true;
	  }
	}
	
	function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
	  for (var i = 0; i < hooks.length; i++) {
	    var hook = hooks[i];
	    var fn = hook[event];
	    if (fn) {
	      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
	    }
	  }
	}
	
	var _isProfiling = false;
	var flushHistory = [];
	var lifeCycleTimerStack = [];
	var currentFlushNesting = 0;
	var currentFlushMeasurements = [];
	var currentFlushStartTime = 0;
	var currentTimerDebugID = null;
	var currentTimerStartTime = 0;
	var currentTimerNestedFlushDuration = 0;
	var currentTimerType = null;
	
	var lifeCycleTimerHasWarned = false;
	
	function clearHistory() {
	  ReactComponentTreeHook.purgeUnmountedComponents();
	  ReactHostOperationHistoryHook.clearHistory();
	}
	
	function getTreeSnapshot(registeredIDs) {
	  return registeredIDs.reduce(function (tree, id) {
	    var ownerID = ReactComponentTreeHook.getOwnerID(id);
	    var parentID = ReactComponentTreeHook.getParentID(id);
	    tree[id] = {
	      displayName: ReactComponentTreeHook.getDisplayName(id),
	      text: ReactComponentTreeHook.getText(id),
	      updateCount: ReactComponentTreeHook.getUpdateCount(id),
	      childIDs: ReactComponentTreeHook.getChildIDs(id),
	      // Text nodes don't have owners but this is close enough.
	      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
	      parentID: parentID
	    };
	    return tree;
	  }, {});
	}
	
	function resetMeasurements() {
	  var previousStartTime = currentFlushStartTime;
	  var previousMeasurements = currentFlushMeasurements;
	  var previousOperations = ReactHostOperationHistoryHook.getHistory();
	
	  if (currentFlushNesting === 0) {
	    currentFlushStartTime = 0;
	    currentFlushMeasurements = [];
	    clearHistory();
	    return;
	  }
	
	  if (previousMeasurements.length || previousOperations.length) {
	    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
	    flushHistory.push({
	      duration: performanceNow() - previousStartTime,
	      measurements: previousMeasurements || [],
	      operations: previousOperations || [],
	      treeSnapshot: getTreeSnapshot(registeredIDs)
	    });
	  }
	
	  clearHistory();
	  currentFlushStartTime = performanceNow();
	  currentFlushMeasurements = [];
	}
	
	function checkDebugID(debugID) {
	  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	  if (allowRoot && debugID === 0) {
	    return;
	  }
	  if (!debugID) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
	  }
	}
	
	function beginLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  currentTimerStartTime = performanceNow();
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	function endLifeCycleTimer(debugID, timerType) {
	  if (currentFlushNesting === 0) {
	    return;
	  }
	  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
	    lifeCycleTimerHasWarned = true;
	  }
	  if (_isProfiling) {
	    currentFlushMeasurements.push({
	      timerType: timerType,
	      instanceID: debugID,
	      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
	    });
	  }
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function pauseCurrentLifeCycleTimer() {
	  var currentTimer = {
	    startTime: currentTimerStartTime,
	    nestedFlushStartTime: performanceNow(),
	    debugID: currentTimerDebugID,
	    timerType: currentTimerType
	  };
	  lifeCycleTimerStack.push(currentTimer);
	  currentTimerStartTime = 0;
	  currentTimerNestedFlushDuration = 0;
	  currentTimerDebugID = null;
	  currentTimerType = null;
	}
	
	function resumeCurrentLifeCycleTimer() {
	  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
	      startTime = _lifeCycleTimerStack$.startTime,
	      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
	      debugID = _lifeCycleTimerStack$.debugID,
	      timerType = _lifeCycleTimerStack$.timerType;
	
	  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
	  currentTimerStartTime = startTime;
	  currentTimerNestedFlushDuration += nestedFlushDuration;
	  currentTimerDebugID = debugID;
	  currentTimerType = timerType;
	}
	
	var lastMarkTimeStamp = 0;
	var canUsePerformanceMeasure =
	// $FlowFixMe https://github.com/facebook/flow/issues/2345
	typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
	
	function shouldMark(debugID) {
	  if (!_isProfiling || !canUsePerformanceMeasure) {
	    return false;
	  }
	  var element = ReactComponentTreeHook.getElement(debugID);
	  if (element == null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
	    return false;
	  }
	  var isHostElement = typeof element.type === 'string';
	  if (isHostElement) {
	    return false;
	  }
	  return true;
	}
	
	function markBegin(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }
	
	  var markName = debugID + '::' + markType;
	  lastMarkTimeStamp = performanceNow();
	  performance.mark(markName);
	}
	
	function markEnd(debugID, markType) {
	  if (!shouldMark(debugID)) {
	    return;
	  }
	
	  var markName = debugID + '::' + markType;
	  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';
	
	  // Chrome has an issue of dropping markers recorded too fast:
	  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
	  // To work around this, we will not report very small measurements.
	  // I determined the magic number by tweaking it back and forth.
	  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
	  // When the bug is fixed, we can `measure()` unconditionally if we want to.
	  var timeStamp = performanceNow();
	  if (timeStamp - lastMarkTimeStamp > 0.1) {
	    var measurementName = displayName + ' [' + markType + ']';
	    performance.measure(measurementName, markName);
	  }
	
	  performance.clearMarks(markName);
	  performance.clearMeasures(measurementName);
	}
	
	var ReactDebugTool = {
	  addHook: function addHook(hook) {
	    hooks.push(hook);
	  },
	  removeHook: function removeHook(hook) {
	    for (var i = 0; i < hooks.length; i++) {
	      if (hooks[i] === hook) {
	        hooks.splice(i, 1);
	        i--;
	      }
	    }
	  },
	  isProfiling: function isProfiling() {
	    return _isProfiling;
	  },
	  beginProfiling: function beginProfiling() {
	    if (_isProfiling) {
	      return;
	    }
	
	    _isProfiling = true;
	    flushHistory.length = 0;
	    resetMeasurements();
	    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
	  },
	  endProfiling: function endProfiling() {
	    if (!_isProfiling) {
	      return;
	    }
	
	    _isProfiling = false;
	    resetMeasurements();
	    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
	  },
	  getFlushHistory: function getFlushHistory() {
	    return flushHistory;
	  },
	  onBeginFlush: function onBeginFlush() {
	    currentFlushNesting++;
	    resetMeasurements();
	    pauseCurrentLifeCycleTimer();
	    emitEvent('onBeginFlush');
	  },
	  onEndFlush: function onEndFlush() {
	    resetMeasurements();
	    currentFlushNesting--;
	    resumeCurrentLifeCycleTimer();
	    emitEvent('onEndFlush');
	  },
	  onBeginLifeCycleTimer: function onBeginLifeCycleTimer(debugID, timerType) {
	    checkDebugID(debugID);
	    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
	    markBegin(debugID, timerType);
	    beginLifeCycleTimer(debugID, timerType);
	  },
	  onEndLifeCycleTimer: function onEndLifeCycleTimer(debugID, timerType) {
	    checkDebugID(debugID);
	    endLifeCycleTimer(debugID, timerType);
	    markEnd(debugID, timerType);
	    emitEvent('onEndLifeCycleTimer', debugID, timerType);
	  },
	  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	    emitEvent('onBeginProcessingChildContext');
	  },
	  onEndProcessingChildContext: function onEndProcessingChildContext() {
	    emitEvent('onEndProcessingChildContext');
	  },
	  onHostOperation: function onHostOperation(operation) {
	    checkDebugID(operation.instanceID);
	    emitEvent('onHostOperation', operation);
	  },
	  onSetState: function onSetState() {
	    emitEvent('onSetState');
	  },
	  onSetChildren: function onSetChildren(debugID, childDebugIDs) {
	    checkDebugID(debugID);
	    childDebugIDs.forEach(checkDebugID);
	    emitEvent('onSetChildren', debugID, childDebugIDs);
	  },
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element, parentDebugID) {
	    checkDebugID(debugID);
	    checkDebugID(parentDebugID, true);
	    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
	    markBegin(debugID, 'mount');
	  },
	  onMountComponent: function onMountComponent(debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'mount');
	    emitEvent('onMountComponent', debugID);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUpdateComponent', debugID, element);
	    markBegin(debugID, 'update');
	  },
	  onUpdateComponent: function onUpdateComponent(debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'update');
	    emitEvent('onUpdateComponent', debugID);
	  },
	  onBeforeUnmountComponent: function onBeforeUnmountComponent(debugID) {
	    checkDebugID(debugID);
	    emitEvent('onBeforeUnmountComponent', debugID);
	    markBegin(debugID, 'unmount');
	  },
	  onUnmountComponent: function onUnmountComponent(debugID) {
	    checkDebugID(debugID);
	    markEnd(debugID, 'unmount');
	    emitEvent('onUnmountComponent', debugID);
	  },
	  onTestEvent: function onTestEvent() {
	    emitEvent('onTestEvent');
	  }
	};
	
	// TODO remove these when RN/www gets updated
	ReactDebugTool.addDevtool = ReactDebugTool.addHook;
	ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;
	
	ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
	ReactDebugTool.addHook(ReactComponentTreeHook);
	var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	if (/[?&]react_perf\b/.test(url)) {
	  ReactDebugTool.beginProfiling();
	}
	
	module.exports = ReactDebugTool;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var warning = __webpack_require__(18);
	
	if (process.env.NODE_ENV !== 'production') {
	  var processingChildContext = false;
	
	  var warnInvalidSetState = function warnInvalidSetState() {
	    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
	  };
	}
	
	var ReactInvalidSetStateWarningHook = {
	  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
	    processingChildContext = true;
	  },
	  onEndProcessingChildContext: function onEndProcessingChildContext() {
	    processingChildContext = false;
	  },
	  onSetState: function onSetState() {
	    warnInvalidSetState();
	  }
	};
	
	module.exports = ReactInvalidSetStateWarningHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 72 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var history = [];
	
	var ReactHostOperationHistoryHook = {
	  onHostOperation: function onHostOperation(operation) {
	    history.push(operation);
	  },
	  clearHistory: function clearHistory() {
	    if (ReactHostOperationHistoryHook._preventClearing) {
	      // Should only be used for tests.
	      return;
	    }
	
	    history = [];
	  },
	  getHistory: function getHistory() {
	    return history;
	  }
	};
	
	module.exports = ReactHostOperationHistoryHook;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var performance = __webpack_require__(74);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	var OBSERVED_ERROR = {};
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var TransactionImpl = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function reinitializeTransaction() {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function isInTransaction() {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function perform(method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function initializeAll(startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function closeAll(startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	module.exports = TransactionImpl;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 76 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	
	  // Normalize SVG <use> element events #4963
	  if (target.correspondingUseElement) {
	    target = target.correspondingUseElement;
	  }
	
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 78 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	
	  if (nodeName === 'input') {
	    return !!supportedInputTypes[elem.type];
	  }
	
	  if (nodeName === 'textarea') {
	    return true;
	  }
	
	  return false;
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 79 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	
	var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(48);
	var ReactDOMComponentTree = __webpack_require__(41);
	var SyntheticMouseEvent = __webpack_require__(81);
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: 'onMouseEnter',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  },
	  mouseLeave: {
	    registrationName: 'onMouseLeave',
	    dependencies: ['topMouseOut', 'topMouseOver']
	  }
	};
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   */
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (nativeEventTarget.window === nativeEventTarget) {
	      // `nativeEventTarget` is probably a window object.
	      win = nativeEventTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = nativeEventTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    if (topLevelType === 'topMouseOut') {
	      from = targetInst;
	      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
	      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
	    } else {
	      // Moving to a node from outside the window.
	      from = null;
	      to = targetInst;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
	    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = fromNode;
	    leave.relatedTarget = toNode;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = toNode;
	    enter.relatedTarget = fromNode;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);
	
	    return [leave, enter];
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	var ViewportMetrics = __webpack_require__(83);
	
	var getEventModifierState = __webpack_require__(84);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function button(event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function relatedTarget(event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function pageX(event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function pageY(event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	var getEventTarget = __webpack_require__(76);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function view(event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function detail(event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 83 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function refreshScrollValues(scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 84 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(43);
	
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: 0,
	    acceptCharset: 0,
	    accessKey: 0,
	    action: 0,
	    allowFullScreen: HAS_BOOLEAN_VALUE,
	    allowTransparency: 0,
	    alt: 0,
	    // specifies target context for links with `preload` type
	    as: 0,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: 0,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: HAS_BOOLEAN_VALUE,
	    cellPadding: 0,
	    cellSpacing: 0,
	    charSet: 0,
	    challenge: 0,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    cite: 0,
	    classID: 0,
	    className: 0,
	    cols: HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: 0,
	    content: 0,
	    contentEditable: 0,
	    contextMenu: 0,
	    controls: HAS_BOOLEAN_VALUE,
	    coords: 0,
	    crossOrigin: 0,
	    data: 0, // For `<object />` acts as `src`.
	    dateTime: 0,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: 0,
	    disabled: HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: 0,
	    encType: 0,
	    form: 0,
	    formAction: 0,
	    formEncType: 0,
	    formMethod: 0,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: 0,
	    frameBorder: 0,
	    headers: 0,
	    height: 0,
	    hidden: HAS_BOOLEAN_VALUE,
	    high: 0,
	    href: 0,
	    hrefLang: 0,
	    htmlFor: 0,
	    httpEquiv: 0,
	    icon: 0,
	    id: 0,
	    inputMode: 0,
	    integrity: 0,
	    is: 0,
	    keyParams: 0,
	    keyType: 0,
	    kind: 0,
	    label: 0,
	    lang: 0,
	    list: 0,
	    loop: HAS_BOOLEAN_VALUE,
	    low: 0,
	    manifest: 0,
	    marginHeight: 0,
	    marginWidth: 0,
	    max: 0,
	    maxLength: 0,
	    media: 0,
	    mediaGroup: 0,
	    method: 0,
	    min: 0,
	    minLength: 0,
	    // Caution; `option.selected` is not updated if `select.multiple` is
	    // disabled with `removeAttribute`.
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: 0,
	    nonce: 0,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: 0,
	    pattern: 0,
	    placeholder: 0,
	    playsInline: HAS_BOOLEAN_VALUE,
	    poster: 0,
	    preload: 0,
	    profile: 0,
	    radioGroup: 0,
	    readOnly: HAS_BOOLEAN_VALUE,
	    referrerPolicy: 0,
	    rel: 0,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: 0,
	    rows: HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: HAS_NUMERIC_VALUE,
	    sandbox: 0,
	    scope: 0,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: 0,
	    seamless: HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: 0,
	    size: HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: 0,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: 0,
	    src: 0,
	    srcDoc: 0,
	    srcLang: 0,
	    srcSet: 0,
	    start: HAS_NUMERIC_VALUE,
	    step: 0,
	    style: 0,
	    summary: 0,
	    tabIndex: 0,
	    target: 0,
	    title: 0,
	    // Setting .type throws on non-<input> tags
	    type: 0,
	    useMap: 0,
	    value: 0,
	    width: 0,
	    wmode: 0,
	    wrap: 0,
	
	    /**
	     * RDFa Properties
	     */
	    about: 0,
	    datatype: 0,
	    inlist: 0,
	    prefix: 0,
	    // property is also supported for OpenGraph in meta tags.
	    property: 0,
	    resource: 0,
	    'typeof': 0,
	    vocab: 0,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: 0,
	    autoCorrect: 0,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: 0,
	    // color is for Safari mask-icon link
	    color: 0,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: 0,
	    itemScope: HAS_BOOLEAN_VALUE,
	    itemType: 0,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: 0,
	    itemRef: 0,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: 0,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: 0,
	    // IE-only attribute that controls focus behavior
	    unselectable: 0
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {}
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(87);
	var ReactDOMIDOperations = __webpack_require__(98);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMLazyTree = __webpack_require__(88);
	var Danger = __webpack_require__(94);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInstrumentation = __webpack_require__(69);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	var setInnerHTML = __webpack_require__(90);
	var setTextContent = __webpack_require__(92);
	
	function getNodeAfter(parentNode, node) {
	  // Special case for text components, which return [open, close] comments
	  // from getHostNode.
	  if (Array.isArray(node)) {
	    node = node[1];
	  }
	  return node ? node.nextSibling : parentNode.firstChild;
	}
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
	  // We rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
	  // we are careful to use `null`.)
	  parentNode.insertBefore(childNode, referenceNode);
	});
	
	function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
	  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
	}
	
	function moveChild(parentNode, childNode, referenceNode) {
	  if (Array.isArray(childNode)) {
	    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
	  } else {
	    insertChildAt(parentNode, childNode, referenceNode);
	  }
	}
	
	function removeChild(parentNode, childNode) {
	  if (Array.isArray(childNode)) {
	    var closingComment = childNode[1];
	    childNode = childNode[0];
	    removeDelimitedText(parentNode, childNode, closingComment);
	    parentNode.removeChild(closingComment);
	  }
	  parentNode.removeChild(childNode);
	}
	
	function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
	  var node = openingComment;
	  while (true) {
	    var nextNode = node.nextSibling;
	    insertChildAt(parentNode, node, referenceNode);
	    if (node === closingComment) {
	      break;
	    }
	    node = nextNode;
	  }
	}
	
	function removeDelimitedText(parentNode, startNode, closingComment) {
	  while (true) {
	    var node = startNode.nextSibling;
	    if (node === closingComment) {
	      // The closing comment is removed by ReactMultiChild.
	      break;
	    } else {
	      parentNode.removeChild(node);
	    }
	  }
	}
	
	function replaceDelimitedText(openingComment, closingComment, stringText) {
	  var parentNode = openingComment.parentNode;
	  var nodeAfterComment = openingComment.nextSibling;
	  if (nodeAfterComment === closingComment) {
	    // There are no text nodes between the opening and closing comments; insert
	    // a new one if stringText isn't empty.
	    if (stringText) {
	      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
	    }
	  } else {
	    if (stringText) {
	      // Set the text content of the first node after the opening comment, and
	      // remove all following nodes up until the closing comment.
	      setTextContent(nodeAfterComment, stringText);
	      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
	    } else {
	      removeDelimitedText(parentNode, openingComment, closingComment);
	    }
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onHostOperation({
	      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
	      type: 'replace text',
	      payload: stringText
	    });
	  }
	}
	
	var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
	if (process.env.NODE_ENV !== 'production') {
	  dangerouslyReplaceNodeWithMarkup = function dangerouslyReplaceNodeWithMarkup(oldChild, markup, prevInstance) {
	    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
	    if (prevInstance._debugID !== 0) {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: prevInstance._debugID,
	        type: 'replace with',
	        payload: markup.toString()
	      });
	    } else {
	      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
	      if (nextInstance._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: nextInstance._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  };
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,
	
	  replaceDelimitedText: replaceDelimitedText,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  processUpdates: function processUpdates(parentNode, updates) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      var update = updates[k];
	      switch (update.type) {
	        case 'INSERT_MARKUP':
	          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'insert child',
	              payload: { toIndex: update.toIndex, content: update.content.toString() }
	            });
	          }
	          break;
	        case 'MOVE_EXISTING':
	          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'move child',
	              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
	            });
	          }
	          break;
	        case 'SET_MARKUP':
	          setInnerHTML(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace children',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'TEXT_CONTENT':
	          setTextContent(parentNode, update.content);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'replace text',
	              payload: update.content.toString()
	            });
	          }
	          break;
	        case 'REMOVE_NODE':
	          removeChild(parentNode, update.fromNode);
	          if (process.env.NODE_ENV !== 'production') {
	            ReactInstrumentation.debugTool.onHostOperation({
	              instanceID: parentNodeDebugID,
	              type: 'remove child',
	              payload: { fromIndex: update.fromIndex }
	            });
	          }
	          break;
	      }
	    }
	  }
	
	};
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = __webpack_require__(89);
	var setInnerHTML = __webpack_require__(90);
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	var setTextContent = __webpack_require__(92);
	
	var ELEMENT_NODE_TYPE = 1;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * In IE (8-11) and Edge, appending nodes with no children is dramatically
	 * faster than appending a full subtree, so we essentially queue up the
	 * .appendChild calls here and apply them so each node is added to its parent
	 * before any children are added.
	 *
	 * In other browsers, doing so is slower or neutral compared to the other order
	 * (in Firefox, twice as slow) so we only do this inversion in IE.
	 *
	 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
	 */
	var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);
	
	function insertTreeChildren(tree) {
	  if (!enableLazy) {
	    return;
	  }
	  var node = tree.node;
	  var children = tree.children;
	  if (children.length) {
	    for (var i = 0; i < children.length; i++) {
	      insertTreeBefore(node, children[i], null);
	    }
	  } else if (tree.html != null) {
	    setInnerHTML(node, tree.html);
	  } else if (tree.text != null) {
	    setTextContent(node, tree.text);
	  }
	}
	
	var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
	  // DocumentFragments aren't actually part of the DOM after insertion so
	  // appending children won't update the DOM. We need to ensure the fragment
	  // is properly populated first, breaking out of our lazy approach for just
	  // this level. Also, some <object> plugins (like Flash Player) will read
	  // <param> nodes immediately upon insertion into the DOM, so <object>
	  // must also be populated prior to insertion into the DOM.
	  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
	    insertTreeChildren(tree);
	    parentNode.insertBefore(tree.node, referenceNode);
	  } else {
	    parentNode.insertBefore(tree.node, referenceNode);
	    insertTreeChildren(tree);
	  }
	});
	
	function replaceChildWithTree(oldNode, newTree) {
	  oldNode.parentNode.replaceChild(newTree.node, oldNode);
	  insertTreeChildren(newTree);
	}
	
	function queueChild(parentTree, childTree) {
	  if (enableLazy) {
	    parentTree.children.push(childTree);
	  } else {
	    parentTree.node.appendChild(childTree.node);
	  }
	}
	
	function queueHTML(tree, html) {
	  if (enableLazy) {
	    tree.html = html;
	  } else {
	    setInnerHTML(tree.node, html);
	  }
	}
	
	function queueText(tree, text) {
	  if (enableLazy) {
	    tree.text = text;
	  } else {
	    setTextContent(tree.node, text);
	  }
	}
	
	function toString() {
	  return this.node.nodeName;
	}
	
	function DOMLazyTree(node) {
	  return {
	    node: node,
	    children: [],
	    html: null,
	    text: null,
	    toString: toString
	  };
	}
	
	DOMLazyTree.insertTreeBefore = insertTreeBefore;
	DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
	DOMLazyTree.queueChild = queueChild;
	DOMLazyTree.queueHTML = queueHTML;
	DOMLazyTree.queueText = queueText;
	
	module.exports = DOMLazyTree;

/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMNamespaces = {
	  html: 'http://www.w3.org/1999/xhtml',
	  mathml: 'http://www.w3.org/1998/Math/MathML',
	  svg: 'http://www.w3.org/2000/svg'
	};
	
	module.exports = DOMNamespaces;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	var DOMNamespaces = __webpack_require__(89);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	var createMicrosoftUnsafeLocalFunction = __webpack_require__(91);
	
	// SVG temp container for IE lacking innerHTML
	var reusableSVGContainer;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
	  // IE does not have innerHTML for SVG nodes, so instead we inject the
	  // new markup in a temp node and then move the child nodes across into
	  // the target node
	  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
	    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
	    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
	    var svgNode = reusableSVGContainer.firstChild;
	    while (svgNode.firstChild) {
	      node.appendChild(svgNode.firstChild);
	    }
	  } else {
	    node.innerHTML = html;
	  }
	});
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function setInnerHTML(node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	  testElement = null;
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 91 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	/**
	 * Create a function which has 'unsafe' privileges (required by windows8 apps)
	 */
	
	var createMicrosoftUnsafeLocalFunction = function createMicrosoftUnsafeLocalFunction(func) {
	  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	    return function (arg0, arg1, arg2, arg3) {
	      MSApp.execUnsafeLocalFunction(function () {
	        return func(arg0, arg1, arg2, arg3);
	      });
	    };
	  } else {
	    return func;
	  }
	};
	
	module.exports = createMicrosoftUnsafeLocalFunction;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	var escapeTextContentForBrowser = __webpack_require__(93);
	var setInnerHTML = __webpack_require__(90);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function setTextContent(node, text) {
	  if (text) {
	    var firstChild = node.firstChild;
	
	    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
	      firstChild.nodeValue = text;
	      return;
	    }
	  }
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function setTextContent(node, text) {
	      if (node.nodeType === 3) {
	        node.nodeValue = text;
	        return;
	      }
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 93 */
/***/ function(module, exports) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * Based on the escape-html library, which is used under the MIT License below:
	 *
	 * Copyright (c) 2012-2013 TJ Holowaychuk
	 * Copyright (c) 2015 Andreas Lubbe
	 * Copyright (c) 2015 Tiancheng "Timothy" Gu
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * 'Software'), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 *
	 */
	
	'use strict';
	
	// code copied and modified from escape-html
	/**
	 * Module variables.
	 * @private
	 */
	
	var matchHtmlRegExp = /["'&<>]/;
	
	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */
	
	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);
	
	  if (!match) {
	    return str;
	  }
	
	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;
	
	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34:
	        // "
	        escape = '&quot;';
	        break;
	      case 38:
	        // &
	        escape = '&amp;';
	        break;
	      case 39:
	        // '
	        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
	        break;
	      case 60:
	        // <
	        escape = '&lt;';
	        break;
	      case 62:
	        // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }
	
	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }
	
	    lastIndex = index + 1;
	    html += escape;
	  }
	
	  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
	}
	// end code copied and modified from escape-html
	
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  if (typeof text === 'boolean' || typeof text === 'number') {
	    // this shortcircuit helps perf for types that we know will never have
	    // special characters, especially given that this function is used often
	    // for numeric dom ids.
	    return '' + text;
	  }
	  return escapeHtml(text);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var DOMLazyTree = __webpack_require__(88);
	var ExecutionEnvironment = __webpack_require__(55);
	
	var createNodesFromMarkup = __webpack_require__(95);
	var emptyFunction = __webpack_require__(19);
	var invariant = __webpack_require__(15);
	
	var Danger = {
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
	    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;
	
	    if (typeof markup === 'string') {
	      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	      oldChild.parentNode.replaceChild(newChild, oldChild);
	    } else {
	      DOMLazyTree.replaceChildWithTree(oldChild, markup);
	    }
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var createArrayFromMixed = __webpack_require__(96);
	var getMarkupWrap = __webpack_require__(97);
	var invariant = __webpack_require__(15);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = Array.from(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
	  // in old versions of Safari).
	  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;
	
	  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(87);
	var ReactDOMComponentTree = __webpack_require__(41);
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(parentInst, updates) {
	    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
	    DOMChildrenOperations.processUpdates(node, updates);
	  }
	};
	
	module.exports = ReactDOMIDOperations;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var AutoFocusUtils = __webpack_require__(100);
	var CSSPropertyOperations = __webpack_require__(102);
	var DOMLazyTree = __webpack_require__(88);
	var DOMNamespaces = __webpack_require__(89);
	var DOMProperty = __webpack_require__(43);
	var DOMPropertyOperations = __webpack_require__(110);
	var EventPluginHub = __webpack_require__(49);
	var EventPluginRegistry = __webpack_require__(50);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactDOMComponentFlags = __webpack_require__(44);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMInput = __webpack_require__(115);
	var ReactDOMOption = __webpack_require__(118);
	var ReactDOMSelect = __webpack_require__(119);
	var ReactDOMTextarea = __webpack_require__(120);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactMultiChild = __webpack_require__(121);
	var ReactServerRenderingTransaction = __webpack_require__(140);
	
	var emptyFunction = __webpack_require__(19);
	var escapeTextContentForBrowser = __webpack_require__(93);
	var invariant = __webpack_require__(15);
	var isEventSupported = __webpack_require__(77);
	var shallowEqual = __webpack_require__(130);
	var validateDOMNesting = __webpack_require__(143);
	var warning = __webpack_require__(18);
	
	var Flags = ReactDOMComponentFlags;
	var deleteListener = EventPluginHub.deleteListener;
	var getNode = ReactDOMComponentTree.getNodeFromInstance;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = EventPluginRegistry.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var STYLE = 'style';
	var HTML = '__html';
	var RESERVED_PROPS = {
	  children: null,
	  dangerouslySetInnerHTML: null,
	  suppressContentEditableWarning: null
	};
	
	// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
	var DOC_FRAGMENT_TYPE = 11;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	function friendlyStringify(obj) {
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined because undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (voidElementTags[component._tag]) {
	    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
	    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
	  }
	  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
	}
	
	function enqueuePutListener(inst, registrationName, listener, transaction) {
	  if (transaction instanceof ReactServerRenderingTransaction) {
	    return;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
	  }
	  var containerInfo = inst._hostContainerInfo;
	  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
	  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
	  listenTo(registrationName, doc);
	  transaction.getReactMountReady().enqueue(putListener, {
	    inst: inst,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	function inputPostMount() {
	  var inst = this;
	  ReactDOMInput.postMountWrapper(inst);
	}
	
	function textareaPostMount() {
	  var inst = this;
	  ReactDOMTextarea.postMountWrapper(inst);
	}
	
	function optionPostMount() {
	  var inst = this;
	  ReactDOMOption.postMountWrapper(inst);
	}
	
	var setAndValidateContentChildDev = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  setAndValidateContentChildDev = function setAndValidateContentChildDev(content) {
	    var hasExistingContent = this._contentDebugID != null;
	    var debugID = this._debugID;
	    // This ID represents the inlined child that has no backing instance:
	    var contentDebugID = -debugID;
	
	    if (content == null) {
	      if (hasExistingContent) {
	        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
	      }
	      this._contentDebugID = null;
	      return;
	    }
	
	    validateDOMNesting(null, String(content), this, this._ancestorInfo);
	    this._contentDebugID = contentDebugID;
	    if (hasExistingContent) {
	      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
	      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
	    } else {
	      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
	      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
	      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
	    }
	  };
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
	  var node = getNode(inst);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;
	
	  switch (inst._tag) {
	    case 'iframe':
	    case 'object':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // Create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
	        }
	      }
	      break;
	    case 'source':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
	      break;
	    case 'input':
	    case 'select':
	    case 'textarea':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
	      break;
	  }
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special-case tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = _assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	var globalIdCounter = 1;
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(element) {
	  var tag = element.type;
	  validateDangerousTag(tag);
	  this._currentElement = element;
	  this._tag = tag.toLowerCase();
	  this._namespaceURI = null;
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._hostNode = null;
	  this._hostParent = null;
	  this._rootNodeID = 0;
	  this._domID = 0;
	  this._hostContainerInfo = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._flags = 0;
	  if (process.env.NODE_ENV !== 'production') {
	    this._ancestorInfo = null;
	    setAndValidateContentChildDev.call(this, null);
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?ReactDOMComponent} the parent component instance
	   * @param {?object} info about the host container
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    this._rootNodeID = globalIdCounter++;
	    this._domID = hostContainerInfo._idCounter++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, hostParent);
	        props = ReactDOMInput.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, hostParent);
	        props = ReactDOMOption.getHostProps(this, props);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, hostParent);
	        props = ReactDOMSelect.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, hostParent);
	        props = ReactDOMTextarea.getHostProps(this, props);
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	    }
	
	    assertValidProps(this, props);
	
	    // We create tags in the namespace of their parent container, except HTML
	    // tags get no namespace.
	    var namespaceURI;
	    var parentTag;
	    if (hostParent != null) {
	      namespaceURI = hostParent._namespaceURI;
	      parentTag = hostParent._tag;
	    } else if (hostContainerInfo._tag) {
	      namespaceURI = hostContainerInfo._namespaceURI;
	      parentTag = hostContainerInfo._tag;
	    }
	    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
	      namespaceURI = DOMNamespaces.html;
	    }
	    if (namespaceURI === DOMNamespaces.html) {
	      if (this._tag === 'svg') {
	        namespaceURI = DOMNamespaces.svg;
	      } else if (this._tag === 'math') {
	        namespaceURI = DOMNamespaces.mathml;
	      }
	    }
	    this._namespaceURI = namespaceURI;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo._tag) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(this._tag, null, this, parentInfo);
	      }
	      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var el;
	      if (namespaceURI === DOMNamespaces.html) {
	        if (this._tag === 'script') {
	          // Create the script via .innerHTML so its "parser-inserted" flag is
	          // set to true and it does not execute
	          var div = ownerDocument.createElement('div');
	          var type = this._currentElement.type;
	          div.innerHTML = '<' + type + '></' + type + '>';
	          el = div.removeChild(div.firstChild);
	        } else if (props.is) {
	          el = ownerDocument.createElement(this._currentElement.type, props.is);
	        } else {
	          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
	          // See discussion in https://github.com/facebook/react/pull/6896
	          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
	          el = ownerDocument.createElement(this._currentElement.type);
	        }
	      } else {
	        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
	      }
	      ReactDOMComponentTree.precacheNode(this, el);
	      this._flags |= Flags.hasCachedChildNodes;
	      if (!this._hostParent) {
	        DOMPropertyOperations.setAttributeForRoot(el);
	      }
	      this._updateDOMProperties(null, props, transaction);
	      var lazyTree = DOMLazyTree(el);
	      this._createInitialChildren(transaction, props, context, lazyTree);
	      mountImage = lazyTree;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(inputPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'textarea':
	        transaction.getReactMountReady().enqueue(textareaPostMount, this);
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'select':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'button':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	      case 'option':
	        transaction.getReactMountReady().enqueue(optionPostMount, this);
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = _assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    if (!this._hostParent) {
	      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
	    }
	    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
	    return ret;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function _createInitialChildren(transaction, props, context, lazyTree) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, contentToUse);
	        }
	        DOMLazyTree.queueText(lazyTree, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function receiveComponent(nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'input':
	        lastProps = ReactDOMInput.getHostProps(this, lastProps);
	        nextProps = ReactDOMInput.getHostProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getHostProps(this, lastProps);
	        nextProps = ReactDOMOption.getHostProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
	        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
	        break;
	      case 'textarea':
	        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
	        break;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    switch (this._tag) {
	      case 'input':
	        // Update the wrapper around inputs *after* updating props. This has to
	        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
	        // raise warnings and prevent the new value from being assigned.
	        ReactDOMInput.updateWrapper(this);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        break;
	      case 'select':
	        // <select> value update needs to occur after <option> children
	        // reconciliation
	        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	        break;
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, lastProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = _assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
	          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        var node = getNode(this);
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertently setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	        if (process.env.NODE_ENV !== 'production') {
	          setAndValidateContentChildDev.call(this, nextContent);
	        }
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
	      }
	    } else if (nextChildren != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        setAndValidateContentChildDev.call(this, null);
	      }
	
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  getHostNode: function getHostNode() {
	    return getNode(this);
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function unmountComponent(safely) {
	    switch (this._tag) {
	      case 'audio':
	      case 'form':
	      case 'iframe':
	      case 'img':
	      case 'link':
	      case 'object':
	      case 'source':
	      case 'video':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
	        break;
	    }
	
	    this.unmountChildren(safely);
	    ReactDOMComponentTree.uncacheNode(this);
	    EventPluginHub.deleteAllListeners(this);
	    this._rootNodeID = 0;
	    this._domID = 0;
	    this._wrapperState = null;
	
	    if (process.env.NODE_ENV !== 'production') {
	      setAndValidateContentChildDev.call(this, null);
	    }
	  },
	
	  getPublicInstance: function getPublicInstance() {
	    return getNode(this);
	  }
	
	};
	
	_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMComponentTree = __webpack_require__(41);
	
	var focusNode = __webpack_require__(101);
	
	var AutoFocusUtils = {
	  focusDOMComponent: function focusDOMComponent() {
	    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 101 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(103);
	var ExecutionEnvironment = __webpack_require__(55);
	var ReactInstrumentation = __webpack_require__(69);
	
	var camelizeStyleName = __webpack_require__(104);
	var dangerousStyleValue = __webpack_require__(106);
	var hyphenateStyleName = __webpack_require__(107);
	var memoizeStringOnly = __webpack_require__(109);
	var warning = __webpack_require__(18);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	  var warnedForNaNValue = false;
	
	  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name, owner) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
	  };
	
	  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value, owner) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
	  };
	
	  var warnStyleValueIsNaN = function warnStyleValueIsNaN(name, value, owner) {
	    if (warnedForNaNValue) {
	      return;
	    }
	
	    warnedForNaNValue = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
	  };
	
	  var checkRenderMessage = function checkRenderMessage(owner) {
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' Check the render method of `' + name + '`.';
	      }
	    }
	    return '';
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   * @param {ReactDOMComponent} component
	   */
	  var warnValidStyle = function warnValidStyle(name, value, component) {
	    var owner;
	    if (component) {
	      owner = component._currentElement._owner;
	    }
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name, owner);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name, owner);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value, owner);
	    }
	
	    if (typeof value === 'number' && isNaN(value)) {
	      warnStyleValueIsNaN(name, value, owner);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   * @return {?string}
	   */
	  createMarkupForStyles: function createMarkupForStyles(styles, component) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue, component);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   * @param {ReactDOMComponent} component
	   */
	  setValueForStyles: function setValueForStyles(node, styles, component) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: component._debugID,
	        type: 'update styles',
	        payload: styles
	      });
	    }
	
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName], component);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
	      if (styleName === 'float' || styleName === 'cssFloat') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 103 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  borderImageOutset: true,
	  borderImageSlice: true,
	  borderImageWidth: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  gridRow: true,
	  gridColumn: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  floodOpacity: true,
	  stopOpacity: true,
	  strokeDasharray: true,
	  strokeDashoffset: true,
	  strokeMiterlimit: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(105);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 105 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(103);
	var warning = __webpack_require__(18);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	var styleWarnings = {};
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @param {ReactDOMComponent} component
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value, component) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    if (process.env.NODE_ENV !== 'production') {
	      // Allow '0' to pass through without warning. 0 is already special and
	      // doesn't require units, so we don't need to warn about it.
	      if (component && value !== '0') {
	        var owner = component._currentElement._owner;
	        var ownerName = owner ? owner.getName() : null;
	        if (ownerName && !styleWarnings[ownerName]) {
	          styleWarnings[ownerName] = {};
	        }
	        var warned = false;
	        if (ownerName) {
	          var warnings = styleWarnings[ownerName];
	          warned = warnings[name];
	          if (!warned) {
	            warnings[name] = true;
	          }
	        }
	        if (!warned) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
	        }
	      }
	    }
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(108);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 108 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(43);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInstrumentation = __webpack_require__(69);
	
	var quoteAttributeValueForBrowser = __webpack_require__(111);
	var warning = __webpack_require__(18);
	
	var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function createMarkupForID(id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function setAttributeForID(node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  createMarkupForRoot: function createMarkupForRoot() {
	    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
	  },
	
	  setAttributeForRoot: function setAttributeForRoot(node) {
	    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function createMarkupForProperty(name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function setValueForProperty(node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	        return;
	      } else if (propertyInfo.mustUseProperty) {
	        // Contrary to `setAttribute`, object properties are properly
	        // `toString`ed by IE8/9.
	        node[propertyInfo.propertyName] = value;
	      } else {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	      return;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  setValueForAttribute: function setValueForAttribute(node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var payload = {};
	      payload[name] = value;
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'update attribute',
	        payload: payload
	      });
	    }
	  },
	
	  /**
	   * Deletes an attributes from a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForAttribute: function deleteValueForAttribute(node, name) {
	    node.removeAttribute(name);
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function deleteValueForProperty(node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseProperty) {
	        var propName = propertyInfo.propertyName;
	        if (propertyInfo.hasBooleanValue) {
	          node[propName] = false;
	        } else {
	          node[propName] = '';
	        }
	      } else {
	        node.removeAttribute(propertyInfo.attributeName);
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onHostOperation({
	        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
	        type: 'remove attribute',
	        payload: name
	      });
	    }
	  }
	
	};
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(93);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var EventPluginRegistry = __webpack_require__(50);
	var ReactEventEmitterMixin = __webpack_require__(113);
	var ViewportMetrics = __webpack_require__(83);
	
	var getVendorPrefixedEventName = __webpack_require__(114);
	var isEventSupported = __webpack_require__(77);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var hasEventPageXY;
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
	  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
	  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function setEnabled(enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function isEnabled() {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function listenTo(registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === 'topWheel') {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === 'topScroll') {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening.topBlur = true;
	          isListening.topFocus = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Protect against document.createEvent() returning null
	   * Some popup blocker extensions appear to do this:
	   * https://github.com/facebook/react/issues/6887
	   */
	  supportsEventPageXY: function supportsEventPageXY() {
	    if (!document.createEvent) {
	      return false;
	    }
	    var ev = document.createEvent('MouseEvent');
	    return ev != null && 'pageX' in ev;
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
	   * pageX/pageY isn't supported (legacy browsers).
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
	    if (hasEventPageXY === undefined) {
	      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
	    }
	    if (!hasEventPageXY && !isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  }
	
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(49);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   */
	  handleTopLevel: function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	/**
	 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
	 *
	 * @param {string} styleProp
	 * @param {string} eventName
	 * @returns {object}
	 */
	function makePrefixMap(styleProp, eventName) {
	  var prefixes = {};
	
	  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
	  prefixes['Moz' + styleProp] = 'moz' + eventName;
	  prefixes['ms' + styleProp] = 'MS' + eventName;
	  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
	
	  return prefixes;
	}
	
	/**
	 * A list of event names to a configurable list of vendor prefixes.
	 */
	var vendorPrefixes = {
	  animationend: makePrefixMap('Animation', 'AnimationEnd'),
	  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
	  animationstart: makePrefixMap('Animation', 'AnimationStart'),
	  transitionend: makePrefixMap('Transition', 'TransitionEnd')
	};
	
	/**
	 * Event names that have already been detected and prefixed (if applicable).
	 */
	var prefixedEventNames = {};
	
	/**
	 * Element to check for prefixes on.
	 */
	var style = {};
	
	/**
	 * Bootstrap if a DOM exists.
	 */
	if (ExecutionEnvironment.canUseDOM) {
	  style = document.createElement('div').style;
	
	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are usable, and if not remove them from the map.
	  if (!('AnimationEvent' in window)) {
	    delete vendorPrefixes.animationend.animation;
	    delete vendorPrefixes.animationiteration.animation;
	    delete vendorPrefixes.animationstart.animation;
	  }
	
	  // Same as above
	  if (!('TransitionEvent' in window)) {
	    delete vendorPrefixes.transitionend.transition;
	  }
	}
	
	/**
	 * Attempts to determine the correct vendor prefixed event name.
	 *
	 * @param {string} eventName
	 * @returns {string}
	 */
	function getVendorPrefixedEventName(eventName) {
	  if (prefixedEventNames[eventName]) {
	    return prefixedEventNames[eventName];
	  } else if (!vendorPrefixes[eventName]) {
	    return eventName;
	  }
	
	  var prefixMap = vendorPrefixes[eventName];
	
	  for (var styleProp in prefixMap) {
	    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
	      return prefixedEventNames[eventName] = prefixMap[styleProp];
	    }
	  }
	
	  return '';
	}
	
	module.exports = getVendorPrefixedEventName;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var DOMPropertyOperations = __webpack_require__(110);
	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var didWarnValueLink = false;
	var didWarnCheckedLink = false;
	var didWarnValueDefaultValue = false;
	var didWarnCheckedDefaultChecked = false;
	var didWarnControlledToUncontrolled = false;
	var didWarnUncontrolledToControlled = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	function isControlled(props) {
	  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
	  return usesChecked ? props.checked != null : props.value != null;
	}
	
	/**
	 * Implements an <input> host component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getHostProps: function getHostProps(inst, props) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var hostProps = _assign({
	      // Make sure we set .type before any other properties (setting .value
	      // before .type means .value is lost in IE11 and below)
	      type: undefined,
	      // Make sure we set .step before .value (setting .value before .step
	      // means .value is rounded on mount, based upon step precision)
	      step: undefined,
	      // Make sure we set .min & .max before .value (to ensure proper order
	      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
	      min: undefined,
	      max: undefined
	    }, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	
	      var owner = inst._currentElement._owner;
	
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnCheckedLink = true;
	      }
	      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnCheckedDefaultChecked = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnValueDefaultValue = true;
	      }
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
	      initialValue: props.value != null ? props.value : defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	
	    if (process.env.NODE_ENV !== 'production') {
	      inst._wrapperState.controlled = isControlled(props);
	    }
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    if (process.env.NODE_ENV !== 'production') {
	      var controlled = isControlled(props);
	      var owner = inst._currentElement._owner;
	
	      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnUncontrolledToControlled = true;
	      }
	      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
	        didWarnControlledToUncontrolled = true;
	      }
	    }
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
	    }
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	    } else {
	      if (props.value == null && props.defaultValue != null) {
	        node.defaultValue = '' + props.defaultValue;
	      }
	      if (props.checked == null && props.defaultChecked != null) {
	        node.defaultChecked = !!props.defaultChecked;
	      }
	    }
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Detach value from defaultValue. We won't do anything if we're working on
	    // submit or reset inputs as those values & defaultValues are linked. They
	    // are not resetable nodes so this operation doesn't matter and actually
	    // removes browser-default values (eg "Submit Query") when no value is
	    // provided.
	
	    switch (props.type) {
	      case 'submit':
	      case 'reset':
	        break;
	      case 'color':
	      case 'date':
	      case 'datetime':
	      case 'datetime-local':
	      case 'month':
	      case 'time':
	      case 'week':
	        // This fixes the no-show issue on iOS Safari and Android Chrome:
	        // https://github.com/facebook/react/issues/7233
	        node.value = '';
	        node.value = node.defaultValue;
	        break;
	      default:
	        node.value = node.value;
	        break;
	    }
	
	    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
	    // this is needed to work around a chrome bug where setting defaultChecked
	    // will sometimes influence the value of checked (even after detachment).
	    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
	    // We need to temporarily unset name to avoid disrupting radio button groups.
	    var name = node.name;
	    if (name !== '') {
	      node.name = '';
	    }
	    node.defaultChecked = !node.defaultChecked;
	    node.defaultChecked = !node.defaultChecked;
	    if (name !== '') {
	      node.name = name;
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React radio buttons with non-React ones.
	      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var React = __webpack_require__(9);
	var ReactPropTypesSecret = __webpack_require__(117);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
	}
	
	var propTypes = {
	  value: function value(props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function checked(props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: React.PropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function checkPropTypes(tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function getValue(inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function getChecked(inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function executeOnChange(inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 117 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var React = __webpack_require__(9);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMSelect = __webpack_require__(119);
	
	var warning = __webpack_require__(18);
	var didWarnInvalidOptionChildren = false;
	
	function flattenChildren(children) {
	  var content = '';
	
	  // Flatten children and warn if they aren't strings or numbers;
	  // invalid types are ignored.
	  React.Children.forEach(children, function (child) {
	    if (child == null) {
	      return;
	    }
	    if (typeof child === 'string' || typeof child === 'number') {
	      content += child;
	    } else if (!didWarnInvalidOptionChildren) {
	      didWarnInvalidOptionChildren = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
	    }
	  });
	
	  return content;
	}
	
	/**
	 * Implements an <option> host component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function mountWrapper(inst, props, hostParent) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
	    }
	
	    // Look up whether this option is 'selected'
	    var selectValue = null;
	    if (hostParent != null) {
	      var selectParent = hostParent;
	
	      if (selectParent._tag === 'optgroup') {
	        selectParent = selectParent._hostParent;
	      }
	
	      if (selectParent != null && selectParent._tag === 'select') {
	        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
	      }
	    }
	
	    // If the value is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      var value;
	      if (props.value != null) {
	        value = props.value + '';
	      } else {
	        value = flattenChildren(props.children);
	      }
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    // value="" should make a value attribute (#6219)
	    var props = inst._currentElement.props;
	    if (props.value != null) {
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      node.setAttribute('value', props.value);
	    }
	  },
	
	  getHostProps: function getHostProps(inst, props) {
	    var hostProps = _assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      hostProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = flattenChildren(props.children);
	
	    if (content) {
	      hostProps.children = content;
	    }
	
	    return hostProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	
	var warning = __webpack_require__(18);
	
	var didWarnValueLink = false;
	var didWarnValueDefaultValue = false;
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  if (props.valueLink !== undefined && !didWarnValueLink) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
	    didWarnValueLink = true;
	  }
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    var isArray = Array.isArray(props[propName]);
	    if (props.multiple && !isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    } else if (!props.multiple && isArray) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> host component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  getHostProps: function getHostProps(inst, props) {
	    return _assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	
	    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	      didWarnValueDefaultValue = true;
	    }
	  },
	
	  getSelectValueContext: function getSelectValueContext(inst) {
	    // ReactDOMOption looks at this initial value so the initial generated
	    // markup has correct `selected` attributes
	    return inst._wrapperState.initialValue;
	  },
	
	  postUpdateWrapper: function postUpdateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // this value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  if (this._rootNodeID) {
	    this._wrapperState.pendingUpdate = true;
	  }
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var LinkedValueUtils = __webpack_require__(116);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var didWarnValueLink = false;
	var didWarnValDefaultVal = false;
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> host component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getHostProps: function getHostProps(inst, props) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.  We could add a check in setTextContent
	    // to only set the value if/when the value differs from the node value (which would
	    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
	    // The value can be a boolean or object so that's why it's forced to be a string.
	    var hostProps = _assign({}, props, {
	      value: undefined,
	      defaultValue: undefined,
	      children: '' + inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return hostProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	      if (props.valueLink !== undefined && !didWarnValueLink) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
	        didWarnValueLink = true;
	      }
	      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
	        didWarnValDefaultVal = true;
	      }
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    var initialValue = value;
	
	    // Only bother fetching default value if we're going to use it
	    if (value == null) {
	      var defaultValue = props.defaultValue;
	      // TODO (yungsters): Remove support for children content in <textarea>.
	      var children = props.children;
	      if (children != null) {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
	        }
	        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
	        if (Array.isArray(children)) {
	          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
	          children = children[0];
	        }
	
	        defaultValue = '' + children;
	      }
	      if (defaultValue == null) {
	        defaultValue = '';
	      }
	      initialValue = defaultValue;
	    }
	
	    inst._wrapperState = {
	      initialValue: '' + initialValue,
	      listeners: null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      var newValue = '' + value;
	
	      // To avoid side effects (such as losing text selection), only set value if changed
	      if (newValue !== node.value) {
	        node.value = newValue;
	      }
	      if (props.defaultValue == null) {
	        node.defaultValue = newValue;
	      }
	    }
	    if (props.defaultValue != null) {
	      node.defaultValue = props.defaultValue;
	    }
	  },
	
	  postMountWrapper: function postMountWrapper(inst) {
	    // This is in postMount because we need access to the DOM node, which is not
	    // available until after the component has mounted.
	    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	
	    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
	    node.value = node.textContent; // Detach value from defaultValue
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactReconciler = __webpack_require__(66);
	var ReactChildReconciler = __webpack_require__(124);
	
	var emptyFunction = __webpack_require__(19);
	var flattenChildren = __webpack_require__(139);
	var invariant = __webpack_require__(15);
	
	/**
	 * Make an update for markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function makeInsertMarkup(markup, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'INSERT_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for moving an existing element to another index.
	 *
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function makeMove(child, afterNode, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'MOVE_EXISTING',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: ReactReconciler.getHostNode(child),
	    toIndex: toIndex,
	    afterNode: afterNode
	  };
	}
	
	/**
	 * Make an update for removing an element at an index.
	 *
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function makeRemove(child, node) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'REMOVE_NODE',
	    content: null,
	    fromIndex: child._mountIndex,
	    fromNode: node,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the markup of a node.
	 *
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function makeSetMarkup(markup) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'SET_MARKUP',
	    content: markup,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Make an update for setting the text content.
	 *
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function makeTextContent(textContent) {
	  // NOTE: Null values reduce hidden classes.
	  return {
	    type: 'TEXT_CONTENT',
	    content: textContent,
	    fromIndex: null,
	    fromNode: null,
	    toIndex: null,
	    afterNode: null
	  };
	}
	
	/**
	 * Push an update, if any, onto the queue. Creates a new queue if none is
	 * passed and always returns the queue. Mutative.
	 */
	function enqueue(queue, update) {
	  if (update) {
	    queue = queue || [];
	    queue.push(update);
	  }
	  return queue;
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue(inst, updateQueue) {
	  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
	}
	
	var setChildrenForInstrumentation = emptyFunction;
	if (process.env.NODE_ENV !== 'production') {
	  var getDebugID = function getDebugID(inst) {
	    if (!inst._debugID) {
	      // Check for ART-like instances. TODO: This is silly/gross.
	      var internal;
	      if (internal = ReactInstanceMap.get(inst)) {
	        inst = internal;
	      }
	    }
	    return inst._debugID;
	  };
	  setChildrenForInstrumentation = function setChildrenForInstrumentation(children) {
	    var debugID = getDebugID(this);
	    // TODO: React Native empty components are also multichild.
	    // This means they still get into this method but don't have _debugID.
	    if (debugID !== 0) {
	      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
	        return children[key]._debugID;
	      }) : []);
	    }
	  };
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        var selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
	      var nextChildren;
	      var selfDebugID = 0;
	      if (process.env.NODE_ENV !== 'production') {
	        selfDebugID = getDebugID(this);
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          return nextChildren;
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
	      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
	      return nextChildren;
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function mountChildren(nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          var selfDebugID = 0;
	          if (process.env.NODE_ENV !== 'production') {
	            selfDebugID = getDebugID(this);
	          }
	          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, children);
	      }
	
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function updateTextContent(nextContent) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      // Set new text content.
	      var updates = [makeTextContent(nextContent)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function updateMarkup(nextMarkup) {
	      var prevChildren = this._renderedChildren;
	      // Remove any rendered children.
	      ReactChildReconciler.unmountChildren(prevChildren, false);
	      for (var name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name)) {
	           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
	        }
	      }
	      var updates = [makeSetMarkup(nextMarkup)];
	      processQueue(this, updates);
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
	      // Hook used by React ART
	      this._updateChildren(nextNestedChildrenElements, transaction, context);
	    },
	
	    /**
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var removedNodes = {};
	      var mountImages = [];
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var updates = null;
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var nextIndex = 0;
	      var lastIndex = 0;
	      // `nextMountIndex` will increment for each newly mounted child.
	      var nextMountIndex = 0;
	      var lastPlacedNode = null;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            // The `removedNodes` loop below will actually remove the child.
	          }
	          // The child must be instantiated before it's mounted.
	          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
	          nextMountIndex++;
	        }
	        nextIndex++;
	        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
	      }
	      // Remove children that are no longer present.
	      for (name in removedNodes) {
	        if (removedNodes.hasOwnProperty(name)) {
	          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
	        }
	      }
	      if (updates) {
	        processQueue(this, updates);
	      }
	      this._renderedChildren = nextChildren;
	
	      if (process.env.NODE_ENV !== 'production') {
	        setChildrenForInstrumentation.call(this, nextChildren);
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted. It does not actually perform any
	     * backend operations.
	     *
	     * @internal
	     */
	    unmountChildren: function unmountChildren(safely) {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren, safely);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function moveChild(child, afterNode, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        return makeMove(child, afterNode, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function createChild(child, afterNode, mountImage) {
	      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function removeChild(child, node) {
	      return makeRemove(child, node);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildAtIndex: function _mountChildAtIndex(child, mountImage, afterNode, index, transaction, context) {
	      child._mountIndex = index;
	      return this.createChild(child, afterNode, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function _unmountChild(child, node) {
	      var update = this.removeChild(child, node);
	      child._mountIndex = null;
	      return update;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkup: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function injectEnvironment(environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
	      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 123 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function remove(key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function get(key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function has(key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function set(key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(66);
	
	var instantiateReactComponent = __webpack_require__(125);
	var KeyEscapeUtils = __webpack_require__(135);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var traverseAllChildren = __webpack_require__(136);
	var warning = __webpack_require__(18);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}
	
	function instantiateChild(childInstances, child, name, selfDebugID) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    if (!ReactComponentTreeHook) {
	      ReactComponentTreeHook = __webpack_require__(33);
	    }
	    if (!keyUnique) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	    }
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, true);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
	  ) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	
	    if (process.env.NODE_ENV !== 'production') {
	      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
	        return instantiateChild(childInsts, child, name, selfDebugID);
	      }, childInstances);
	    } else {
	      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    }
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
	  ) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return;
	    }
	    var name;
	    var prevChild;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	          ReactReconciler.unmountComponent(prevChild, false);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, true);
	        nextChildren[name] = nextChildInstance;
	        // Creating mount image now ensures refs are resolved in right order
	        // (see https://github.com/facebook/react/pull/7101 for explanation).
	        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
	        mountImages.push(nextChildMountImage);
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        prevChild = prevChildren[name];
	        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
	        ReactReconciler.unmountComponent(prevChild, false);
	      }
	    }
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function unmountChildren(renderedChildren, safely) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild, safely);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var ReactCompositeComponent = __webpack_require__(126);
	var ReactEmptyComponent = __webpack_require__(132);
	var ReactHostComponent = __webpack_require__(133);
	
	var getNextDebugID = __webpack_require__(134);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper(element) {
	  this.construct(element);
	};
	_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @param {boolean} shouldHaveDebugID
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node, shouldHaveDebugID) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = ReactEmptyComponent.create(instantiateReactComponent);
	  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : _prodInvariant('130', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : void 0;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactHostComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	
	      // We renamed this. Allow the old name for compat. :(
	      if (!instance.getHostNode) {
	        instance.getHostNode = instance.getNativeNode;
	      }
	    } else {
	      instance = new ReactCompositeComponentWrapper(element);
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactHostComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : _prodInvariant('131', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : void 0;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
	  }
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var React = __webpack_require__(9);
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactErrorUtils = __webpack_require__(52);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactNodeTypes = __webpack_require__(127);
	var ReactReconciler = __webpack_require__(66);
	
	if (process.env.NODE_ENV !== 'production') {
	  var checkReactTypeSpec = __webpack_require__(128);
	}
	
	var emptyObject = __webpack_require__(27);
	var invariant = __webpack_require__(15);
	var shallowEqual = __webpack_require__(130);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var warning = __webpack_require__(18);
	
	var CompositeTypes = {
	  ImpureClass: 0,
	  PureClass: 1,
	  StatelessFunctional: 2
	};
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  var element = Component(this.props, this.context, this.updater);
	  warnIfInvalidElement(Component, element);
	  return element;
	};
	
	function warnIfInvalidElement(Component, element) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
	    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
	  }
	}
	
	function shouldConstruct(Component) {
	  return !!(Component.prototype && Component.prototype.isReactComponent);
	}
	
	function isPureComponent(Component) {
	  return !!(Component.prototype && Component.prototype.isPureReactComponent);
	}
	
	// Separated into a function to contain deoptimizations caused by try/finally.
	function measureLifeCyclePerf(fn, debugID, timerType) {
	  if (debugID === 0) {
	    // Top-level wrappers (see ReactMount) and empty components (see
	    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
	    // Both are implementation details that should go away in the future.
	    return fn();
	  }
	
	  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
	  try {
	    return fn();
	  } finally {
	    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
	  }
	}
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponent = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function construct(element) {
	    this._currentElement = element;
	    this._rootNodeID = 0;
	    this._compositeType = null;
	    this._instance = null;
	    this._hostParent = null;
	    this._hostContainerInfo = null;
	
	    // See ReactUpdateQueue
	    this._updateBatchNumber = null;
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedNodeType = null;
	    this._renderedComponent = null;
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	
	    // ComponentWillUnmount shall only be called once
	    this._calledComponentWillUnmount = false;
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._warnedAboutRefsInRender = false;
	    }
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {?object} hostParent
	   * @param {?object} hostContainerInfo
	   * @param {?object} context
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    var _this = this;
	
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var publicProps = this._currentElement.props;
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    var updateQueue = transaction.getUpdateQueue();
	
	    // Initialize the public class
	    var doConstruct = shouldConstruct(Component);
	    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
	    var renderedElement;
	
	    // Support functional components
	    if (!doConstruct && (inst == null || inst.render == null)) {
	      renderedElement = inst;
	      warnIfInvalidElement(Component, renderedElement);
	      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
	      inst = new StatelessComponent(Component);
	      this._compositeType = CompositeTypes.StatelessFunctional;
	    } else {
	      if (isPureComponent(Component)) {
	        this._compositeType = CompositeTypes.PureClass;
	      } else {
	        this._compositeType = CompositeTypes.ImpureClass;
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
	      }
	
	      var propsMutated = inst.props !== publicProps;
	      var componentName = Component.displayName || Component.name || 'Component';
	
	      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = updateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    var markup;
	    if (inst.unstable_handleError) {
	      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } else {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	
	    if (inst.componentDidMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(function () {
	            return inst.componentDidMount();
	          }, _this._debugID, 'componentDidMount');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	      }
	    }
	
	    return markup;
	  },
	
	  _constructComponent: function _constructComponent(doConstruct, publicProps, publicContext, updateQueue) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactCurrentOwner.current = this;
	      try {
	        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
	    }
	  },
	
	  _constructComponentWithoutOwner: function _constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue) {
	    var Component = this._currentElement.type;
	
	    if (doConstruct) {
	      if (process.env.NODE_ENV !== 'production') {
	        return measureLifeCyclePerf(function () {
	          return new Component(publicProps, publicContext, updateQueue);
	        }, this._debugID, 'ctor');
	      } else {
	        return new Component(publicProps, publicContext, updateQueue);
	      }
	    }
	
	    // This can still be an instance in case of factory components
	    // but we'll count this as time spent rendering as the more common case.
	    if (process.env.NODE_ENV !== 'production') {
	      return measureLifeCyclePerf(function () {
	        return Component(publicProps, publicContext, updateQueue);
	      }, this._debugID, 'render');
	    } else {
	      return Component(publicProps, publicContext, updateQueue);
	    }
	  },
	
	  performInitialMountWithErrorHandling: function performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var markup;
	    var checkpoint = transaction.checkpoint();
	    try {
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    } catch (e) {
	      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
	      transaction.rollback(checkpoint);
	      this._instance.unstable_handleError(e);
	      if (this._pendingStateQueue) {
	        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
	      }
	      checkpoint = transaction.checkpoint();
	
	      this._renderedComponent.unmountComponent(true);
	      transaction.rollback(checkpoint);
	
	      // Try again - we've informed the component about the error, so they can render an error message this time.
	      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
	      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
	    }
	    return markup;
	  },
	
	  performInitialMount: function performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context) {
	    var inst = this._instance;
	
	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }
	
	    if (inst.componentWillMount) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillMount();
	        }, debugID, 'componentWillMount');
	      } else {
	        inst.componentWillMount();
	      }
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    var nodeType = ReactNodeTypes.getType(renderedElement);
	    this._renderedNodeType = nodeType;
	    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	    );
	    this._renderedComponent = child;
	
	    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (debugID !== 0) {
	        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	      }
	    }
	
	    return markup;
	  },
	
	  getHostNode: function getHostNode() {
	    return ReactReconciler.getHostNode(this._renderedComponent);
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(safely) {
	    if (!this._renderedComponent) {
	      return;
	    }
	
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
	      inst._calledComponentWillUnmount = true;
	
	      if (safely) {
	        var name = this.getName() + '.componentWillUnmount()';
	        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          measureLifeCyclePerf(function () {
	            return inst.componentWillUnmount();
	          }, this._debugID, 'componentWillUnmount');
	        } else {
	          inst.componentWillUnmount();
	        }
	      }
	    }
	
	    if (this._renderedComponent) {
	      ReactReconciler.unmountComponent(this._renderedComponent, safely);
	      this._renderedNodeType = null;
	      this._renderedComponent = null;
	      this._instance = null;
	    }
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = 0;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function _maskContext(context) {
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    var maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function _processContext(context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function _processChildContext(currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext;
	
	    if (inst.getChildContext) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
	        try {
	          childContext = inst.getChildContext();
	        } finally {
	          ReactInstrumentation.debugTool.onEndProcessingChildContext();
	        }
	      } else {
	        childContext = inst.getChildContext();
	      }
	    }
	
	    if (childContext) {
	      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
	      }
	      return _assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Assert that the context types are valid
	   *
	   * @param {object} typeSpecs Map of context field to a ReactPropType
	   * @param {object} values Runtime values that need to be type-checked
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkContextTypes: function _checkContextTypes(typeSpecs, values, location) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
	    }
	  },
	
	  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
	    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    } else {
	      this._updateBatchNumber = null;
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    var willReceive = false;
	    var nextContext;
	
	    // Determine if the context has changed or not
	    if (this._context === nextUnmaskedContext) {
	      nextContext = inst.context;
	    } else {
	      nextContext = this._processContext(nextUnmaskedContext);
	      willReceive = true;
	    }
	
	    var prevProps = prevParentElement.props;
	    var nextProps = nextParentElement.props;
	
	    // Not a simple state update but a props update
	    if (prevParentElement !== nextParentElement) {
	      willReceive = true;
	    }
	
	    // An update here will schedule an update but immediately set
	    // _pendingStateQueue which will ensure that any state updates gets
	    // immediately reconciled instead of waiting for the next batch.
	    if (willReceive && inst.componentWillReceiveProps) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillReceiveProps(nextProps, nextContext);
	        }, this._debugID, 'componentWillReceiveProps');
	      } else {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	    var shouldUpdate = true;
	
	    if (!this._pendingForceUpdate) {
	      if (inst.shouldComponentUpdate) {
	        if (process.env.NODE_ENV !== 'production') {
	          shouldUpdate = measureLifeCyclePerf(function () {
	            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	          }, this._debugID, 'shouldComponentUpdate');
	        } else {
	          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	        }
	      } else {
	        if (this._compositeType === CompositeTypes.PureClass) {
	          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
	        }
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
	    }
	
	    this._updateBatchNumber = null;
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function _processPendingState(props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = _assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var _this2 = this;
	
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        measureLifeCyclePerf(function () {
	          return inst.componentWillUpdate(nextProps, nextState, nextContext);
	        }, this._debugID, 'componentWillUpdate');
	      } else {
	        inst.componentWillUpdate(nextProps, nextState, nextContext);
	      }
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      if (process.env.NODE_ENV !== 'production') {
	        transaction.getReactMountReady().enqueue(function () {
	          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
	        });
	      } else {
	        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	      }
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	
	    var debugID = 0;
	    if (process.env.NODE_ENV !== 'production') {
	      debugID = this._debugID;
	    }
	
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
	      ReactReconciler.unmountComponent(prevComponentInstance, false);
	
	      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
	      this._renderedNodeType = nodeType;
	      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
	      );
	      this._renderedComponent = child;
	
	      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (debugID !== 0) {
	          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
	          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
	        }
	      }
	
	      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
	    }
	  },
	
	  /**
	   * Overridden in shallow rendering.
	   *
	   * @protected
	   */
	  _replaceNodeWithMarkup: function _replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance) {
	    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
	    var inst = this._instance;
	    var renderedElement;
	
	    if (process.env.NODE_ENV !== 'production') {
	      renderedElement = measureLifeCyclePerf(function () {
	        return inst.render();
	      }, this._debugID, 'render');
	    } else {
	      renderedElement = inst.render();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (renderedElement === undefined && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedElement = null;
	      }
	    }
	
	    return renderedElement;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function _renderValidatedComponent() {
	    var renderedElement;
	    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
	      ReactCurrentOwner.current = this;
	      try {
	        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	      } finally {
	        ReactCurrentOwner.current = null;
	      }
	    } else {
	      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;
	
	    return renderedElement;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function attachRef(ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function detachRef(ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function getName() {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function getPublicInstance() {
	    var inst = this._instance;
	    if (this._compositeType === CompositeTypes.StatelessFunctional) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var React = __webpack_require__(9);
	
	var invariant = __webpack_require__(15);
	
	var ReactNodeTypes = {
	  HOST: 0,
	  COMPOSITE: 1,
	  EMPTY: 2,
	
	  getType: function getType(node) {
	    if (node === null || node === false) {
	      return ReactNodeTypes.EMPTY;
	    } else if (React.isValidElement(node)) {
	      if (typeof node.type === 'function') {
	        return ReactNodeTypes.COMPOSITE;
	      } else {
	        return ReactNodeTypes.HOST;
	      }
	    }
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
	  }
	};
	
	module.exports = ReactNodeTypes;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactPropTypeLocationNames = __webpack_require__(129);
	var ReactPropTypesSecret = __webpack_require__(117);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}
	
	var loggedTypeFailures = {};
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var componentStackInfo = '';
	
	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(33);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }
	
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}
	
	module.exports = checkReactTypeSpec;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 130 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
	
	/*eslint-disable no-self-compare */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    // Added the nonzero y check to make Flow happy, but it is redundant
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (is(objA, objB)) {
	    return true;
	  }
	
	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 131 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
	  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 132 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var emptyComponentFactory;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponentFactory: function injectEmptyComponentFactory(factory) {
	    emptyComponentFactory = factory;
	  }
	};
	
	var ReactEmptyComponent = {
	  create: function create(instantiate) {
	    return emptyComponentFactory(instantiate);
	  }
	};
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var invariant = __webpack_require__(15);
	
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around host tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactHostComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function injectTextComponentClass(componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function injectComponentClasses(componentClasses) {
	    _assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a host internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
	  return new genericComponentClass(element);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactHostComponent = {
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactHostComponentInjection
	};
	
	module.exports = ReactHostComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 134 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var nextDebugID = 1;
	
	function getNextDebugID() {
	  return nextDebugID++;
	}
	
	module.exports = getNextDebugID;

/***/ },
/* 135 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */
	
	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });
	
	  return '$' + escapedString;
	}
	
	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);
	
	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}
	
	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};
	
	module.exports = KeyEscapeUtils;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var REACT_ELEMENT_TYPE = __webpack_require__(137);
	
	var getIteratorFn = __webpack_require__(138);
	var invariant = __webpack_require__(15);
	var KeyEscapeUtils = __webpack_require__(135);
	var warning = __webpack_require__(18);
	
	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';
	
	/**
	 * This is inlined from ReactElement since this file is shared between
	 * isomorphic and renderers. We could extract this to a
	 *
	 */
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var didWarnAboutMaps = false;
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' ||
	  // The following is inlined from ReactElement. This means we can optimize
	  // some checks. React Fiber also inlines this logic for similar purposes.
	  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 137 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	module.exports = REACT_ELEMENT_TYPE;

/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var KeyEscapeUtils = __webpack_require__(135);
	var traverseAllChildren = __webpack_require__(136);
	var warning = __webpack_require__(18);
	
	var ReactComponentTreeHook;
	
	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(33);
	}
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 * @param {number=} selfDebugID Optional debugID of the current internal instance.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
	  // We found a component instance.
	  if (traverseContext && (typeof traverseContext === 'undefined' ? 'undefined' : _typeof(traverseContext)) === 'object') {
	    var result = traverseContext;
	    var keyUnique = result[name] === undefined;
	    if (process.env.NODE_ENV !== 'production') {
	      if (!ReactComponentTreeHook) {
	        ReactComponentTreeHook = __webpack_require__(33);
	      }
	      if (!keyUnique) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
	      }
	    }
	    if (keyUnique && child != null) {
	      result[name] = child;
	    }
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children, selfDebugID) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	
	  if (process.env.NODE_ENV !== 'production') {
	    traverseAllChildren(children, function (traverseContext, child, name) {
	      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
	    }, result);
	  } else {
	    traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  }
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var PooledClass = __webpack_require__(57);
	var Transaction = __webpack_require__(75);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactServerUpdateQueue = __webpack_require__(141);
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	var noopCallbackQueue = {
	  enqueue: function enqueue() {}
	};
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.useCreateElement = false;
	  this.updateQueue = new ReactServerUpdateQueue(this);
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return noopCallbackQueue;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function getUpdateQueue() {
	    return this.updateQueue;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {},
	
	  checkpoint: function checkpoint() {},
	
	  rollback: function rollback() {}
	};
	
	_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var ReactUpdateQueue = __webpack_require__(142);
	
	var warning = __webpack_require__(18);
	
	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}
	
	/**
	 * This is the update queue used for server rendering.
	 * It delegates to ReactUpdateQueue while server rendering is in progress and
	 * switches to ReactNoopUpdateQueue after the transaction has completed.
	 * @class ReactServerUpdateQueue
	 * @param {Transaction} transaction
	 */
	
	var ReactServerUpdateQueue = function () {
	  function ReactServerUpdateQueue(transaction) {
	    _classCallCheck(this, ReactServerUpdateQueue);
	
	    this.transaction = transaction;
	  }
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	
	  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
	    return false;
	  };
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
	    }
	  };
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
	    } else {
	      warnNoop(publicInstance, 'forceUpdate');
	    }
	  };
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} completeState Next state.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
	    } else {
	      warnNoop(publicInstance, 'replaceState');
	    }
	  };
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object|function} partialState Next partial state to be merged with state.
	   * @internal
	   */
	
	  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
	    if (this.transaction.isInTransaction()) {
	      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
	    } else {
	      warnNoop(publicInstance, 'setState');
	    }
	  };
	
	  return ReactServerUpdateQueue;
	}();
	
	module.exports = ReactServerUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactUpdates = __webpack_require__(63);
	
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function formatUnexpectedArgument(arg) {
	  var type = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);
	  if (type !== 'object') {
	    return type;
	  }
	  var displayName = arg.constructor && arg.constructor.name || type;
	  var keys = Object.keys(arg);
	  if (keys.length > 0 && keys.length < 20) {
	    return displayName + ' (keys: ' + keys.join(', ') + ')';
	  }
	  return displayName;
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var ctor = publicInstance.constructor;
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @param {string} callerName Name of the calling function in the public API.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback, callerName) {
	    ReactUpdateQueue.validateCallback(callback, callerName);
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    if (process.env.NODE_ENV !== 'production') {
	      ReactInstrumentation.debugTool.onSetState();
	      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
	    }
	
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueElementInternal: function enqueueElementInternal(internalInstance, nextElement, nextContext) {
	    internalInstance._pendingElement = nextElement;
	    // TODO: introduce _pendingContext instead of setting it directly.
	    internalInstance._context = nextContext;
	    enqueueUpdate(internalInstance);
	  },
	
	  validateCallback: function validateCallback(callback, callerName) {
	    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var emptyFunction = __webpack_require__(19);
	var warning = __webpack_require__(18);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    current: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
	    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.current = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	      case '#document':
	        return tag === 'html';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'body':
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'html':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function findOwnerStack(instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    do {
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function validateDOMNesting(childTag, childText, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    if (childText != null) {
	      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
	      childTag = '#text';
	    }
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      var tagDisplayName = childTag;
	      var whitespaceInfo = '';
	      if (childTag === '#text') {
	        if (/\S/.test(childText)) {
	          tagDisplayName = 'Text nodes';
	        } else {
	          tagDisplayName = 'Whitespace text nodes';
	          whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
	        }
	      } else {
	        tagDisplayName = '<' + childTag + '>';
	      }
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
	      }
	    }
	  };
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.current;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var DOMLazyTree = __webpack_require__(88);
	var ReactDOMComponentTree = __webpack_require__(41);
	
	var ReactDOMEmptyComponent = function ReactDOMEmptyComponent(instantiate) {
	  // ReactCompositeComponent uses this:
	  this._currentElement = null;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	  this._hostContainerInfo = null;
	  this._domID = 0;
	};
	_assign(ReactDOMEmptyComponent.prototype, {
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    var domID = hostContainerInfo._idCounter++;
	    this._domID = domID;
	    this._hostParent = hostParent;
	    this._hostContainerInfo = hostContainerInfo;
	
	    var nodeValue = ' react-empty: ' + this._domID + ' ';
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var node = ownerDocument.createComment(nodeValue);
	      ReactDOMComponentTree.precacheNode(this, node);
	      return DOMLazyTree(node);
	    } else {
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd insert a comment node, but since this is a situation
	        // where React won't take over (static pages), we can simply return
	        // nothing.
	        return '';
	      }
	      return '<!--' + nodeValue + '-->';
	    }
	  },
	  receiveComponent: function receiveComponent() {},
	  getHostNode: function getHostNode() {
	    return ReactDOMComponentTree.getNodeFromInstance(this);
	  },
	  unmountComponent: function unmountComponent() {
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	});
	
	module.exports = ReactDOMEmptyComponent;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var invariant = __webpack_require__(15);
	
	/**
	 * Return the lowest common ancestor of A and B, or null if they are in
	 * different trees.
	 */
	function getLowestCommonAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
	
	  var depthA = 0;
	  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
	    depthA++;
	  }
	  var depthB = 0;
	  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
	    depthB++;
	  }
	
	  // If A is deeper, crawl up.
	  while (depthA - depthB > 0) {
	    instA = instA._hostParent;
	    depthA--;
	  }
	
	  // If B is deeper, crawl up.
	  while (depthB - depthA > 0) {
	    instB = instB._hostParent;
	    depthB--;
	  }
	
	  // Walk in lockstep until we find a match.
	  var depth = depthA;
	  while (depth--) {
	    if (instA === instB) {
	      return instA;
	    }
	    instA = instA._hostParent;
	    instB = instB._hostParent;
	  }
	  return null;
	}
	
	/**
	 * Return if A is an ancestor of B.
	 */
	function isAncestor(instA, instB) {
	  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
	
	  while (instB) {
	    if (instB === instA) {
	      return true;
	    }
	    instB = instB._hostParent;
	  }
	  return false;
	}
	
	/**
	 * Return the parent instance of the passed-in instance.
	 */
	function getParentInstance(inst) {
	  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;
	
	  return inst._hostParent;
	}
	
	/**
	 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	 */
	function traverseTwoPhase(inst, fn, arg) {
	  var path = [];
	  while (inst) {
	    path.push(inst);
	    inst = inst._hostParent;
	  }
	  var i;
	  for (i = path.length; i-- > 0;) {
	    fn(path[i], 'captured', arg);
	  }
	  for (i = 0; i < path.length; i++) {
	    fn(path[i], 'bubbled', arg);
	  }
	}
	
	/**
	 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	 * should would receive a `mouseEnter` or `mouseLeave` event.
	 *
	 * Does not invoke the callback on the nearest common ancestor because nothing
	 * "entered" or "left" that element.
	 */
	function traverseEnterLeave(from, to, fn, argFrom, argTo) {
	  var common = from && to ? getLowestCommonAncestor(from, to) : null;
	  var pathFrom = [];
	  while (from && from !== common) {
	    pathFrom.push(from);
	    from = from._hostParent;
	  }
	  var pathTo = [];
	  while (to && to !== common) {
	    pathTo.push(to);
	    to = to._hostParent;
	  }
	  var i;
	  for (i = 0; i < pathFrom.length; i++) {
	    fn(pathFrom[i], 'bubbled', argFrom);
	  }
	  for (i = pathTo.length; i-- > 0;) {
	    fn(pathTo[i], 'captured', argTo);
	  }
	}
	
	module.exports = {
	  isAncestor: isAncestor,
	  getLowestCommonAncestor: getLowestCommonAncestor,
	  getParentInstance: getParentInstance,
	  traverseTwoPhase: traverseTwoPhase,
	  traverseEnterLeave: traverseEnterLeave
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42),
	    _assign = __webpack_require__(11);
	
	var DOMChildrenOperations = __webpack_require__(87);
	var DOMLazyTree = __webpack_require__(88);
	var ReactDOMComponentTree = __webpack_require__(41);
	
	var escapeTextContentForBrowser = __webpack_require__(93);
	var invariant = __webpack_require__(15);
	var validateDOMNesting = __webpack_require__(143);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings between comment nodes so that they
	 * can undergo the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function ReactDOMTextComponent(text) {
	  // TODO: This is really a ReactText (ReactNode), not a ReactElement
	  this._currentElement = text;
	  this._stringText = '' + text;
	  // ReactDOMComponentTree uses these:
	  this._hostNode = null;
	  this._hostParent = null;
	
	  // Properties
	  this._domID = 0;
	  this._mountIndex = 0;
	  this._closingComment = null;
	  this._commentNodes = null;
	};
	
	_assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      var parentInfo;
	      if (hostParent != null) {
	        parentInfo = hostParent._ancestorInfo;
	      } else if (hostContainerInfo != null) {
	        parentInfo = hostContainerInfo._ancestorInfo;
	      }
	      if (parentInfo) {
	        // parentInfo should always be present except for the top-level
	        // component when server rendering
	        validateDOMNesting(null, this._stringText, this, parentInfo);
	      }
	    }
	
	    var domID = hostContainerInfo._idCounter++;
	    var openingValue = ' react-text: ' + domID + ' ';
	    var closingValue = ' /react-text ';
	    this._domID = domID;
	    this._hostParent = hostParent;
	    if (transaction.useCreateElement) {
	      var ownerDocument = hostContainerInfo._ownerDocument;
	      var openingComment = ownerDocument.createComment(openingValue);
	      var closingComment = ownerDocument.createComment(closingValue);
	      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
	      if (this._stringText) {
	        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
	      }
	      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
	      ReactDOMComponentTree.precacheNode(this, openingComment);
	      this._closingComment = closingComment;
	      return lazyTree;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this between comment nodes for the reasons stated
	        // above, but since this is a situation where React won't take over
	        // (static pages), we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function receiveComponent(nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var commentNodes = this.getHostNode();
	        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
	      }
	    }
	  },
	
	  getHostNode: function getHostNode() {
	    var hostNode = this._commentNodes;
	    if (hostNode) {
	      return hostNode;
	    }
	    if (!this._closingComment) {
	      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
	      var node = openingComment.nextSibling;
	      while (true) {
	        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
	        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
	          this._closingComment = node;
	          break;
	        }
	        node = node.nextSibling;
	      }
	    }
	    hostNode = [this._hostNode, this._closingComment];
	    this._commentNodes = hostNode;
	    return hostNode;
	  },
	
	  unmountComponent: function unmountComponent() {
	    this._closingComment = null;
	    this._commentNodes = null;
	    ReactDOMComponentTree.uncacheNode(this);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var ReactUpdates = __webpack_require__(63);
	var Transaction = __webpack_require__(75);
	
	var emptyFunction = __webpack_require__(19);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function close() {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      return callback(a, b, c, d, e);
	    } else {
	      return transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var EventListener = __webpack_require__(149);
	var ExecutionEnvironment = __webpack_require__(55);
	var PooledClass = __webpack_require__(57);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactUpdates = __webpack_require__(63);
	
	var getEventTarget = __webpack_require__(76);
	var getUnboundedScrollPosition = __webpack_require__(150);
	
	/**
	 * Find the deepest React component completely containing the root of the
	 * passed-in instance (for use when entire React trees are nested within each
	 * other). If React trees are not nested, returns null.
	 */
	function findParent(inst) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  while (inst._hostParent) {
	    inst = inst._hostParent;
	  }
	  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
	  var container = rootNode.parentNode;
	  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	_assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function destructor() {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
	  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = targetInst;
	  do {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = ancestor && findParent(ancestor);
	  } while (ancestor);
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    targetInst = bookKeeping.ancestors[i];
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function setEnabled(enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function isEnabled() {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} element Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, element) {
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function monitorScrollValue(refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @typechecks
	 */
	
	var emptyFunction = __webpack_require__(19);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 150 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(43);
	var EventPluginHub = __webpack_require__(49);
	var EventPluginUtils = __webpack_require__(51);
	var ReactComponentEnvironment = __webpack_require__(122);
	var ReactEmptyComponent = __webpack_require__(132);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactHostComponent = __webpack_require__(133);
	var ReactUpdates = __webpack_require__(63);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventPluginUtils: EventPluginUtils.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  HostComponent: ReactHostComponent.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _assign = __webpack_require__(11);
	
	var CallbackQueue = __webpack_require__(64);
	var PooledClass = __webpack_require__(57);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactInputSelection = __webpack_require__(153);
	var ReactInstrumentation = __webpack_require__(69);
	var Transaction = __webpack_require__(75);
	var ReactUpdateQueue = __webpack_require__(142);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function initialize() {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function close(previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function close() {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	if (process.env.NODE_ENV !== 'production') {
	  TRANSACTION_WRAPPERS.push({
	    initialize: ReactInstrumentation.debugTool.onBeginFlush,
	    close: ReactInstrumentation.debugTool.onEndFlush
	  });
	}
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(useCreateElement) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactDOMTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * @return {object} The queue to collect React async events.
	   */
	  getUpdateQueue: function getUpdateQueue() {
	    return ReactUpdateQueue;
	  },
	
	  /**
	   * Save current transaction state -- if the return value from this method is
	   * passed to `rollback`, the transaction will be reset to that state.
	   */
	  checkpoint: function checkpoint() {
	    // reactMountReady is the our only stateful wrapper
	    return this.reactMountReady.checkpoint();
	  },
	
	  rollback: function rollback(checkpoint) {
	    this.reactMountReady.rollback(checkpoint);
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(154);
	
	var containsNode = __webpack_require__(156);
	var focusNode = __webpack_require__(101);
	var getActiveElement = __webpack_require__(159);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function getSelectionInformation() {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function restoreSelection(priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function getSelection(input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function setSelection(input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (end === undefined) {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(55);
	
	var getNodeForCharacterOffset = __webpack_require__(155);
	var getTextContentAccessor = __webpack_require__(58);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (offsets.end === undefined) {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programmatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	var isTextNode = __webpack_require__(157);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 */
	function containsNode(outerNode, innerNode) {
	  if (!outerNode || !innerNode) {
	    return false;
	  } else if (outerNode === innerNode) {
	    return true;
	  } else if (isTextNode(outerNode)) {
	    return false;
	  } else if (isTextNode(innerNode)) {
	    return containsNode(outerNode, innerNode.parentNode);
	  } else if ('contains' in outerNode) {
	    return outerNode.contains(innerNode);
	  } else if (outerNode.compareDocumentPosition) {
	    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	  } else {
	    return false;
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	var isNode = __webpack_require__(158);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 158 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 159 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 160 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	// We use attributes for everything SVG so let's avoid some duplication and run
	// code instead.
	// The following are all specified in the HTML config already so we exclude here.
	// - class (as className)
	// - color
	// - height
	// - id
	// - lang
	// - max
	// - media
	// - method
	// - min
	// - name
	// - style
	// - target
	// - type
	// - width
	var ATTRS = {
	  accentHeight: 'accent-height',
	  accumulate: 0,
	  additive: 0,
	  alignmentBaseline: 'alignment-baseline',
	  allowReorder: 'allowReorder',
	  alphabetic: 0,
	  amplitude: 0,
	  arabicForm: 'arabic-form',
	  ascent: 0,
	  attributeName: 'attributeName',
	  attributeType: 'attributeType',
	  autoReverse: 'autoReverse',
	  azimuth: 0,
	  baseFrequency: 'baseFrequency',
	  baseProfile: 'baseProfile',
	  baselineShift: 'baseline-shift',
	  bbox: 0,
	  begin: 0,
	  bias: 0,
	  by: 0,
	  calcMode: 'calcMode',
	  capHeight: 'cap-height',
	  clip: 0,
	  clipPath: 'clip-path',
	  clipRule: 'clip-rule',
	  clipPathUnits: 'clipPathUnits',
	  colorInterpolation: 'color-interpolation',
	  colorInterpolationFilters: 'color-interpolation-filters',
	  colorProfile: 'color-profile',
	  colorRendering: 'color-rendering',
	  contentScriptType: 'contentScriptType',
	  contentStyleType: 'contentStyleType',
	  cursor: 0,
	  cx: 0,
	  cy: 0,
	  d: 0,
	  decelerate: 0,
	  descent: 0,
	  diffuseConstant: 'diffuseConstant',
	  direction: 0,
	  display: 0,
	  divisor: 0,
	  dominantBaseline: 'dominant-baseline',
	  dur: 0,
	  dx: 0,
	  dy: 0,
	  edgeMode: 'edgeMode',
	  elevation: 0,
	  enableBackground: 'enable-background',
	  end: 0,
	  exponent: 0,
	  externalResourcesRequired: 'externalResourcesRequired',
	  fill: 0,
	  fillOpacity: 'fill-opacity',
	  fillRule: 'fill-rule',
	  filter: 0,
	  filterRes: 'filterRes',
	  filterUnits: 'filterUnits',
	  floodColor: 'flood-color',
	  floodOpacity: 'flood-opacity',
	  focusable: 0,
	  fontFamily: 'font-family',
	  fontSize: 'font-size',
	  fontSizeAdjust: 'font-size-adjust',
	  fontStretch: 'font-stretch',
	  fontStyle: 'font-style',
	  fontVariant: 'font-variant',
	  fontWeight: 'font-weight',
	  format: 0,
	  from: 0,
	  fx: 0,
	  fy: 0,
	  g1: 0,
	  g2: 0,
	  glyphName: 'glyph-name',
	  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
	  glyphOrientationVertical: 'glyph-orientation-vertical',
	  glyphRef: 'glyphRef',
	  gradientTransform: 'gradientTransform',
	  gradientUnits: 'gradientUnits',
	  hanging: 0,
	  horizAdvX: 'horiz-adv-x',
	  horizOriginX: 'horiz-origin-x',
	  ideographic: 0,
	  imageRendering: 'image-rendering',
	  'in': 0,
	  in2: 0,
	  intercept: 0,
	  k: 0,
	  k1: 0,
	  k2: 0,
	  k3: 0,
	  k4: 0,
	  kernelMatrix: 'kernelMatrix',
	  kernelUnitLength: 'kernelUnitLength',
	  kerning: 0,
	  keyPoints: 'keyPoints',
	  keySplines: 'keySplines',
	  keyTimes: 'keyTimes',
	  lengthAdjust: 'lengthAdjust',
	  letterSpacing: 'letter-spacing',
	  lightingColor: 'lighting-color',
	  limitingConeAngle: 'limitingConeAngle',
	  local: 0,
	  markerEnd: 'marker-end',
	  markerMid: 'marker-mid',
	  markerStart: 'marker-start',
	  markerHeight: 'markerHeight',
	  markerUnits: 'markerUnits',
	  markerWidth: 'markerWidth',
	  mask: 0,
	  maskContentUnits: 'maskContentUnits',
	  maskUnits: 'maskUnits',
	  mathematical: 0,
	  mode: 0,
	  numOctaves: 'numOctaves',
	  offset: 0,
	  opacity: 0,
	  operator: 0,
	  order: 0,
	  orient: 0,
	  orientation: 0,
	  origin: 0,
	  overflow: 0,
	  overlinePosition: 'overline-position',
	  overlineThickness: 'overline-thickness',
	  paintOrder: 'paint-order',
	  panose1: 'panose-1',
	  pathLength: 'pathLength',
	  patternContentUnits: 'patternContentUnits',
	  patternTransform: 'patternTransform',
	  patternUnits: 'patternUnits',
	  pointerEvents: 'pointer-events',
	  points: 0,
	  pointsAtX: 'pointsAtX',
	  pointsAtY: 'pointsAtY',
	  pointsAtZ: 'pointsAtZ',
	  preserveAlpha: 'preserveAlpha',
	  preserveAspectRatio: 'preserveAspectRatio',
	  primitiveUnits: 'primitiveUnits',
	  r: 0,
	  radius: 0,
	  refX: 'refX',
	  refY: 'refY',
	  renderingIntent: 'rendering-intent',
	  repeatCount: 'repeatCount',
	  repeatDur: 'repeatDur',
	  requiredExtensions: 'requiredExtensions',
	  requiredFeatures: 'requiredFeatures',
	  restart: 0,
	  result: 0,
	  rotate: 0,
	  rx: 0,
	  ry: 0,
	  scale: 0,
	  seed: 0,
	  shapeRendering: 'shape-rendering',
	  slope: 0,
	  spacing: 0,
	  specularConstant: 'specularConstant',
	  specularExponent: 'specularExponent',
	  speed: 0,
	  spreadMethod: 'spreadMethod',
	  startOffset: 'startOffset',
	  stdDeviation: 'stdDeviation',
	  stemh: 0,
	  stemv: 0,
	  stitchTiles: 'stitchTiles',
	  stopColor: 'stop-color',
	  stopOpacity: 'stop-opacity',
	  strikethroughPosition: 'strikethrough-position',
	  strikethroughThickness: 'strikethrough-thickness',
	  string: 0,
	  stroke: 0,
	  strokeDasharray: 'stroke-dasharray',
	  strokeDashoffset: 'stroke-dashoffset',
	  strokeLinecap: 'stroke-linecap',
	  strokeLinejoin: 'stroke-linejoin',
	  strokeMiterlimit: 'stroke-miterlimit',
	  strokeOpacity: 'stroke-opacity',
	  strokeWidth: 'stroke-width',
	  surfaceScale: 'surfaceScale',
	  systemLanguage: 'systemLanguage',
	  tableValues: 'tableValues',
	  targetX: 'targetX',
	  targetY: 'targetY',
	  textAnchor: 'text-anchor',
	  textDecoration: 'text-decoration',
	  textRendering: 'text-rendering',
	  textLength: 'textLength',
	  to: 0,
	  transform: 0,
	  u1: 0,
	  u2: 0,
	  underlinePosition: 'underline-position',
	  underlineThickness: 'underline-thickness',
	  unicode: 0,
	  unicodeBidi: 'unicode-bidi',
	  unicodeRange: 'unicode-range',
	  unitsPerEm: 'units-per-em',
	  vAlphabetic: 'v-alphabetic',
	  vHanging: 'v-hanging',
	  vIdeographic: 'v-ideographic',
	  vMathematical: 'v-mathematical',
	  values: 0,
	  vectorEffect: 'vector-effect',
	  version: 0,
	  vertAdvY: 'vert-adv-y',
	  vertOriginX: 'vert-origin-x',
	  vertOriginY: 'vert-origin-y',
	  viewBox: 'viewBox',
	  viewTarget: 'viewTarget',
	  visibility: 0,
	  widths: 0,
	  wordSpacing: 'word-spacing',
	  writingMode: 'writing-mode',
	  x: 0,
	  xHeight: 'x-height',
	  x1: 0,
	  x2: 0,
	  xChannelSelector: 'xChannelSelector',
	  xlinkActuate: 'xlink:actuate',
	  xlinkArcrole: 'xlink:arcrole',
	  xlinkHref: 'xlink:href',
	  xlinkRole: 'xlink:role',
	  xlinkShow: 'xlink:show',
	  xlinkTitle: 'xlink:title',
	  xlinkType: 'xlink:type',
	  xmlBase: 'xml:base',
	  xmlns: 0,
	  xmlnsXlink: 'xmlns:xlink',
	  xmlLang: 'xml:lang',
	  xmlSpace: 'xml:space',
	  y: 0,
	  y1: 0,
	  y2: 0,
	  yChannelSelector: 'yChannelSelector',
	  z: 0,
	  zoomAndPan: 'zoomAndPan'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {},
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {}
	};
	
	Object.keys(ATTRS).forEach(function (key) {
	  SVGDOMPropertyConfig.Properties[key] = 0;
	  if (ATTRS[key]) {
	    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
	  }
	});
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var EventPropagators = __webpack_require__(48);
	var ExecutionEnvironment = __webpack_require__(55);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInputSelection = __webpack_require__(153);
	var SyntheticEvent = __webpack_require__(60);
	
	var getActiveElement = __webpack_require__(159);
	var isTextInputElement = __webpack_require__(78);
	var shallowEqual = __webpack_require__(130);
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: 'onSelect',
	      captured: 'onSelectCapture'
	    },
	    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
	  }
	};
	
	var activeElement = null;
	var activeElementInst = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events. See #3639.
	var hasListener = false;
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case 'topFocus':
	        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
	          activeElement = targetNode;
	          activeElementInst = targetInst;
	          lastSelection = null;
	        }
	        break;
	      case 'topBlur':
	        activeElement = null;
	        activeElementInst = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case 'topMouseDown':
	        mouseDown = true;
	        break;
	      case 'topContextMenu':
	      case 'topMouseUp':
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case 'topSelectionChange':
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case 'topKeyDown':
	      case 'topKeyUp':
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function didPutListener(inst, registrationName, listener) {
	    if (registrationName === 'onSelect') {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var EventListener = __webpack_require__(149);
	var EventPropagators = __webpack_require__(48);
	var ReactDOMComponentTree = __webpack_require__(41);
	var SyntheticAnimationEvent = __webpack_require__(163);
	var SyntheticClipboardEvent = __webpack_require__(164);
	var SyntheticEvent = __webpack_require__(60);
	var SyntheticFocusEvent = __webpack_require__(165);
	var SyntheticKeyboardEvent = __webpack_require__(166);
	var SyntheticMouseEvent = __webpack_require__(81);
	var SyntheticDragEvent = __webpack_require__(169);
	var SyntheticTouchEvent = __webpack_require__(170);
	var SyntheticTransitionEvent = __webpack_require__(171);
	var SyntheticUIEvent = __webpack_require__(82);
	var SyntheticWheelEvent = __webpack_require__(172);
	
	var emptyFunction = __webpack_require__(19);
	var getEventCharCode = __webpack_require__(167);
	var invariant = __webpack_require__(15);
	
	/**
	 * Turns
	 * ['abort', ...]
	 * into
	 * eventTypes = {
	 *   'abort': {
	 *     phasedRegistrationNames: {
	 *       bubbled: 'onAbort',
	 *       captured: 'onAbortCapture',
	 *     },
	 *     dependencies: ['topAbort'],
	 *   },
	 *   ...
	 * };
	 * topLevelEventsToDispatchConfig = {
	 *   'topAbort': { sameConfig }
	 * };
	 */
	var eventTypes = {};
	var topLevelEventsToDispatchConfig = {};
	['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
	  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
	  var onEvent = 'on' + capitalizedEvent;
	  var topEvent = 'top' + capitalizedEvent;
	
	  var type = {
	    phasedRegistrationNames: {
	      bubbled: onEvent,
	      captured: onEvent + 'Capture'
	    },
	    dependencies: [topEvent]
	  };
	  eventTypes[event] = type;
	  topLevelEventsToDispatchConfig[topEvent] = type;
	});
	
	var onClickListeners = {};
	
	function getDictionaryKey(inst) {
	  // Prevents V8 performance issue:
	  // https://github.com/facebook/react/pull/7232
	  return '.' + inst._rootNodeID;
	}
	
	function isInteractive(tag) {
	  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
	}
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case 'topAbort':
	      case 'topCanPlay':
	      case 'topCanPlayThrough':
	      case 'topDurationChange':
	      case 'topEmptied':
	      case 'topEncrypted':
	      case 'topEnded':
	      case 'topError':
	      case 'topInput':
	      case 'topInvalid':
	      case 'topLoad':
	      case 'topLoadedData':
	      case 'topLoadedMetadata':
	      case 'topLoadStart':
	      case 'topPause':
	      case 'topPlay':
	      case 'topPlaying':
	      case 'topProgress':
	      case 'topRateChange':
	      case 'topReset':
	      case 'topSeeked':
	      case 'topSeeking':
	      case 'topStalled':
	      case 'topSubmit':
	      case 'topSuspend':
	      case 'topTimeUpdate':
	      case 'topVolumeChange':
	      case 'topWaiting':
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case 'topKeyPress':
	        // Firefox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case 'topKeyDown':
	      case 'topKeyUp':
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case 'topBlur':
	      case 'topFocus':
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case 'topClick':
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case 'topDoubleClick':
	      case 'topMouseDown':
	      case 'topMouseMove':
	      case 'topMouseUp':
	      // TODO: Disabled elements should not respond to mouse events
	      /* falls through */
	      case 'topMouseOut':
	      case 'topMouseOver':
	      case 'topContextMenu':
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case 'topDrag':
	      case 'topDragEnd':
	      case 'topDragEnter':
	      case 'topDragExit':
	      case 'topDragLeave':
	      case 'topDragOver':
	      case 'topDragStart':
	      case 'topDrop':
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case 'topTouchCancel':
	      case 'topTouchEnd':
	      case 'topTouchMove':
	      case 'topTouchStart':
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case 'topAnimationEnd':
	      case 'topAnimationIteration':
	      case 'topAnimationStart':
	        EventConstructor = SyntheticAnimationEvent;
	        break;
	      case 'topTransitionEnd':
	        EventConstructor = SyntheticTransitionEvent;
	        break;
	      case 'topScroll':
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case 'topWheel':
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case 'topCopy':
	      case 'topCut':
	      case 'topPaste':
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
	    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function didPutListener(inst, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
	      if (!onClickListeners[key]) {
	        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function willDeleteListener(inst, registrationName) {
	    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
	      var key = getDictionaryKey(inst);
	      onClickListeners[key].remove();
	      delete onClickListeners[key];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
	 */
	var AnimationEventInterface = {
	  animationName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);
	
	module.exports = SyntheticAnimationEvent;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function clipboardData(event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	
	var getEventCharCode = __webpack_require__(167);
	var getEventKey = __webpack_require__(168);
	var getEventModifierState = __webpack_require__(84);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function charCode(event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function keyCode(event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function which(event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 167 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(167);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(81);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(82);
	
	var getEventModifierState = __webpack_require__(84);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(60);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
	 */
	var TransitionEventInterface = {
	  propertyName: null,
	  elapsedTime: null,
	  pseudoElement: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);
	
	module.exports = SyntheticTransitionEvent;

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(81);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function deltaX(event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function deltaY(event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var DOMLazyTree = __webpack_require__(88);
	var DOMProperty = __webpack_require__(43);
	var React = __webpack_require__(9);
	var ReactBrowserEventEmitter = __webpack_require__(112);
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactDOMContainerInfo = __webpack_require__(174);
	var ReactDOMFeatureFlags = __webpack_require__(175);
	var ReactFeatureFlags = __webpack_require__(65);
	var ReactInstanceMap = __webpack_require__(123);
	var ReactInstrumentation = __webpack_require__(69);
	var ReactMarkupChecksum = __webpack_require__(176);
	var ReactReconciler = __webpack_require__(66);
	var ReactUpdateQueue = __webpack_require__(142);
	var ReactUpdates = __webpack_require__(63);
	
	var emptyObject = __webpack_require__(27);
	var instantiateReactComponent = __webpack_require__(125);
	var invariant = __webpack_require__(15);
	var setInnerHTML = __webpack_require__(90);
	var shouldUpdateReactComponent = __webpack_require__(131);
	var warning = __webpack_require__(18);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var instancesByReactRootID = {};
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
	  var markerName;
	  if (ReactFeatureFlags.logTopLevelRenders) {
	    var wrappedElement = wrapperInstance._currentElement.props.child;
	    var type = wrappedElement.type;
	    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
	    console.time(markerName);
	  }
	
	  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
	  );
	
	  if (markerName) {
	    console.timeEnd(markerName);
	  }
	
	  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
	  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* useCreateElement */
	  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container, safely) {
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onBeginFlush();
	  }
	  ReactReconciler.unmountComponent(instance, safely);
	  if (process.env.NODE_ENV !== 'production') {
	    ReactInstrumentation.debugTool.onEndFlush();
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  if (rootEl) {
	    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
	    return !!(inst && inst._hostParent);
	  }
	}
	
	/**
	 * True if the supplied DOM node is a React DOM element and
	 * it has been rendered by another copy of React.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM has been rendered by another copy of React
	 * @internal
	 */
	function nodeIsRenderedByOtherInstance(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
	}
	
	/**
	 * True if the supplied DOM node is a valid node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid DOM node.
	 * @internal
	 */
	function isValidContainer(node) {
	  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
	}
	
	/**
	 * True if the supplied DOM node is a valid React node element.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM is a valid React DOM node.
	 * @internal
	 */
	function isReactNode(node) {
	  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
	}
	
	function getHostRootInstanceInContainer(container) {
	  var rootEl = getReactRootElementInContainer(container);
	  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
	  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
	}
	
	function getTopLevelWrapperInContainer(container) {
	  var root = getHostRootInstanceInContainer(container);
	  return root ? root._hostContainerInfo._topLevelWrapper : null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var topLevelRootCounter = 1;
	var TopLevelWrapper = function TopLevelWrapper() {
	  this.rootID = topLevelRootCounter++;
	};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  return this.props.child;
	};
	TopLevelWrapper.isReactTopLevelWrapper = true;
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /**
	   * Used by devtools. The keys are not important.
	   */
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function scrollMonitor(container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, nextContext, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    return prevComponent;
	  },
	
	  /**
	   * Render a new component into the DOM. Hooked by hooks!
	   *
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	    var componentInstance = instantiateReactComponent(nextElement, false);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);
	
	    var wrapperID = componentInstance._instance.rootID;
	    instancesByReactRootID[wrapperID] = componentInstance;
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
	    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;
	
	    var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });
	
	    var nextContext;
	    if (parentComponent) {
	      var parentInst = ReactInstanceMap.get(parentComponent);
	      nextContext = parentInst._processChildContext(parentInst._context);
	    } else {
	      nextContext = emptyObject;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props.child;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function render(nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function unmountComponentAtNode(container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;
	
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
	    }
	
	    var prevComponent = getTopLevelWrapperInContainer(container);
	    if (!prevComponent) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
	      }
	
	      return false;
	    }
	    delete instancesByReactRootID[prevComponent._instance.rootID];
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
	    return true;
	  },
	
	  _mountImageIntoNode: function _mountImageIntoNode(markup, container, instance, shouldReuseMarkup, transaction) {
	    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        ReactDOMComponentTree.precacheNode(instance, rootElement);
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      DOMLazyTree.insertTreeBefore(container, markup, null);
	    } else {
	      setInnerHTML(container, markup);
	      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
	      if (hostNode._debugID !== 0) {
	        ReactInstrumentation.debugTool.onHostOperation({
	          instanceID: hostNode._debugID,
	          type: 'mount',
	          payload: markup.toString()
	        });
	      }
	    }
	  }
	};
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var validateDOMNesting = __webpack_require__(143);
	
	var DOC_NODE_TYPE = 9;
	
	function ReactDOMContainerInfo(topLevelWrapper, node) {
	  var info = {
	    _topLevelWrapper: topLevelWrapper,
	    _idCounter: 1,
	    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
	    _node: node,
	    _tag: node ? node.nodeName.toLowerCase() : null,
	    _namespaceURI: node ? node.namespaceURI : null
	  };
	  if (process.env.NODE_ENV !== 'production') {
	    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
	  }
	  return info;
	}
	
	module.exports = ReactDOMContainerInfo;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 175 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: true,
	  useFiber: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(177);
	
	var TAG_END = /\/?>/;
	var COMMENT_START = /^<\!\-\-/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function addChecksumToMarkup(markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags, comments and self-closing tags)
	    if (COMMENT_START.test(markup)) {
	      return markup;
	    } else {
	      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	    }
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function canReuseMarkup(markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 177 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    var n = Math.min(i + 4096, m);
	    for (; i < n; i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 178 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	module.exports = '15.4.1';

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var _prodInvariant = __webpack_require__(42);
	
	var ReactCurrentOwner = __webpack_require__(17);
	var ReactDOMComponentTree = __webpack_require__(41);
	var ReactInstanceMap = __webpack_require__(123);
	
	var getHostComponentFromComposite = __webpack_require__(180);
	var invariant = __webpack_require__(15);
	var warning = __webpack_require__(18);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	
	  var inst = ReactInstanceMap.get(componentOrElement);
	  if (inst) {
	    inst = getHostComponentFromComposite(inst);
	    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
	  }
	
	  if (typeof componentOrElement.render === 'function') {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
	  }
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactNodeTypes = __webpack_require__(127);
	
	function getHostComponentFromComposite(inst) {
	  var type;
	
	  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
	    inst = inst._renderedComponent;
	  }
	
	  if (type === ReactNodeTypes.HOST) {
	    return inst._renderedComponent;
	  } else if (type === ReactNodeTypes.EMPTY) {
	    return null;
	  }
	}
	
	module.exports = getHostComponentFromComposite;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(173);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(43);
	var EventPluginRegistry = __webpack_require__(50);
	var ReactComponentTreeHook = __webpack_require__(33);
	
	var warning = __webpack_require__(18);
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true,
	
	    autoFocus: true,
	    defaultValue: true,
	    valueLink: true,
	    defaultChecked: true,
	    checkedLink: true,
	    innerHTML: true,
	    suppressContentEditableWarning: true,
	    onFocusIn: true,
	    onFocusOut: true
	  };
	  var warnedProperties = {};
	
	  var validateProperty = function validateProperty(tagName, name, debugID) {
	    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
	      return true;
	    }
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return true;
	    }
	    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
	      return true;
	    }
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;
	
	    if (standardName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else if (registrationName != null) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      return true;
	    } else {
	      // We were unable to guess which prop the user intended.
	      // It is likely that the user was just blindly spreading/forwarding props
	      // Components should be careful to only render valid props/attributes.
	      // Warning will be invoked in warnUnknownProperties to allow grouping.
	      return false;
	    }
	  };
	}
	
	var warnUnknownProperties = function warnUnknownProperties(debugID, element) {
	  var unknownProps = [];
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      unknownProps.push(key);
	    }
	  }
	
	  var unknownPropString = unknownProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (unknownProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (unknownProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	};
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	  warnUnknownProperties(debugID, element);
	}
	
	var ReactDOMUnknownPropertyHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMUnknownPropertyHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var ReactComponentTreeHook = __webpack_require__(33);
	
	var warning = __webpack_require__(18);
	
	var didWarnValueNull = false;
	
	function handleElement(debugID, element) {
	  if (element == null) {
	    return;
	  }
	  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
	    return;
	  }
	  if (element.props != null && element.props.value === null && !didWarnValueNull) {
	    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	
	    didWarnValueNull = true;
	  }
	}
	
	var ReactDOMNullInputValuePropHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    handleElement(debugID, element);
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    handleElement(debugID, element);
	  }
	};
	
	module.exports = ReactDOMNullInputValuePropHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(43);
	var ReactComponentTreeHook = __webpack_require__(33);
	
	var warning = __webpack_require__(18);
	
	var warnedProperties = {};
	var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
	
	function validateProperty(tagName, name, debugID) {
	  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	    return true;
	  }
	
	  if (rARIA.test(name)) {
	    var lowerCasedName = name.toLowerCase();
	    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // If this is an aria-* attribute, but is not listed in the known DOM
	    // DOM properties, then it is an invalid aria-* attribute.
	    if (standardName == null) {
	      warnedProperties[name] = true;
	      return false;
	    }
	    // aria-* attributes should be lowercase; suggest the lowercase version.
	    if (name !== standardName) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	      warnedProperties[name] = true;
	      return true;
	    }
	  }
	
	  return true;
	}
	
	function warnInvalidARIAProps(debugID, element) {
	  var invalidProps = [];
	
	  for (var key in element.props) {
	    var isValid = validateProperty(element.type, key, debugID);
	    if (!isValid) {
	      invalidProps.push(key);
	    }
	  }
	
	  var unknownPropString = invalidProps.map(function (prop) {
	    return '`' + prop + '`';
	  }).join(', ');
	
	  if (invalidProps.length === 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  } else if (invalidProps.length > 1) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
	  }
	}
	
	function handleElement(debugID, element) {
	  if (element == null || typeof element.type !== 'string') {
	    return;
	  }
	  if (element.type.indexOf('-') >= 0 || element.props.is) {
	    return;
	  }
	
	  warnInvalidARIAProps(debugID, element);
	}
	
	var ReactDOMInvalidARIAHook = {
	  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  },
	  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
	    if (process.env.NODE_ENV !== 'production') {
	      handleElement(debugID, element);
	    }
	  }
	};
	
	module.exports = ReactDOMInvalidARIAHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.RouterContext = exports.createRoutes = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;
	
	var _RouteUtils = __webpack_require__(186);
	
	Object.defineProperty(exports, 'createRoutes', {
	  enumerable: true,
	  get: function get() {
	    return _RouteUtils.createRoutes;
	  }
	});
	
	var _PropTypes = __webpack_require__(187);
	
	Object.defineProperty(exports, 'locationShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes.locationShape;
	  }
	});
	Object.defineProperty(exports, 'routerShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes.routerShape;
	  }
	});
	
	var _PatternUtils = __webpack_require__(188);
	
	Object.defineProperty(exports, 'formatPattern', {
	  enumerable: true,
	  get: function get() {
	    return _PatternUtils.formatPattern;
	  }
	});
	
	var _Router2 = __webpack_require__(190);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	var _Link2 = __webpack_require__(206);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	var _IndexLink2 = __webpack_require__(207);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	var _withRouter2 = __webpack_require__(208);
	
	var _withRouter3 = _interopRequireDefault(_withRouter2);
	
	var _IndexRedirect2 = __webpack_require__(210);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	var _IndexRoute2 = __webpack_require__(212);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	var _Redirect2 = __webpack_require__(211);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	var _Route2 = __webpack_require__(213);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	var _RouterContext2 = __webpack_require__(202);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	var _match2 = __webpack_require__(214);
	
	var _match3 = _interopRequireDefault(_match2);
	
	var _useRouterHistory2 = __webpack_require__(227);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	var _applyRouterMiddleware2 = __webpack_require__(228);
	
	var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);
	
	var _browserHistory2 = __webpack_require__(229);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	var _hashHistory2 = __webpack_require__(237);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	var _createMemoryHistory2 = __webpack_require__(216);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.Router = _Router3.default; /* components */
	
	exports.Link = _Link3.default;
	exports.IndexLink = _IndexLink3.default;
	exports.withRouter = _withRouter3.default;
	
	/* components (configuration) */
	
	exports.IndexRedirect = _IndexRedirect3.default;
	exports.IndexRoute = _IndexRoute3.default;
	exports.Redirect = _Redirect3.default;
	exports.Route = _Route3.default;
	
	/* utils */
	
	exports.RouterContext = _RouterContext3.default;
	exports.match = _match3.default;
	exports.useRouterHistory = _useRouterHistory3.default;
	exports.applyRouterMiddleware = _applyRouterMiddleware3.default;
	
	/* histories */
	
	exports.browserHistory = _browserHistory3.default;
	exports.hashHistory = _hashHistory3.default;
	exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function isValidChild(object) {
	  return object == null || _react2.default.isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2.default.Children.forEach(children, function (element) {
	    if (_react2.default.isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.locationShape = exports.routerShape = undefined;
	
	var _react = __webpack_require__(8);
	
	var func = _react.PropTypes.func,
	    object = _react.PropTypes.object,
	    shape = _react.PropTypes.shape,
	    string = _react.PropTypes.string;
	var routerShape = exports.routerShape = shape({
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired,
	  setRouteLeaveHook: func.isRequired,
	  isActive: func.isRequired
	});
	
	var locationShape = exports.locationShape = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = void 0,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '(.*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '(.*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = Object.create(null);
	
	function compilePattern(pattern) {
	  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 *  The function calls callback(error, matched) when finished.
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	function matchPattern(pattern, pathname) {
	  // Ensure pattern starts with leading slash for consistency with pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	
	  var _compilePattern2 = compilePattern(pattern),
	      regexpSource = _compilePattern2.regexpSource,
	      paramNames = _compilePattern2.paramNames,
	      tokens = _compilePattern2.tokens;
	
	  if (pattern.charAt(pattern.length - 1) !== '/') {
	    regexpSource += '/?'; // Allow optional path separator at end.
	  }
	
	  // Special-case patterns like '*' for catch-all routes.
	  if (tokens[tokens.length - 1] === '*') {
	    regexpSource += '$';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
	  if (match == null) {
	    return null;
	  }
	
	  var matchedPath = match[0];
	  var remainingPathname = pathname.substr(matchedPath.length);
	
	  if (remainingPathname) {
	    // Require that the match ends at a path separator, if we didn't match
	    // the full path, so any remaining pathname is a new path segment.
	    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
	      return null;
	    }
	
	    // If there is a remaining pathname, treat the path separator as part of
	    // the remaining pathname for properly continuing the match.
	    remainingPathname = '/' + remainingPathname;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: match.slice(1).map(function (v) {
	      return v && decodeURIComponent(v);
	    })
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var match = matchPattern(pattern, pathname);
	  if (!match) {
	    return null;
	  }
	
	  var paramNames = match.paramNames,
	      paramValues = match.paramValues;
	
	  var params = {};
	
	  paramNames.forEach(function (paramName, index) {
	    params[paramName] = paramValues[index];
	  });
	
	  return params;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern),
	      tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0,
	      parenHistory = [];
	
	  var token = void 0,
	      paramName = void 0,
	      paramValue = void 0;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenHistory[parenCount] = '';
	      parenCount += 1;
	    } else if (token === ')') {
	      var parenText = parenHistory.pop();
	      parenCount -= 1;
	
	      if (parenCount) parenHistory[parenCount - 1] += parenText;else pathname += parenText;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue == null) {
	        if (parenCount) {
	          parenHistory[parenCount - 1] = '';
	
	          var curTokenIdx = tokens.indexOf(token);
	          var tokensSubset = tokens.slice(curTokenIdx, tokens.length);
	          var nextParenIdx = -1;
	
	          for (var _i = 0; _i < tokensSubset.length; _i++) {
	            if (tokensSubset[_i] == ')') {
	              nextParenIdx = _i;
	              break;
	            }
	          }
	
	          !(nextParenIdx > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Path "%s" is missing end paren at segment "%s"', pattern, tokensSubset.join('')) : (0, _invariant2.default)(false) : void 0;
	
	          // jump to ending paren
	          i = curTokenIdx + nextParenIdx - 1;
	        }
	      } else if (parenCount) parenHistory[parenCount - 1] += encodeURIComponent(paramValue);else pathname += encodeURIComponent(paramValue);
	    } else {
	      if (parenCount) parenHistory[parenCount - 1] += token;else pathname += token;
	    }
	  }
	
	  !(parenCount <= 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Path "%s" is missing end paren', pattern) : (0, _invariant2.default)(false) : void 0;
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager2 = __webpack_require__(191);
	
	var _createTransitionManager3 = _interopRequireDefault(_createTransitionManager2);
	
	var _InternalPropTypes = __webpack_require__(201);
	
	var _RouterContext = __webpack_require__(202);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(186);
	
	var _RouterUtils = __webpack_require__(205);
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    func = _React$PropTypes.func,
	    object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	
	var Router = _react2.default.createClass({
	  displayName: 'Router',
	
	  propTypes: {
	    history: object,
	    children: _InternalPropTypes.routes,
	    routes: _InternalPropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2.default.createElement(_RouterContext2.default, props);
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	  createRouterObject: function createRouterObject(state) {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext.router;
	    }
	
	    var history = this.props.history;
	
	    return (0, _RouterUtils.createRouterObject)(history, this.transitionManager, state);
	  },
	  createTransitionManager: function createTransitionManager() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext.transitionManager;
	    }
	
	    var history = this.props.history;
	    var _props = this.props,
	        routes = _props.routes,
	        children = _props.children;
	
	    !history.getCurrentLocation ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v2.x or ' + 'earlier. This version of React Router is only compatible with v3 ' + 'history objects. Please upgrade to history v3.x.') : (0, _invariant2.default)(false) : void 0;
	
	    return (0, _createTransitionManager3.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    this.transitionManager = this.createTransitionManager();
	    this.router = this.createRouterObject(this.state);
	
	    this._unlisten = this.transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        // Keep the identity of this.router because of a caveat in ContextUtils:
	        // they only work if the object identity is preserved.
	        (0, _RouterUtils.assignRouterState)(_this.router, state);
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	  },
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	  render: function render() {
	    var _state = this.state,
	        location = _state.location,
	        routes = _state.routes,
	        params = _state.params,
	        components = _state.components;
	
	    var _props2 = this.props,
	        createElement = _props2.createElement,
	        render = _props2.render,
	        props = _objectWithoutProperties(_props2, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	});
	
	exports.default = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = createTransitionManager;
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _computeChangedRoutes2 = __webpack_require__(194);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(195);
	
	var _isActive2 = __webpack_require__(197);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(198);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(200);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location, indexOnly) {
	    location = history.createLocation(location);
	
	    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  var partialNextState = void 0;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState),
	        leaveRoutes = _computeChangedRoutes.leaveRoutes,
	        changeRoutes = _computeChangedRoutes.changeRoutes,
	        enterRoutes = _computeChangedRoutes.enterRoutes;
	
	    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.filter(function (route) {
	      return enterRoutes.indexOf(route) === -1;
	    }).forEach(removeListenBeforeHooksForRoute);
	
	    // change and enter hooks are run in series
	    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
	    });
	
	    function finishEnterHooks(error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      // TODO: Fetch components after state is updated.
	      (0, _getComponents2.default)(nextState, function (error, components) {
	        if (error) {
	          callback(error);
	        } else {
	          // TODO: Make match a pure function and have some other API
	          // for "match and update state".
	          callback(null, null, state = _extends({}, nextState, { components: components }));
	        }
	      });
	    }
	
	    function handleErrorOrRedirect(error, redirectInfo) {
	      if (error) callback(error);else callback(null, redirectInfo);
	    }
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = Object.create(null);
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.map(function (route) {
	      return RouteHooks[getRouteID(route)];
	    }).filter(function (hook) {
	      return hook;
	    });
	  }
	
	  function transitionHook(location, callback) {
	    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);
	
	      var result = void 0;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = void 0;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = void 0,
	      unlistenBeforeUnload = void 0;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and can return either a prompt message (string) to show the user,
	   * to make sure they want to leave the page; or `false`, to prevent the transition.
	   * Any other return value will have no effect.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	    var routeID = getRouteID(route, true);
	
	    RouteHooks[routeID] = hook;
	
	    if (thereWereNoRouteHooks) {
	      // setup transition & beforeunload hooks
	      unlistenBefore = history.listenBefore(transitionHook);
	
	      if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	    }
	
	    return function () {
	      removeListenBeforeHooksForRoute(route);
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    function historyListener(location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.replace(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
	          }
	        });
	      }
	    }
	
	    // TODO: Only use a single history listener. Otherwise we'll end up with
	    // multiple concurrent calls to match.
	
	    // Set up the history listener first in case the initial match redirects.
	    var unsubscribe = history.listen(historyListener);
	
	    if (state.location) {
	      // Picking up on a matchContext.
	      listener(null, state);
	    } else {
	      historyListener(history.getCurrentLocation());
	    }
	
	    return unsubscribe;
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = routerWarning;
	exports._resetWarned = _resetWarned;
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var warned = {};
	
	function routerWarning(falseToWarn, message) {
	  // Only issue deprecation warnings once.
	  if (message.indexOf('deprecated') !== -1) {
	    if (warned[message]) {
	      return;
	    }
	
	    warned[message] = true;
	  }
	
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
	}
	
	function _resetWarned() {
	  warned = {};
	}

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function warning() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(188);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = (0, _PatternUtils.getParamNames)(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 *
	 * changeRoutes are any routes that didn't leave or enter during
	 * the transition.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = void 0,
	      changeRoutes = void 0,
	      enterRoutes = void 0;
	  if (prevRoutes) {
	    (function () {
	      var parentIsLeaving = false;
	      leaveRoutes = prevRoutes.filter(function (route) {
	        if (parentIsLeaving) {
	          return true;
	        } else {
	          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	          if (isLeaving) parentIsLeaving = true;
	          return isLeaving;
	        }
	      });
	
	      // onLeave hooks start at the leaf route.
	      leaveRoutes.reverse();
	
	      enterRoutes = [];
	      changeRoutes = [];
	
	      nextRoutes.forEach(function (route) {
	        var isNew = prevRoutes.indexOf(route) === -1;
	        var paramsChanged = leaveRoutes.indexOf(route) !== -1;
	
	        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
	      });
	    })();
	  } else {
	    leaveRoutes = [];
	    changeRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    changeRoutes: changeRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports.default = computeChangedRoutes;
	module.exports = exports['default'];

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runChangeHooks = runChangeHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	var _AsyncUtils = __webpack_require__(196);
	
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	
	var PendingHooks = function PendingHooks() {
	  var _this = this;
	
	  _classCallCheck(this, PendingHooks);
	
	  this.hooks = [];
	
	  this.add = function (hook) {
	    return _this.hooks.push(hook);
	  };
	
	  this.remove = function (hook) {
	    return _this.hooks = _this.hooks.filter(function (h) {
	      return h !== hook;
	    });
	  };
	
	  this.has = function (hook) {
	    return _this.hooks.indexOf(hook) !== -1;
	  };
	
	  this.clear = function () {
	    return _this.hooks = [];
	  };
	};
	
	var enterHooks = new PendingHooks();
	var changeHooks = new PendingHooks();
	
	function createTransitionHook(hook, route, asyncArity, pendingHooks) {
	  var isSync = hook.length < asyncArity;
	
	  var transitionHook = function transitionHook() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    hook.apply(route, args);
	
	    if (isSync) {
	      var callback = args[args.length - 1];
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	
	  pendingHooks.add(transitionHook);
	
	  return transitionHook;
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3, enterHooks));
	    return hooks;
	  }, []);
	}
	
	function getChangeHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4, changeHooks));
	    return hooks;
	  }, []);
	}
	
	function runTransitionHooks(length, iter, callback) {
	  if (!length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = void 0;
	  function replace(location) {
	    redirectInfo = location;
	  }
	
	  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
	    iter(index, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runEnterHooks(routes, nextState, callback) {
	  enterHooks.clear();
	  var hooks = getEnterHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    var wrappedNext = function wrappedNext() {
	      if (enterHooks.has(hooks[index])) {
	        next();
	        enterHooks.remove(hooks[index]);
	      }
	    };
	    hooks[index](nextState, replace, wrappedNext);
	  }, callback);
	}
	
	/**
	 * Runs all onChange hooks in the given array of routes in order
	 * with onChange(prevState, nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runChangeHooks(routes, state, nextState, callback) {
	  changeHooks.clear();
	  var hooks = getChangeHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    var wrappedNext = function wrappedNext() {
	      if (changeHooks.has(hooks[index])) {
	        next();
	        changeHooks.remove(hooks[index]);
	      }
	    };
	    hooks[index](state, nextState, replace, wrappedNext);
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	function runLeaveHooks(routes, prevState) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
	  }
	}

/***/ },
/* 196 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(Array.prototype.slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	exports.default = isActive;
	
	var _PatternUtils = __webpack_require__(188);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!Object.prototype.hasOwnProperty.call(a, p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	/**
	 * Returns true if the current pathname matches the supplied one, net of
	 * leading and trailing slash normalization. This is sufficient for an
	 * indexOnly route match.
	 */
	function pathIsActive(pathname, currentPathname) {
	  // Normalize leading slash for consistency. Leading slash on pathname has
	  // already been normalized in isActive. See caveat there.
	  if (currentPathname.charAt(0) !== '/') {
	    currentPathname = '/' + currentPathname;
	  }
	
	  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
	  // `/foo` as active, but in this case, we would already have failed the
	  // match.
	  if (pathname.charAt(pathname.length - 1) !== '/') {
	    pathname += '/';
	  }
	  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
	    currentPathname += '/';
	  }
	
	  return currentPathname === pathname;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes and params.
	 */
	function routeIsActive(pathname, routes, params) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  // for...of would work here but it's probably slower post-transpilation.
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    var route = routes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null && pattern) {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	
	      if (remainingPathname === '') {
	        // We have an exact match on the route. Just check that all the params
	        // match.
	        // FIXME: This doesn't work on repeated params.
	        return paramNames.every(function (paramName, index) {
	          return String(paramValues[index]) === String(params[paramName]);
	        });
	      }
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname,
	      query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  // TODO: This is a bit ugly. It keeps around support for treating pathnames
	  // without preceding slashes as absolute paths, but possibly also works
	  // around the same quirks with basenames as in matchRoutes.
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  if (!pathIsActive(pathname, currentLocation.pathname)) {
	    // The path check is necessary and sufficient for indexOnly, but otherwise
	    // we still need to check the routes.
	    if (indexOnly || !routeIsActive(pathname, routes, params)) {
	      return false;
	    }
	  }
	
	  return queryIsActive(query, currentLocation.query);
	}
	module.exports = exports['default'];

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(196);
	
	var _PromiseUtils = __webpack_require__(199);
	
	function getComponentsForRoute(nextState, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	    return;
	  }
	
	  var getComponent = route.getComponent || route.getComponents;
	  if (getComponent) {
	    var componentReturn = getComponent.call(route, nextState, callback);
	    if ((0, _PromiseUtils.isPromise)(componentReturn)) componentReturn.then(function (component) {
	      return callback(null, component);
	    }, callback);
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState, route, callback);
	  }, callback);
	}
	
	exports.default = getComponents;
	module.exports = exports['default'];

/***/ },
/* 199 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.isPromise = isPromise;
	function isPromise(obj) {
	  return obj && typeof obj.then === 'function';
	}

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	exports.default = matchRoutes;
	
	var _AsyncUtils = __webpack_require__(196);
	
	var _PromiseUtils = __webpack_require__(199);
	
	var _PatternUtils = __webpack_require__(188);
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _RouteUtils = __webpack_require__(186);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getChildRoutes(route, location, paramNames, paramValues, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = void 0;
	
	  var partialNextState = {
	    location: location,
	    params: createParams(paramNames, paramValues)
	  };
	
	  var childRoutesReturn = route.getChildRoutes(partialNextState, function (error, childRoutes) {
	    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  if ((0, _PromiseUtils.isPromise)(childRoutesReturn)) childRoutesReturn.then(function (childRoutes) {
	    return callback(null, (0, _RouteUtils.createRoutes)(childRoutes));
	  }, callback);
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, paramNames, paramValues, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    var partialNextState = {
	      location: location,
	      params: createParams(paramNames, paramValues)
	    };
	
	    var indexRoutesReturn = route.getIndexRoute(partialNextState, function (error, indexRoute) {
	      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    });
	
	    if ((0, _PromiseUtils.isPromise)(indexRoutesReturn)) indexRoutesReturn.then(function (indexRoute) {
	      return callback(null, (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    }, callback);
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (childRoute) {
	        return !childRoute.path;
	      });
	
	      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  // Only try to match the path if the route actually has a pattern, and if
	  // we're not just searching for potential nested absolute paths.
	  if (remainingPathname !== null && pattern) {
	    try {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	    } catch (error) {
	      callback(error);
	    }
	
	    // By assumption, pattern is non-empty here, which is the prerequisite for
	    // actually terminating a match.
	    if (remainingPathname === '') {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : void 0;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	
	        return {
	          v: void 0
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback, remainingPathname) {
	  var paramNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
	  var paramValues = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
	
	  if (remainingPathname === undefined) {
	    // TODO: This is a little bit ugly, but it works around a quirk in history
	    // that strips the leading slash from pathnames when using basenames with
	    // trailing slashes.
	    if (location.pathname.charAt(0) !== '/') {
	      location = _extends({}, location, {
	        pathname: '/' + location.pathname
	      });
	    }
	    remainingPathname = location.pathname;
	  }
	
	  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
	    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	      if (error || match) {
	        done(error, match);
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(8);
	
	var func = _react.PropTypes.func,
	    object = _react.PropTypes.object,
	    arrayOf = _react.PropTypes.arrayOf,
	    oneOfType = _react.PropTypes.oneOfType,
	    element = _react.PropTypes.element,
	    shape = _react.PropTypes.shape,
	    string = _react.PropTypes.string;
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = exports.history = shape({
	  listen: func.isRequired,
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired
	});
	
	var component = exports.component = oneOfType([func, string]);
	var components = exports.components = oneOfType([component, object]);
	var route = exports.route = oneOfType([object, element]);
	var routes = exports.routes = oneOfType([route, arrayOf(route)]);

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _getRouteParams = __webpack_require__(203);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _ContextUtils = __webpack_require__(204);
	
	var _RouteUtils = __webpack_require__(186);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    array = _React$PropTypes.array,
	    func = _React$PropTypes.func,
	    object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	
	var RouterContext = _react2.default.createClass({
	  displayName: 'RouterContext',
	
	  mixins: [(0, _ContextUtils.ContextProvider)('router')],
	
	  propTypes: {
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2.default.createElement
	    };
	  },
	
	  childContextTypes: {
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      router: this.props.router
	    };
	  },
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	  render: function render() {
	    var _this = this;
	
	    var _props = this.props,
	        location = _props.location,
	        routes = _props.routes,
	        params = _props.params,
	        components = _props.components,
	        router = _props.router;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = (0, _getRouteParams2.default)(route, params);
	        var props = {
	          location: location,
	          params: params,
	          route: route,
	          router: router,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if ((0, _RouteUtils.isReactChildren)(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (Object.prototype.hasOwnProperty.call(components, key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2.default.isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;
	
	    return element;
	  }
	});
	
	exports.default = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(188);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
	    if (Object.prototype.hasOwnProperty.call(params, p)) {
	      routeParams[p] = params[p];
	    }
	  });
	
	  return routeParams;
	}
	
	exports.default = getRouteParams;
	module.exports = exports['default'];

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.ContextProvider = ContextProvider;
	exports.ContextSubscriber = ContextSubscriber;
	
	var _react = __webpack_require__(8);
	
	// Works around issues with context updates failing to propagate.
	// Caveat: the context value is expected to never change its identity.
	// https://github.com/facebook/react/issues/2517
	// https://github.com/reactjs/react-router/issues/470
	
	var contextProviderShape = _react.PropTypes.shape({
	  subscribe: _react.PropTypes.func.isRequired,
	  eventIndex: _react.PropTypes.number.isRequired
	});
	
	function makeContextName(name) {
	  return '@@contextSubscriber/' + name;
	}
	
	function ContextProvider(name) {
	  var _childContextTypes, _ref2;
	
	  var contextName = makeContextName(name);
	  var listenersKey = contextName + '/listeners';
	  var eventIndexKey = contextName + '/eventIndex';
	  var subscribeKey = contextName + '/subscribe';
	
	  return _ref2 = {
	    childContextTypes: (_childContextTypes = {}, _childContextTypes[contextName] = contextProviderShape.isRequired, _childContextTypes),
	
	    getChildContext: function getChildContext() {
	      var _ref;
	
	      return _ref = {}, _ref[contextName] = {
	        eventIndex: this[eventIndexKey],
	        subscribe: this[subscribeKey]
	      }, _ref;
	    },
	    componentWillMount: function componentWillMount() {
	      this[listenersKey] = [];
	      this[eventIndexKey] = 0;
	    },
	    componentWillReceiveProps: function componentWillReceiveProps() {
	      this[eventIndexKey]++;
	    },
	    componentDidUpdate: function componentDidUpdate() {
	      var _this = this;
	
	      this[listenersKey].forEach(function (listener) {
	        return listener(_this[eventIndexKey]);
	      });
	    }
	  }, _ref2[subscribeKey] = function (listener) {
	    var _this2 = this;
	
	    // No need to immediately call listener here.
	    this[listenersKey].push(listener);
	
	    return function () {
	      _this2[listenersKey] = _this2[listenersKey].filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }, _ref2;
	}
	
	function ContextSubscriber(name) {
	  var _contextTypes, _ref4;
	
	  var contextName = makeContextName(name);
	  var lastRenderedEventIndexKey = contextName + '/lastRenderedEventIndex';
	  var handleContextUpdateKey = contextName + '/handleContextUpdate';
	  var unsubscribeKey = contextName + '/unsubscribe';
	
	  return _ref4 = {
	    contextTypes: (_contextTypes = {}, _contextTypes[contextName] = contextProviderShape, _contextTypes),
	
	    getInitialState: function getInitialState() {
	      var _ref3;
	
	      if (!this.context[contextName]) {
	        return {};
	      }
	
	      return _ref3 = {}, _ref3[lastRenderedEventIndexKey] = this.context[contextName].eventIndex, _ref3;
	    },
	    componentDidMount: function componentDidMount() {
	      if (!this.context[contextName]) {
	        return;
	      }
	
	      this[unsubscribeKey] = this.context[contextName].subscribe(this[handleContextUpdateKey]);
	    },
	    componentWillReceiveProps: function componentWillReceiveProps() {
	      var _setState;
	
	      if (!this.context[contextName]) {
	        return;
	      }
	
	      this.setState((_setState = {}, _setState[lastRenderedEventIndexKey] = this.context[contextName].eventIndex, _setState));
	    },
	    componentWillUnmount: function componentWillUnmount() {
	      if (!this[unsubscribeKey]) {
	        return;
	      }
	
	      this[unsubscribeKey]();
	      this[unsubscribeKey] = null;
	    }
	  }, _ref4[handleContextUpdateKey] = function (eventIndex) {
	    if (eventIndex !== this.state[lastRenderedEventIndexKey]) {
	      var _setState2;
	
	      this.setState((_setState2 = {}, _setState2[lastRenderedEventIndexKey] = eventIndex, _setState2));
	    }
	  }, _ref4;
	}

/***/ },
/* 205 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.createRouterObject = createRouterObject;
	exports.assignRouterState = assignRouterState;
	function createRouterObject(history, transitionManager, state) {
	  var router = _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	
	  return assignRouterState(router, state);
	}
	
	function assignRouterState(router, _ref) {
	  var location = _ref.location,
	      params = _ref.params,
	      routes = _ref.routes;
	
	  router.location = location;
	  router.params = params;
	  router.routes = routes;
	
	  return router;
	}

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PropTypes = __webpack_require__(187);
	
	var _ContextUtils = __webpack_require__(204);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    bool = _React$PropTypes.bool,
	    object = _React$PropTypes.object,
	    string = _React$PropTypes.string,
	    func = _React$PropTypes.func,
	    oneOfType = _React$PropTypes.oneOfType;
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
	  }return true;
	}
	
	function resolveToLocation(to, router) {
	  return typeof to === 'function' ? to(router.location) : to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2.default.createClass({
	  displayName: 'Link',
	
	  mixins: [(0, _ContextUtils.ContextSubscriber)('router')],
	
	  contextTypes: {
	    router: _PropTypes.routerShape
	  },
	
	  propTypes: {
	    to: oneOfType([string, object, func]),
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func,
	    target: string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      style: {}
	    };
	  },
	  handleClick: function handleClick(event) {
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (event.defaultPrevented) return;
	
	    var router = this.context.router;
	
	    !router ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    // If target prop is set (e.g. to "_blank"), let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) return;
	
	    event.preventDefault();
	
	    router.push(resolveToLocation(this.props.to, router));
	  },
	  render: function render() {
	    var _props = this.props,
	        to = _props.to,
	        activeClassName = _props.activeClassName,
	        activeStyle = _props.activeStyle,
	        onlyActiveOnIndex = _props.onlyActiveOnIndex,
	        props = _objectWithoutProperties(_props, ['to', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    // Ignore if rendered outside the context of router to simplify unit testing.
	
	
	    var router = this.context.router;
	
	    if (router) {
	      // If user does not specify a `to` prop, return an empty anchor tag.
	      if (to == null) {
	        return _react2.default.createElement('a', props);
	      }
	
	      var toLocation = resolveToLocation(to, router);
	      props.href = router.createHref(toLocation);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(toLocation, onlyActiveOnIndex)) {
	          if (activeClassName) {
	            if (props.className) {
	              props.className += ' ' + activeClassName;
	            } else {
	              props.className = activeClassName;
	            }
	          }
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	});
	
	exports.default = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(206);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2.default.createClass({
	  displayName: 'IndexLink',
	  render: function render() {
	    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	});
	
	exports.default = IndexLink;
	module.exports = exports['default'];

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = withRouter;
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _hoistNonReactStatics = __webpack_require__(209);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _ContextUtils = __webpack_require__(204);
	
	var _PropTypes = __webpack_require__(187);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	function withRouter(WrappedComponent, options) {
	  var withRef = options && options.withRef;
	
	  var WithRouter = _react2.default.createClass({
	    displayName: 'WithRouter',
	
	    mixins: [(0, _ContextUtils.ContextSubscriber)('router')],
	
	    contextTypes: { router: _PropTypes.routerShape },
	    propTypes: { router: _PropTypes.routerShape },
	
	    getWrappedInstance: function getWrappedInstance() {
	      !withRef ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;
	
	      return this.wrappedInstance;
	    },
	    render: function render() {
	      var _this = this;
	
	      var router = this.props.router || this.context.router;
	      var params = router.params,
	          location = router.location,
	          routes = router.routes;
	
	      var props = _extends({}, this.props, { router: router, params: params, location: location, routes: routes });
	
	      if (withRef) {
	        props.ref = function (c) {
	          _this.wrappedInstance = c;
	        };
	      }
	
	      return _react2.default.createElement(WrappedComponent, props);
	    }
	  });
	
	  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
	  WithRouter.WrappedComponent = WrappedComponent;
	
	  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 209 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') {
	        // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {}
	            }
	        }
	    }
	
	    return targetComponent;
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(211);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _InternalPropTypes = __webpack_require__(201);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    string = _React$PropTypes.string,
	    object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	/* eslint-disable react/require-render-return */
	
	var IndexRedirect = _react2.default.createClass({
	  displayName: 'IndexRedirect',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(186);
	
	var _PatternUtils = __webpack_require__(188);
	
	var _InternalPropTypes = __webpack_require__(201);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    string = _React$PropTypes.string,
	    object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	/* eslint-disable react/require-render-return */
	
	var Redirect = _react2.default.createClass({
	  displayName: 'Redirect',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = (0, _RouteUtils.createRouteFromReactElement)(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location,
	            params = nextState.params;
	
	        var pathname = void 0;
	        if (route.to.charAt(0) === '/') {
	          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(186);
	
	var _InternalPropTypes = __webpack_require__(201);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var func = _react2.default.PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	/* eslint-disable react/require-render-return */
	
	var IndexRoute = _react2.default.createClass({
	  displayName: 'IndexRoute',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    path: _InternalPropTypes.falsy,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(186);
	
	var _InternalPropTypes = __webpack_require__(201);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes,
	    string = _React$PropTypes.string,
	    func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	/* eslint-disable react/require-render-return */
	
	var Route = _react2.default.createClass({
	  displayName: 'Route',
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _Actions = __webpack_require__(215);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(216);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(191);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(186);
	
	var _RouterUtils = __webpack_require__(205);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history,
	      routes = _ref.routes,
	      location = _ref.location,
	      options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;
	
	  history = history ? history : (0, _createMemoryHistory2.default)(options);
	  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    location = history.getCurrentLocation();
	  }
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    var renderProps = void 0;
	
	    if (nextState) {
	      var router = (0, _RouterUtils.createRouterObject)(history, transitionManager, nextState);
	      renderProps = _extends({}, nextState, {
	        router: router,
	        matchContext: { transitionManager: transitionManager, router: router }
	      });
	    }
	
	    callback(error, redirectLocation && history.createLocation(redirectLocation, _Actions.REPLACE), renderProps);
	  });
	}
	
	exports.default = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 215 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	var PUSH = exports.PUSH = 'PUSH';
	
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = exports.REPLACE = 'REPLACE';
	
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = exports.POP = 'POP';

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = createMemoryHistory;
	
	var _useQueries = __webpack_require__(217);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(223);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	var _createMemoryHistory = __webpack_require__(224);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useQueries` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = (0, _createMemoryHistory2.default)(options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	  return history;
	}
	module.exports = exports['default'];

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _queryString = __webpack_require__(218);
	
	var _runTransitionHook = __webpack_require__(220);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _LocationUtils = __webpack_require__(221);
	
	var _PathUtils = __webpack_require__(222);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var defaultStringifyQuery = function defaultStringifyQuery(query) {
	  return (0, _queryString.stringify)(query).replace(/%20/g, '+');
	};
	
	var defaultParseQueryString = _queryString.parse;
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	var useQueries = function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    var decodeQuery = function decodeQuery(location) {
	      if (!location) return location;
	
	      if (location.query == null) location.query = parseQueryString(location.search.substring(1));
	
	      return location;
	    };
	
	    var encodeQuery = function encodeQuery(location, query) {
	      if (query == null) return location;
	
	      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
	      var queryString = stringifyQuery(query);
	      var search = queryString ? '?' + queryString : '';
	
	      return _extends({}, object, {
	        search: search
	      });
	    };
	
	    // Override all read methods with query-aware versions.
	    var getCurrentLocation = function getCurrentLocation() {
	      return decodeQuery(history.getCurrentLocation());
	    };
	
	    var listenBefore = function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        return (0, _runTransitionHook2.default)(hook, decodeQuery(location), callback);
	      });
	    };
	
	    var listen = function listen(listener) {
	      return history.listen(function (location) {
	        return listener(decodeQuery(location));
	      });
	    };
	
	    // Override all write methods with query-aware versions.
	    var push = function push(location) {
	      return history.push(encodeQuery(location, location.query));
	    };
	
	    var replace = function replace(location) {
	      return history.replace(encodeQuery(location, location.query));
	    };
	
	    var createPath = function createPath(location) {
	      return history.createPath(encodeQuery(location, location.query));
	    };
	
	    var createHref = function createHref(location) {
	      return history.createHref(encodeQuery(location, location.query));
	    };
	
	    var createLocation = function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var newLocation = history.createLocation.apply(history, [encodeQuery(location, location.query)].concat(args));
	
	      if (location.query) newLocation.query = (0, _LocationUtils.createQuery)(location.query);
	
	      return decodeQuery(newLocation);
	    };
	
	    return _extends({}, history, {
	      getCurrentLocation: getCurrentLocation,
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation
	    });
	  };
	};
	
	exports.default = useQueries;

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var strictUriEncode = __webpack_require__(219);
	var objectAssign = __webpack_require__(11);
	
	function encode(value, opts) {
		if (opts.encode) {
			return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
		}
	
		return value;
	}
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		// Create an object with no prototype
		// https://github.com/sindresorhus/query-string/issues/47
		var ret = Object.create(null);
	
		if (typeof str !== 'string') {
			return ret;
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return ret;
		}
	
		str.split('&').forEach(function (param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (ret[key] === undefined) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
		});
	
		return ret;
	};
	
	exports.stringify = function (obj, opts) {
		var defaults = {
			encode: true,
			strict: true
		};
	
		opts = objectAssign(defaults, opts);
	
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return encode(key, opts);
			}
	
			if (Array.isArray(val)) {
				var result = [];
	
				val.slice().forEach(function (val2) {
					if (val2 === undefined) {
						return;
					}
	
					if (val2 === null) {
						result.push(encode(key, opts));
					} else {
						result.push(encode(key, opts) + '=' + encode(val2, opts));
					}
				});
	
				return result.join('&');
			}
	
			return encode(key, opts) + '=' + encode(val, opts);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};

/***/ },
/* 219 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var runTransitionHook = function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(result === undefined, 'You should not "return" in a transition hook with a callback argument; ' + 'call the callback instead') : void 0;
	  }
	};
	
	exports.default = runTransitionHook;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	exports.locationsAreEqual = exports.statesAreEqual = exports.createLocation = exports.createQuery = undefined;
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _PathUtils = __webpack_require__(222);
	
	var _Actions = __webpack_require__(215);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var createQuery = exports.createQuery = function createQuery(props) {
	  return _extends(Object.create(null), props);
	};
	
	var createLocation = exports.createLocation = function createLocation() {
	  var input = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var object = typeof input === 'string' ? (0, _PathUtils.parsePath)(input) : input;
	
	  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(!object.path, 'Location descriptor objects should have a `pathname`, not a `path`.') : void 0;
	
	  var pathname = object.pathname || '/';
	  var search = object.search || '';
	  var hash = object.hash || '';
	  var state = object.state;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	};
	
	var isDate = function isDate(object) {
	  return Object.prototype.toString.call(object) === '[object Date]';
	};
	
	var statesAreEqual = exports.statesAreEqual = function statesAreEqual(a, b) {
	  if (a === b) return true;
	
	  var typeofA = typeof a === 'undefined' ? 'undefined' : _typeof(a);
	  var typeofB = typeof b === 'undefined' ? 'undefined' : _typeof(b);
	
	  if (typeofA !== typeofB) return false;
	
	  !(typeofA !== 'function') ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You must not store functions in location state') : (0, _invariant2.default)(false) : void 0;
	
	  // Not the same object, but same type.
	  if (typeofA === 'object') {
	    !!(isDate(a) && isDate(b)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You must not store Date objects in location state') : (0, _invariant2.default)(false) : void 0;
	
	    if (!Array.isArray(a)) {
	      var keysofA = Object.keys(a);
	      var keysofB = Object.keys(b);
	      return keysofA.length === keysofB.length && keysofA.every(function (key) {
	        return statesAreEqual(a[key], b[key]);
	      });
	    }
	
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return statesAreEqual(item, b[index]);
	    });
	  }
	
	  // All other serializable types (string, number, boolean)
	  // should be strict equal.
	  return false;
	};
	
	var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
	  return a.key === b.key &&
	  // a.action === b.action && // Different action !== location change.
	  a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && statesAreEqual(a.state, b.state);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.createPath = exports.parsePath = exports.getQueryStringValueFromPath = exports.stripQueryStringValueFromPath = exports.addQueryStringValueToPath = undefined;
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var addQueryStringValueToPath = exports.addQueryStringValueToPath = function addQueryStringValueToPath(path, key, value) {
	  var _parsePath = parsePath(path);
	
	  var pathname = _parsePath.pathname;
	  var search = _parsePath.search;
	  var hash = _parsePath.hash;
	
	  return createPath({
	    pathname: pathname,
	    search: search + (search.indexOf('?') === -1 ? '?' : '&') + key + '=' + value,
	    hash: hash
	  });
	};
	
	var stripQueryStringValueFromPath = exports.stripQueryStringValueFromPath = function stripQueryStringValueFromPath(path, key) {
	  var _parsePath2 = parsePath(path);
	
	  var pathname = _parsePath2.pathname;
	  var search = _parsePath2.search;
	  var hash = _parsePath2.hash;
	
	  return createPath({
	    pathname: pathname,
	    search: search.replace(new RegExp('([?&])' + key + '=[a-zA-Z0-9]+(&?)'), function (match, prefix, suffix) {
	      return prefix === '?' ? prefix : suffix;
	    }),
	    hash: hash
	  });
	};
	
	var getQueryStringValueFromPath = exports.getQueryStringValueFromPath = function getQueryStringValueFromPath(path, key) {
	  var _parsePath3 = parsePath(path);
	
	  var search = _parsePath3.search;
	
	  var match = search.match(new RegExp('[?&]' + key + '=([a-zA-Z0-9]+)'));
	  return match && match[1];
	};
	
	var extractPath = function extractPath(string) {
	  var match = string.match(/^(https?:)?\/\/[^\/]*/);
	  return match == null ? string : string.substring(match[0].length);
	};
	
	var parsePath = exports.parsePath = function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(path === pathname, 'A path must be pathname + search + hash only, not a full URL like "%s"', path) : void 0;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	};
	
	var createPath = exports.createPath = function createPath(location) {
	  if (location == null || typeof location === 'string') return location;
	
	  var basename = location.basename;
	  var pathname = location.pathname;
	  var search = location.search;
	  var hash = location.hash;
	
	  var path = (basename || '') + pathname;
	
	  if (search && search !== '?') path += search;
	
	  if (hash) path += hash;
	
	  return path;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _runTransitionHook = __webpack_require__(220);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(222);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var useBasename = function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	    var basename = options.basename;
	
	    var addBasename = function addBasename(location) {
	      if (!location) return location;
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    };
	
	    var prependBasename = function prependBasename(location) {
	      if (!basename) return location;
	
	      var object = typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : location;
	      var pname = object.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, object, {
	        pathname: pathname
	      });
	    };
	
	    // Override all read methods with basename-aware versions.
	    var getCurrentLocation = function getCurrentLocation() {
	      return addBasename(history.getCurrentLocation());
	    };
	
	    var listenBefore = function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        return (0, _runTransitionHook2.default)(hook, addBasename(location), callback);
	      });
	    };
	
	    var listen = function listen(listener) {
	      return history.listen(function (location) {
	        return listener(addBasename(location));
	      });
	    };
	
	    // Override all write methods with basename-aware versions.
	    var push = function push(location) {
	      return history.push(prependBasename(location));
	    };
	
	    var replace = function replace(location) {
	      return history.replace(prependBasename(location));
	    };
	
	    var createPath = function createPath(location) {
	      return history.createPath(prependBasename(location));
	    };
	
	    var createHref = function createHref(location) {
	      return history.createHref(prependBasename(location));
	    };
	
	    var createLocation = function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    };
	
	    return _extends({}, history, {
	      getCurrentLocation: getCurrentLocation,
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation
	    });
	  };
	};
	
	exports.default = useBasename;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _LocationUtils = __webpack_require__(221);
	
	var _PathUtils = __webpack_require__(222);
	
	var _createHistory = __webpack_require__(225);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	var _Actions = __webpack_require__(215);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var createStateStorage = function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	};
	
	var createMemoryHistory = function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var getCurrentLocation = function getCurrentLocation() {
	    var entry = entries[current];
	    var path = (0, _PathUtils.createPath)(entry);
	
	    var key = void 0,
	        state = void 0;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    }
	
	    var init = (0, _PathUtils.parsePath)(path);
	
	    return (0, _LocationUtils.createLocation)(_extends({}, init, { state: state }), undefined, key);
	  };
	
	  var canGo = function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  };
	
	  var go = function go(n) {
	    if (!n) return;
	
	    if (!canGo(n)) {
	      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'Cannot go(%s) there is not enough history', n) : void 0;
	
	      return;
	    }
	
	    current += n;
	    var currentLocation = getCurrentLocation();
	
	    // Change action to POP
	    history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	  };
	
	  var pushLocation = function pushLocation(location) {
	    current += 1;
	
	    if (current < entries.length) entries.splice(current);
	
	    entries.push(location);
	
	    saveState(location.key, location.state);
	  };
	
	  var replaceLocation = function replaceLocation(location) {
	    entries[current] = location;
	    saveState(location.key, location.state);
	  };
	
	  var history = (0, _createHistory2.default)(_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    pushLocation: pushLocation,
	    replaceLocation: replaceLocation,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    return (0, _LocationUtils.createLocation)(entry);
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : (0, _invariant2.default)(false) : void 0;
	  }
	
	  var storage = createStateStorage(entries);
	
	  var saveState = function saveState(key, state) {
	    return storage[key] = state;
	  };
	
	  var readState = function readState(key) {
	    return storage[key];
	  };
	
	  return _extends({}, history, {
	    canGo: canGo
	  });
	};
	
	exports.default = createMemoryHistory;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(226);
	
	var _PathUtils = __webpack_require__(222);
	
	var _runTransitionHook = __webpack_require__(220);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _Actions = __webpack_require__(215);
	
	var _LocationUtils = __webpack_require__(221);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var createHistory = function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var getUserConfirmation = options.getUserConfirmation;
	  var pushLocation = options.pushLocation;
	  var replaceLocation = options.replaceLocation;
	  var go = options.go;
	  var keyLength = options.keyLength;
	
	  var currentLocation = void 0;
	  var pendingLocation = void 0;
	  var beforeListeners = [];
	  var listeners = [];
	  var allKeys = [];
	
	  var getCurrentIndex = function getCurrentIndex() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) return allKeys.indexOf(pendingLocation.key);
	
	    if (currentLocation) return allKeys.indexOf(currentLocation.key);
	
	    return -1;
	  };
	
	  var updateLocation = function updateLocation(nextLocation) {
	    var currentIndex = getCurrentIndex();
	
	    currentLocation = nextLocation;
	
	    if (currentLocation.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, currentIndex + 1), [currentLocation.key]);
	    } else if (currentLocation.action === _Actions.REPLACE) {
	      allKeys[currentIndex] = currentLocation.key;
	    }
	
	    listeners.forEach(function (listener) {
	      return listener(currentLocation);
	    });
	  };
	
	  var listenBefore = function listenBefore(listener) {
	    beforeListeners.push(listener);
	
	    return function () {
	      return beforeListeners = beforeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  };
	
	  var listen = function listen(listener) {
	    listeners.push(listener);
	
	    return function () {
	      return listeners = listeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  };
	
	  var confirmTransitionTo = function confirmTransitionTo(location, callback) {
	    (0, _AsyncUtils.loopAsync)(beforeListeners.length, function (index, next, done) {
	      (0, _runTransitionHook2.default)(beforeListeners[index], location, function (result) {
	        return result != null ? done(result) : next();
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          return callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  };
	
	  var transitionTo = function transitionTo(nextLocation) {
	    if (currentLocation && (0, _LocationUtils.locationsAreEqual)(currentLocation, nextLocation) || pendingLocation && (0, _LocationUtils.locationsAreEqual)(pendingLocation, nextLocation)) return; // Nothing to do
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted during confirmation
	
	      pendingLocation = null;
	
	      if (ok) {
	        // Treat PUSH to same path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = (0, _PathUtils.createPath)(currentLocation);
	          var nextPath = (0, _PathUtils.createPath)(nextLocation);
	
	          if (nextPath === prevPath && (0, _LocationUtils.statesAreEqual)(currentLocation.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (nextLocation.action === _Actions.POP) {
	          updateLocation(nextLocation);
	        } else if (nextLocation.action === _Actions.PUSH) {
	          if (pushLocation(nextLocation) !== false) updateLocation(nextLocation);
	        } else if (nextLocation.action === _Actions.REPLACE) {
	          if (replaceLocation(nextLocation) !== false) updateLocation(nextLocation);
	        }
	      } else if (currentLocation && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(currentLocation.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL
	      }
	    });
	  };
	
	  var push = function push(input) {
	    return transitionTo(createLocation(input, _Actions.PUSH));
	  };
	
	  var replace = function replace(input) {
	    return transitionTo(createLocation(input, _Actions.REPLACE));
	  };
	
	  var goBack = function goBack() {
	    return go(-1);
	  };
	
	  var goForward = function goForward() {
	    return go(1);
	  };
	
	  var createKey = function createKey() {
	    return Math.random().toString(36).substr(2, keyLength || 6);
	  };
	
	  var createHref = function createHref(location) {
	    return (0, _PathUtils.createPath)(location);
	  };
	
	  var createLocation = function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	    return (0, _LocationUtils.createLocation)(location, action, key);
	  };
	
	  return {
	    getCurrentLocation: getCurrentLocation,
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: _PathUtils.createPath,
	    createHref: createHref,
	    createLocation: createLocation
	  };
	};
	
	exports.default = createHistory;

/***/ },
/* 226 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var loopAsync = exports.loopAsync = function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var isSync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  var done = function done() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    isDone = true;
	
	    if (isSync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = args;
	      return;
	    }
	
	    callback.apply(undefined, args);
	  };
	
	  var next = function next() {
	    if (isDone) return;
	
	    hasNext = true;
	
	    if (isSync) return; // Iterate instead of recursing if possible.
	
	    isSync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work(currentTurn++, next, done);
	    }
	
	    isSync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(undefined, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  };
	
	  next();
	};

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = useRouterHistory;
	
	var _useQueries = __webpack_require__(217);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(223);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	    return history;
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(202);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(192);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = function () {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    middlewares.forEach(function (middleware, index) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
	    });
	  }
	
	  var withContext = middlewares.map(function (middleware) {
	    return middleware.renderRouterContext;
	  }).filter(Boolean);
	  var withComponent = middlewares.map(function (middleware) {
	    return middleware.renderRouteComponent;
	  }).filter(Boolean);
	
	  var makeCreateElement = function makeCreateElement() {
	    var baseCreateElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _react.createElement;
	    return function (Component, props) {
	      return withComponent.reduceRight(function (previous, renderRouteComponent) {
	        return renderRouteComponent(previous, props);
	      }, baseCreateElement(Component, props));
	    };
	  };
	
	  return function (renderProps) {
	    return withContext.reduceRight(function (previous, renderRouterContext) {
	      return renderRouterContext(previous, renderProps);
	    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
	      createElement: makeCreateElement(renderProps.createElement)
	    })));
	  };
	};
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createBrowserHistory = __webpack_require__(230);
	
	var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(236);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(231);
	
	var _BrowserProtocol = __webpack_require__(232);
	
	var BrowserProtocol = _interopRequireWildcard(_BrowserProtocol);
	
	var _RefreshProtocol = __webpack_require__(235);
	
	var RefreshProtocol = _interopRequireWildcard(_RefreshProtocol);
	
	var _DOMUtils = __webpack_require__(233);
	
	var _createHistory = __webpack_require__(225);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj.default = obj;return newObj;
	  }
	}
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve clean URLs. You can force this
	 * behavior using { forceRefresh: true } in options.
	 */
	var createBrowserHistory = function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Browser history needs a DOM') : (0, _invariant2.default)(false) : void 0;
	
	  var useRefresh = options.forceRefresh || !(0, _DOMUtils.supportsHistory)();
	  var Protocol = useRefresh ? RefreshProtocol : BrowserProtocol;
	
	  var getUserConfirmation = Protocol.getUserConfirmation;
	  var getCurrentLocation = Protocol.getCurrentLocation;
	  var pushLocation = Protocol.pushLocation;
	  var replaceLocation = Protocol.replaceLocation;
	  var go = Protocol.go;
	
	  var history = (0, _createHistory2.default)(_extends({
	    getUserConfirmation: getUserConfirmation }, options, {
	    getCurrentLocation: getCurrentLocation,
	    pushLocation: pushLocation,
	    replaceLocation: replaceLocation,
	    go: go
	  }));
	
	  var listenerCount = 0,
	      stopListener = void 0;
	
	  var startListener = function startListener(listener, before) {
	    if (++listenerCount === 1) stopListener = BrowserProtocol.startListener(history.transitionTo);
	
	    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopListener();
	    };
	  };
	
	  var listenBefore = function listenBefore(listener) {
	    return startListener(listener, true);
	  };
	
	  var listen = function listen(listener) {
	    return startListener(listener, false);
	  };
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen
	  });
	};
	
	exports.default = createBrowserHistory;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 231 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.go = exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getUserConfirmation = exports.getCurrentLocation = undefined;
	
	var _LocationUtils = __webpack_require__(221);
	
	var _DOMUtils = __webpack_require__(233);
	
	var _DOMStateStorage = __webpack_require__(234);
	
	var _PathUtils = __webpack_require__(222);
	
	var _ExecutionEnvironment = __webpack_require__(231);
	
	var PopStateEvent = 'popstate';
	var HashChangeEvent = 'hashchange';
	
	var needsHashchangeListener = _ExecutionEnvironment.canUseDOM && !(0, _DOMUtils.supportsPopstateOnHashchange)();
	
	var _createLocation = function _createLocation(historyState) {
	  var key = historyState && historyState.key;
	
	  return (0, _LocationUtils.createLocation)({
	    pathname: window.location.pathname,
	    search: window.location.search,
	    hash: window.location.hash,
	    state: key ? (0, _DOMStateStorage.readState)(key) : undefined
	  }, undefined, key);
	};
	
	var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
	  var historyState = void 0;
	  try {
	    historyState = window.history.state || {};
	  } catch (error) {
	    // IE 11 sometimes throws when accessing window.history.state
	    // See https://github.com/ReactTraining/history/pull/289
	    historyState = {};
	  }
	
	  return _createLocation(historyState);
	};
	
	var getUserConfirmation = exports.getUserConfirmation = function getUserConfirmation(message, callback) {
	  return callback(window.confirm(message));
	}; // eslint-disable-line no-alert
	
	var startListener = exports.startListener = function startListener(listener) {
	  var handlePopState = function handlePopState(event) {
	    if (event.state !== undefined) // Ignore extraneous popstate events in WebKit
	      listener(_createLocation(event.state));
	  };
	
	  (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);
	
	  var handleUnpoppedHashChange = function handleUnpoppedHashChange() {
	    return listener(getCurrentLocation());
	  };
	
	  if (needsHashchangeListener) {
	    (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleUnpoppedHashChange);
	  }
	
	  return function () {
	    (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);
	
	    if (needsHashchangeListener) {
	      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleUnpoppedHashChange);
	    }
	  };
	};
	
	var updateLocation = function updateLocation(location, updateState) {
	  var state = location.state;
	  var key = location.key;
	
	  if (state !== undefined) (0, _DOMStateStorage.saveState)(key, state);
	
	  updateState({ key: key }, (0, _PathUtils.createPath)(location));
	};
	
	var pushLocation = exports.pushLocation = function pushLocation(location) {
	  return updateLocation(location, function (state, path) {
	    return window.history.pushState(state, null, path);
	  });
	};
	
	var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
	  return updateLocation(location, function (state, path) {
	    return window.history.replaceState(state, null, path);
	  });
	};
	
	var go = exports.go = function go(n) {
	  if (n) window.history.go(n);
	};

/***/ },
/* 233 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
	  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
	};
	
	var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
	  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
	};
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
	 */
	var supportsHistory = exports.supportsHistory = function supportsHistory() {
	  var ua = window.navigator.userAgent;
	
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
	
	  return window.history && 'pushState' in window.history;
	};
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
	  return window.navigator.userAgent.indexOf('Firefox') === -1;
	};
	
	/**
	 * Returns true if browser fires popstate on hash change.
	 * IE10 and IE11 do not.
	 */
	var supportsPopstateOnHashchange = exports.supportsPopstateOnHashchange = function supportsPopstateOnHashchange() {
	  return window.navigator.userAgent.indexOf('Trident') === -1;
	};

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.readState = exports.saveState = undefined;
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var QuotaExceededErrors = {
	  QuotaExceededError: true,
	  QUOTA_EXCEEDED_ERR: true
	};
	
	var SecurityErrors = {
	  SecurityError: true
	};
	
	var KeyPrefix = '@@History/';
	
	var createKey = function createKey(key) {
	  return KeyPrefix + key;
	};
	
	var saveState = exports.saveState = function saveState(key, state) {
	  if (!window.sessionStorage) {
	    // Session storage is not available or hidden.
	    // sessionStorage is undefined in Internet Explorer when served via file protocol.
	    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available') : void 0;
	
	    return;
	  }
	
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (SecurityErrors[error.name]) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available due to security settings') : void 0;
	
	      return;
	    }
	
	    if (QuotaExceededErrors[error.name] && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : void 0;
	
	      return;
	    }
	
	    throw error;
	  }
	};
	
	var readState = exports.readState = function readState(key) {
	  var json = void 0;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (SecurityErrors[error.name]) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, '[history] Unable to read state; sessionStorage is not available due to security settings') : void 0;
	
	      return undefined;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return undefined;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.replaceLocation = exports.pushLocation = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;
	
	var _BrowserProtocol = __webpack_require__(232);
	
	Object.defineProperty(exports, 'getUserConfirmation', {
	  enumerable: true,
	  get: function get() {
	    return _BrowserProtocol.getUserConfirmation;
	  }
	});
	Object.defineProperty(exports, 'go', {
	  enumerable: true,
	  get: function get() {
	    return _BrowserProtocol.go;
	  }
	});
	
	var _LocationUtils = __webpack_require__(221);
	
	var _PathUtils = __webpack_require__(222);
	
	var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation() {
	  return (0, _LocationUtils.createLocation)(window.location);
	};
	
	var pushLocation = exports.pushLocation = function pushLocation(location) {
	  window.location.href = (0, _PathUtils.createPath)(location);
	  return false; // Don't update location
	};
	
	var replaceLocation = exports.replaceLocation = function replaceLocation(location) {
	  window.location.replace((0, _PathUtils.createPath)(location));
	  return false; // Don't update location
	};

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	exports.default = function (createHistory) {
	  var history = void 0;
	  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
	  return history;
	};
	
	var _useRouterHistory = __webpack_require__(227);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	module.exports = exports['default'];

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createHashHistory = __webpack_require__(238);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _createRouterHistory = __webpack_require__(236);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(189);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(231);
	
	var _DOMUtils = __webpack_require__(233);
	
	var _HashProtocol = __webpack_require__(239);
	
	var HashProtocol = _interopRequireWildcard(_HashProtocol);
	
	var _createHistory = __webpack_require__(225);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj.default = obj;return newObj;
	  }
	}
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var DefaultQueryKey = '_k';
	
	var addLeadingSlash = function addLeadingSlash(path) {
	  return path.charAt(0) === '/' ? path : '/' + path;
	};
	
	var HashPathCoders = {
	  hashbang: {
	    encodePath: function encodePath(path) {
	      return path.charAt(0) === '!' ? path : '!' + path;
	    },
	    decodePath: function decodePath(path) {
	      return path.charAt(0) === '!' ? path.substring(1) : path;
	    }
	  },
	  noslash: {
	    encodePath: function encodePath(path) {
	      return path.charAt(0) === '/' ? path.substring(1) : path;
	    },
	    decodePath: addLeadingSlash
	  },
	  slash: {
	    encodePath: addLeadingSlash,
	    decodePath: addLeadingSlash
	  }
	};
	
	var createHashHistory = function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Hash history needs a DOM') : (0, _invariant2.default)(false) : void 0;
	
	  var queryKey = options.queryKey;
	  var hashType = options.hashType;
	
	  process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(queryKey !== false, 'Using { queryKey: false } no longer works. Instead, just don\'t ' + 'use location state if you don\'t want a key in your URL query string') : void 0;
	
	  if (typeof queryKey !== 'string') queryKey = DefaultQueryKey;
	
	  if (hashType == null) hashType = 'slash';
	
	  if (!(hashType in HashPathCoders)) {
	    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'Invalid hash type: %s', hashType) : void 0;
	
	    hashType = 'slash';
	  }
	
	  var pathCoder = HashPathCoders[hashType];
	
	  var getUserConfirmation = HashProtocol.getUserConfirmation;
	
	  var getCurrentLocation = function getCurrentLocation() {
	    return HashProtocol.getCurrentLocation(pathCoder, queryKey);
	  };
	
	  var pushLocation = function pushLocation(location) {
	    return HashProtocol.pushLocation(location, pathCoder, queryKey);
	  };
	
	  var replaceLocation = function replaceLocation(location) {
	    return HashProtocol.replaceLocation(location, pathCoder, queryKey);
	  };
	
	  var history = (0, _createHistory2.default)(_extends({
	    getUserConfirmation: getUserConfirmation }, options, {
	    getCurrentLocation: getCurrentLocation,
	    pushLocation: pushLocation,
	    replaceLocation: replaceLocation,
	    go: HashProtocol.go
	  }));
	
	  var listenerCount = 0,
	      stopListener = void 0;
	
	  var startListener = function startListener(listener, before) {
	    if (++listenerCount === 1) stopListener = HashProtocol.startListener(history.transitionTo, pathCoder, queryKey);
	
	    var unlisten = before ? history.listenBefore(listener) : history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopListener();
	    };
	  };
	
	  var listenBefore = function listenBefore(listener) {
	    return startListener(listener, true);
	  };
	
	  var listen = function listen(listener) {
	    return startListener(listener, false);
	  };
	
	  var goIsSupportedWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();
	
	  var go = function go(n) {
	    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : void 0;
	
	    history.go(n);
	  };
	
	  var createHref = function createHref(path) {
	    return '#' + pathCoder.encodePath(history.createHref(path));
	  };
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    go: go,
	    createHref: createHref
	  });
	};
	
	exports.default = createHashHistory;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.replaceLocation = exports.pushLocation = exports.startListener = exports.getCurrentLocation = exports.go = exports.getUserConfirmation = undefined;
	
	var _BrowserProtocol = __webpack_require__(232);
	
	Object.defineProperty(exports, 'getUserConfirmation', {
	  enumerable: true,
	  get: function get() {
	    return _BrowserProtocol.getUserConfirmation;
	  }
	});
	Object.defineProperty(exports, 'go', {
	  enumerable: true,
	  get: function get() {
	    return _BrowserProtocol.go;
	  }
	});
	
	var _warning = __webpack_require__(193);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _LocationUtils = __webpack_require__(221);
	
	var _DOMUtils = __webpack_require__(233);
	
	var _DOMStateStorage = __webpack_require__(234);
	
	var _PathUtils = __webpack_require__(222);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var HashChangeEvent = 'hashchange';
	
	var getHashPath = function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  var href = window.location.href;
	  var hashIndex = href.indexOf('#');
	  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
	};
	
	var pushHashPath = function pushHashPath(path) {
	  return window.location.hash = path;
	};
	
	var replaceHashPath = function replaceHashPath(path) {
	  var hashIndex = window.location.href.indexOf('#');
	
	  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
	};
	
	var getCurrentLocation = exports.getCurrentLocation = function getCurrentLocation(pathCoder, queryKey) {
	  var path = pathCoder.decodePath(getHashPath());
	  var key = (0, _PathUtils.getQueryStringValueFromPath)(path, queryKey);
	
	  var state = void 0;
	  if (key) {
	    path = (0, _PathUtils.stripQueryStringValueFromPath)(path, queryKey);
	    state = (0, _DOMStateStorage.readState)(key);
	  }
	
	  var init = (0, _PathUtils.parsePath)(path);
	  init.state = state;
	
	  return (0, _LocationUtils.createLocation)(init, undefined, key);
	};
	
	var prevLocation = void 0;
	
	var startListener = exports.startListener = function startListener(listener, pathCoder, queryKey) {
	  var handleHashChange = function handleHashChange() {
	    var path = getHashPath();
	    var encodedPath = pathCoder.encodePath(path);
	
	    if (path !== encodedPath) {
	      // Always be sure we have a properly-encoded hash.
	      replaceHashPath(encodedPath);
	    } else {
	      var currentLocation = getCurrentLocation(pathCoder, queryKey);
	
	      if (prevLocation && currentLocation.key && prevLocation.key === currentLocation.key) return; // Ignore extraneous hashchange events
	
	      prevLocation = currentLocation;
	
	      listener(currentLocation);
	    }
	  };
	
	  // Ensure the hash is encoded properly.
	  var path = getHashPath();
	  var encodedPath = pathCoder.encodePath(path);
	
	  if (path !== encodedPath) replaceHashPath(encodedPath);
	
	  (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
	
	  return function () {
	    return (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
	  };
	};
	
	var updateLocation = function updateLocation(location, pathCoder, queryKey, updateHash) {
	  var state = location.state;
	  var key = location.key;
	
	  var path = pathCoder.encodePath((0, _PathUtils.createPath)(location));
	
	  if (state !== undefined) {
	    path = (0, _PathUtils.addQueryStringValueToPath)(path, queryKey, key);
	    (0, _DOMStateStorage.saveState)(key, state);
	  }
	
	  prevLocation = location;
	
	  updateHash(path);
	};
	
	var pushLocation = exports.pushLocation = function pushLocation(location, pathCoder, queryKey) {
	  return updateLocation(location, pathCoder, queryKey, function (path) {
	    if (getHashPath() !== path) {
	      pushHashPath(path);
	    } else {
	      process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'You cannot PUSH the same path using hash history') : void 0;
	    }
	  });
	};
	
	var replaceLocation = exports.replaceLocation = function replaceLocation(location, pathCoder, queryKey) {
	  return updateLocation(location, pathCoder, queryKey, function (path) {
	    if (getHashPath() !== path) replaceHashPath(path);
	  });
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Nav = __webpack_require__(241);
	
	var _Nav2 = _interopRequireDefault(_Nav);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Main = function Main(props) {
	    return _react2.default.createElement(
	        'div',
	        null,
	        _react2.default.createElement(_Nav2.default, null),
	        _react2.default.createElement(
	            'div',
	            { className: 'row' },
	            _react2.default.createElement(
	                'div',
	                { className: 'column small-centered medium-6 large-4' },
	                props.children
	            )
	        )
	    );
	};
	
	exports.default = Main;

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouter = __webpack_require__(185);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Nav = function Nav() {
	    return _react2.default.createElement(
	        'div',
	        { className: 'top-bar' },
	        _react2.default.createElement(
	            'div',
	            { className: 'top-bar-left' },
	            _react2.default.createElement(
	                'ul',
	                { className: 'menu' },
	                _react2.default.createElement(
	                    'li',
	                    { className: 'menu-text' },
	                    'React Timer App'
	                ),
	                _react2.default.createElement(
	                    'li',
	                    null,
	                    _react2.default.createElement(
	                        _reactRouter.IndexLink,
	                        { to: '/', activeClassName: 'active-link' },
	                        'Timer'
	                    )
	                ),
	                _react2.default.createElement(
	                    'li',
	                    null,
	                    _react2.default.createElement(
	                        _reactRouter.Link,
	                        { to: '/countdown', activeClassName: 'active-link' },
	                        'Countdown'
	                    )
	                )
	            )
	        ),
	        _react2.default.createElement(
	            'div',
	            { className: 'top-bar-right' },
	            _react2.default.createElement(
	                'ul',
	                { className: 'menu' },
	                _react2.default.createElement(
	                    'li',
	                    { className: 'menu-text' },
	                    _react2.default.createElement(
	                        'a',
	                        null,
	                        'Hello'
	                    )
	                )
	            )
	        )
	    );
	};
	
	exports.default = Nav;

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Timer = function (_Component) {
	    _inherits(Timer, _Component);
	
	    function Timer() {
	        _classCallCheck(this, Timer);
	
	        return _possibleConstructorReturn(this, (Timer.__proto__ || Object.getPrototypeOf(Timer)).apply(this, arguments));
	    }
	
	    _createClass(Timer, [{
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(
	                    'p',
	                    null,
	                    'Timer'
	                )
	            );
	        }
	    }]);
	
	    return Timer;
	}(_react.Component);
	
	exports.default = Timer;

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Clock = __webpack_require__(244);
	
	var _Clock2 = _interopRequireDefault(_Clock);
	
	var _CountdownForm = __webpack_require__(245);
	
	var _CountdownForm2 = _interopRequireDefault(_CountdownForm);
	
	var _Controls = __webpack_require__(252);
	
	var _Controls2 = _interopRequireDefault(_Controls);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Countdown = function (_Component) {
	    _inherits(Countdown, _Component);
	
	    function Countdown() {
	        _classCallCheck(this, Countdown);
	
	        var _this = _possibleConstructorReturn(this, (Countdown.__proto__ || Object.getPrototypeOf(Countdown)).call(this));
	
	        _this.state = {
	            count: 0,
	            countdownStatus: 'stopped'
	        };
	        return _this;
	    }
	
	    _createClass(Countdown, [{
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps, prevState) {
	            if (this.state.countdownStatus !== prevState.countdownStatus) {
	                switch (this.state.countdownStatus) {
	                    case 'started':
	                        this.startTimer();
	                        break;
	                    case 'stopped':
	                        this.setState({ count: 0 });
	                    case 'paused':
	                        clearInterval(this.timer);
	                        this.timer = undefined;
	                        break;
	
	                    default:
	                        return;
	                }
	            }
	        }
	    }, {
	        key: 'startTimer',
	        value: function startTimer() {
	            var _this2 = this;
	
	            this.timer = setInterval(function () {
	                var newCount = _this2.state.count - 1;
	                _this2.setState({ count: newCount >= 0 ? newCount : 0 });
	            }, 1000);
	        }
	    }, {
	        key: 'handleSetCountdown',
	        value: function handleSetCountdown(seconds) {
	            this.setState({
	                count: seconds,
	                countdownStatus: 'started'
	            });
	        }
	    }, {
	        key: 'handleStatusChange',
	        value: function handleStatusChange(newStatus) {
	            this.setState({ countdownStatus: newStatus });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this3 = this;
	
	            var _state = this.state,
	                count = _state.count,
	                countdownStatus = _state.countdownStatus;
	
	            var renderControlArea = function renderControlArea() {
	                if (countdownStatus !== 'stopped') {
	                    return _react2.default.createElement(_Controls2.default, { countdownStatus: countdownStatus, onStatusChange: _this3.handleStatusChange.bind(_this3) });
	                }
	                return _react2.default.createElement(_CountdownForm2.default, { onSetCountdown: _this3.handleSetCountdown.bind(_this3) });
	            };
	            return _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(_Clock2.default, { totalSeconds: count }),
	                renderControlArea()
	            );
	        }
	    }]);
	
	    return Countdown;
	}(_react.Component);
	
	exports.default = Countdown;

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Clock = function (_React$Component) {
	    _inherits(Clock, _React$Component);
	
	    function Clock() {
	        _classCallCheck(this, Clock);
	
	        return _possibleConstructorReturn(this, (Clock.__proto__ || Object.getPrototypeOf(Clock)).apply(this, arguments));
	    }
	
	    _createClass(Clock, [{
	        key: 'formatSeconds',
	        value: function formatSeconds(totalSeconds) {
	            var seconds = totalSeconds % 60;
	            var minutes = Math.floor(totalSeconds / 60);
	
	            seconds = seconds < 10 ? '0' + seconds : seconds;
	            minutes = minutes < 10 ? '0' + minutes : minutes;
	
	            return minutes + ':' + seconds;
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var totalSeconds = this.props.totalSeconds;
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'clock' },
	                _react2.default.createElement(
	                    'span',
	                    { className: 'clock-text' },
	                    this.formatSeconds(totalSeconds)
	                )
	            );
	        }
	    }]);
	
	    return Clock;
	}(_react2.default.Component);
	
	Clock.propTypes = {
	    totalSeconds: _react2.default.PropTypes.number
	};
	
	Clock.defaultProps = {
	    totalSeconds: 0
	};
	
	exports.default = Clock;

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var CountdownForm = function (_Component) {
	    _inherits(CountdownForm, _Component);
	
	    function CountdownForm() {
	        _classCallCheck(this, CountdownForm);
	
	        return _possibleConstructorReturn(this, (CountdownForm.__proto__ || Object.getPrototypeOf(CountdownForm)).apply(this, arguments));
	    }
	
	    _createClass(CountdownForm, [{
	        key: 'onSubmit',
	        value: function onSubmit(e) {
	            e.preventDefault();
	            var strSeconds = this.refs.seconds.value;
	
	            if (strSeconds.match(/^[0-9]*$/)) {
	                this.refs.seconds.value = '';
	                this.props.onSetCountdown(parseInt(strSeconds, 10));
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement(
	                    'form',
	                    { ref: 'form', onSubmit: this.onSubmit.bind(this), className: 'countdown-form' },
	                    _react2.default.createElement('input', { type: 'text', ref: 'seconds', placeholder: 'Enter time in seconds' }),
	                    _react2.default.createElement(
	                        'button',
	                        { className: 'button expanded' },
	                        'Start'
	                    )
	                )
	            );
	        }
	    }]);
	
	    return CountdownForm;
	}(_react.Component);
	
	exports.default = CountdownForm;

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(247);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(249)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./foundation.min.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./foundation.min.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(248)();
	// imports
	
	
	// module
	exports.push([module.id, "@charset \"UTF-8\";\n/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:not-allowed}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}.foundation-mq{font-family:\"small=0em&medium=40em&large=64em&xlarge=75em&xxlarge=90em\"}html{font-size:100%;box-sizing:border-box}*,:after,:before{box-sizing:inherit}body{padding:0;margin:0;font-family:Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;font-weight:400;line-height:1.5;color:#0a0a0a;background:#fefefe;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}img{max-width:100%;height:auto;-ms-interpolation-mode:bicubic;display:inline-block;vertical-align:middle}textarea{height:auto;min-height:50px;border-radius:0}select{width:100%;border-radius:0}#map_canvas embed,#map_canvas img,#map_canvas object,.map_canvas embed,.map_canvas img,.map_canvas object,.mqa-display embed,.mqa-display img,.mqa-display object{max-width:none!important}button{-webkit-appearance:none;-moz-appearance:none;background:transparent;padding:0;border:0;border-radius:0;line-height:1}[data-whatinput=mouse] button{outline:0}.is-visible{display:block!important}.is-hidden{display:none!important}.row{max-width:75rem;margin-left:auto;margin-right:auto}.row:after,.row:before{content:' ';display:table}.row:after{clear:both}.row.collapse>.column,.row.collapse>.columns{padding-left:0;padding-right:0}.row .row{margin-left:-.625rem;margin-right:-.625rem}@media screen and (min-width:40em){.row .row{margin-left:-.9375rem;margin-right:-.9375rem}}.row .row.collapse{margin-left:0;margin-right:0}.row.expanded{max-width:none}.row.expanded .row{margin-left:auto;margin-right:auto}.column,.columns{width:100%;float:left;padding-left:.625rem;padding-right:.625rem}@media screen and (min-width:40em){.column,.columns{padding-left:.9375rem;padding-right:.9375rem}}.column:last-child:not(:first-child),.columns:last-child:not(:first-child){float:right}.column.end:last-child:last-child,.end.columns:last-child:last-child{float:left}.column.row.row,.row.row.columns{float:none}.row .column.row.row,.row .row.row.columns{padding-left:0;padding-right:0;margin-left:0;margin-right:0}.small-1{width:8.33333%}.small-push-1{position:relative;left:8.33333%}.small-pull-1{position:relative;left:-8.33333%}.small-offset-0{margin-left:0}.small-2{width:16.66667%}.small-push-2{position:relative;left:16.66667%}.small-pull-2{position:relative;left:-16.66667%}.small-offset-1{margin-left:8.33333%}.small-3{width:25%}.small-push-3{position:relative;left:25%}.small-pull-3{position:relative;left:-25%}.small-offset-2{margin-left:16.66667%}.small-4{width:33.33333%}.small-push-4{position:relative;left:33.33333%}.small-pull-4{position:relative;left:-33.33333%}.small-offset-3{margin-left:25%}.small-5{width:41.66667%}.small-push-5{position:relative;left:41.66667%}.small-pull-5{position:relative;left:-41.66667%}.small-offset-4{margin-left:33.33333%}.small-6{width:50%}.small-push-6{position:relative;left:50%}.small-pull-6{position:relative;left:-50%}.small-offset-5{margin-left:41.66667%}.small-7{width:58.33333%}.small-push-7{position:relative;left:58.33333%}.small-pull-7{position:relative;left:-58.33333%}.small-offset-6{margin-left:50%}.small-8{width:66.66667%}.small-push-8{position:relative;left:66.66667%}.small-pull-8{position:relative;left:-66.66667%}.small-offset-7{margin-left:58.33333%}.small-9{width:75%}.small-push-9{position:relative;left:75%}.small-pull-9{position:relative;left:-75%}.small-offset-8{margin-left:66.66667%}.small-10{width:83.33333%}.small-push-10{position:relative;left:83.33333%}.small-pull-10{position:relative;left:-83.33333%}.small-offset-9{margin-left:75%}.small-11{width:91.66667%}.small-push-11{position:relative;left:91.66667%}.small-pull-11{position:relative;left:-91.66667%}.small-offset-10{margin-left:83.33333%}.small-12{width:100%}.small-offset-11{margin-left:91.66667%}.small-up-1>.column,.small-up-1>.columns{width:100%;float:left}.small-up-1>.column:nth-of-type(1n),.small-up-1>.columns:nth-of-type(1n){clear:none}.small-up-1>.column:nth-of-type(1n+1),.small-up-1>.columns:nth-of-type(1n+1){clear:both}.small-up-1>.column:last-child,.small-up-1>.columns:last-child{float:left}.small-up-2>.column,.small-up-2>.columns{width:50%;float:left}.small-up-2>.column:nth-of-type(1n),.small-up-2>.columns:nth-of-type(1n){clear:none}.small-up-2>.column:nth-of-type(2n+1),.small-up-2>.columns:nth-of-type(2n+1){clear:both}.small-up-2>.column:last-child,.small-up-2>.columns:last-child{float:left}.small-up-3>.column,.small-up-3>.columns{width:33.33333%;float:left}.small-up-3>.column:nth-of-type(1n),.small-up-3>.columns:nth-of-type(1n){clear:none}.small-up-3>.column:nth-of-type(3n+1),.small-up-3>.columns:nth-of-type(3n+1){clear:both}.small-up-3>.column:last-child,.small-up-3>.columns:last-child{float:left}.small-up-4>.column,.small-up-4>.columns{width:25%;float:left}.small-up-4>.column:nth-of-type(1n),.small-up-4>.columns:nth-of-type(1n){clear:none}.small-up-4>.column:nth-of-type(4n+1),.small-up-4>.columns:nth-of-type(4n+1){clear:both}.small-up-4>.column:last-child,.small-up-4>.columns:last-child{float:left}.small-up-5>.column,.small-up-5>.columns{width:20%;float:left}.small-up-5>.column:nth-of-type(1n),.small-up-5>.columns:nth-of-type(1n){clear:none}.small-up-5>.column:nth-of-type(5n+1),.small-up-5>.columns:nth-of-type(5n+1){clear:both}.small-up-5>.column:last-child,.small-up-5>.columns:last-child{float:left}.small-up-6>.column,.small-up-6>.columns{width:16.66667%;float:left}.small-up-6>.column:nth-of-type(1n),.small-up-6>.columns:nth-of-type(1n){clear:none}.small-up-6>.column:nth-of-type(6n+1),.small-up-6>.columns:nth-of-type(6n+1){clear:both}.small-up-6>.column:last-child,.small-up-6>.columns:last-child{float:left}.small-up-7>.column,.small-up-7>.columns{width:14.28571%;float:left}.small-up-7>.column:nth-of-type(1n),.small-up-7>.columns:nth-of-type(1n){clear:none}.small-up-7>.column:nth-of-type(7n+1),.small-up-7>.columns:nth-of-type(7n+1){clear:both}.small-up-7>.column:last-child,.small-up-7>.columns:last-child{float:left}.small-up-8>.column,.small-up-8>.columns{width:12.5%;float:left}.small-up-8>.column:nth-of-type(1n),.small-up-8>.columns:nth-of-type(1n){clear:none}.small-up-8>.column:nth-of-type(8n+1),.small-up-8>.columns:nth-of-type(8n+1){clear:both}.small-up-8>.column:last-child,.small-up-8>.columns:last-child{float:left}.small-collapse>.column,.small-collapse>.columns{padding-left:0;padding-right:0}.expanded.row .small-collapse.row,.small-collapse .row{margin-left:0;margin-right:0}.small-uncollapse>.column,.small-uncollapse>.columns{padding-left:.625rem;padding-right:.625rem}.small-centered{margin-left:auto;margin-right:auto}.small-centered,.small-centered:last-child:not(:first-child){float:none;clear:both}.small-pull-0,.small-push-0,.small-uncentered{position:static;margin-left:0;margin-right:0;float:left}@media screen and (min-width:40em){.medium-1{width:8.33333%}.medium-push-1{position:relative;left:8.33333%}.medium-pull-1{position:relative;left:-8.33333%}.medium-offset-0{margin-left:0}.medium-2{width:16.66667%}.medium-push-2{position:relative;left:16.66667%}.medium-pull-2{position:relative;left:-16.66667%}.medium-offset-1{margin-left:8.33333%}.medium-3{width:25%}.medium-push-3{position:relative;left:25%}.medium-pull-3{position:relative;left:-25%}.medium-offset-2{margin-left:16.66667%}.medium-4{width:33.33333%}.medium-push-4{position:relative;left:33.33333%}.medium-pull-4{position:relative;left:-33.33333%}.medium-offset-3{margin-left:25%}.medium-5{width:41.66667%}.medium-push-5{position:relative;left:41.66667%}.medium-pull-5{position:relative;left:-41.66667%}.medium-offset-4{margin-left:33.33333%}.medium-6{width:50%}.medium-push-6{position:relative;left:50%}.medium-pull-6{position:relative;left:-50%}.medium-offset-5{margin-left:41.66667%}.medium-7{width:58.33333%}.medium-push-7{position:relative;left:58.33333%}.medium-pull-7{position:relative;left:-58.33333%}.medium-offset-6{margin-left:50%}.medium-8{width:66.66667%}.medium-push-8{position:relative;left:66.66667%}.medium-pull-8{position:relative;left:-66.66667%}.medium-offset-7{margin-left:58.33333%}.medium-9{width:75%}.medium-push-9{position:relative;left:75%}.medium-pull-9{position:relative;left:-75%}.medium-offset-8{margin-left:66.66667%}.medium-10{width:83.33333%}.medium-push-10{position:relative;left:83.33333%}.medium-pull-10{position:relative;left:-83.33333%}.medium-offset-9{margin-left:75%}.medium-11{width:91.66667%}.medium-push-11{position:relative;left:91.66667%}.medium-pull-11{position:relative;left:-91.66667%}.medium-offset-10{margin-left:83.33333%}.medium-12{width:100%}.medium-offset-11{margin-left:91.66667%}.medium-up-1>.column,.medium-up-1>.columns{width:100%;float:left}.medium-up-1>.column:nth-of-type(1n),.medium-up-1>.columns:nth-of-type(1n){clear:none}.medium-up-1>.column:nth-of-type(1n+1),.medium-up-1>.columns:nth-of-type(1n+1){clear:both}.medium-up-1>.column:last-child,.medium-up-1>.columns:last-child{float:left}.medium-up-2>.column,.medium-up-2>.columns{width:50%;float:left}.medium-up-2>.column:nth-of-type(1n),.medium-up-2>.columns:nth-of-type(1n){clear:none}.medium-up-2>.column:nth-of-type(2n+1),.medium-up-2>.columns:nth-of-type(2n+1){clear:both}.medium-up-2>.column:last-child,.medium-up-2>.columns:last-child{float:left}.medium-up-3>.column,.medium-up-3>.columns{width:33.33333%;float:left}.medium-up-3>.column:nth-of-type(1n),.medium-up-3>.columns:nth-of-type(1n){clear:none}.medium-up-3>.column:nth-of-type(3n+1),.medium-up-3>.columns:nth-of-type(3n+1){clear:both}.medium-up-3>.column:last-child,.medium-up-3>.columns:last-child{float:left}.medium-up-4>.column,.medium-up-4>.columns{width:25%;float:left}.medium-up-4>.column:nth-of-type(1n),.medium-up-4>.columns:nth-of-type(1n){clear:none}.medium-up-4>.column:nth-of-type(4n+1),.medium-up-4>.columns:nth-of-type(4n+1){clear:both}.medium-up-4>.column:last-child,.medium-up-4>.columns:last-child{float:left}.medium-up-5>.column,.medium-up-5>.columns{width:20%;float:left}.medium-up-5>.column:nth-of-type(1n),.medium-up-5>.columns:nth-of-type(1n){clear:none}.medium-up-5>.column:nth-of-type(5n+1),.medium-up-5>.columns:nth-of-type(5n+1){clear:both}.medium-up-5>.column:last-child,.medium-up-5>.columns:last-child{float:left}.medium-up-6>.column,.medium-up-6>.columns{width:16.66667%;float:left}.medium-up-6>.column:nth-of-type(1n),.medium-up-6>.columns:nth-of-type(1n){clear:none}.medium-up-6>.column:nth-of-type(6n+1),.medium-up-6>.columns:nth-of-type(6n+1){clear:both}.medium-up-6>.column:last-child,.medium-up-6>.columns:last-child{float:left}.medium-up-7>.column,.medium-up-7>.columns{width:14.28571%;float:left}.medium-up-7>.column:nth-of-type(1n),.medium-up-7>.columns:nth-of-type(1n){clear:none}.medium-up-7>.column:nth-of-type(7n+1),.medium-up-7>.columns:nth-of-type(7n+1){clear:both}.medium-up-7>.column:last-child,.medium-up-7>.columns:last-child{float:left}.medium-up-8>.column,.medium-up-8>.columns{width:12.5%;float:left}.medium-up-8>.column:nth-of-type(1n),.medium-up-8>.columns:nth-of-type(1n){clear:none}.medium-up-8>.column:nth-of-type(8n+1),.medium-up-8>.columns:nth-of-type(8n+1){clear:both}.medium-up-8>.column:last-child,.medium-up-8>.columns:last-child{float:left}.medium-collapse>.column,.medium-collapse>.columns{padding-left:0;padding-right:0}.expanded.row .medium-collapse.row,.medium-collapse .row{margin-left:0;margin-right:0}.medium-uncollapse>.column,.medium-uncollapse>.columns{padding-left:.9375rem;padding-right:.9375rem}.medium-centered{margin-left:auto;margin-right:auto}.medium-centered,.medium-centered:last-child:not(:first-child){float:none;clear:both}.medium-pull-0,.medium-push-0,.medium-uncentered{position:static;margin-left:0;margin-right:0;float:left}}@media screen and (min-width:64em){.large-1{width:8.33333%}.large-push-1{position:relative;left:8.33333%}.large-pull-1{position:relative;left:-8.33333%}.large-offset-0{margin-left:0}.large-2{width:16.66667%}.large-push-2{position:relative;left:16.66667%}.large-pull-2{position:relative;left:-16.66667%}.large-offset-1{margin-left:8.33333%}.large-3{width:25%}.large-push-3{position:relative;left:25%}.large-pull-3{position:relative;left:-25%}.large-offset-2{margin-left:16.66667%}.large-4{width:33.33333%}.large-push-4{position:relative;left:33.33333%}.large-pull-4{position:relative;left:-33.33333%}.large-offset-3{margin-left:25%}.large-5{width:41.66667%}.large-push-5{position:relative;left:41.66667%}.large-pull-5{position:relative;left:-41.66667%}.large-offset-4{margin-left:33.33333%}.large-6{width:50%}.large-push-6{position:relative;left:50%}.large-pull-6{position:relative;left:-50%}.large-offset-5{margin-left:41.66667%}.large-7{width:58.33333%}.large-push-7{position:relative;left:58.33333%}.large-pull-7{position:relative;left:-58.33333%}.large-offset-6{margin-left:50%}.large-8{width:66.66667%}.large-push-8{position:relative;left:66.66667%}.large-pull-8{position:relative;left:-66.66667%}.large-offset-7{margin-left:58.33333%}.large-9{width:75%}.large-push-9{position:relative;left:75%}.large-pull-9{position:relative;left:-75%}.large-offset-8{margin-left:66.66667%}.large-10{width:83.33333%}.large-push-10{position:relative;left:83.33333%}.large-pull-10{position:relative;left:-83.33333%}.large-offset-9{margin-left:75%}.large-11{width:91.66667%}.large-push-11{position:relative;left:91.66667%}.large-pull-11{position:relative;left:-91.66667%}.large-offset-10{margin-left:83.33333%}.large-12{width:100%}.large-offset-11{margin-left:91.66667%}.large-up-1>.column,.large-up-1>.columns{width:100%;float:left}.large-up-1>.column:nth-of-type(1n),.large-up-1>.columns:nth-of-type(1n){clear:none}.large-up-1>.column:nth-of-type(1n+1),.large-up-1>.columns:nth-of-type(1n+1){clear:both}.large-up-1>.column:last-child,.large-up-1>.columns:last-child{float:left}.large-up-2>.column,.large-up-2>.columns{width:50%;float:left}.large-up-2>.column:nth-of-type(1n),.large-up-2>.columns:nth-of-type(1n){clear:none}.large-up-2>.column:nth-of-type(2n+1),.large-up-2>.columns:nth-of-type(2n+1){clear:both}.large-up-2>.column:last-child,.large-up-2>.columns:last-child{float:left}.large-up-3>.column,.large-up-3>.columns{width:33.33333%;float:left}.large-up-3>.column:nth-of-type(1n),.large-up-3>.columns:nth-of-type(1n){clear:none}.large-up-3>.column:nth-of-type(3n+1),.large-up-3>.columns:nth-of-type(3n+1){clear:both}.large-up-3>.column:last-child,.large-up-3>.columns:last-child{float:left}.large-up-4>.column,.large-up-4>.columns{width:25%;float:left}.large-up-4>.column:nth-of-type(1n),.large-up-4>.columns:nth-of-type(1n){clear:none}.large-up-4>.column:nth-of-type(4n+1),.large-up-4>.columns:nth-of-type(4n+1){clear:both}.large-up-4>.column:last-child,.large-up-4>.columns:last-child{float:left}.large-up-5>.column,.large-up-5>.columns{width:20%;float:left}.large-up-5>.column:nth-of-type(1n),.large-up-5>.columns:nth-of-type(1n){clear:none}.large-up-5>.column:nth-of-type(5n+1),.large-up-5>.columns:nth-of-type(5n+1){clear:both}.large-up-5>.column:last-child,.large-up-5>.columns:last-child{float:left}.large-up-6>.column,.large-up-6>.columns{width:16.66667%;float:left}.large-up-6>.column:nth-of-type(1n),.large-up-6>.columns:nth-of-type(1n){clear:none}.large-up-6>.column:nth-of-type(6n+1),.large-up-6>.columns:nth-of-type(6n+1){clear:both}.large-up-6>.column:last-child,.large-up-6>.columns:last-child{float:left}.large-up-7>.column,.large-up-7>.columns{width:14.28571%;float:left}.large-up-7>.column:nth-of-type(1n),.large-up-7>.columns:nth-of-type(1n){clear:none}.large-up-7>.column:nth-of-type(7n+1),.large-up-7>.columns:nth-of-type(7n+1){clear:both}.large-up-7>.column:last-child,.large-up-7>.columns:last-child{float:left}.large-up-8>.column,.large-up-8>.columns{width:12.5%;float:left}.large-up-8>.column:nth-of-type(1n),.large-up-8>.columns:nth-of-type(1n){clear:none}.large-up-8>.column:nth-of-type(8n+1),.large-up-8>.columns:nth-of-type(8n+1){clear:both}.large-up-8>.column:last-child,.large-up-8>.columns:last-child{float:left}.large-collapse>.column,.large-collapse>.columns{padding-left:0;padding-right:0}.expanded.row .large-collapse.row,.large-collapse .row{margin-left:0;margin-right:0}.large-uncollapse>.column,.large-uncollapse>.columns{padding-left:.9375rem;padding-right:.9375rem}.large-centered{margin-left:auto;margin-right:auto}.large-centered,.large-centered:last-child:not(:first-child){float:none;clear:both}.large-pull-0,.large-push-0,.large-uncentered{position:static;margin-left:0;margin-right:0;float:left}}blockquote,dd,div,dl,dt,form,h1,h2,h3,h4,h5,h6,li,ol,p,pre,td,th,ul{margin:0;padding:0}p{font-size:inherit;line-height:1.6;margin-bottom:1rem;text-rendering:optimizeLegibility}em,i{font-style:italic}b,em,i,strong{line-height:inherit}b,strong{font-weight:700}small{font-size:80%;line-height:inherit}h1,h2,h3,h4,h5,h6{font-family:Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;font-weight:400;font-style:normal;color:inherit;text-rendering:optimizeLegibility;margin-top:0;margin-bottom:.5rem;line-height:1.4}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{color:#cacaca;line-height:0}h1{font-size:1.5rem}h2{font-size:1.25rem}h3{font-size:1.1875rem}h4{font-size:1.125rem}h5{font-size:1.0625rem}h6{font-size:1rem}@media screen and (min-width:40em){h1{font-size:3rem}h2{font-size:2.5rem}h3{font-size:1.9375rem}h4{font-size:1.5625rem}h5{font-size:1.25rem}h6{font-size:1rem}}a{color:#2199e8;text-decoration:none;line-height:inherit;cursor:pointer}a:focus,a:hover{color:#1585cf}a img{border:0}hr{max-width:75rem;height:0;border-right:0;border-top:0;border-bottom:1px solid #cacaca;border-left:0;margin:1.25rem auto;clear:both}dl,ol,ul{line-height:1.6;margin-bottom:1rem;list-style-position:outside}li{font-size:inherit}ul{list-style-type:disc}ol,ul{margin-left:1.25rem}ol ol,ol ul,ul ol,ul ul{margin-left:1.25rem;margin-bottom:0}dl{margin-bottom:1rem}dl dt{margin-bottom:.3rem;font-weight:700}blockquote{margin:0 0 1rem;padding:.5625rem 1.25rem 0 1.1875rem;border-left:1px solid #cacaca}blockquote,blockquote p{line-height:1.6;color:#8a8a8a}cite{display:block;font-size:.8125rem;color:#8a8a8a}cite:before{content:'\\2014    '}abbr{color:#0a0a0a;cursor:help;border-bottom:1px dotted #0a0a0a}code{font-weight:400;border:1px solid #cacaca;padding:.125rem .3125rem .0625rem}code,kbd{font-family:Consolas,Liberation Mono,Courier,monospace;color:#0a0a0a;background-color:#e6e6e6}kbd{padding:.125rem .25rem 0;margin:0}.subheader{margin-top:.2rem;margin-bottom:.5rem;font-weight:400;line-height:1.4;color:#8a8a8a}.lead{font-size:125%;line-height:1.6}.stat{font-size:2.5rem;line-height:1}p+.stat{margin-top:-1rem}.no-bullet{margin-left:0;list-style:none}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}@media screen and (min-width:40em){.medium-text-left{text-align:left}.medium-text-right{text-align:right}.medium-text-center{text-align:center}.medium-text-justify{text-align:justify}}@media screen and (min-width:64em){.large-text-left{text-align:left}.large-text-right{text-align:right}.large-text-center{text-align:center}.large-text-justify{text-align:justify}}.show-for-print{display:none!important}@media print{*{background:transparent!important;color:#000!important;box-shadow:none!important;text-shadow:none!important}.show-for-print{display:block!important}.hide-for-print{display:none!important}table.show-for-print{display:table!important}thead.show-for-print{display:table-header-group!important}tbody.show-for-print{display:table-row-group!important}tr.show-for-print{display:table-row!important}td.show-for-print,th.show-for-print{display:table-cell!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}.ir a:after,a[href^='#']:after,a[href^='javascript:']:after{content:''}abbr[title]:after{content:\" (\" attr(title) \")\"}blockquote,pre{border:1px solid #8a8a8a;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}@page{margin:.5cm}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}}[type=color],[type=date],[type=datetime-local],[type=datetime],[type=email],[type=month],[type=number],[type=password],[type=search],[type=tel],[type=text],[type=time],[type=url],[type=week],textarea{display:block;box-sizing:border-box;width:100%;height:2.4375rem;padding:.5rem;border:1px solid #cacaca;margin:0 0 1rem;font-family:inherit;font-size:1rem;color:#0a0a0a;background-color:#fefefe;box-shadow:inset 0 1px 2px hsla(0,0%,4%,.1);border-radius:0;-webkit-transition:-webkit-box-shadow .5s,border-color .25s ease-in-out;transition:box-shadow .5s,border-color .25s ease-in-out;-webkit-appearance:none;-moz-appearance:none}[type=color]:focus,[type=date]:focus,[type=datetime-local]:focus,[type=datetime]:focus,[type=email]:focus,[type=month]:focus,[type=number]:focus,[type=password]:focus,[type=search]:focus,[type=tel]:focus,[type=text]:focus,[type=time]:focus,[type=url]:focus,[type=week]:focus,textarea:focus{border:1px solid #8a8a8a;background-color:#fefefe;outline:none;box-shadow:0 0 5px #cacaca;-webkit-transition:-webkit-box-shadow .5s,border-color .25s ease-in-out;transition:box-shadow .5s,border-color .25s ease-in-out}textarea{max-width:100%}textarea[rows]{height:auto}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#cacaca}input::-moz-placeholder,textarea::-moz-placeholder{color:#cacaca}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#cacaca}input::placeholder,textarea::placeholder{color:#cacaca}input:disabled,input[readonly],textarea:disabled,textarea[readonly]{background-color:#e6e6e6;cursor:not-allowed}[type=button],[type=submit]{border-radius:0;-webkit-appearance:none;-moz-appearance:none}input[type=search]{box-sizing:border-box}[type=checkbox],[type=file],[type=radio]{margin:0 0 1rem}[type=checkbox]+label,[type=radio]+label{display:inline-block;margin-left:.5rem;margin-right:1rem;margin-bottom:0;vertical-align:baseline}[type=checkbox]+label[for],[type=radio]+label[for]{cursor:pointer}label>[type=checkbox],label>[type=radio]{margin-right:.5rem}[type=file]{width:100%}label{display:block;margin:0;font-size:.875rem;font-weight:400;line-height:1.8;color:#0a0a0a}label.middle{margin:0 0 1rem;padding:.5625rem 0}.help-text{margin-top:-.5rem;font-size:.8125rem;font-style:italic;color:#0a0a0a}.input-group{display:table;width:100%;margin-bottom:1rem}.input-group>:first-child,.input-group>:last-child>*{border-radius:0 0 0 0}.input-group-button,.input-group-field,.input-group-label{margin:0;white-space:nowrap;display:table-cell;vertical-align:middle}.input-group-label{text-align:center;padding:0 1rem;background:#e6e6e6;color:#0a0a0a;border:1px solid #cacaca;white-space:nowrap;width:1%;height:100%}.input-group-label:first-child{border-right:0}.input-group-label:last-child{border-left:0}.input-group-field{border-radius:0;height:2.5rem}.input-group-button{padding-top:0;padding-bottom:0;text-align:center;height:100%;width:1%}.input-group-button a,.input-group-button button,.input-group-button input{margin:0}.input-group .input-group-button{display:table-cell}fieldset{border:0;padding:0;margin:0}legend{margin-bottom:.5rem;max-width:100%}.fieldset{border:1px solid #cacaca;padding:1.25rem;margin:1.125rem 0}.fieldset legend{background:#fefefe;padding:0 .1875rem;margin:0;margin-left:-.1875rem}select{height:2.4375rem;padding:.5rem;border:1px solid #cacaca;margin:0 0 1rem;font-size:1rem;font-family:inherit;line-height:normal;color:#0a0a0a;background-color:#fefefe;border-radius:0;-webkit-appearance:none;-moz-appearance:none;background-image:url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='32' height='24' viewBox='0 0 32 24'><polygon points='0,0 32,0 16,24' style='fill: rgb%28138, 138, 138%29'></polygon></svg>\");background-size:9px 6px;background-position:right -1rem center;background-origin:content-box;background-repeat:no-repeat;padding-right:1.5rem}@media screen and (min-width:0\\0){select{background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIpJREFUeNrEkckNgDAMBBfRkEt0ObRBBdsGXUDgmQfK4XhH2m8czQAAy27R3tsw4Qfe2x8uOO6oYLb6GlOor3GF+swURAOmUJ+RwtEJs9WvTGEYxBXqI1MQAZhCfUQKRzDMVj+TwrAIV6jvSUEkYAr1LSkcyTBb/V+KYfX7xAeusq3sLDtGH3kEGACPWIflNZfhRQAAAABJRU5ErkJggg==\")}}select:disabled{background-color:#e6e6e6;cursor:not-allowed}select::-ms-expand{display:none}select[multiple]{height:auto;background-image:none}.is-invalid-input:not(:focus){background-color:rgba(236,88,64,.1);border-color:#ec5840}.form-error,.is-invalid-label{color:#ec5840}.form-error{display:none;margin-top:-.5rem;margin-bottom:1rem;font-size:.75rem;font-weight:700}.form-error.is-visible{display:block}.button{display:inline-block;text-align:center;line-height:1;cursor:pointer;-webkit-appearance:none;-webkit-transition:background-color .25s ease-out,color .25s ease-out;transition:background-color .25s ease-out,color .25s ease-out;vertical-align:middle;border:1px solid transparent;border-radius:0;padding:.85em 1em;margin:0 0 1rem;font-size:.9rem;background-color:#2199e8;color:#fefefe}[data-whatinput=mouse] .button{outline:0}.button:focus,.button:hover{background-color:#1583cc;color:#fefefe}.button.tiny{font-size:.6rem}.button.small{font-size:.75rem}.button.large{font-size:1.25rem}.button.expanded{display:block;width:100%;margin-left:0;margin-right:0}.button.primary{background-color:#2199e8;color:#fefefe}.button.primary:focus,.button.primary:hover{background-color:#147cc0;color:#fefefe}.button.secondary{background-color:#777;color:#fefefe}.button.secondary:focus,.button.secondary:hover{background-color:#5f5f5f;color:#fefefe}.button.success{background-color:#3adb76;color:#fefefe}.button.success:focus,.button.success:hover{background-color:#22bb5b;color:#fefefe}.button.warning{background-color:#ffae00;color:#fefefe}.button.warning:focus,.button.warning:hover{background-color:#cc8b00;color:#fefefe}.button.alert{background-color:#ec5840;color:#fefefe}.button.alert:focus,.button.alert:hover{background-color:#da3116;color:#fefefe}.button.hollow{border:1px solid #2199e8;color:#2199e8}.button.hollow,.button.hollow:focus,.button.hollow:hover{background-color:transparent}.button.hollow:focus,.button.hollow:hover{border-color:#0c4d78;color:#0c4d78}.button.hollow.primary{border:1px solid #2199e8;color:#2199e8}.button.hollow.primary:focus,.button.hollow.primary:hover{border-color:#0c4d78;color:#0c4d78}.button.hollow.secondary{border:1px solid #777;color:#777}.button.hollow.secondary:focus,.button.hollow.secondary:hover{border-color:#3c3c3c;color:#3c3c3c}.button.hollow.success{border:1px solid #3adb76;color:#3adb76}.button.hollow.success:focus,.button.hollow.success:hover{border-color:#157539;color:#157539}.button.hollow.warning{border:1px solid #ffae00;color:#ffae00}.button.hollow.warning:focus,.button.hollow.warning:hover{border-color:#805700;color:#805700}.button.hollow.alert{border:1px solid #ec5840;color:#ec5840}.button.hollow.alert:focus,.button.hollow.alert:hover{border-color:#881f0e;color:#881f0e}.button.disabled,.button[disabled]{opacity:.25;cursor:not-allowed}.button.disabled:focus,.button.disabled:hover,.button[disabled]:focus,.button[disabled]:hover{background-color:#2199e8;color:#fefefe}.button.disabled.primary,.button[disabled].primary{opacity:.25;cursor:not-allowed}.button.disabled.primary:focus,.button.disabled.primary:hover,.button[disabled].primary:focus,.button[disabled].primary:hover{background-color:#2199e8;color:#fefefe}.button.disabled.secondary,.button[disabled].secondary{opacity:.25;cursor:not-allowed}.button.disabled.secondary:focus,.button.disabled.secondary:hover,.button[disabled].secondary:focus,.button[disabled].secondary:hover{background-color:#777;color:#fefefe}.button.disabled.success,.button[disabled].success{opacity:.25;cursor:not-allowed}.button.disabled.success:focus,.button.disabled.success:hover,.button[disabled].success:focus,.button[disabled].success:hover{background-color:#3adb76;color:#fefefe}.button.disabled.warning,.button[disabled].warning{opacity:.25;cursor:not-allowed}.button.disabled.warning:focus,.button.disabled.warning:hover,.button[disabled].warning:focus,.button[disabled].warning:hover{background-color:#ffae00;color:#fefefe}.button.disabled.alert,.button[disabled].alert{opacity:.25;cursor:not-allowed}.button.disabled.alert:focus,.button.disabled.alert:hover,.button[disabled].alert:focus,.button[disabled].alert:hover{background-color:#ec5840;color:#fefefe}.button.dropdown:after{content:'';display:block;width:0;height:0;border:.4em inset;border-color:#fefefe transparent transparent;border-top-style:solid;border-bottom-width:0;position:relative;top:.4em;float:right;margin-left:1em;display:inline-block}.button.arrow-only:after{margin-left:0;float:none;top:-.1em}.accordion{list-style-type:none;background:#fefefe;margin-left:0}.accordion-item:first-child>:first-child,.accordion-item:last-child>:last-child{border-radius:0 0 0 0}.accordion-title{display:block;padding:1.25rem 1rem;line-height:1;font-size:.75rem;color:#2199e8;position:relative;border:1px solid #e6e6e6;border-bottom:0}:last-child:not(.is-active)>.accordion-title{border-radius:0 0 0 0;border-bottom:1px solid #e6e6e6}.accordion-title:focus,.accordion-title:hover{background-color:#e6e6e6}.accordion-title:before{content:'+';position:absolute;right:1rem;top:50%;margin-top:-.5rem}.is-active>.accordion-title:before{content:'\\2013'}.accordion-content{padding:1rem;display:none;border:1px solid #e6e6e6;border-bottom:0;background-color:#fefefe;color:#0a0a0a}:last-child>.accordion-content:last-child{border-bottom:1px solid #e6e6e6}.is-accordion-submenu-parent>a{position:relative}.is-accordion-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:6px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;position:absolute;top:50%;margin-top:-4px;right:1rem}.is-accordion-submenu-parent[aria-expanded=true]>a:after{-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transform:scaleY(-1);transform:scaleY(-1)}.badge{display:inline-block;padding:.3em;min-width:2.1em;font-size:.6rem;text-align:center;border-radius:50%;background:#2199e8;color:#fefefe}.badge.secondary{background:#777;color:#fefefe}.badge.success{background:#3adb76;color:#fefefe}.badge.warning{background:#ffae00;color:#fefefe}.badge.alert{background:#ec5840;color:#fefefe}.breadcrumbs{list-style:none;margin:0 0 1rem}.breadcrumbs:after,.breadcrumbs:before{content:' ';display:table}.breadcrumbs:after{clear:both}.breadcrumbs li{float:left;color:#0a0a0a;font-size:.6875rem;cursor:default;text-transform:uppercase}.breadcrumbs li:not(:last-child):after{color:#cacaca;content:\"/\";margin:0 .75rem;position:relative;top:1px;opacity:1}.breadcrumbs a{color:#2199e8}.breadcrumbs a:hover{text-decoration:underline}.breadcrumbs .disabled{color:#cacaca;cursor:not-allowed}.button-group{margin-bottom:1rem;font-size:0}.button-group:after,.button-group:before{content:' ';display:table}.button-group:after{clear:both}.button-group .button{margin:0;margin-right:1px;margin-bottom:1px;font-size:.9rem}.button-group .button:last-child{margin-right:0}.button-group.tiny .button{font-size:.6rem}.button-group.small .button{font-size:.75rem}.button-group.large .button{font-size:1.25rem}.button-group.expanded{margin-right:-1px}.button-group.expanded:after,.button-group.expanded:before{display:none}.button-group.expanded .button:first-child:nth-last-child(2),.button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2)~.button{display:inline-block;width:calc(50% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(2):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(3),.button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3)~.button{display:inline-block;width:calc(33.33333% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(3):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(4),.button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4)~.button{display:inline-block;width:calc(25% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(4):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(5),.button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5)~.button{display:inline-block;width:calc(20% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(5):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(6),.button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6)~.button{display:inline-block;width:calc(16.66667% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(6):last-child{margin-right:-6px}.button-group.primary .button{background-color:#2199e8;color:#fefefe}.button-group.primary .button:focus,.button-group.primary .button:hover{background-color:#147cc0;color:#fefefe}.button-group.secondary .button{background-color:#777;color:#fefefe}.button-group.secondary .button:focus,.button-group.secondary .button:hover{background-color:#5f5f5f;color:#fefefe}.button-group.success .button{background-color:#3adb76;color:#fefefe}.button-group.success .button:focus,.button-group.success .button:hover{background-color:#22bb5b;color:#fefefe}.button-group.warning .button{background-color:#ffae00;color:#fefefe}.button-group.warning .button:focus,.button-group.warning .button:hover{background-color:#cc8b00;color:#fefefe}.button-group.alert .button{background-color:#ec5840;color:#fefefe}.button-group.alert .button:focus,.button-group.alert .button:hover{background-color:#da3116;color:#fefefe}.button-group.stacked-for-medium .button,.button-group.stacked-for-small .button,.button-group.stacked .button{width:100%}.button-group.stacked-for-medium .button:last-child,.button-group.stacked-for-small .button:last-child,.button-group.stacked .button:last-child{margin-bottom:0}@media screen and (min-width:40em){.button-group.stacked-for-small .button{width:auto;margin-bottom:0}}@media screen and (min-width:64em){.button-group.stacked-for-medium .button{width:auto;margin-bottom:0}}@media screen and (max-width:39.9375em){.button-group.stacked-for-small.expanded{display:block}.button-group.stacked-for-small.expanded .button{display:block;margin-right:0}}.callout{margin:0 0 1rem;padding:1rem;border:1px solid hsla(0,0%,4%,.25);border-radius:0;position:relative;color:#0a0a0a;background-color:#fff}.callout>:first-child{margin-top:0}.callout>:last-child{margin-bottom:0}.callout.primary{background-color:#def0fc}.callout.secondary{background-color:#ebebeb}.callout.success{background-color:#e1faea}.callout.warning{background-color:#fff3d9}.callout.alert{background-color:#fce6e2}.callout.small{padding:.5rem}.callout.large{padding:3rem}.close-button{position:absolute;color:#8a8a8a;right:1rem;top:.5rem;font-size:2em;line-height:1;cursor:pointer}[data-whatinput=mouse] .close-button{outline:0}.close-button:focus,.close-button:hover{color:#0a0a0a}.menu{margin:0;list-style-type:none}.menu>li{display:table-cell;vertical-align:middle}[data-whatinput=mouse] .menu>li{outline:0}.menu>li>a{display:block;padding:.7rem 1rem;line-height:1}.menu a,.menu button,.menu input{margin-bottom:0}.menu>li>a i,.menu>li>a i+span,.menu>li>a img,.menu>li>a img+span,.menu>li>a svg,.menu>li>a svg+span{vertical-align:middle}.menu>li>a i,.menu>li>a img,.menu>li>a svg{margin-right:.25rem;display:inline-block}.menu>li{display:table-cell}.menu.vertical>li{display:block}@media screen and (min-width:40em){.menu.medium-horizontal>li{display:table-cell}.menu.medium-vertical>li{display:block}}@media screen and (min-width:64em){.menu.large-horizontal>li{display:table-cell}.menu.large-vertical>li{display:block}}.menu.simple li{line-height:1;display:inline-block;margin-right:1rem}.menu.simple a{padding:0}.menu.align-right:after,.menu.align-right:before{content:' ';display:table}.menu.align-right:after{clear:both}.menu.align-right>li{float:right}.menu.expanded{width:100%;display:table;table-layout:fixed}.menu.expanded>li:first-child:last-child{width:100%}.menu.icon-top>li>a{text-align:center}.menu.icon-top>li>a i,.menu.icon-top>li>a img,.menu.icon-top>li>a svg{display:block;margin:0 auto .25rem}.menu.nested{margin-left:1rem}.menu .active>a{color:#fefefe;background:#2199e8}.menu-text{font-weight:700;color:inherit;line-height:1;padding-top:0;padding-bottom:0;padding:.7rem 1rem}.menu-centered{text-align:center}.menu-centered>.menu{display:inline-block}.no-js [data-responsive-menu] ul{display:none}.menu-icon{position:relative;display:inline-block;vertical-align:middle;cursor:pointer;width:20px;height:16px}.menu-icon:after{content:'';position:absolute;display:block;width:100%;height:2px;background:#fefefe;top:0;left:0;box-shadow:0 7px 0 #fefefe,0 14px 0 #fefefe}.menu-icon:hover:after{background:#cacaca;box-shadow:0 7px 0 #cacaca,0 14px 0 #cacaca}.menu-icon.dark{position:relative;display:inline-block;vertical-align:middle;cursor:pointer;width:20px;height:16px}.menu-icon.dark:after{content:'';position:absolute;display:block;width:100%;height:2px;background:#0a0a0a;top:0;left:0;box-shadow:0 7px 0 #0a0a0a,0 14px 0 #0a0a0a}.menu-icon.dark:hover:after{background:#8a8a8a;box-shadow:0 7px 0 #8a8a8a,0 14px 0 #8a8a8a}.is-drilldown{position:relative;overflow:hidden}.is-drilldown li{display:block!important}.is-drilldown-submenu{position:absolute;top:0;left:100%;z-index:-1;width:100%;background:#fefefe;-webkit-transition:-webkit-transform .15s linear;transition:transform .15s linear}.is-drilldown-submenu.is-active{z-index:1;display:block;-webkit-transform:translateX(-100%);transform:translateX(-100%)}.is-drilldown-submenu.is-closing{-webkit-transform:translateX(100%);transform:translateX(100%)}.is-drilldown-submenu-parent>a{position:relative}.is-drilldown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:6px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0;position:absolute;top:50%;margin-top:-6px;right:1rem}.js-drilldown-back>a:before{content:'';display:block;width:0;height:0;border:6px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0;display:inline-block;vertical-align:middle;margin-right:.75rem}.dropdown-pane{background-color:#fefefe;border:1px solid #cacaca;border-radius:0;display:block;font-size:1rem;padding:1rem;position:absolute;visibility:hidden;width:300px;z-index:10}.dropdown-pane.is-open{visibility:visible}.dropdown-pane.tiny{width:100px}.dropdown-pane.small{width:200px}.dropdown-pane.large{width:400px}.dropdown.menu>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}[data-whatinput=mouse] .dropdown.menu a{outline:0}.no-js .dropdown.menu ul{display:none}.dropdown.menu.vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.vertical>li.opens-left>.is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.vertical>li.opens-right>.is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}@media screen and (min-width:40em){.dropdown.menu.medium-horizontal>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu.medium-horizontal>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu.medium-horizontal>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu.medium-horizontal>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}.dropdown.menu.medium-vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.medium-vertical>li.opens-left>.is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.medium-vertical>li.opens-right>.is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.medium-vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.medium-vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.medium-vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}}@media screen and (min-width:64em){.dropdown.menu.large-horizontal>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu.large-horizontal>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu.large-horizontal>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu.large-horizontal>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}.dropdown.menu.large-vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.large-vertical>li.opens-left>.is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.large-vertical>li.opens-right>.is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.large-vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.large-vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.large-vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}}.dropdown.menu.align-right .is-dropdown-submenu.first-sub{top:100%;left:auto;right:0}.is-dropdown-menu.vertical{width:100px}.is-dropdown-menu.vertical.align-right{float:right}.is-dropdown-submenu-parent{position:relative}.is-dropdown-submenu-parent a:after{position:absolute;top:50%;right:5px;margin-top:-2px}.is-dropdown-submenu-parent.opens-inner>.is-dropdown-submenu{top:100%;left:auto}.is-dropdown-submenu-parent.opens-left>.is-dropdown-submenu{left:auto;right:100%}.is-dropdown-submenu-parent.opens-right>.is-dropdown-submenu{right:auto;left:100%}.is-dropdown-submenu{display:none;position:absolute;top:0;left:100%;min-width:200px;z-index:1;background:#fefefe;border:1px solid #cacaca}.is-dropdown-submenu .is-dropdown-submenu-parent>a:after{right:14px;margin-top:-3px}.is-dropdown-submenu .is-dropdown-submenu-parent.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.is-dropdown-submenu .is-dropdown-submenu-parent.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}.is-dropdown-submenu .is-dropdown-submenu{margin-top:-1px}.is-dropdown-submenu>li{width:100%}.is-dropdown-submenu.js-dropdown-active{display:block}.flex-video{position:relative;height:0;padding-bottom:75%;margin-bottom:1rem;overflow:hidden}.flex-video embed,.flex-video iframe,.flex-video object,.flex-video video{position:absolute;top:0;left:0;width:100%;height:100%}.flex-video.widescreen{padding-bottom:56.25%}.flex-video.vimeo{padding-top:0}.label{display:inline-block;padding:.33333rem .5rem;font-size:.8rem;line-height:1;white-space:nowrap;cursor:default;border-radius:0;background:#2199e8;color:#fefefe}.label.secondary{background:#777;color:#fefefe}.label.success{background:#3adb76;color:#fefefe}.label.warning{background:#ffae00;color:#fefefe}.label.alert{background:#ec5840;color:#fefefe}.media-object{margin-bottom:1rem;display:block}.media-object img{max-width:none}@media screen and (max-width:39.9375em){.media-object.stack-for-small .media-object-section{padding:0;padding-bottom:1rem;display:block}.media-object.stack-for-small .media-object-section img{width:100%}}.media-object-section{display:table-cell;vertical-align:top}.media-object-section:first-child{padding-right:1rem}.media-object-section:last-child:not(:nth-child(2)){padding-left:1rem}.media-object-section>:last-child{margin-bottom:0}.media-object-section.middle{vertical-align:middle}.media-object-section.bottom{vertical-align:bottom}body,html{height:100%}.off-canvas-wrapper{width:100%;overflow-x:hidden;position:relative;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-overflow-scrolling:auto}.off-canvas-wrapper-inner{position:relative;width:100%;min-height:100%;-webkit-transition:-webkit-transform .5s ease;transition:transform .5s ease}.off-canvas-wrapper-inner:after,.off-canvas-wrapper-inner:before{content:' ';display:table}.off-canvas-wrapper-inner:after{clear:both}.off-canvas-content{min-height:100%;background:#fefefe;-webkit-transition:-webkit-transform .5s ease;transition:transform .5s ease;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;padding-bottom:.1px;box-shadow:0 0 10px hsla(0,0%,4%,.5)}.js-off-canvas-exit{display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:hsla(0,0%,100%,.25);cursor:pointer;-webkit-transition:background .5s ease;transition:background .5s ease}.off-canvas{position:absolute;background:#e6e6e6;z-index:-1;max-height:100%;overflow-y:auto;-webkit-transform:translateX(0);transform:translateX(0)}[data-whatinput=mouse] .off-canvas{outline:0}.off-canvas.position-left{left:-250px;top:0;width:250px}.is-open-left{-webkit-transform:translateX(250px);transform:translateX(250px)}.off-canvas.position-right{right:-250px;top:0;width:250px}.is-open-right{-webkit-transform:translateX(-250px);transform:translateX(-250px)}@media screen and (min-width:40em){.position-left.reveal-for-medium{left:0;z-index:auto;position:fixed}.position-left.reveal-for-medium~.off-canvas-content{margin-left:250px}.position-right.reveal-for-medium{right:0;z-index:auto;position:fixed}.position-right.reveal-for-medium~.off-canvas-content{margin-right:250px}}@media screen and (min-width:64em){.position-left.reveal-for-large{left:0;z-index:auto;position:fixed}.position-left.reveal-for-large~.off-canvas-content{margin-left:250px}.position-right.reveal-for-large{right:0;z-index:auto;position:fixed}.position-right.reveal-for-large~.off-canvas-content{margin-right:250px}}.orbit,.orbit-container{position:relative}.orbit-container{margin:0;overflow:hidden;list-style:none}.orbit-slide{width:100%;max-height:100%}.orbit-slide.no-motionui.is-active{top:0;left:0}.orbit-figure{margin:0}.orbit-image{margin:0;width:100%;max-width:100%}.orbit-caption{bottom:0;width:100%;margin-bottom:0;background-color:hsla(0,0%,4%,.5)}.orbit-caption,.orbit-next,.orbit-previous{position:absolute;padding:1rem;color:#fefefe}.orbit-next,.orbit-previous{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);z-index:10}[data-whatinput=mouse] .orbit-next,[data-whatinput=mouse] .orbit-previous{outline:0}.orbit-next:active,.orbit-next:focus,.orbit-next:hover,.orbit-previous:active,.orbit-previous:focus,.orbit-previous:hover{background-color:hsla(0,0%,4%,.5)}.orbit-previous{left:0}.orbit-next{left:auto;right:0}.orbit-bullets{position:relative;margin-top:.8rem;margin-bottom:.8rem;text-align:center}[data-whatinput=mouse] .orbit-bullets{outline:0}.orbit-bullets button{width:1.2rem;height:1.2rem;margin:.1rem;background-color:#cacaca;border-radius:50%}.orbit-bullets button.is-active,.orbit-bullets button:hover{background-color:#8a8a8a}.pagination{margin-left:0;margin-bottom:1rem}.pagination:after,.pagination:before{content:' ';display:table}.pagination:after{clear:both}.pagination li{font-size:.875rem;margin-right:.0625rem;border-radius:0;display:none}.pagination li:first-child,.pagination li:last-child{display:inline-block}@media screen and (min-width:40em){.pagination li{display:inline-block}}.pagination a,.pagination button{color:#0a0a0a;display:block;padding:.1875rem .625rem;border-radius:0}.pagination a:hover,.pagination button:hover{background:#e6e6e6}.pagination .current{padding:.1875rem .625rem;background:#2199e8;color:#fefefe;cursor:default}.pagination .disabled{padding:.1875rem .625rem;color:#cacaca;cursor:not-allowed}.pagination .disabled:hover{background:transparent}.pagination .ellipsis:after{content:'\\2026';padding:.1875rem .625rem;color:#0a0a0a}.pagination-previous.disabled:before,.pagination-previous a:before{content:'\\AB';display:inline-block;margin-right:.5rem}.pagination-next.disabled:after,.pagination-next a:after{content:'\\BB';display:inline-block;margin-left:.5rem}.progress{background-color:#cacaca;height:1rem;margin-bottom:1rem;border-radius:0}.progress.primary .progress-meter{background-color:#2199e8}.progress.secondary .progress-meter{background-color:#777}.progress.success .progress-meter{background-color:#3adb76}.progress.warning .progress-meter{background-color:#ffae00}.progress.alert .progress-meter{background-color:#ec5840}.progress-meter{position:relative;display:block;width:0;height:100%;background-color:#2199e8}.progress-meter-text{top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);position:absolute;margin:0;font-size:.75rem;font-weight:700;color:#fefefe;white-space:nowrap}.slider{position:relative;height:.5rem;margin-top:1.25rem;margin-bottom:2.25rem;background-color:#e6e6e6;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:none;touch-action:none}.slider-fill{position:absolute;top:0;left:0;display:inline-block;max-width:100%;height:.5rem;background-color:#cacaca;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.slider-fill.is-dragging{-webkit-transition:all 0s linear;transition:all 0s linear}.slider-handle{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);position:absolute;left:0;z-index:1;display:inline-block;width:1.4rem;height:1.4rem;background-color:#2199e8;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out;-ms-touch-action:manipulation;touch-action:manipulation;border-radius:0}[data-whatinput=mouse] .slider-handle{outline:0}.slider-handle:hover{background-color:#1583cc}.slider-handle.is-dragging{-webkit-transition:all 0s linear;transition:all 0s linear}.slider.disabled,.slider[disabled]{opacity:.25;cursor:not-allowed}.slider.vertical{display:inline-block;width:.5rem;height:12.5rem;margin:0 1.25rem;-webkit-transform:scaleY(-1);transform:scaleY(-1)}.slider.vertical .slider-fill{top:0;width:.5rem;max-height:100%}.slider.vertical .slider-handle{position:absolute;top:0;left:50%;width:1.4rem;height:1.4rem;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.sticky-container{position:relative}.sticky{position:absolute;z-index:0;-webkit-transform:translateZ(0);transform:translateZ(0)}.sticky.is-stuck{position:fixed;z-index:5}.sticky.is-stuck.is-at-top{top:0}.sticky.is-stuck.is-at-bottom{bottom:0}.sticky.is-anchored{position:absolute;left:auto;right:auto}.sticky.is-anchored.is-at-bottom{bottom:0}body.is-reveal-open{overflow:hidden}html.is-reveal-open,html.is-reveal-open body{min-height:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.reveal-overlay{display:none;position:fixed;top:0;bottom:0;left:0;right:0;z-index:1005;background-color:hsla(0,0%,4%,.45);overflow-y:scroll}.reveal{display:none;z-index:1006;padding:1rem;border:1px solid #cacaca;background-color:#fefefe;border-radius:0;position:relative;top:100px;margin-left:auto;margin-right:auto;overflow-y:auto}[data-whatinput=mouse] .reveal{outline:0}@media screen and (min-width:40em){.reveal{min-height:0}}.reveal .column,.reveal .columns{min-width:0}.reveal>:last-child{margin-bottom:0}@media screen and (min-width:40em){.reveal{width:600px;max-width:75rem}}@media screen and (min-width:40em){.reveal .reveal{left:auto;right:auto;margin:0 auto}}.reveal.collapse{padding:0}@media screen and (min-width:40em){.reveal.tiny{width:30%;max-width:75rem}}@media screen and (min-width:40em){.reveal.small{width:50%;max-width:75rem}}@media screen and (min-width:40em){.reveal.large{width:90%;max-width:75rem}}.reveal.full{top:0;left:0;width:100%;height:100%;height:100vh;min-height:100vh;max-width:none;margin-left:0;border:0;border-radius:0}@media screen and (max-width:39.9375em){.reveal{top:0;left:0;width:100%;height:100%;height:100vh;min-height:100vh;max-width:none;margin-left:0;border:0;border-radius:0}}.reveal.without-overlay{position:fixed}.switch{height:2rem;margin-bottom:1rem;outline:0;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:#fefefe;font-weight:700;font-size:.875rem}.switch-input{opacity:0;position:absolute;margin-bottom:0}.switch-paddle{background:#cacaca;cursor:pointer;display:block;position:relative;width:4rem;height:2rem;-webkit-transition:all .25s ease-out;transition:all .25s ease-out;border-radius:0;color:inherit;font-weight:inherit}input+.switch-paddle{margin:0}.switch-paddle:after{background:#fefefe;content:'';display:block;position:absolute;height:1.5rem;left:.25rem;top:.25rem;width:1.5rem;-webkit-transition:all .25s ease-out;transition:all .25s ease-out;-webkit-transform:translateZ(0);transform:translateZ(0);border-radius:0}input:checked~.switch-paddle{background:#2199e8}input:checked~.switch-paddle:after{left:2.25rem}[data-whatinput=mouse] input:focus~.switch-paddle{outline:0}.switch-active,.switch-inactive{position:absolute;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.switch-active{left:8%;display:none}input:checked+label>.switch-active{display:block}.switch-inactive{right:15%}input:checked+label>.switch-inactive{display:none}.switch.tiny{height:1.5rem}.switch.tiny .switch-paddle{width:3rem;height:1.5rem;font-size:.625rem}.switch.tiny .switch-paddle:after{width:1rem;height:1rem}.switch.tiny input:checked~.switch-paddle:after{left:1.75rem}.switch.small{height:1.75rem}.switch.small .switch-paddle{width:3.5rem;height:1.75rem;font-size:.75rem}.switch.small .switch-paddle:after{width:1.25rem;height:1.25rem}.switch.small input:checked~.switch-paddle:after{left:2rem}.switch.large{height:2.5rem}.switch.large .switch-paddle{width:5rem;height:2.5rem;font-size:1rem}.switch.large .switch-paddle:after{width:2rem;height:2rem}.switch.large input:checked~.switch-paddle:after{left:2.75rem}table{width:100%;margin-bottom:1rem;border-radius:0}table tbody,table tfoot,table thead{border:1px solid #f1f1f1;background-color:#fefefe}table caption{font-weight:700;padding:.5rem .625rem .625rem}table thead{background:#f8f8f8;color:#0a0a0a}table tfoot{background:#f1f1f1;color:#0a0a0a}table tfoot tr,table thead tr{background:transparent}table tfoot td,table tfoot th,table thead td,table thead th{padding:.5rem .625rem .625rem;font-weight:700;text-align:left}table tbody tr:nth-child(even){background-color:#f1f1f1}table tbody td,table tbody th{padding:.5rem .625rem .625rem}@media screen and (max-width:63.9375em){table.stack tfoot,table.stack thead{display:none}table.stack td,table.stack th,table.stack tr{display:block}table.stack td{border-top:0}}table.scroll{display:block;width:100%;overflow-x:auto}table.hover thead tr:hover{background-color:#f3f3f3}table.hover tfoot tr:hover{background-color:#ececec}table.hover tbody tr:hover{background-color:#f9f9f9}table.hover tbody tr:nth-of-type(even):hover{background-color:#ececec}.table-scroll{overflow-x:auto}.table-scroll table{width:auto}.tabs{margin:0;list-style-type:none;background:#fefefe;border:1px solid #e6e6e6}.tabs:after,.tabs:before{content:' ';display:table}.tabs:after{clear:both}.tabs.vertical>li{width:auto;float:none;display:block}.tabs.simple>li>a{padding:0}.tabs.simple>li>a:hover{background:transparent}.tabs.primary{background:#2199e8}.tabs.primary>li>a{color:#fefefe}.tabs.primary>li>a:focus,.tabs.primary>li>a:hover{background:#1893e4}.tabs-title{float:left}.tabs-title>a{display:block;padding:1.25rem 1.5rem;line-height:1;font-size:.75rem}.tabs-title>a:hover{background:#fefefe}.tabs-title>a:focus,.tabs-title>a[aria-selected=true]{background:#e6e6e6}.tabs-content{background:#fefefe;-webkit-transition:all .5s ease;transition:all .5s ease;border:1px solid #e6e6e6;border-top:0}.tabs-content.vertical{border:1px solid #e6e6e6;border-left:0}.tabs-panel{display:none;padding:1rem}.tabs-panel.is-active{display:block}.thumbnail{border:4px solid #fefefe;box-shadow:0 0 0 1px hsla(0,0%,4%,.2);display:inline-block;line-height:0;max-width:100%;-webkit-transition:-webkit-box-shadow .2s ease-out;transition:box-shadow .2s ease-out;border-radius:0;margin-bottom:1rem}.thumbnail:focus,.thumbnail:hover{box-shadow:0 0 6px 1px rgba(33,153,232,.5)}.title-bar{background:#0a0a0a;color:#fefefe;padding:.5rem}.title-bar:after,.title-bar:before{content:' ';display:table}.title-bar:after{clear:both}.title-bar .menu-icon{margin-left:.25rem;margin-right:.25rem}.title-bar-left{float:left}.title-bar-right{float:right;text-align:right}.title-bar-title{vertical-align:middle}.has-tip,.title-bar-title{font-weight:700;display:inline-block}.has-tip{border-bottom:1px dotted #8a8a8a;position:relative;cursor:help}.tooltip{background-color:#0a0a0a;color:#fefefe;font-size:80%;padding:.75rem;position:absolute;z-index:10;top:calc(100% + .6495rem);max-width:10rem!important;border-radius:0}.tooltip:before{border:.75rem inset;border-color:transparent transparent #0a0a0a;border-bottom-style:solid;border-top-width:0;bottom:100%;position:absolute;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.tooltip.top:before,.tooltip:before{content:'';display:block;width:0;height:0}.tooltip.top:before{border:.75rem inset;border-color:#0a0a0a transparent transparent;border-top-style:solid;border-bottom-width:0;top:100%;bottom:auto}.tooltip.left:before{border:.75rem inset;border-color:transparent transparent transparent #0a0a0a;border-left-style:solid;border-right-width:0;left:100%}.tooltip.left:before,.tooltip.right:before{content:'';display:block;width:0;height:0;bottom:auto;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.tooltip.right:before{border:.75rem inset;border-color:transparent #0a0a0a transparent transparent;border-right-style:solid;border-left-width:0;left:auto;right:100%}.top-bar{padding:.5rem}.top-bar:after,.top-bar:before{content:' ';display:table}.top-bar:after{clear:both}.top-bar,.top-bar ul{background-color:#e6e6e6}.top-bar input{max-width:200px;margin-right:1rem}.top-bar .input-group-field{width:100%;margin-right:0}.top-bar input.button{width:auto}.top-bar .top-bar-left,.top-bar .top-bar-right{width:100%}@media screen and (min-width:40em){.top-bar .top-bar-left,.top-bar .top-bar-right{width:auto}}@media screen and (max-width:63.9375em){.top-bar.stacked-for-medium .top-bar-left,.top-bar.stacked-for-medium .top-bar-right{width:100%}}@media screen and (max-width:74.9375em){.top-bar.stacked-for-large .top-bar-left,.top-bar.stacked-for-large .top-bar-right{width:100%}}.top-bar-title{float:left;margin-right:1rem}.top-bar-left{float:left}.top-bar-right{float:right}.hide{display:none!important}.invisible{visibility:hidden}@media screen and (max-width:39.9375em){.hide-for-small-only{display:none!important}}@media screen and (max-width:0em),screen and (min-width:40em){.show-for-small-only{display:none!important}}@media screen and (min-width:40em){.hide-for-medium{display:none!important}}@media screen and (max-width:39.9375em){.show-for-medium{display:none!important}}@media screen and (min-width:40em) and (max-width:63.9375em){.hide-for-medium-only{display:none!important}}@media screen and (max-width:39.9375em),screen and (min-width:64em){.show-for-medium-only{display:none!important}}@media screen and (min-width:64em){.hide-for-large{display:none!important}}@media screen and (max-width:63.9375em){.show-for-large{display:none!important}}@media screen and (min-width:64em) and (max-width:74.9375em){.hide-for-large-only{display:none!important}}@media screen and (max-width:63.9375em),screen and (min-width:75em){.show-for-large-only{display:none!important}}.show-for-sr,.show-on-focus{position:absolute!important;width:1px;height:1px;overflow:hidden;clip:rect(0,0,0,0)}.show-on-focus:active,.show-on-focus:focus{position:static!important;height:auto;width:auto;overflow:visible;clip:auto}.hide-for-portrait,.show-for-landscape{display:block!important}@media screen and (orientation:landscape){.hide-for-portrait,.show-for-landscape{display:block!important}}@media screen and (orientation:portrait){.hide-for-portrait,.show-for-landscape{display:none!important}}.hide-for-landscape,.show-for-portrait{display:none!important}@media screen and (orientation:landscape){.hide-for-landscape,.show-for-portrait{display:none!important}}@media screen and (orientation:portrait){.hide-for-landscape,.show-for-portrait{display:block!important}}.float-left{float:left!important}.float-right{float:right!important}.float-center{display:block;margin-left:auto;margin-right:auto}.clearfix:after,.clearfix:before{content:' ';display:table}.clearfix:after{clear:both}", ""]);
	
	// exports


/***/ },
/* 248 */
/***/ function(module, exports) {

	"use strict";
	
	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function () {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for (var i = 0; i < this.length; i++) {
				var item = this[i];
				if (item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function (modules, mediaQuery) {
			if (typeof modules === "string") modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for (var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if (typeof id === "number") alreadyImportedModules[id] = true;
			}
			for (i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if (mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if (mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(251);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(249)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./app.scss", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./app.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(248)();
	// imports
	
	
	// module
	exports.push([module.id, ".top-bar, .top-bar ul {\n  background-color: #333; }\n\n.top-bar .menu-text {\n  color: white; }\n\n.top-bar .menu > .menu-text > a {\n  display: inline;\n  padding: 0; }\n\n.top-bar .active-link {\n  font-weight: bold; }\n\n.clock {\n  align-items: center;\n  background-color: #b5d0e2;\n  border: 2px solid #2088e8;\n  border-radius: 50%;\n  display: flex;\n  height: 14rem;\n  width: 14rem;\n  justify-content: center;\n  margin: 4rem auto; }\n\n.clock-text {\n  color: white;\n  font-size: 2.25rem;\n  font-weight: 300; }\n\n.controls {\n  display: flex;\n  justify-content: center; }\n  .controls .button {\n    padding: .75rem, 3rem;\n    margin: 0 .75rem 0 .75rem; }\n", ""]);
	
	// exports


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Controls = function (_React$Component) {
	    _inherits(Controls, _React$Component);
	
	    function Controls() {
	        _classCallCheck(this, Controls);
	
	        return _possibleConstructorReturn(this, (Controls.__proto__ || Object.getPrototypeOf(Controls)).apply(this, arguments));
	    }
	
	    _createClass(Controls, [{
	        key: 'renderStartStopButton',
	
	        // constructor(props) {
	        //     super(props);
	        // }
	
	        value: function renderStartStopButton() {
	            var _this2 = this;
	
	            var countdownStatus = this.props.countdownStatus;
	
	
	            if (countdownStatus === 'started') {
	                return _react2.default.createElement(
	                    'button',
	                    { className: 'button secondary', onClick: function onClick() {
	                            return _this2.onStatusChange('paused');
	                        } },
	                    'Pause'
	                );
	            } else if (countdownStatus === 'paused') {
	                return _react2.default.createElement(
	                    'button',
	                    { className: 'button primary', onClick: function onClick() {
	                            return _this2.onStatusChange('started');
	                        } },
	                    'Start'
	                );
	            }
	        }
	    }, {
	        key: 'onStatusChange',
	        value: function onStatusChange(newStatus) {
	            this.props.onStatusChange(newStatus);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this3 = this;
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'controls' },
	                this.renderStartStopButton(),
	                _react2.default.createElement(
	                    'button',
	                    { className: 'button alert hollow', onClick: function onClick() {
	                            return _this3.onStatusChange('stopped');
	                        } },
	                    'Clear'
	                )
	            );
	        }
	    }]);
	
	    return Controls;
	}(_react2.default.Component);
	
	Controls.propTypes = {
	    countdownStatus: _react2.default.PropTypes.string.isRequired,
	    onStatusChange: _react2.default.PropTypes.func.isRequired
	};
	
	exports.default = Controls;

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDY5Mjg5ZTg4YzI1NWY2YjY3YTMiLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzP2MyYWIiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanM/NzBjNCIsIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9hcHAvYXBwLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImpRdWVyeVwiIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvcmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvS2V5RXNjYXBlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9SZWFjdFB1cmVDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET00uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9BUklBRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9Qb29sZWRDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdFVwZGF0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0NhbGxiYWNrUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0UmVmLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdE93bmVyLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3REZWJ1Z1Rvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2suanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1VJRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0RPTUxhenlUcmVlLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9ET01OYW1lc3BhY2VzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9zZXRJbm5lckhUTUwuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL3NldFRleHRDb250ZW50LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0Rhbmdlci5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9DU1NQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvY2FtZWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvTGlua2VkVmFsdWVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NT3B0aW9uLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01UZXh0YXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RhbmNlTWFwLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0Tm9kZVR5cGVzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9nZXROZXh0RGVidWdJRC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvS2V5RXNjYXBlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvZmxhdHRlbkNoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdFVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVHJlZVRyYXZlcnNhbC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNBbmltYXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2dldEV2ZW50S2V5LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RNb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9maW5kRE9NTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnZhbGlkQVJJQUhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9Qcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL1BhdHRlcm5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vd2FybmluZy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9jb21wdXRlQ2hhbmdlZFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvVHJhbnNpdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9pc0FjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Q29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvUHJvbWlzZVV0aWxzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvSW50ZXJuYWxQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL2dldFJvdXRlUGFyYW1zLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9Db250ZXh0VXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleExpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4Um91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcXVlcnktc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL0xvY2F0aW9uVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvYXBwbHlSb3V0ZXJNaWRkbGV3YXJlLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9icm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vaGlzdG9yeS9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi9Ccm93c2VyUHJvdG9jb2wuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL0RPTVN0YXRlU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL1JlZnJlc2hQcm90b2NvbC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlUm91dGVySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL0hhc2hQcm90b2NvbC5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9hcHAvY29tcG9uZW50cy9NYWluLmpzIiwid2VicGFjazovLy8uL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL2FwcC9jb21wb25lbnRzL05hdi5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9hcHAvY29tcG9uZW50cy9UaW1lci5qcyIsIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9hcHAvY29tcG9uZW50cy9Db3VudGRvd24uanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvYXBwL2NvbXBvbmVudHMvQ2xvY2suanMiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvYXBwL2NvbXBvbmVudHMvQ291bnRkb3duRm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5jc3M/NWQwZSIsIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5jc3MiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL3N0eWxlcy9hcHAuc2Nzcz9iMjlmIiwid2VicGFjazovLy8uL2FwcC9zdHlsZXMvYXBwLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvYXBwL2NvbXBvbmVudHMvQ29udHJvbHMuanMiXSwibmFtZXMiOlsicmVxdWlyZSIsIiQiLCJkb2N1bWVudCIsImZvdW5kYXRpb24iLCJyZW5kZXIiLCJnZXRFbGVtZW50QnlJZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJfYXNzaWduIiwiUmVhY3RDaGlsZHJlbiIsIlJlYWN0Q29tcG9uZW50IiwiUmVhY3RQdXJlQ29tcG9uZW50IiwiUmVhY3RDbGFzcyIsIlJlYWN0RE9NRmFjdG9yaWVzIiwiUmVhY3RFbGVtZW50IiwiUmVhY3RQcm9wVHlwZXMiLCJSZWFjdFZlcnNpb24iLCJvbmx5Q2hpbGQiLCJ3YXJuaW5nIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUZhY3RvcnkiLCJjbG9uZUVsZW1lbnQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJSZWFjdEVsZW1lbnRWYWxpZGF0b3IiLCJfX3NwcmVhZCIsIndhcm5lZCIsImFwcGx5IiwiYXJndW1lbnRzIiwiUmVhY3QiLCJDaGlsZHJlbiIsIm1hcCIsImZvckVhY2giLCJjb3VudCIsInRvQXJyYXkiLCJvbmx5IiwiQ29tcG9uZW50IiwiUHVyZUNvbXBvbmVudCIsImlzVmFsaWRFbGVtZW50IiwiUHJvcFR5cGVzIiwiY3JlYXRlQ2xhc3MiLCJjcmVhdGVNaXhpbiIsIm1peGluIiwiRE9NIiwidmVyc2lvbiIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImUiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwiY2FsbCIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJsZW4iLCJydW4iLCJuZXh0VGljayIsImFyZ3MiLCJBcnJheSIsImkiLCJwdXNoIiwiSXRlbSIsImFycmF5IiwicHJvdG90eXBlIiwidGl0bGUiLCJicm93c2VyIiwiYXJndiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwiYmluZGluZyIsIm5hbWUiLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsImFzc2lnbiIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibiIsImpvaW4iLCJ0ZXN0MyIsInNwbGl0IiwibGV0dGVyIiwia2V5cyIsInRhcmdldCIsInNvdXJjZSIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwia2V5IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiUG9vbGVkQ2xhc3MiLCJlbXB0eUZ1bmN0aW9uIiwidHJhdmVyc2VBbGxDaGlsZHJlbiIsInR3b0FyZ3VtZW50UG9vbGVyIiwiZm91ckFyZ3VtZW50UG9vbGVyIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJ0ZXh0IiwicmVwbGFjZSIsIkZvckVhY2hCb29rS2VlcGluZyIsImZvckVhY2hGdW5jdGlvbiIsImZvckVhY2hDb250ZXh0IiwiZnVuYyIsImNvbnRleHQiLCJkZXN0cnVjdG9yIiwiYWRkUG9vbGluZ1RvIiwiZm9yRWFjaFNpbmdsZUNoaWxkIiwiYm9va0tlZXBpbmciLCJjaGlsZCIsImZvckVhY2hDaGlsZHJlbiIsImNoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJ0cmF2ZXJzZUNvbnRleHQiLCJnZXRQb29sZWQiLCJyZWxlYXNlIiwiTWFwQm9va0tlZXBpbmciLCJtYXBSZXN1bHQiLCJrZXlQcmVmaXgiLCJtYXBGdW5jdGlvbiIsIm1hcENvbnRleHQiLCJyZXN1bHQiLCJtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0IiwiY2hpbGRLZXkiLCJtYXBwZWRDaGlsZCIsImlzQXJyYXkiLCJtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsIiwidGhhdFJldHVybnNBcmd1bWVudCIsImNsb25lQW5kUmVwbGFjZUtleSIsInByZWZpeCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImZvckVhY2hTaW5nbGVDaGlsZER1bW15IiwiY291bnRDaGlsZHJlbiIsIl9wcm9kSW52YXJpYW50IiwiaW52YXJpYW50Iiwib25lQXJndW1lbnRQb29sZXIiLCJjb3B5RmllbGRzRnJvbSIsIktsYXNzIiwiaW5zdGFuY2VQb29sIiwiaW5zdGFuY2UiLCJwb3AiLCJhMSIsImEyIiwidGhyZWVBcmd1bWVudFBvb2xlciIsImEzIiwiYTQiLCJmaXZlQXJndW1lbnRQb29sZXIiLCJhNSIsInN0YW5kYXJkUmVsZWFzZXIiLCJwb29sU2l6ZSIsIkRFRkFVTFRfUE9PTF9TSVpFIiwiREVGQVVMVF9QT09MRVIiLCJDb3B5Q29uc3RydWN0b3IiLCJwb29sZXIiLCJOZXdLbGFzcyIsInJlYWN0UHJvZEludmFyaWFudCIsImNvZGUiLCJhcmdDb3VudCIsIm1lc3NhZ2UiLCJhcmdJZHgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJlcnJvciIsImZyYW1lc1RvUG9wIiwiY29uZGl0aW9uIiwiZm9ybWF0IiwiYSIsImIiLCJjIiwiZCIsImYiLCJhcmdJbmRleCIsIlJlYWN0Q3VycmVudE93bmVyIiwiY2FuRGVmaW5lUHJvcGVydHkiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRVNFUlZFRF9QUk9QUyIsInJlZiIsIl9fc2VsZiIsIl9fc291cmNlIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0dGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwicHJvcHMiLCJkaXNwbGF5TmFtZSIsIndhcm5BYm91dEFjY2Vzc2luZ0tleSIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJ0eXBlIiwic2VsZiIsIm93bmVyIiwiZWxlbWVudCIsIiQkdHlwZW9mIiwiX293bmVyIiwiX3N0b3JlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJ2YWxpZGF0ZWQiLCJfc2VsZiIsIl9zb3VyY2UiLCJmcmVlemUiLCJwcm9wTmFtZSIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImRlZmF1bHRQcm9wcyIsImN1cnJlbnQiLCJmYWN0b3J5IiwiYmluZCIsIm9sZEVsZW1lbnQiLCJuZXdLZXkiLCJuZXdFbGVtZW50Iiwib2JqZWN0IiwicHJpbnRXYXJuaW5nIiwiX2xlbiIsIl9rZXkiLCJjb25zb2xlIiwieCIsImluZGV4T2YiLCJfbGVuMiIsIl9rZXkyIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJhcmciLCJ0aGF0UmV0dXJucyIsInRoYXRSZXR1cm5zRmFsc2UiLCJ0aGF0UmV0dXJuc1RydWUiLCJ0aGF0UmV0dXJuc051bGwiLCJ0aGF0UmV0dXJuc1RoaXMiLCJTeW1ib2wiLCJnZXRJdGVyYXRvckZuIiwiS2V5RXNjYXBlVXRpbHMiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZ2V0Q29tcG9uZW50S2V5IiwiY29tcG9uZW50IiwiaW5kZXgiLCJlc2NhcGUiLCJ0b1N0cmluZyIsInRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsIiwibmFtZVNvRmFyIiwiY2FsbGJhY2siLCJuZXh0TmFtZSIsInN1YnRyZWVDb3VudCIsIm5leHROYW1lUHJlZml4IiwiaXRlcmF0b3JGbiIsIml0ZXJhdG9yIiwic3RlcCIsImVudHJpZXMiLCJpaSIsIm5leHQiLCJkb25lIiwibWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSIsIm1hcHNBc0NoaWxkcmVuT3duZXJOYW1lIiwiZ2V0TmFtZSIsImVudHJ5IiwiYWRkZW5kdW0iLCJfaXNSZWFjdEVsZW1lbnQiLCJjaGlsZHJlblN0cmluZyIsIklURVJBVE9SX1NZTUJPTCIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwibWF5YmVJdGVyYWJsZSIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJtYXRjaCIsInVuZXNjYXBlIiwidW5lc2NhcGVSZWdleCIsInVuZXNjYXBlckxvb2t1cCIsImtleVN1YnN0cmluZyIsInN1YnN0cmluZyIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiZW1wdHlPYmplY3QiLCJ1cGRhdGVyIiwicmVmcyIsImlzUmVhY3RDb21wb25lbnQiLCJzZXRTdGF0ZSIsInBhcnRpYWxTdGF0ZSIsImVucXVldWVTZXRTdGF0ZSIsImVucXVldWVDYWxsYmFjayIsImZvcmNlVXBkYXRlIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJpc01vdW50ZWQiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJtZXRob2ROYW1lIiwiaW5mbyIsImZuTmFtZSIsIndhcm5Ob29wIiwicHVibGljSW5zdGFuY2UiLCJjYWxsZXJOYW1lIiwiY29uc3RydWN0b3IiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiY29tcGxldGVTdGF0ZSIsIkNvbXBvbmVudER1bW15IiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyIsIk1JWElOU19LRVkiLCJpZGVudGl0eSIsImZuIiwiaW5qZWN0ZWRNaXhpbnMiLCJSZWFjdENsYXNzSW50ZXJmYWNlIiwibWl4aW5zIiwic3RhdGljcyIsInByb3BUeXBlcyIsImNvbnRleHRUeXBlcyIsImNoaWxkQ29udGV4dFR5cGVzIiwiZ2V0RGVmYXVsdFByb3BzIiwiZ2V0SW5pdGlhbFN0YXRlIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwidXBkYXRlQ29tcG9uZW50IiwiUkVTRVJWRURfU1BFQ19LRVlTIiwiQ29uc3RydWN0b3IiLCJtaXhTcGVjSW50b0NvbXBvbmVudCIsInZhbGlkYXRlVHlwZURlZiIsImNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uIiwibWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQiLCJhdXRvYmluZCIsInR5cGVEZWYiLCJsb2NhdGlvbiIsInZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUiLCJpc0FscmVhZHlEZWZpbmVkIiwic3BlY1BvbGljeSIsIlJlYWN0Q2xhc3NNaXhpbiIsInNwZWMiLCJ0eXBlb2ZTcGVjIiwiaXNNaXhpblZhbGlkIiwicHJvdG8iLCJhdXRvQmluZFBhaXJzIiwiX19yZWFjdEF1dG9CaW5kUGFpcnMiLCJwcm9wZXJ0eSIsImlzUmVhY3RDbGFzc01ldGhvZCIsImlzRnVuY3Rpb24iLCJzaG91bGRBdXRvQmluZCIsImNyZWF0ZUNoYWluZWRGdW5jdGlvbiIsImlzUmVzZXJ2ZWQiLCJpc0luaGVyaXRlZCIsIm1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMiLCJvbmUiLCJ0d28iLCJtZXJnZWRSZXN1bHQiLCJjaGFpbmVkRnVuY3Rpb24iLCJiaW5kQXV0b0JpbmRNZXRob2QiLCJtZXRob2QiLCJib3VuZE1ldGhvZCIsIl9fcmVhY3RCb3VuZENvbnRleHQiLCJfX3JlYWN0Qm91bmRNZXRob2QiLCJfX3JlYWN0Qm91bmRBcmd1bWVudHMiLCJjb21wb25lbnROYW1lIiwiX2JpbmQiLCJuZXdUaGlzIiwicmVib3VuZE1ldGhvZCIsImJpbmRBdXRvQmluZE1ldGhvZHMiLCJwYWlycyIsImF1dG9CaW5kS2V5IiwibmV3U3RhdGUiLCJSZWFjdENsYXNzQ29tcG9uZW50Iiwic3RhdGUiLCJpbml0aWFsU3RhdGUiLCJfaXNNb2NrRnVuY3Rpb24iLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJpbmplY3Rpb24iLCJpbmplY3RNaXhpbiIsInByb3AiLCJjaGlsZENvbnRleHQiLCJjcmVhdGVET01GYWN0b3J5IiwiYWJiciIsImFkZHJlc3MiLCJhcmVhIiwiYXJ0aWNsZSIsImFzaWRlIiwiYXVkaW8iLCJiYXNlIiwiYmRpIiwiYmRvIiwiYmlnIiwiYmxvY2txdW90ZSIsImJvZHkiLCJiciIsImJ1dHRvbiIsImNhbnZhcyIsImNhcHRpb24iLCJjaXRlIiwiY29sIiwiY29sZ3JvdXAiLCJkYXRhIiwiZGF0YWxpc3QiLCJkZCIsImRlbCIsImRldGFpbHMiLCJkZm4iLCJkaWFsb2ciLCJkaXYiLCJkbCIsImR0IiwiZW0iLCJlbWJlZCIsImZpZWxkc2V0IiwiZmlnY2FwdGlvbiIsImZpZ3VyZSIsImZvb3RlciIsImZvcm0iLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJoZWFkIiwiaGVhZGVyIiwiaGdyb3VwIiwiaHIiLCJodG1sIiwiaWZyYW1lIiwiaW1nIiwiaW5wdXQiLCJpbnMiLCJrYmQiLCJrZXlnZW4iLCJsYWJlbCIsImxlZ2VuZCIsImxpIiwibGluayIsIm1haW4iLCJtYXJrIiwibWVudSIsIm1lbnVpdGVtIiwibWV0YSIsIm1ldGVyIiwibmF2Iiwibm9zY3JpcHQiLCJvbCIsIm9wdGdyb3VwIiwib3B0aW9uIiwib3V0cHV0IiwicCIsInBhcmFtIiwicGljdHVyZSIsInByZSIsInByb2dyZXNzIiwicSIsInJwIiwicnQiLCJydWJ5Iiwic2FtcCIsInNjcmlwdCIsInNlY3Rpb24iLCJzZWxlY3QiLCJzbWFsbCIsInNwYW4iLCJzdHJvbmciLCJzdHlsZSIsInN1YiIsInN1bW1hcnkiLCJzdXAiLCJ0YWJsZSIsInRib2R5IiwidGQiLCJ0ZXh0YXJlYSIsInRmb290IiwidGgiLCJ0aGVhZCIsInRpbWUiLCJ0ciIsInRyYWNrIiwidSIsInVsIiwidmlkZW8iLCJ3YnIiLCJjaXJjbGUiLCJjbGlwUGF0aCIsImRlZnMiLCJlbGxpcHNlIiwiZyIsImltYWdlIiwibGluZSIsImxpbmVhckdyYWRpZW50IiwibWFzayIsInBhdGgiLCJwYXR0ZXJuIiwicG9seWdvbiIsInBvbHlsaW5lIiwicmFkaWFsR3JhZGllbnQiLCJyZWN0Iiwic3RvcCIsInN2ZyIsInRzcGFuIiwiUmVhY3RDb21wb25lbnRUcmVlSG9vayIsImNoZWNrUmVhY3RUeXBlU3BlYyIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJwYXJlbnRUeXBlIiwicGFyZW50TmFtZSIsInZhbGlkYXRlRXhwbGljaXRLZXkiLCJtZW1vaXplciIsInVuaXF1ZUtleSIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyIiwiZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0iLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsImNvbXBvbmVudENsYXNzIiwidmFsaWRUeXBlIiwidmFsaWRhdGVkRmFjdG9yeSIsImlzTmF0aXZlIiwiZnVuY1RvU3RyaW5nIiwiRnVuY3Rpb24iLCJyZUlzTmF0aXZlIiwiUmVnRXhwIiwidGVzdCIsImVyciIsImNhblVzZUNvbGxlY3Rpb25zIiwiTWFwIiwiU2V0Iiwic2V0SXRlbSIsImdldEl0ZW0iLCJyZW1vdmVJdGVtIiwiZ2V0SXRlbUlEcyIsImFkZFJvb3QiLCJyZW1vdmVSb290IiwiZ2V0Um9vdElEcyIsIml0ZW1NYXAiLCJyb290SURTZXQiLCJpZCIsIml0ZW0iLCJzZXQiLCJhZGQiLCJpdGVtQnlLZXkiLCJyb290QnlLZXkiLCJnZXRLZXlGcm9tSUQiLCJnZXRJREZyb21LZXkiLCJwYXJzZUludCIsInN1YnN0ciIsInVubW91bnRlZElEcyIsInB1cmdlRGVlcCIsImNoaWxkSURzIiwiZGVzY3JpYmVDb21wb25lbnRGcmFtZSIsIm93bmVyTmFtZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImdldERpc3BsYXlOYW1lIiwiZGVzY3JpYmVJRCIsImdldEVsZW1lbnQiLCJvd25lcklEIiwiZ2V0T3duZXJJRCIsIm9uU2V0Q2hpbGRyZW4iLCJuZXh0Q2hpbGRJRHMiLCJuZXh0Q2hpbGRJRCIsIm5leHRDaGlsZCIsInBhcmVudElEIiwib25CZWZvcmVNb3VudENvbXBvbmVudCIsInVwZGF0ZUNvdW50Iiwib25CZWZvcmVVcGRhdGVDb21wb25lbnQiLCJvbk1vdW50Q29tcG9uZW50IiwiaXNSb290Iiwib25VcGRhdGVDb21wb25lbnQiLCJvblVubW91bnRDb21wb25lbnQiLCJwdXJnZVVubW91bnRlZENvbXBvbmVudHMiLCJfcHJldmVudFB1cmdpbmciLCJ0b3BFbGVtZW50IiwiY3VycmVudE93bmVyIiwiX2RlYnVnSUQiLCJnZXRTdGFja0FkZGVuZHVtQnlJRCIsImdldFBhcmVudElEIiwiZ2V0Q2hpbGRJRHMiLCJnZXRTb3VyY2UiLCJnZXRUZXh0IiwiZ2V0VXBkYXRlQ291bnQiLCJnZXRSZWdpc3RlcmVkSURzIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJkZWJ1Z0lEIiwidHlwZVNwZWNOYW1lIiwiZXgiLCJjb21wb25lbnRTdGFja0luZm8iLCJBTk9OWU1PVVMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJvb2wiLCJudW1iZXIiLCJzdHJpbmciLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwic2hhcGUiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiaXMiLCJ5IiwiUHJvcFR5cGVFcnJvciIsInN0YWNrIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImNhY2hlS2V5IiwibG9jYXRpb25OYW1lIiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BWYWx1ZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImlzTm9kZSIsInNoYXBlVHlwZXMiLCJldmVyeSIsImlzU3ltYm9sIiwiRGF0ZSIsIlJlYWN0RE9NQ29tcG9uZW50VHJlZSIsIlJlYWN0RGVmYXVsdEluamVjdGlvbiIsIlJlYWN0TW91bnQiLCJSZWFjdFJlY29uY2lsZXIiLCJSZWFjdFVwZGF0ZXMiLCJmaW5kRE9NTm9kZSIsImdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJpbmplY3QiLCJSZWFjdERPTSIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJDb21wb25lbnRUcmVlIiwiZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwiaW5zdCIsIl9yZW5kZXJlZENvbXBvbmVudCIsIk1vdW50IiwiUmVjb25jaWxlciIsIkV4ZWN1dGlvbkVudmlyb25tZW50IiwiY2FuVXNlRE9NIiwid2luZG93IiwidG9wIiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwic2hvd0ZpbGVVcmxNZXNzYWdlIiwicHJvdG9jb2wiLCJkZWJ1ZyIsInRlc3RGdW5jIiwidGVzdEZuIiwiaWVDb21wYXRpYmlsaXR5TW9kZSIsImRvY3VtZW50TW9kZSIsImV4cGVjdGVkRmVhdHVyZXMiLCJub3ciLCJ0cmltIiwiUmVhY3RJbnN0cnVtZW50YXRpb24iLCJSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2siLCJSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2siLCJSZWFjdERPTUludmFsaWRBUklBSG9vayIsImRlYnVnVG9vbCIsImFkZEhvb2siLCJET01Qcm9wZXJ0eSIsIlJlYWN0RE9NQ29tcG9uZW50RmxhZ3MiLCJBVFRSX05BTUUiLCJJRF9BVFRSSUJVVEVfTkFNRSIsIkZsYWdzIiwiaW50ZXJuYWxJbnN0YW5jZUtleSIsIk1hdGgiLCJyYW5kb20iLCJzbGljZSIsImdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQiLCJyZW5kZXJlZCIsInByZWNhY2hlTm9kZSIsImhvc3RJbnN0IiwiX2hvc3ROb2RlIiwidW5jYWNoZU5vZGUiLCJwcmVjYWNoZUNoaWxkTm9kZXMiLCJfZmxhZ3MiLCJoYXNDYWNoZWRDaGlsZE5vZGVzIiwiX3JlbmRlcmVkQ2hpbGRyZW4iLCJjaGlsZE5vZGUiLCJmaXJzdENoaWxkIiwib3V0ZXIiLCJjaGlsZEluc3QiLCJjaGlsZElEIiwiX2RvbUlEIiwibmV4dFNpYmxpbmciLCJub2RlVHlwZSIsImdldEF0dHJpYnV0ZSIsIm5vZGVWYWx1ZSIsInBhcmVudHMiLCJwYXJlbnROb2RlIiwiY2xvc2VzdCIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJfaG9zdFBhcmVudCIsImNoZWNrTWFzayIsImJpdG1hc2siLCJET01Qcm9wZXJ0eUluamVjdGlvbiIsIk1VU1RfVVNFX1BST1BFUlRZIiwiSEFTX0JPT0xFQU5fVkFMVUUiLCJIQVNfTlVNRVJJQ19WQUxVRSIsIkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFIiwiSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSIsImluamVjdERPTVByb3BlcnR5Q29uZmlnIiwiZG9tUHJvcGVydHlDb25maWciLCJJbmplY3Rpb24iLCJQcm9wZXJ0aWVzIiwiRE9NQXR0cmlidXRlTmFtZXNwYWNlcyIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwiRE9NUHJvcGVydHlOYW1lcyIsIkRPTU11dGF0aW9uTWV0aG9kcyIsImlzQ3VzdG9tQXR0cmlidXRlIiwiX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zIiwicHJvcGVydGllcyIsImxvd2VyQ2FzZWQiLCJ0b0xvd2VyQ2FzZSIsInByb3BDb25maWciLCJwcm9wZXJ0eUluZm8iLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwicHJvcGVydHlOYW1lIiwibXV0YXRpb25NZXRob2QiLCJtdXN0VXNlUHJvcGVydHkiLCJoYXNCb29sZWFuVmFsdWUiLCJoYXNOdW1lcmljVmFsdWUiLCJoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSIsImhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUiLCJnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZSIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJST09UX0FUVFJJQlVURV9OQU1FIiwiQVRUUklCVVRFX05BTUVfQ0hBUiIsImF1dG9mb2N1cyIsImlzQ3VzdG9tQXR0cmlidXRlRm4iLCJBUklBRE9NUHJvcGVydHlDb25maWciLCJCZWZvcmVJbnB1dEV2ZW50UGx1Z2luIiwiQ2hhbmdlRXZlbnRQbHVnaW4iLCJEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciIsIkVudGVyTGVhdmVFdmVudFBsdWdpbiIsIkhUTUxET01Qcm9wZXJ0eUNvbmZpZyIsIlJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50IiwiUmVhY3RET01Db21wb25lbnQiLCJSZWFjdERPTUVtcHR5Q29tcG9uZW50IiwiUmVhY3RET01UcmVlVHJhdmVyc2FsIiwiUmVhY3RET01UZXh0Q29tcG9uZW50IiwiUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSIsIlJlYWN0RXZlbnRMaXN0ZW5lciIsIlJlYWN0SW5qZWN0aW9uIiwiUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiIsIlNWR0RPTVByb3BlcnR5Q29uZmlnIiwiU2VsZWN0RXZlbnRQbHVnaW4iLCJTaW1wbGVFdmVudFBsdWdpbiIsImFscmVhZHlJbmplY3RlZCIsIkV2ZW50RW1pdHRlciIsImluamVjdFJlYWN0RXZlbnRMaXN0ZW5lciIsIkV2ZW50UGx1Z2luSHViIiwiaW5qZWN0RXZlbnRQbHVnaW5PcmRlciIsIkV2ZW50UGx1Z2luVXRpbHMiLCJpbmplY3RDb21wb25lbnRUcmVlIiwiaW5qZWN0VHJlZVRyYXZlcnNhbCIsImluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSIsIkhvc3RDb21wb25lbnQiLCJpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MiLCJpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MiLCJFbXB0eUNvbXBvbmVudCIsImluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeSIsImluc3RhbnRpYXRlIiwiVXBkYXRlcyIsImluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiaW5qZWN0QmF0Y2hpbmdTdHJhdGVneSIsImluamVjdEVudmlyb25tZW50IiwiRXZlbnRQcm9wYWdhdG9ycyIsIkZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJTeW50aGV0aWNJbnB1dEV2ZW50IiwiRU5EX0tFWUNPREVTIiwiU1RBUlRfS0VZQ09ERSIsImNhblVzZUNvbXBvc2l0aW9uRXZlbnQiLCJjYW5Vc2VUZXh0SW5wdXRFdmVudCIsImlzUHJlc3RvIiwidXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEiLCJvcGVyYSIsIlNQQUNFQkFSX0NPREUiLCJTUEFDRUJBUl9DSEFSIiwiZXZlbnRUeXBlcyIsImJlZm9yZUlucHV0IiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMiLCJidWJibGVkIiwiY2FwdHVyZWQiLCJkZXBlbmRlbmNpZXMiLCJjb21wb3NpdGlvbkVuZCIsImNvbXBvc2l0aW9uU3RhcnQiLCJjb21wb3NpdGlvblVwZGF0ZSIsImhhc1NwYWNlS2V5cHJlc3MiLCJpc0tleXByZXNzQ29tbWFuZCIsIm5hdGl2ZUV2ZW50IiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSIsInRvcExldmVsVHlwZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0Iiwia2V5Q29kZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJjdXJyZW50Q29tcG9zaXRpb24iLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsInRhcmdldEluc3QiLCJuYXRpdmVFdmVudFRhcmdldCIsImV2ZW50VHlwZSIsImZhbGxiYWNrRGF0YSIsImdldERhdGEiLCJldmVudCIsImN1c3RvbURhdGEiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsIndoaWNoIiwiY2hhcnMiLCJnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMiLCJleHRyYWN0QmVmb3JlSW5wdXRFdmVudCIsImV4dHJhY3RFdmVudHMiLCJhY2N1bXVsYXRlSW50byIsImZvckVhY2hBY2N1bXVsYXRlZCIsImdldExpc3RlbmVyIiwibGlzdGVuZXJBdFBoYXNlIiwicHJvcGFnYXRpb25QaGFzZSIsInJlZ2lzdHJhdGlvbk5hbWUiLCJkaXNwYXRjaENvbmZpZyIsImFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMiLCJwaGFzZSIsImxpc3RlbmVyIiwiX2Rpc3BhdGNoTGlzdGVuZXJzIiwiX2Rpc3BhdGNoSW5zdGFuY2VzIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsInRyYXZlcnNlVHdvUGhhc2UiLCJfdGFyZ2V0SW5zdCIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0IiwicGFyZW50SW5zdCIsImdldFBhcmVudEluc3RhbmNlIiwiYWNjdW11bGF0ZURpc3BhdGNoZXMiLCJpZ25vcmVkRGlyZWN0aW9uIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUiLCJldmVudHMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCIsImFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyIsImxlYXZlIiwiZW50ZXIiLCJ0cmF2ZXJzZUVudGVyTGVhdmUiLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyIsIkV2ZW50UGx1Z2luUmVnaXN0cnkiLCJSZWFjdEVycm9yVXRpbHMiLCJsaXN0ZW5lckJhbmsiLCJldmVudFF1ZXVlIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlIiwic2ltdWxhdGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiaXNQZXJzaXN0ZW50IiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwiLCJnZXREaWN0aW9uYXJ5S2V5IiwiX3Jvb3ROb2RlSUQiLCJpc0ludGVyYWN0aXZlIiwidGFnIiwic2hvdWxkUHJldmVudE1vdXNlRXZlbnQiLCJkaXNhYmxlZCIsInB1dExpc3RlbmVyIiwiYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUiLCJQbHVnaW5Nb2R1bGUiLCJyZWdpc3RyYXRpb25OYW1lTW9kdWxlcyIsImRpZFB1dExpc3RlbmVyIiwiX2N1cnJlbnRFbGVtZW50IiwiZGVsZXRlTGlzdGVuZXIiLCJ3aWxsRGVsZXRlTGlzdGVuZXIiLCJkZWxldGVBbGxMaXN0ZW5lcnMiLCJwbHVnaW5zIiwicG9zc2libGVQbHVnaW4iLCJleHRyYWN0ZWRFdmVudHMiLCJlbnF1ZXVlRXZlbnRzIiwicHJvY2Vzc0V2ZW50UXVldWUiLCJwcm9jZXNzaW5nRXZlbnRRdWV1ZSIsInJldGhyb3dDYXVnaHRFcnJvciIsIl9fcHVyZ2UiLCJfX2dldExpc3RlbmVyQmFuayIsImV2ZW50UGx1Z2luT3JkZXIiLCJuYW1lc1RvUGx1Z2lucyIsInJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nIiwicGx1Z2luTmFtZSIsInBsdWdpbk1vZHVsZSIsInBsdWdpbkluZGV4IiwicHVibGlzaGVkRXZlbnRzIiwiZXZlbnROYW1lIiwicHVibGlzaEV2ZW50Rm9yUGx1Z2luIiwiZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzIiwicGhhc2VOYW1lIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZSIsInB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsImxvd2VyQ2FzZWROYW1lIiwicG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyIsIm9uZGJsY2xpY2siLCJpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RlZE5hbWVzVG9QbHVnaW5zIiwiaXNPcmRlcmluZ0RpcnR5IiwiZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQiLCJfcmVzZXRFdmVudFBsdWdpbnMiLCJUcmVlVHJhdmVyc2FsIiwiSW5qZWN0ZWQiLCJpc0FuY2VzdG9yIiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpc0VuZGlzaCIsImlzTW92ZWlzaCIsImlzU3RhcnRpc2giLCJ2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyIsImRpc3BhdGNoTGlzdGVuZXJzIiwiZGlzcGF0Y2hJbnN0YW5jZXMiLCJsaXN0ZW5lcnNJc0FyciIsImxpc3RlbmVyc0xlbiIsImluc3RhbmNlc0lzQXJyIiwiaW5zdGFuY2VzTGVuIiwiZXhlY3V0ZURpc3BhdGNoIiwiY3VycmVudFRhcmdldCIsImludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlIiwicmV0IiwiZXhlY3V0ZURpcmVjdERpc3BhdGNoIiwiZGlzcGF0Y2hMaXN0ZW5lciIsImRpc3BhdGNoSW5zdGFuY2UiLCJyZXMiLCJoYXNEaXNwYXRjaGVzIiwiYXJnRnJvbSIsImFyZ1RvIiwiY2F1Z2h0RXJyb3IiLCJkaXNwYXRjaEV2ZW50IiwiY3JlYXRlRXZlbnQiLCJmYWtlTm9kZSIsImJvdW5kRnVuYyIsImV2dFR5cGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZ0IiwiaW5pdEV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFyciIsImNiIiwic2NvcGUiLCJjYW5Vc2VXb3JrZXJzIiwiV29ya2VyIiwiY2FuVXNlRXZlbnRMaXN0ZW5lcnMiLCJhdHRhY2hFdmVudCIsImNhblVzZVZpZXdwb3J0Iiwic2NyZWVuIiwiaXNJbldvcmtlciIsImdldFRleHRDb250ZW50QWNjZXNzb3IiLCJyb290IiwiX3Jvb3QiLCJfc3RhcnRUZXh0IiwiX2ZhbGxiYWNrVGV4dCIsInN0YXJ0Iiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJjb250ZW50S2V5IiwiZG9jdW1lbnRFbGVtZW50IiwiU3ludGhldGljRXZlbnQiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiZGlzcGF0Y2hNYXJrZXIiLCJhdWdtZW50Q2xhc3MiLCJkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSIsImlzUHJveHlTdXBwb3J0ZWQiLCJQcm94eSIsInNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudFBoYXNlIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJ0aW1lU3RhbXAiLCJkZWZhdWx0UHJldmVudGVkIiwiaXNUcnVzdGVkIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJJbnRlcmZhY2UiLCJub3JtYWxpemUiLCJyZXR1cm5WYWx1ZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsImNhbmNlbEJ1YmJsZSIsInBlcnNpc3QiLCJnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uIiwiY29uc3RydWN0IiwiY3JlYXRlIiwidGhhdCIsIkNsYXNzIiwiU3VwZXIiLCJFIiwiZ2V0VmFsIiwiYWN0aW9uIiwid2FybiIsIndhcm5pbmdDb25kaXRpb24iLCJJbnB1dEV2ZW50SW50ZXJmYWNlIiwiZ2V0RXZlbnRUYXJnZXQiLCJpc0V2ZW50U3VwcG9ydGVkIiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiY2hhbmdlIiwiYWN0aXZlRWxlbWVudCIsImFjdGl2ZUVsZW1lbnRJbnN0IiwiYWN0aXZlRWxlbWVudFZhbHVlIiwiYWN0aXZlRWxlbWVudFZhbHVlUHJvcCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwiZWxlbSIsIm5vZGVOYW1lIiwiZG9lc0NoYW5nZUV2ZW50QnViYmxlIiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsInN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCIsInN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4IiwiZGV0YWNoRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQiLCJoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCIsImlzSW5wdXRFdmVudFN1cHBvcnRlZCIsIm5ld1ZhbHVlUHJvcCIsInN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImhhbmRsZVByb3BlcnR5Q2hhbmdlIiwic3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJzcmNFbGVtZW50IiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQiLCJoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudElFIiwic2hvdWxkVXNlQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50IiwidGFyZ2V0Tm9kZSIsImdldFRhcmdldEluc3RGdW5jIiwiaGFuZGxlRXZlbnRGdW5jIiwiQ2FsbGJhY2tRdWV1ZSIsIlJlYWN0RmVhdHVyZUZsYWdzIiwiVHJhbnNhY3Rpb24iLCJkaXJ0eUNvbXBvbmVudHMiLCJ1cGRhdGVCYXRjaE51bWJlciIsImFzYXBDYWxsYmFja1F1ZXVlIiwiYXNhcEVucXVldWVkIiwiYmF0Y2hpbmdTdHJhdGVneSIsImVuc3VyZUluamVjdGVkIiwiTkVTVEVEX1VQREFURVMiLCJpbml0aWFsaXplIiwiZGlydHlDb21wb25lbnRzTGVuZ3RoIiwiY2xvc2UiLCJzcGxpY2UiLCJmbHVzaEJhdGNoZWRVcGRhdGVzIiwiVVBEQVRFX1FVRVVFSU5HIiwiY2FsbGJhY2tRdWV1ZSIsInJlc2V0Iiwibm90aWZ5QWxsIiwiVFJBTlNBQ1RJT05fV1JBUFBFUlMiLCJSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uIiwicmVpbml0aWFsaXplVHJhbnNhY3Rpb24iLCJyZWNvbmNpbGVUcmFuc2FjdGlvbiIsImdldFRyYW5zYWN0aW9uV3JhcHBlcnMiLCJwZXJmb3JtIiwibW91bnRPcmRlckNvbXBhcmF0b3IiLCJjMSIsImMyIiwiX21vdW50T3JkZXIiLCJydW5CYXRjaGVkVXBkYXRlcyIsInRyYW5zYWN0aW9uIiwic29ydCIsImNhbGxiYWNrcyIsIl9wZW5kaW5nQ2FsbGJhY2tzIiwibWFya2VyTmFtZSIsImxvZ1RvcExldmVsUmVuZGVycyIsIm5hbWVkQ29tcG9uZW50IiwiaXNSZWFjdFRvcExldmVsV3JhcHBlciIsInBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSIsInRpbWVFbmQiLCJqIiwiZW5xdWV1ZSIsImdldFB1YmxpY0luc3RhbmNlIiwiZW5xdWV1ZVVwZGF0ZSIsImlzQmF0Y2hpbmdVcGRhdGVzIiwiX3VwZGF0ZUJhdGNoTnVtYmVyIiwiYXNhcCIsIlJlYWN0VXBkYXRlc0luamVjdGlvbiIsIlJlY29uY2lsZVRyYW5zYWN0aW9uIiwiX2JhdGNoaW5nU3RyYXRlZ3kiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY2FsbGJhY2tzIiwiX2NvbnRleHRzIiwiX2FyZyIsImNvbnRleHRzIiwiY2hlY2twb2ludCIsInJvbGxiYWNrIiwiUmVhY3RSZWYiLCJhdHRhY2hSZWZzIiwibW91bnRDb21wb25lbnQiLCJpbnRlcm5hbEluc3RhbmNlIiwiaG9zdFBhcmVudCIsImhvc3RDb250YWluZXJJbmZvIiwicGFyZW50RGVidWdJRCIsIm1hcmt1cCIsImdldFJlYWN0TW91bnRSZWFkeSIsImdldEhvc3ROb2RlIiwidW5tb3VudENvbXBvbmVudCIsInNhZmVseSIsIm9uQmVmb3JlVW5tb3VudENvbXBvbmVudCIsImRldGFjaFJlZnMiLCJyZWNlaXZlQ29tcG9uZW50IiwibmV4dEVsZW1lbnQiLCJwcmV2RWxlbWVudCIsIl9jb250ZXh0IiwicmVmc0NoYW5nZWQiLCJzaG91bGRVcGRhdGVSZWZzIiwiUmVhY3RPd25lciIsImF0dGFjaFJlZiIsImFkZENvbXBvbmVudEFzUmVmVG8iLCJkZXRhY2hSZWYiLCJyZW1vdmVDb21wb25lbnRBc1JlZkZyb20iLCJwcmV2UmVmIiwicHJldk93bmVyIiwibmV4dFJlZiIsIm5leHRPd25lciIsImlzVmFsaWRPd25lciIsIm93bmVyUHVibGljSW5zdGFuY2UiLCJSZWFjdERlYnVnVG9vbCIsIlJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2siLCJSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayIsInBlcmZvcm1hbmNlTm93IiwiaG9va3MiLCJkaWRIb29rVGhyb3dGb3JFdmVudCIsImNhbGxIb29rIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsImFyZzUiLCJlbWl0RXZlbnQiLCJob29rIiwiaXNQcm9maWxpbmciLCJmbHVzaEhpc3RvcnkiLCJsaWZlQ3ljbGVUaW1lclN0YWNrIiwiY3VycmVudEZsdXNoTmVzdGluZyIsImN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyIsImN1cnJlbnRGbHVzaFN0YXJ0VGltZSIsImN1cnJlbnRUaW1lckRlYnVnSUQiLCJjdXJyZW50VGltZXJTdGFydFRpbWUiLCJjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uIiwiY3VycmVudFRpbWVyVHlwZSIsImxpZmVDeWNsZVRpbWVySGFzV2FybmVkIiwiY2xlYXJIaXN0b3J5IiwiZ2V0VHJlZVNuYXBzaG90IiwicmVnaXN0ZXJlZElEcyIsInJlZHVjZSIsInRyZWUiLCJyZXNldE1lYXN1cmVtZW50cyIsInByZXZpb3VzU3RhcnRUaW1lIiwicHJldmlvdXNNZWFzdXJlbWVudHMiLCJwcmV2aW91c09wZXJhdGlvbnMiLCJnZXRIaXN0b3J5IiwiZHVyYXRpb24iLCJtZWFzdXJlbWVudHMiLCJvcGVyYXRpb25zIiwidHJlZVNuYXBzaG90IiwiY2hlY2tEZWJ1Z0lEIiwiYWxsb3dSb290IiwiYmVnaW5MaWZlQ3ljbGVUaW1lciIsInRpbWVyVHlwZSIsImVuZExpZmVDeWNsZVRpbWVyIiwiaW5zdGFuY2VJRCIsInBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyIiwiY3VycmVudFRpbWVyIiwic3RhcnRUaW1lIiwibmVzdGVkRmx1c2hTdGFydFRpbWUiLCJyZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIiLCJfbGlmZUN5Y2xlVGltZXJTdGFjayQiLCJuZXN0ZWRGbHVzaER1cmF0aW9uIiwibGFzdE1hcmtUaW1lU3RhbXAiLCJjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUiLCJwZXJmb3JtYW5jZSIsImNsZWFyTWFya3MiLCJtZWFzdXJlIiwiY2xlYXJNZWFzdXJlcyIsInNob3VsZE1hcmsiLCJpc0hvc3RFbGVtZW50IiwibWFya0JlZ2luIiwibWFya1R5cGUiLCJtYXJrTmFtZSIsIm1hcmtFbmQiLCJtZWFzdXJlbWVudE5hbWUiLCJyZW1vdmVIb29rIiwiYmVnaW5Qcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJnZXRGbHVzaEhpc3RvcnkiLCJvbkJlZ2luRmx1c2giLCJvbkVuZEZsdXNoIiwib25CZWdpbkxpZmVDeWNsZVRpbWVyIiwib25FbmRMaWZlQ3ljbGVUaW1lciIsIm9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Iiwib25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Iiwib25Ib3N0T3BlcmF0aW9uIiwib3BlcmF0aW9uIiwib25TZXRTdGF0ZSIsImNoaWxkRGVidWdJRHMiLCJvblRlc3RFdmVudCIsImFkZERldnRvb2wiLCJyZW1vdmVEZXZ0b29sIiwidXJsIiwiaHJlZiIsInByb2Nlc3NpbmdDaGlsZENvbnRleHQiLCJ3YXJuSW52YWxpZFNldFN0YXRlIiwiaGlzdG9yeSIsIl9wcmV2ZW50Q2xlYXJpbmciLCJtc1BlcmZvcm1hbmNlIiwid2Via2l0UGVyZm9ybWFuY2UiLCJPQlNFUlZFRF9FUlJPUiIsIlRyYW5zYWN0aW9uSW1wbCIsInRyYW5zYWN0aW9uV3JhcHBlcnMiLCJ3cmFwcGVySW5pdERhdGEiLCJfaXNJblRyYW5zYWN0aW9uIiwiaXNJblRyYW5zYWN0aW9uIiwiZXJyb3JUaHJvd24iLCJpbml0aWFsaXplQWxsIiwiY2xvc2VBbGwiLCJzdGFydEluZGV4Iiwid3JhcHBlciIsImluaXREYXRhIiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJ1c2VIYXNGZWF0dXJlIiwiaW1wbGVtZW50YXRpb24iLCJoYXNGZWF0dXJlIiwiZXZlbnROYW1lU3VmZml4IiwiY2FwdHVyZSIsImlzU3VwcG9ydGVkIiwic2V0QXR0cmlidXRlIiwic3VwcG9ydGVkSW5wdXRUeXBlcyIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJtb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsIndpbiIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsInBhcmVudFdpbmRvdyIsInJlbGF0ZWQiLCJ0b0VsZW1lbnQiLCJmcm9tTm9kZSIsInRvTm9kZSIsIlN5bnRoZXRpY1VJRXZlbnQiLCJWaWV3cG9ydE1ldHJpY3MiLCJnZXRFdmVudE1vZGlmaWVyU3RhdGUiLCJNb3VzZUV2ZW50SW50ZXJmYWNlIiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsInNoaWZ0S2V5IiwiZ2V0TW9kaWZpZXJTdGF0ZSIsImJ1dHRvbnMiLCJwYWdlWCIsImN1cnJlbnRTY3JvbGxMZWZ0IiwicGFnZVkiLCJjdXJyZW50U2Nyb2xsVG9wIiwiVUlFdmVudEludGVyZmFjZSIsInZpZXciLCJyZWZyZXNoU2Nyb2xsVmFsdWVzIiwic2Nyb2xsUG9zaXRpb24iLCJtb2RpZmllcktleVRvUHJvcCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJhY2NlcHQiLCJhY2NlcHRDaGFyc2V0IiwiYWNjZXNzS2V5IiwiYWxsb3dGdWxsU2NyZWVuIiwiYWxsb3dUcmFuc3BhcmVuY3kiLCJhbHQiLCJhcyIsImFzeW5jIiwiYXV0b0NvbXBsZXRlIiwiYXV0b1BsYXkiLCJjZWxsUGFkZGluZyIsImNlbGxTcGFjaW5nIiwiY2hhclNldCIsImNoYWxsZW5nZSIsImNoZWNrZWQiLCJjbGFzc0lEIiwiY2xhc3NOYW1lIiwiY29scyIsImNvbFNwYW4iLCJjb250ZW50IiwiY29udGVudEVkaXRhYmxlIiwiY29udGV4dE1lbnUiLCJjb250cm9scyIsImNvb3JkcyIsImNyb3NzT3JpZ2luIiwiZGF0ZVRpbWUiLCJkZWZlciIsImRvd25sb2FkIiwiZHJhZ2dhYmxlIiwiZW5jVHlwZSIsImZvcm1BY3Rpb24iLCJmb3JtRW5jVHlwZSIsImZvcm1NZXRob2QiLCJmb3JtTm9WYWxpZGF0ZSIsImZvcm1UYXJnZXQiLCJmcmFtZUJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWRkZW4iLCJoaWdoIiwiaHJlZkxhbmciLCJodG1sRm9yIiwiaHR0cEVxdWl2IiwiaWNvbiIsImlucHV0TW9kZSIsImludGVncml0eSIsImtleVBhcmFtcyIsImtleVR5cGUiLCJraW5kIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW5IZWlnaHQiLCJtYXJnaW5XaWR0aCIsIm1heCIsIm1heExlbmd0aCIsIm1lZGlhIiwibWVkaWFHcm91cCIsIm1pbiIsIm1pbkxlbmd0aCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub25jZSIsIm5vVmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBsYWNlaG9sZGVyIiwicGxheXNJbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvR3JvdXAiLCJyZWFkT25seSIsInJlZmVycmVyUG9saWN5IiwicmVsIiwicmVxdWlyZWQiLCJyZXZlcnNlZCIsInJvbGUiLCJyb3dzIiwicm93U3BhbiIsInNhbmRib3giLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2l6ZSIsInNpemVzIiwic3BlbGxDaGVjayIsInNyYyIsInNyY0RvYyIsInNyY0xhbmciLCJzcmNTZXQiLCJ0YWJJbmRleCIsInVzZU1hcCIsIndpZHRoIiwid21vZGUiLCJ3cmFwIiwiYWJvdXQiLCJkYXRhdHlwZSIsImlubGlzdCIsInJlc291cmNlIiwidm9jYWIiLCJhdXRvQ2FwaXRhbGl6ZSIsImF1dG9Db3JyZWN0IiwiYXV0b1NhdmUiLCJjb2xvciIsIml0ZW1Qcm9wIiwiaXRlbVNjb3BlIiwiaXRlbVR5cGUiLCJpdGVtSUQiLCJpdGVtUmVmIiwicmVzdWx0cyIsInNlY3VyaXR5IiwidW5zZWxlY3RhYmxlIiwiRE9NQ2hpbGRyZW5PcGVyYXRpb25zIiwiUmVhY3RET01JRE9wZXJhdGlvbnMiLCJwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwiZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwicmVwbGFjZU5vZGVXaXRoTWFya3VwIiwiZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAiLCJET01MYXp5VHJlZSIsIkRhbmdlciIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJzZXRJbm5lckhUTUwiLCJzZXRUZXh0Q29udGVudCIsImdldE5vZGVBZnRlciIsImluc2VydENoaWxkQXQiLCJyZWZlcmVuY2VOb2RlIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0TGF6eVRyZWVDaGlsZEF0IiwiY2hpbGRUcmVlIiwiaW5zZXJ0VHJlZUJlZm9yZSIsIm1vdmVDaGlsZCIsIm1vdmVEZWxpbWl0ZWRUZXh0IiwicmVtb3ZlQ2hpbGQiLCJjbG9zaW5nQ29tbWVudCIsInJlbW92ZURlbGltaXRlZFRleHQiLCJvcGVuaW5nQ29tbWVudCIsIm5leHROb2RlIiwic3RhcnROb2RlIiwicmVwbGFjZURlbGltaXRlZFRleHQiLCJzdHJpbmdUZXh0Iiwibm9kZUFmdGVyQ29tbWVudCIsImNyZWF0ZVRleHROb2RlIiwicGF5bG9hZCIsIm9sZENoaWxkIiwicHJldkluc3RhbmNlIiwibmV4dEluc3RhbmNlIiwicHJvY2Vzc1VwZGF0ZXMiLCJ1cGRhdGVzIiwicGFyZW50Tm9kZURlYnVnSUQiLCJrIiwidXBkYXRlIiwiYWZ0ZXJOb2RlIiwidG9JbmRleCIsImZyb21JbmRleCIsIkRPTU5hbWVzcGFjZXMiLCJFTEVNRU5UX05PREVfVFlQRSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSIsImVuYWJsZUxhenkiLCJpbnNlcnRUcmVlQ2hpbGRyZW4iLCJuYW1lc3BhY2VVUkkiLCJyZXBsYWNlQ2hpbGRXaXRoVHJlZSIsIm9sZE5vZGUiLCJuZXdUcmVlIiwicmVwbGFjZUNoaWxkIiwicXVldWVDaGlsZCIsInBhcmVudFRyZWUiLCJhcHBlbmRDaGlsZCIsInF1ZXVlSFRNTCIsInF1ZXVlVGV4dCIsIm1hdGhtbCIsIldISVRFU1BBQ0VfVEVTVCIsIk5PTlZJU0lCTEVfVEVTVCIsInJldXNhYmxlU1ZHQ29udGFpbmVyIiwiaW5uZXJIVE1MIiwic3ZnTm9kZSIsInRlc3RFbGVtZW50IiwidGV4dE5vZGUiLCJkZWxldGVEYXRhIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIiLCJsYXN0Q2hpbGQiLCJ0ZXh0Q29udGVudCIsIm1hdGNoSHRtbFJlZ0V4cCIsImVzY2FwZUh0bWwiLCJzdHIiLCJleGVjIiwibGFzdEluZGV4IiwiY2hhckNvZGVBdCIsImNyZWF0ZU5vZGVzRnJvbU1hcmt1cCIsIm5ld0NoaWxkIiwiY3JlYXRlQXJyYXlGcm9tTWl4ZWQiLCJnZXRNYXJrdXBXcmFwIiwiZHVtbXlOb2RlIiwibm9kZU5hbWVQYXR0ZXJuIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZU1hdGNoIiwiaGFuZGxlU2NyaXB0Iiwid3JhcERlcHRoIiwic2NyaXB0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibm9kZXMiLCJjaGlsZE5vZGVzIiwib2JqIiwiY2FsbGVlIiwiaGFzQXJyYXlOYXR1cmUiLCJzaG91bGRXcmFwIiwic2VsZWN0V3JhcCIsInRhYmxlV3JhcCIsInRyV3JhcCIsInN2Z1dyYXAiLCJtYXJrdXBXcmFwIiwic3ZnRWxlbWVudHMiLCJBdXRvRm9jdXNVdGlscyIsIkNTU1Byb3BlcnR5T3BlcmF0aW9ucyIsIkRPTVByb3BlcnR5T3BlcmF0aW9ucyIsIlJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciIsIlJlYWN0RE9NSW5wdXQiLCJSZWFjdERPTU9wdGlvbiIsIlJlYWN0RE9NU2VsZWN0IiwiUmVhY3RET01UZXh0YXJlYSIsIlJlYWN0TXVsdGlDaGlsZCIsIlJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24iLCJzaGFsbG93RXF1YWwiLCJ2YWxpZGF0ZURPTU5lc3RpbmciLCJnZXROb2RlIiwibGlzdGVuVG8iLCJDT05URU5UX1RZUEVTIiwiU1RZTEUiLCJIVE1MIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJET0NfRlJBR01FTlRfVFlQRSIsImZyaWVuZGx5U3RyaW5naWZ5Iiwia2V5RXNjYXBlZCIsInN0eWxlTXV0YXRpb25XYXJuaW5nIiwiY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlIiwic3R5bGUxIiwic3R5bGUyIiwiX3RhZyIsImhhc2giLCJhc3NlcnRWYWxpZFByb3BzIiwidm9pZEVsZW1lbnRUYWdzIiwib25Gb2N1c0luIiwib25Gb2N1c091dCIsImVucXVldWVQdXRMaXN0ZW5lciIsImNvbnRhaW5lckluZm8iLCJfaG9zdENvbnRhaW5lckluZm8iLCJpc0RvY3VtZW50RnJhZ21lbnQiLCJfbm9kZSIsIl9vd25lckRvY3VtZW50IiwibGlzdGVuZXJUb1B1dCIsImlucHV0UG9zdE1vdW50IiwicG9zdE1vdW50V3JhcHBlciIsInRleHRhcmVhUG9zdE1vdW50Iiwib3B0aW9uUG9zdE1vdW50Iiwic2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYiLCJoYXNFeGlzdGluZ0NvbnRlbnQiLCJfY29udGVudERlYnVnSUQiLCJjb250ZW50RGVidWdJRCIsIl9hbmNlc3RvckluZm8iLCJtZWRpYUV2ZW50cyIsInRvcEFib3J0IiwidG9wQ2FuUGxheSIsInRvcENhblBsYXlUaHJvdWdoIiwidG9wRHVyYXRpb25DaGFuZ2UiLCJ0b3BFbXB0aWVkIiwidG9wRW5jcnlwdGVkIiwidG9wRW5kZWQiLCJ0b3BFcnJvciIsInRvcExvYWRlZERhdGEiLCJ0b3BMb2FkZWRNZXRhZGF0YSIsInRvcExvYWRTdGFydCIsInRvcFBhdXNlIiwidG9wUGxheSIsInRvcFBsYXlpbmciLCJ0b3BQcm9ncmVzcyIsInRvcFJhdGVDaGFuZ2UiLCJ0b3BTZWVrZWQiLCJ0b3BTZWVraW5nIiwidG9wU3RhbGxlZCIsInRvcFN1c3BlbmQiLCJ0b3BUaW1lVXBkYXRlIiwidG9wVm9sdW1lQ2hhbmdlIiwidG9wV2FpdGluZyIsInRyYXBCdWJibGVkRXZlbnRzTG9jYWwiLCJfd3JhcHBlclN0YXRlIiwibGlzdGVuZXJzIiwidHJhcEJ1YmJsZWRFdmVudCIsInBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyIiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJvbWl0dGVkQ2xvc2VUYWdzIiwibmV3bGluZUVhdGluZ1RhZ3MiLCJWQUxJRF9UQUdfUkVHRVgiLCJ2YWxpZGF0ZWRUYWdDYWNoZSIsInZhbGlkYXRlRGFuZ2Vyb3VzVGFnIiwiaXNDdXN0b21Db21wb25lbnQiLCJ0YWdOYW1lIiwiZ2xvYmFsSWRDb3VudGVyIiwiX25hbWVzcGFjZVVSSSIsIl9wcmV2aW91c1N0eWxlIiwiX3ByZXZpb3VzU3R5bGVDb3B5IiwiX3RvcExldmVsV3JhcHBlciIsIk1peGluIiwiX2lkQ291bnRlciIsIm1vdW50V3JhcHBlciIsImdldEhvc3RQcm9wcyIsInBhcmVudFRhZyIsInBhcmVudEluZm8iLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwibW91bnRJbWFnZSIsInVzZUNyZWF0ZUVsZW1lbnQiLCJlbCIsImNyZWF0ZUVsZW1lbnROUyIsInNldEF0dHJpYnV0ZUZvclJvb3QiLCJfdXBkYXRlRE9NUHJvcGVydGllcyIsImxhenlUcmVlIiwiX2NyZWF0ZUluaXRpYWxDaGlsZHJlbiIsInRhZ09wZW4iLCJfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyIsInRhZ0NvbnRlbnQiLCJfY3JlYXRlQ29udGVudE1hcmt1cCIsImF1dG9Gb2N1cyIsImZvY3VzRE9NQ29tcG9uZW50IiwicHJvcEtleSIsImNyZWF0ZU1hcmt1cEZvclN0eWxlcyIsImNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZSIsImNyZWF0ZU1hcmt1cEZvclByb3BlcnR5IiwicmVuZGVyVG9TdGF0aWNNYXJrdXAiLCJjcmVhdGVNYXJrdXBGb3JSb290IiwiY3JlYXRlTWFya3VwRm9ySUQiLCJfX2h0bWwiLCJjb250ZW50VG9Vc2UiLCJjaGlsZHJlblRvVXNlIiwibW91bnRJbWFnZXMiLCJtb3VudENoaWxkcmVuIiwiY2hhckF0IiwibGFzdFByb3BzIiwibmV4dFByb3BzIiwiX3VwZGF0ZURPTUNoaWxkcmVuIiwidXBkYXRlV3JhcHBlciIsInN0eWxlTmFtZSIsInN0eWxlVXBkYXRlcyIsImxhc3RTdHlsZSIsImRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlIiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm5leHRQcm9wIiwibGFzdFByb3AiLCJzZXRWYWx1ZUZvckF0dHJpYnV0ZSIsInNldFZhbHVlRm9yUHJvcGVydHkiLCJzZXRWYWx1ZUZvclN0eWxlcyIsImxhc3RDb250ZW50IiwibmV4dENvbnRlbnQiLCJsYXN0SHRtbCIsIm5leHRIdG1sIiwibGFzdENoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibGFzdEhhc0NvbnRlbnRPckh0bWwiLCJuZXh0SGFzQ29udGVudE9ySHRtbCIsInVwZGF0ZUNoaWxkcmVuIiwidXBkYXRlVGV4dENvbnRlbnQiLCJ1cGRhdGVNYXJrdXAiLCJyZW1vdmUiLCJ1bm1vdW50Q2hpbGRyZW4iLCJmb2N1c05vZGUiLCJmb2N1cyIsIkNTU1Byb3BlcnR5IiwiY2FtZWxpemVTdHlsZU5hbWUiLCJkYW5nZXJvdXNTdHlsZVZhbHVlIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwibWVtb2l6ZVN0cmluZ09ubHkiLCJwcm9jZXNzU3R5bGVOYW1lIiwiaGFzU2hvcnRoYW5kUHJvcGVydHlCdWciLCJzdHlsZUZsb2F0QWNjZXNzb3IiLCJ0ZW1wU3R5bGUiLCJmb250IiwiY3NzRmxvYXQiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwiY2hlY2tSZW5kZXJNZXNzYWdlIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwidG9VcHBlckNhc2UiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblZhbGlkU3R5bGUiLCJpc05hTiIsInN0eWxlcyIsInNlcmlhbGl6ZWQiLCJzdHlsZVZhbHVlIiwiZXhwYW5zaW9uIiwic2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zIiwiaW5kaXZpZHVhbFN0eWxlTmFtZSIsImlzVW5pdGxlc3NOdW1iZXIiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRDb2x1bW4iLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsInByZWZpeGVzIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRBdHRhY2htZW50IiwiYmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFBvc2l0aW9uWCIsImJhY2tncm91bmRQb3NpdGlvblkiLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYm9yZGVyIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJTdHlsZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckJvdHRvbUNvbG9yIiwiYm9yZGVyTGVmdCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlckxlZnRTdHlsZSIsImJvcmRlckxlZnRDb2xvciIsImJvcmRlclJpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlclJpZ2h0U3R5bGUiLCJib3JkZXJSaWdodENvbG9yIiwiYm9yZGVyVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJUb3BTdHlsZSIsImJvcmRlclRvcENvbG9yIiwiZm9udFN0eWxlIiwiZm9udFZhcmlhbnQiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJvdXRsaW5lIiwib3V0bGluZVdpZHRoIiwib3V0bGluZVN0eWxlIiwib3V0bGluZUNvbG9yIiwiY2FtZWxpemUiLCJtc1BhdHRlcm4iLCJfaHlwaGVuUGF0dGVybiIsIl8iLCJjaGFyYWN0ZXIiLCJzdHlsZVdhcm5pbmdzIiwiaXNFbXB0eSIsImlzTm9uTnVtZXJpYyIsIndhcm5pbmdzIiwiaHlwaGVuYXRlIiwiX3VwcGVyY2FzZVBhdHRlcm4iLCJjYWNoZSIsInF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInNob3VsZElnbm9yZVZhbHVlIiwic2V0QXR0cmlidXRlRm9ySUQiLCJuYW1lc3BhY2UiLCJzZXRBdHRyaWJ1dGVOUyIsInJlbW92ZUF0dHJpYnV0ZSIsIlJlYWN0RXZlbnRFbWl0dGVyTWl4aW4iLCJnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSIsImhhc0V2ZW50UGFnZVhZIiwiYWxyZWFkeUxpc3RlbmluZ1RvIiwiaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUiLCJyZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIiLCJ0b3BFdmVudE1hcHBpbmciLCJ0b3BBbmltYXRpb25FbmQiLCJ0b3BBbmltYXRpb25JdGVyYXRpb24iLCJ0b3BBbmltYXRpb25TdGFydCIsInRvcEJsdXIiLCJ0b3BDaGFuZ2UiLCJ0b3BDbGljayIsInRvcENvbXBvc2l0aW9uRW5kIiwidG9wQ29tcG9zaXRpb25TdGFydCIsInRvcENvbXBvc2l0aW9uVXBkYXRlIiwidG9wQ29udGV4dE1lbnUiLCJ0b3BDb3B5IiwidG9wQ3V0IiwidG9wRG91YmxlQ2xpY2siLCJ0b3BEcmFnIiwidG9wRHJhZ0VuZCIsInRvcERyYWdFbnRlciIsInRvcERyYWdFeGl0IiwidG9wRHJhZ0xlYXZlIiwidG9wRHJhZ092ZXIiLCJ0b3BEcmFnU3RhcnQiLCJ0b3BEcm9wIiwidG9wRm9jdXMiLCJ0b3BJbnB1dCIsInRvcEtleURvd24iLCJ0b3BLZXlQcmVzcyIsInRvcEtleVVwIiwidG9wTW91c2VEb3duIiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGFzdGUiLCJ0b3BTY3JvbGwiLCJ0b3BTZWxlY3Rpb25DaGFuZ2UiLCJ0b3BUZXh0SW5wdXQiLCJ0b3BUb3VjaENhbmNlbCIsInRvcFRvdWNoRW5kIiwidG9wVG91Y2hNb3ZlIiwidG9wVG91Y2hTdGFydCIsInRvcFRyYW5zaXRpb25FbmQiLCJ0b3BXaGVlbCIsInRvcExpc3RlbmVyc0lES2V5IiwiZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQiLCJtb3VudEF0Iiwic2V0SGFuZGxlVG9wTGV2ZWwiLCJoYW5kbGVUb3BMZXZlbCIsInNldEVuYWJsZWQiLCJlbmFibGVkIiwiaXNFbmFibGVkIiwiY29udGVudERvY3VtZW50SGFuZGxlIiwiaXNMaXN0ZW5pbmciLCJkZXBlbmRlbmN5IiwidHJhcENhcHR1cmVkRXZlbnQiLCJXSU5ET1dfSEFORExFIiwiaGFuZGxlckJhc2VOYW1lIiwiaGFuZGxlIiwic3VwcG9ydHNFdmVudFBhZ2VYWSIsImV2IiwiZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nIiwicmVmcmVzaCIsIm1vbml0b3JTY3JvbGxWYWx1ZSIsInJ1bkV2ZW50UXVldWVJbkJhdGNoIiwibWFrZVByZWZpeE1hcCIsInN0eWxlUHJvcCIsInZlbmRvclByZWZpeGVzIiwiYW5pbWF0aW9uZW5kIiwiYW5pbWF0aW9uaXRlcmF0aW9uIiwiYW5pbWF0aW9uc3RhcnQiLCJ0cmFuc2l0aW9uZW5kIiwicHJlZml4ZWRFdmVudE5hbWVzIiwiYW5pbWF0aW9uIiwidHJhbnNpdGlvbiIsInByZWZpeE1hcCIsIkxpbmtlZFZhbHVlVXRpbHMiLCJkaWRXYXJuVmFsdWVMaW5rIiwiZGlkV2FybkNoZWNrZWRMaW5rIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiZm9yY2VVcGRhdGVJZk1vdW50ZWQiLCJpc0NvbnRyb2xsZWQiLCJ1c2VzQ2hlY2tlZCIsImdldFZhbHVlIiwiZ2V0Q2hlY2tlZCIsImhvc3RQcm9wcyIsImRlZmF1bHRDaGVja2VkIiwiZGVmYXVsdFZhbHVlIiwiaW5pdGlhbFZhbHVlIiwiaW5pdGlhbENoZWNrZWQiLCJvbkNoYW5nZSIsImNoZWNrUHJvcFR5cGVzIiwidmFsdWVMaW5rIiwiY2hlY2tlZExpbmsiLCJfaGFuZGxlQ2hhbmdlIiwiY29udHJvbGxlZCIsIm5ld1ZhbHVlIiwiZXhlY3V0ZU9uQ2hhbmdlIiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJncm91cCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvdGhlck5vZGUiLCJvdGhlckluc3RhbmNlIiwiaGFzUmVhZE9ubHlWYWx1ZSIsIl9hc3NlcnRTaW5nbGVMaW5rIiwiaW5wdXRQcm9wcyIsIl9hc3NlcnRWYWx1ZUxpbmsiLCJfYXNzZXJ0Q2hlY2tlZExpbmsiLCJyZXF1ZXN0Q2hhbmdlIiwiZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiIsImZsYXR0ZW5DaGlsZHJlbiIsInNlbGVjdFZhbHVlIiwic2VsZWN0UGFyZW50IiwiZ2V0U2VsZWN0VmFsdWVDb250ZXh0IiwidXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQiLCJwZW5kaW5nVXBkYXRlIiwidXBkYXRlT3B0aW9ucyIsIkJvb2xlYW4iLCJ2YWx1ZVByb3BOYW1lcyIsImNoZWNrU2VsZWN0UHJvcFR5cGVzIiwic2VsZWN0ZWRWYWx1ZSIsIm9wdGlvbnMiLCJ3YXNNdWx0aXBsZSIsImRpZFdhcm5WYWxEZWZhdWx0VmFsIiwiUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCIsIlJlYWN0SW5zdGFuY2VNYXAiLCJSZWFjdENoaWxkUmVjb25jaWxlciIsIm1ha2VJbnNlcnRNYXJrdXAiLCJtYWtlTW92ZSIsIl9tb3VudEluZGV4IiwibWFrZVJlbW92ZSIsIm1ha2VTZXRNYXJrdXAiLCJtYWtlVGV4dENvbnRlbnQiLCJwcm9jZXNzUXVldWUiLCJ1cGRhdGVRdWV1ZSIsInNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uIiwiZ2V0RGVidWdJRCIsImludGVybmFsIiwiX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuIiwibmVzdGVkQ2hpbGRyZW4iLCJzZWxmRGVidWdJRCIsImluc3RhbnRpYXRlQ2hpbGRyZW4iLCJfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuIiwicHJldkNoaWxkcmVuIiwibmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMiLCJyZW1vdmVkTm9kZXMiLCJuZXh0TWFya3VwIiwiX3VwZGF0ZUNoaWxkcmVuIiwibmV4dEluZGV4IiwibmV4dE1vdW50SW5kZXgiLCJsYXN0UGxhY2VkTm9kZSIsInByZXZDaGlsZCIsIl9tb3VudENoaWxkQXRJbmRleCIsIl91bm1vdW50Q2hpbGQiLCJyZW5kZXJlZENoaWxkcmVuIiwiY3JlYXRlQ2hpbGQiLCJpbmplY3RlZCIsImVudmlyb25tZW50IiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImhhcyIsImluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQiLCJzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCIsImluc3RhbnRpYXRlQ2hpbGQiLCJjaGlsZEluc3RhbmNlcyIsImtleVVuaXF1ZSIsIm5lc3RlZENoaWxkTm9kZXMiLCJjaGlsZEluc3RzIiwibmV4dENoaWxkSW5zdGFuY2UiLCJuZXh0Q2hpbGRNb3VudEltYWdlIiwicmVuZGVyZWRDaGlsZCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IiwiUmVhY3RFbXB0eUNvbXBvbmVudCIsIlJlYWN0SG9zdENvbXBvbmVudCIsImdldE5leHREZWJ1Z0lEIiwiUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyIiwiX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQiLCJpc0ludGVybmFsQ29tcG9uZW50VHlwZSIsInNob3VsZEhhdmVEZWJ1Z0lEIiwiY3JlYXRlSW50ZXJuYWxDb21wb25lbnQiLCJnZXROYXRpdmVOb2RlIiwiY3JlYXRlSW5zdGFuY2VGb3JUZXh0IiwiX21vdW50SW1hZ2UiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsIlJlYWN0Tm9kZVR5cGVzIiwiQ29tcG9zaXRlVHlwZXMiLCJJbXB1cmVDbGFzcyIsIlB1cmVDbGFzcyIsIlN0YXRlbGVzc0Z1bmN0aW9uYWwiLCJTdGF0ZWxlc3NDb21wb25lbnQiLCJ3YXJuSWZJbnZhbGlkRWxlbWVudCIsInNob3VsZENvbnN0cnVjdCIsImlzUHVyZUNvbXBvbmVudCIsIm1lYXN1cmVMaWZlQ3ljbGVQZXJmIiwibmV4dE1vdW50SUQiLCJfY29tcG9zaXRlVHlwZSIsIl9pbnN0YW5jZSIsIl9wZW5kaW5nRWxlbWVudCIsIl9wZW5kaW5nU3RhdGVRdWV1ZSIsIl9wZW5kaW5nUmVwbGFjZVN0YXRlIiwiX3BlbmRpbmdGb3JjZVVwZGF0ZSIsIl9yZW5kZXJlZE5vZGVUeXBlIiwiX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50IiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiX3RoaXMiLCJwdWJsaWNQcm9wcyIsInB1YmxpY0NvbnRleHQiLCJfcHJvY2Vzc0NvbnRleHQiLCJnZXRVcGRhdGVRdWV1ZSIsImRvQ29uc3RydWN0IiwiX2NvbnN0cnVjdENvbXBvbmVudCIsInJlbmRlcmVkRWxlbWVudCIsInByb3BzTXV0YXRlZCIsImNvbXBvbmVudERpZFVubW91bnQiLCJ1bnN0YWJsZV9oYW5kbGVFcnJvciIsInBlcmZvcm1Jbml0aWFsTW91bnRXaXRoRXJyb3JIYW5kbGluZyIsInBlcmZvcm1Jbml0aWFsTW91bnQiLCJfY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyIiwiX3Byb2Nlc3NQZW5kaW5nU3RhdGUiLCJfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50IiwiZ2V0VHlwZSIsIkVNUFRZIiwiX3Byb2Nlc3NDaGlsZENvbnRleHQiLCJfbWFza0NvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiY29udGV4dE5hbWUiLCJfY2hlY2tDb250ZXh0VHlwZXMiLCJjdXJyZW50Q29udGV4dCIsIm5leHRDb250ZXh0IiwicHJldkNvbnRleHQiLCJwcmV2UGFyZW50RWxlbWVudCIsIm5leHRQYXJlbnRFbGVtZW50IiwicHJldlVubWFza2VkQ29udGV4dCIsIm5leHRVbm1hc2tlZENvbnRleHQiLCJ3aWxsUmVjZWl2ZSIsInByZXZQcm9wcyIsIm5leHRTdGF0ZSIsInNob3VsZFVwZGF0ZSIsIl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlIiwicGFydGlhbCIsInVubWFza2VkQ29udGV4dCIsIl90aGlzMiIsImhhc0NvbXBvbmVudERpZFVwZGF0ZSIsInByZXZTdGF0ZSIsIl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCIsInByZXZDb21wb25lbnRJbnN0YW5jZSIsInByZXZSZW5kZXJlZEVsZW1lbnQiLCJuZXh0UmVuZGVyZWRFbGVtZW50Iiwib2xkSG9zdE5vZGUiLCJfcmVwbGFjZU5vZGVXaXRoTWFya3VwIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCIsInB1YmxpY0NvbXBvbmVudEluc3RhbmNlIiwiSE9TVCIsIkNPTVBPU0lURSIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsInByZXZFbXB0eSIsIm5leHRFbXB0eSIsInByZXZUeXBlIiwibmV4dFR5cGUiLCJlbXB0eUNvbXBvbmVudEZhY3RvcnkiLCJSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uIiwiZ2VuZXJpY0NvbXBvbmVudENsYXNzIiwidGFnVG9Db21wb25lbnRDbGFzcyIsInRleHRDb21wb25lbnRDbGFzcyIsIlJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiIsImluamVjdENvbXBvbmVudENsYXNzZXMiLCJjb21wb25lbnRDbGFzc2VzIiwiaXNUZXh0Q29tcG9uZW50IiwibmV4dERlYnVnSUQiLCJmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsIlJlYWN0U2VydmVyVXBkYXRlUXVldWUiLCJub29wQ2FsbGJhY2tRdWV1ZSIsIlJlYWN0VXBkYXRlUXVldWUiLCJmb3JtYXRVbmV4cGVjdGVkQXJndW1lbnQiLCJnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUiLCJjdG9yIiwidmFsaWRhdGVDYWxsYmFjayIsImVucXVldWVDYWxsYmFja0ludGVybmFsIiwiZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbCIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZmluZE93bmVyU3RhY2siLCJyZXZlcnNlIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRUZXh0IiwiY2hpbGRJbnN0YW5jZSIsImludmFsaWRQYXJlbnQiLCJpbnZhbGlkQW5jZXN0b3IiLCJwcm9ibGVtYXRpYyIsImFuY2VzdG9yVGFnIiwiYW5jZXN0b3JJbnN0YW5jZSIsImFuY2VzdG9yT3duZXIiLCJjaGlsZE93bmVycyIsImFuY2VzdG9yT3duZXJzIiwibWluU3RhY2tMZW4iLCJkZWVwZXN0Q29tbW9uIiwiVU5LTk9XTiIsImNoaWxkT3duZXJOYW1lcyIsImFuY2VzdG9yT3duZXJOYW1lcyIsIm93bmVySW5mbyIsIndhcm5LZXkiLCJ0YWdEaXNwbGF5TmFtZSIsIndoaXRlc3BhY2VJbmZvIiwiaXNUYWdWYWxpZEluQ29udGV4dCIsImRvbUlEIiwiY3JlYXRlQ29tbWVudCIsImluc3RBIiwiaW5zdEIiLCJkZXB0aEEiLCJ0ZW1wQSIsImRlcHRoQiIsInRlbXBCIiwiZGVwdGgiLCJjb21tb24iLCJwYXRoRnJvbSIsInBhdGhUbyIsIl9zdHJpbmdUZXh0IiwiX2Nsb3NpbmdDb21tZW50IiwiX2NvbW1lbnROb2RlcyIsIm9wZW5pbmdWYWx1ZSIsImNsb3NpbmdWYWx1ZSIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJlc2NhcGVkVGV4dCIsIm5leHRUZXh0IiwibmV4dFN0cmluZ1RleHQiLCJjb21tZW50Tm9kZXMiLCJob3N0Tm9kZSIsIlJFU0VUX0JBVENIRURfVVBEQVRFUyIsIkZMVVNIX0JBVENIRURfVVBEQVRFUyIsIlJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbiIsImFscmVhZHlCYXRjaGluZ1VwZGF0ZXMiLCJFdmVudExpc3RlbmVyIiwiZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24iLCJmaW5kUGFyZW50IiwiY29udGFpbmVyIiwiVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiYW5jZXN0b3JzIiwiaGFuZGxlVG9wTGV2ZWxJbXBsIiwiYW5jZXN0b3IiLCJfaGFuZGxlVG9wTGV2ZWwiLCJzY3JvbGxWYWx1ZU1vbml0b3IiLCJfZW5hYmxlZCIsImxpc3RlbiIsInJlZ2lzdGVyRGVmYXVsdCIsInNjcm9sbGFibGUiLCJwYWdlWE9mZnNldCIsInNjcm9sbExlZnQiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsIlJlYWN0SW5wdXRTZWxlY3Rpb24iLCJTRUxFQ1RJT05fUkVTVE9SQVRJT04iLCJnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiIsInJlc3RvcmVTZWxlY3Rpb24iLCJFVkVOVF9TVVBQUkVTU0lPTiIsImN1cnJlbnRseUVuYWJsZWQiLCJwcmV2aW91c2x5RW5hYmxlZCIsIk9OX0RPTV9SRUFEWV9RVUVVRUlORyIsInJlYWN0TW91bnRSZWFkeSIsIlJlYWN0RE9NU2VsZWN0aW9uIiwiY29udGFpbnNOb2RlIiwiZ2V0QWN0aXZlRWxlbWVudCIsImlzSW5Eb2N1bWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImZvY3VzZWRFbGVtIiwic2VsZWN0aW9uUmFuZ2UiLCJnZXRTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwicmFuZ2UiLCJjcmVhdGVSYW5nZSIsInBhcmVudEVsZW1lbnQiLCJtb3ZlU3RhcnQiLCJtb3ZlRW5kIiwiZ2V0T2Zmc2V0cyIsIm9mZnNldHMiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsInNldE9mZnNldHMiLCJnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0IiwiaXNDb2xsYXBzZWQiLCJhbmNob3JOb2RlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJnZXRJRU9mZnNldHMiLCJzZWxlY3RlZFJhbmdlIiwic2VsZWN0ZWRMZW5ndGgiLCJmcm9tU3RhcnQiLCJkdXBsaWNhdGUiLCJtb3ZlVG9FbGVtZW50VGV4dCIsInNldEVuZFBvaW50Iiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJnZXRNb2Rlcm5PZmZzZXRzIiwicmFuZ2VDb3VudCIsImN1cnJlbnRSYW5nZSIsImdldFJhbmdlQXQiLCJzdGFydENvbnRhaW5lciIsImVuZENvbnRhaW5lciIsImlzU2VsZWN0aW9uQ29sbGFwc2VkIiwicmFuZ2VMZW5ndGgiLCJ0ZW1wUmFuZ2UiLCJjbG9uZVJhbmdlIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwic2V0RW5kIiwiaXNUZW1wUmFuZ2VDb2xsYXBzZWQiLCJkZXRlY3Rpb25SYW5nZSIsInNldFN0YXJ0IiwiaXNCYWNrd2FyZCIsImNvbGxhcHNlZCIsInNldElFT2Zmc2V0cyIsInNldE1vZGVybk9mZnNldHMiLCJleHRlbmQiLCJ0ZW1wIiwic3RhcnRNYXJrZXIiLCJlbmRNYXJrZXIiLCJvZmZzZXQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInVzZUlFT2Zmc2V0cyIsImdldExlYWZOb2RlIiwiZ2V0U2libGluZ05vZGUiLCJub2RlU3RhcnQiLCJub2RlRW5kIiwiaXNUZXh0Tm9kZSIsIm91dGVyTm9kZSIsImlubmVyTm9kZSIsImNvbnRhaW5zIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiTlMiLCJ4bGluayIsInhtbCIsIkFUVFJTIiwiYWNjZW50SGVpZ2h0IiwiYWNjdW11bGF0ZSIsImFkZGl0aXZlIiwiYWxpZ25tZW50QmFzZWxpbmUiLCJhbGxvd1Jlb3JkZXIiLCJhbHBoYWJldGljIiwiYW1wbGl0dWRlIiwiYXJhYmljRm9ybSIsImFzY2VudCIsImF0dHJpYnV0ZVR5cGUiLCJhdXRvUmV2ZXJzZSIsImF6aW11dGgiLCJiYXNlRnJlcXVlbmN5IiwiYmFzZVByb2ZpbGUiLCJiYXNlbGluZVNoaWZ0IiwiYmJveCIsImJlZ2luIiwiYmlhcyIsImJ5IiwiY2FsY01vZGUiLCJjYXBIZWlnaHQiLCJjbGlwIiwiY2xpcFJ1bGUiLCJjbGlwUGF0aFVuaXRzIiwiY29sb3JJbnRlcnBvbGF0aW9uIiwiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycyIsImNvbG9yUHJvZmlsZSIsImNvbG9yUmVuZGVyaW5nIiwiY29udGVudFNjcmlwdFR5cGUiLCJjb250ZW50U3R5bGVUeXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZUNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudEJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2VNb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlQmFja2dyb3VuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCIsImZpbGwiLCJmaWxsUnVsZSIsImZpbHRlciIsImZpbHRlclJlcyIsImZpbHRlclVuaXRzIiwiZmxvb2RDb2xvciIsImZvY3VzYWJsZSIsImZvbnRTaXplQWRqdXN0IiwiZm9udFN0cmV0Y2giLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBoTmFtZSIsImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsIiwiZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsIiwiZ2x5cGhSZWYiLCJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50VW5pdHMiLCJoYW5naW5nIiwiaG9yaXpBZHZYIiwiaG9yaXpPcmlnaW5YIiwiaWRlb2dyYXBoaWMiLCJpbWFnZVJlbmRlcmluZyIsImluMiIsImludGVyY2VwdCIsImsxIiwiazIiLCJrMyIsIms0Iiwia2VybmVsTWF0cml4Iiwia2VybmVsVW5pdExlbmd0aCIsImtlcm5pbmciLCJrZXlQb2ludHMiLCJrZXlTcGxpbmVzIiwia2V5VGltZXMiLCJsZW5ndGhBZGp1c3QiLCJsZXR0ZXJTcGFjaW5nIiwibGlnaHRpbmdDb2xvciIsImxpbWl0aW5nQ29uZUFuZ2xlIiwibG9jYWwiLCJtYXJrZXJFbmQiLCJtYXJrZXJNaWQiLCJtYXJrZXJTdGFydCIsIm1hcmtlckhlaWdodCIsIm1hcmtlclVuaXRzIiwibWFya2VyV2lkdGgiLCJtYXNrQ29udGVudFVuaXRzIiwibWFza1VuaXRzIiwibWF0aGVtYXRpY2FsIiwibW9kZSIsIm51bU9jdGF2ZXMiLCJvcGVyYXRvciIsIm9yaWVudCIsIm9yaWVudGF0aW9uIiwib3JpZ2luIiwib3ZlcmZsb3ciLCJvdmVybGluZVBvc2l0aW9uIiwib3ZlcmxpbmVUaGlja25lc3MiLCJwYWludE9yZGVyIiwicGFub3NlMSIsInBhdGhMZW5ndGgiLCJwYXR0ZXJuQ29udGVudFVuaXRzIiwicGF0dGVyblRyYW5zZm9ybSIsInBhdHRlcm5Vbml0cyIsInBvaW50ZXJFdmVudHMiLCJwb2ludHMiLCJwb2ludHNBdFgiLCJwb2ludHNBdFkiLCJwb2ludHNBdFoiLCJwcmVzZXJ2ZUFscGhhIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsInByaW1pdGl2ZVVuaXRzIiwiciIsInJhZGl1cyIsInJlZlgiLCJyZWZZIiwicmVuZGVyaW5nSW50ZW50IiwicmVwZWF0Q291bnQiLCJyZXBlYXREdXIiLCJyZXF1aXJlZEV4dGVuc2lvbnMiLCJyZXF1aXJlZEZlYXR1cmVzIiwicmVzdGFydCIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlZWQiLCJzaGFwZVJlbmRlcmluZyIsInNsb3BlIiwic3BhY2luZyIsInNwZWN1bGFyQ29uc3RhbnQiLCJzcGVjdWxhckV4cG9uZW50Iiwic3BlZWQiLCJzcHJlYWRNZXRob2QiLCJzdGREZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNoVGlsZXMiLCJzdG9wQ29sb3IiLCJzdHJpa2V0aHJvdWdoUG9zaXRpb24iLCJzdHJpa2V0aHJvdWdoVGhpY2tuZXNzIiwic3Ryb2tlIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwic3VyZmFjZVNjYWxlIiwic3lzdGVtTGFuZ3VhZ2UiLCJ0YWJsZVZhbHVlcyIsInRhcmdldFgiLCJ0YXJnZXRZIiwidGV4dEFuY2hvciIsInRleHREZWNvcmF0aW9uIiwidGV4dFJlbmRlcmluZyIsInRleHRMZW5ndGgiLCJ0cmFuc2Zvcm0iLCJ1MSIsInUyIiwidW5kZXJsaW5lUG9zaXRpb24iLCJ1bmRlcmxpbmVUaGlja25lc3MiLCJ1bmljb2RlIiwidW5pY29kZUJpZGkiLCJ1bmljb2RlUmFuZ2UiLCJ1bml0c1BlckVtIiwidkFscGhhYmV0aWMiLCJ2SGFuZ2luZyIsInZJZGVvZ3JhcGhpYyIsInZNYXRoZW1hdGljYWwiLCJ2ZWN0b3JFZmZlY3QiLCJ2ZXJ0QWR2WSIsInZlcnRPcmlnaW5YIiwidmVydE9yaWdpblkiLCJ2aWV3Qm94Iiwidmlld1RhcmdldCIsInZpc2liaWxpdHkiLCJ3aWR0aHMiLCJ3b3JkU3BhY2luZyIsIndyaXRpbmdNb2RlIiwieEhlaWdodCIsIngxIiwieDIiLCJ4Q2hhbm5lbFNlbGVjdG9yIiwieGxpbmtBY3R1YXRlIiwieGxpbmtBcmNyb2xlIiwieGxpbmtIcmVmIiwieGxpbmtSb2xlIiwieGxpbmtTaG93IiwieGxpbmtUaXRsZSIsInhsaW5rVHlwZSIsInhtbEJhc2UiLCJ4bWxucyIsInhtbG5zWGxpbmsiLCJ4bWxMYW5nIiwieG1sU3BhY2UiLCJ5MSIsInkyIiwieUNoYW5uZWxTZWxlY3RvciIsInoiLCJ6b29tQW5kUGFuIiwic2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50IiwibGFzdFNlbGVjdGlvbiIsIm1vdXNlRG93biIsImhhc0xpc3RlbmVyIiwiYm91bmRpbmdUb3AiLCJsZWZ0IiwiYm91bmRpbmdMZWZ0IiwiY29uc3RydWN0U2VsZWN0RXZlbnQiLCJjdXJyZW50U2VsZWN0aW9uIiwiU3ludGhldGljQW5pbWF0aW9uRXZlbnQiLCJTeW50aGV0aWNDbGlwYm9hcmRFdmVudCIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiU3ludGhldGljRHJhZ0V2ZW50IiwiU3ludGhldGljVG91Y2hFdmVudCIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIlN5bnRoZXRpY1doZWVsRXZlbnQiLCJnZXRFdmVudENoYXJDb2RlIiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiY2FwaXRhbGl6ZWRFdmVudCIsIm9uRXZlbnQiLCJ0b3BFdmVudCIsIm9uQ2xpY2tMaXN0ZW5lcnMiLCJFdmVudENvbnN0cnVjdG9yIiwiQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UiLCJhbmltYXRpb25OYW1lIiwiZWxhcHNlZFRpbWUiLCJwc2V1ZG9FbGVtZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiRm9jdXNFdmVudEludGVyZmFjZSIsImdldEV2ZW50S2V5IiwiS2V5Ym9hcmRFdmVudEludGVyZmFjZSIsInJlcGVhdCIsImxvY2FsZSIsImNoYXJDb2RlIiwibm9ybWFsaXplS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIlJlYWN0RE9NQ29udGFpbmVySW5mbyIsIlJlYWN0RE9NRmVhdHVyZUZsYWdzIiwiUmVhY3RNYXJrdXBDaGVja3N1bSIsIlJPT1RfQVRUUl9OQU1FIiwiRE9DX05PREVfVFlQRSIsImluc3RhbmNlc0J5UmVhY3RSb290SUQiLCJmaXJzdERpZmZlcmVuY2VJbmRleCIsInN0cmluZzEiLCJzdHJpbmcyIiwibWluTGVuIiwiZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyIiwiaW50ZXJuYWxHZXRJRCIsIm1vdW50Q29tcG9uZW50SW50b05vZGUiLCJ3cmFwcGVySW5zdGFuY2UiLCJzaG91bGRSZXVzZU1hcmt1cCIsIndyYXBwZWRFbGVtZW50IiwiX21vdW50SW1hZ2VJbnRvTm9kZSIsImJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJ1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUiLCJoYXNOb25Sb290UmVhY3RDaGlsZCIsInJvb3RFbCIsIm5vZGVJc1JlbmRlcmVkQnlPdGhlckluc3RhbmNlIiwiaXNSZWFjdE5vZGUiLCJpc1ZhbGlkQ29udGFpbmVyIiwiaGFzQXR0cmlidXRlIiwiZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyIiwicHJldkhvc3RJbnN0YW5jZSIsImdldFRvcExldmVsV3JhcHBlckluQ29udGFpbmVyIiwidG9wTGV2ZWxSb290Q291bnRlciIsIlRvcExldmVsV3JhcHBlciIsInJvb3RJRCIsIl9pbnN0YW5jZXNCeVJlYWN0Um9vdElEIiwic2Nyb2xsTW9uaXRvciIsInJlbmRlckNhbGxiYWNrIiwiX3VwZGF0ZVJvb3RDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50IiwiX3JlbmRlck5ld1Jvb3RDb21wb25lbnQiLCJ3cmFwcGVySUQiLCJwYXJlbnRDb21wb25lbnQiLCJfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJuZXh0V3JhcHBlZEVsZW1lbnQiLCJwcmV2V3JhcHBlZEVsZW1lbnQiLCJwdWJsaWNJbnN0IiwidXBkYXRlZENhbGxiYWNrIiwicmVhY3RSb290RWxlbWVudCIsImNvbnRhaW5lckhhc1JlYWN0TWFya3VwIiwiY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQiLCJyb290RWxlbWVudFNpYmxpbmciLCJpc0NvbnRhaW5lclJlYWN0Um9vdCIsInJvb3RFbGVtZW50IiwiY2FuUmV1c2VNYXJrdXAiLCJjaGVja3N1bSIsIkNIRUNLU1VNX0FUVFJfTkFNRSIsInJvb3RNYXJrdXAiLCJvdXRlckhUTUwiLCJub3JtYWxpemVkTWFya3VwIiwibm9ybWFsaXplciIsImNvbnRlbnREb2N1bWVudCIsIndyaXRlIiwiZGlmZkluZGV4IiwiZGlmZmVyZW5jZSIsInRvcExldmVsV3JhcHBlciIsInVzZUZpYmVyIiwiYWRsZXIzMiIsIlRBR19FTkQiLCJDT01NRU5UX1NUQVJUIiwiYWRkQ2hlY2tzdW1Ub01hcmt1cCIsImV4aXN0aW5nQ2hlY2tzdW0iLCJtYXJrdXBDaGVja3N1bSIsIk1PRCIsImwiLCJtIiwiY29tcG9uZW50T3JFbGVtZW50IiwicmVhY3RQcm9wcyIsIndhcm5lZFByb3BlcnRpZXMiLCJ2YWxpZGF0ZVByb3BlcnR5Iiwic3RhbmRhcmROYW1lIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwiaGFuZGxlRWxlbWVudCIsImRpZFdhcm5WYWx1ZU51bGwiLCJyQVJJQSIsIndhcm5JbnZhbGlkQVJJQVByb3BzIiwiaW52YWxpZFByb3BzIiwiX19lc01vZHVsZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJoYXNoSGlzdG9yeSIsImJyb3dzZXJIaXN0b3J5IiwiYXBwbHlSb3V0ZXJNaWRkbGV3YXJlIiwiZm9ybWF0UGF0dGVybiIsInVzZVJvdXRlckhpc3RvcnkiLCJyb3V0ZXJTaGFwZSIsImxvY2F0aW9uU2hhcGUiLCJSb3V0ZXJDb250ZXh0IiwiY3JlYXRlUm91dGVzIiwiUm91dGUiLCJSZWRpcmVjdCIsIkluZGV4Um91dGUiLCJJbmRleFJlZGlyZWN0Iiwid2l0aFJvdXRlciIsIkluZGV4TGluayIsIkxpbmsiLCJSb3V0ZXIiLCJfUm91dGVVdGlscyIsIl9Qcm9wVHlwZXMiLCJfUGF0dGVyblV0aWxzIiwiX1JvdXRlcjIiLCJfUm91dGVyMyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfTGluazIiLCJfTGluazMiLCJfSW5kZXhMaW5rMiIsIl9JbmRleExpbmszIiwiX3dpdGhSb3V0ZXIyIiwiX3dpdGhSb3V0ZXIzIiwiX0luZGV4UmVkaXJlY3QyIiwiX0luZGV4UmVkaXJlY3QzIiwiX0luZGV4Um91dGUyIiwiX0luZGV4Um91dGUzIiwiX1JlZGlyZWN0MiIsIl9SZWRpcmVjdDMiLCJfUm91dGUyIiwiX1JvdXRlMyIsIl9Sb3V0ZXJDb250ZXh0MiIsIl9Sb3V0ZXJDb250ZXh0MyIsIl9tYXRjaDIiLCJfbWF0Y2gzIiwiX3VzZVJvdXRlckhpc3RvcnkyIiwiX3VzZVJvdXRlckhpc3RvcnkzIiwiX2FwcGx5Um91dGVyTWlkZGxld2FyZTIiLCJfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMyIsIl9icm93c2VySGlzdG9yeTIiLCJfYnJvd3Nlckhpc3RvcnkzIiwiX2hhc2hIaXN0b3J5MiIsIl9oYXNoSGlzdG9yeTMiLCJfY3JlYXRlTWVtb3J5SGlzdG9yeTIiLCJfY3JlYXRlTWVtb3J5SGlzdG9yeTMiLCJkZWZhdWx0IiwiX2V4dGVuZHMiLCJpc1JlYWN0Q2hpbGRyZW4iLCJjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQiLCJjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbiIsIl9yZWFjdCIsIl9yZWFjdDIiLCJpc1ZhbGlkQ2hpbGQiLCJjcmVhdGVSb3V0ZSIsInJvdXRlIiwiY2hpbGRSb3V0ZXMiLCJwYXJlbnRSb3V0ZSIsInJvdXRlcyIsImdvIiwiZ29CYWNrIiwiZ29Gb3J3YXJkIiwic2V0Um91dGVMZWF2ZUhvb2siLCJpc0FjdGl2ZSIsInBhdGhuYW1lIiwic2VhcmNoIiwiY29tcGlsZVBhdHRlcm4iLCJtYXRjaFBhdHRlcm4iLCJnZXRQYXJhbU5hbWVzIiwiZ2V0UGFyYW1zIiwiX2ludmFyaWFudCIsIl9pbnZhcmlhbnQyIiwiZXNjYXBlUmVnRXhwIiwiX2NvbXBpbGVQYXR0ZXJuIiwicmVnZXhwU291cmNlIiwicGFyYW1OYW1lcyIsInRva2VucyIsIm1hdGNoZXIiLCJDb21waWxlZFBhdHRlcm5zQ2FjaGUiLCJfY29tcGlsZVBhdHRlcm4yIiwibWF0Y2hlZFBhdGgiLCJyZW1haW5pbmdQYXRobmFtZSIsInBhcmFtVmFsdWVzIiwidiIsImRlY29kZVVSSUNvbXBvbmVudCIsInBhcmFtcyIsInBhcmFtTmFtZSIsIl9jb21waWxlUGF0dGVybjMiLCJwYXJlbkNvdW50Iiwic3BsYXRJbmRleCIsInBhcmVuSGlzdG9yeSIsInRva2VuIiwicGFyYW1WYWx1ZSIsInNwbGF0IiwiZW5jb2RlVVJJIiwicGFyZW5UZXh0IiwiY3VyVG9rZW5JZHgiLCJ0b2tlbnNTdWJzZXQiLCJuZXh0UGFyZW5JZHgiLCJfaSIsIl9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIiLCJfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIzIiwiX0ludGVybmFsUHJvcFR5cGVzIiwiX1JvdXRlckNvbnRleHQiLCJfUm91dGVyVXRpbHMiLCJfcm91dGVyV2FybmluZyIsIl9yb3V0ZXJXYXJuaW5nMiIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9SZWFjdCRQcm9wVHlwZXMiLCJvbkVycm9yIiwib25VcGRhdGUiLCJtYXRjaENvbnRleHQiLCJjb21wb25lbnRzIiwiaGFuZGxlRXJyb3IiLCJjcmVhdGVSb3V0ZXJPYmplY3QiLCJyb3V0ZXIiLCJ0cmFuc2l0aW9uTWFuYWdlciIsImNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIiwiX3Byb3BzIiwiZ2V0Q3VycmVudExvY2F0aW9uIiwiX3VubGlzdGVuIiwiYXNzaWduUm91dGVyU3RhdGUiLCJfc3RhdGUiLCJfcHJvcHMyIiwiX2NvbXB1dGVDaGFuZ2VkUm91dGVzMiIsIl9jb21wdXRlQ2hhbmdlZFJvdXRlczMiLCJfVHJhbnNpdGlvblV0aWxzIiwiX2lzQWN0aXZlMiIsIl9pc0FjdGl2ZTMiLCJfZ2V0Q29tcG9uZW50cyIsIl9nZXRDb21wb25lbnRzMiIsIl9tYXRjaFJvdXRlcyIsIl9tYXRjaFJvdXRlczIiLCJoYXNBbnlQcm9wZXJ0aWVzIiwiaW5kZXhPbmx5IiwiY3JlYXRlTG9jYXRpb24iLCJwYXJ0aWFsTmV4dFN0YXRlIiwiZmluaXNoTWF0Y2giLCJfY29tcHV0ZUNoYW5nZWRSb3V0ZXMiLCJsZWF2ZVJvdXRlcyIsImNoYW5nZVJvdXRlcyIsImVudGVyUm91dGVzIiwicnVuTGVhdmVIb29rcyIsInJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUiLCJydW5DaGFuZ2VIb29rcyIsInJlZGlyZWN0SW5mbyIsImhhbmRsZUVycm9yT3JSZWRpcmVjdCIsInJ1bkVudGVySG9va3MiLCJmaW5pc2hFbnRlckhvb2tzIiwiUm91dGVHdWlkIiwiZ2V0Um91dGVJRCIsIl9faWRfXyIsIlJvdXRlSG9va3MiLCJnZXRSb3V0ZUhvb2tzRm9yUm91dGVzIiwidHJhbnNpdGlvbkhvb2siLCJiZWZvcmVVbmxvYWRIb29rIiwidW5saXN0ZW5CZWZvcmUiLCJ1bmxpc3RlbkJlZm9yZVVubG9hZCIsInJvdXRlSUQiLCJsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUiLCJ0aGVyZVdlcmVOb1JvdXRlSG9va3MiLCJsaXN0ZW5CZWZvcmUiLCJsaXN0ZW5CZWZvcmVVbmxvYWQiLCJoaXN0b3J5TGlzdGVuZXIiLCJyZWRpcmVjdExvY2F0aW9uIiwidW5zdWJzY3JpYmUiLCJyb3V0ZXJXYXJuaW5nIiwiX3Jlc2V0V2FybmVkIiwiX3dhcm5pbmciLCJfd2FybmluZzIiLCJmYWxzZVRvV2FybiIsInJvdXRlUGFyYW1zQ2hhbmdlZCIsInNvbWUiLCJjb21wdXRlQ2hhbmdlZFJvdXRlcyIsInByZXZSb3V0ZXMiLCJuZXh0Um91dGVzIiwicGFyZW50SXNMZWF2aW5nIiwiaXNMZWF2aW5nIiwiaXNOZXciLCJwYXJhbXNDaGFuZ2VkIiwiX0FzeW5jVXRpbHMiLCJQZW5kaW5nSG9va3MiLCJoIiwiY2xlYXIiLCJlbnRlckhvb2tzIiwiY2hhbmdlSG9va3MiLCJjcmVhdGVUcmFuc2l0aW9uSG9vayIsImFzeW5jQXJpdHkiLCJwZW5kaW5nSG9va3MiLCJpc1N5bmMiLCJnZXRFbnRlckhvb2tzIiwib25FbnRlciIsImdldENoYW5nZUhvb2tzIiwicnVuVHJhbnNpdGlvbkhvb2tzIiwiaXRlciIsImxvb3BBc3luYyIsIndyYXBwZWROZXh0Iiwib25MZWF2ZSIsIm1hcEFzeW5jIiwidHVybnMiLCJ3b3JrIiwiY3VycmVudFR1cm4iLCJpc0RvbmUiLCJzeW5jIiwiaGFzTmV4dCIsImRvbmVBcmdzIiwiZG9uZUNvdW50IiwiX3R5cGVvZiIsImRlZXBFcXVhbCIsInBhdGhJc0FjdGl2ZSIsImN1cnJlbnRQYXRobmFtZSIsInJvdXRlSXNBY3RpdmUiLCJtYXRjaGVkIiwicXVlcnlJc0FjdGl2ZSIsInF1ZXJ5IiwiYWN0aXZlUXVlcnkiLCJfcmVmIiwiY3VycmVudExvY2F0aW9uIiwiX1Byb21pc2VVdGlscyIsImdldENvbXBvbmVudHNGb3JSb3V0ZSIsImdldENvbXBvbmVudCIsImdldENvbXBvbmVudHMiLCJjb21wb25lbnRSZXR1cm4iLCJpc1Byb21pc2UiLCJ0aGVuIiwibWF0Y2hSb3V0ZXMiLCJnZXRDaGlsZFJvdXRlcyIsImNyZWF0ZVBhcmFtcyIsImNoaWxkUm91dGVzUmV0dXJuIiwiZ2V0SW5kZXhSb3V0ZSIsImluZGV4Um91dGUiLCJpbmRleFJvdXRlc1JldHVybiIsInBhdGhsZXNzIiwiY2hpbGRSb3V0ZSIsImFzc2lnblBhcmFtcyIsIm1hdGNoUm91dGVEZWVwIiwiX3JldDIiLCJfbWF0Y2gkcm91dGVzIiwib25DaGlsZFJvdXRlcyIsInVuc2hpZnQiLCJmYWxzeSIsIl9nZXRSb3V0ZVBhcmFtcyIsIl9nZXRSb3V0ZVBhcmFtczIiLCJfQ29udGV4dFV0aWxzIiwiQ29udGV4dFByb3ZpZGVyIiwicmVkdWNlUmlnaHQiLCJyb3V0ZVBhcmFtcyIsImVsZW1lbnRzIiwiZ2V0Um91dGVQYXJhbXMiLCJDb250ZXh0U3Vic2NyaWJlciIsImNvbnRleHRQcm92aWRlclNoYXBlIiwic3Vic2NyaWJlIiwiZXZlbnRJbmRleCIsIm1ha2VDb250ZXh0TmFtZSIsIl9jaGlsZENvbnRleHRUeXBlcyIsIl9yZWYyIiwibGlzdGVuZXJzS2V5IiwiZXZlbnRJbmRleEtleSIsInN1YnNjcmliZUtleSIsIl9jb250ZXh0VHlwZXMiLCJfcmVmNCIsImxhc3RSZW5kZXJlZEV2ZW50SW5kZXhLZXkiLCJoYW5kbGVDb250ZXh0VXBkYXRlS2V5IiwidW5zdWJzY3JpYmVLZXkiLCJfcmVmMyIsIl9zZXRTdGF0ZSIsIl9zZXRTdGF0ZTIiLCJpc0xlZnRDbGlja0V2ZW50IiwiaXNNb2RpZmllZEV2ZW50IiwiaXNFbXB0eU9iamVjdCIsInJlc29sdmVUb0xvY2F0aW9uIiwiYWN0aXZlU3R5bGUiLCJhY3RpdmVDbGFzc05hbWUiLCJvbmx5QWN0aXZlT25JbmRleCIsIm9uQ2xpY2siLCJoYW5kbGVDbGljayIsInRvTG9jYXRpb24iLCJjcmVhdGVIcmVmIiwiX0xpbmsiLCJfaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJfaG9pc3ROb25SZWFjdFN0YXRpY3MyIiwiV3JhcHBlZENvbXBvbmVudCIsIndpdGhSZWYiLCJXaXRoUm91dGVyIiwiZ2V0V3JhcHBlZEluc3RhbmNlIiwid3JhcHBlZEluc3RhbmNlIiwiUkVBQ1RfU1RBVElDUyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJhcml0eSIsImlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJjdXN0b21TdGF0aWNzIiwiX1JlZGlyZWN0Iiwicm91dGVJbmRleCIsInBhcmVudFBhdHRlcm4iLCJnZXRSb3V0ZVBhdHRlcm4iLCJfQWN0aW9ucyIsIl9jcmVhdGVNZW1vcnlIaXN0b3J5IiwiX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIiwicmVuZGVyUHJvcHMiLCJSRVBMQUNFIiwiUFVTSCIsIlBPUCIsIl91c2VRdWVyaWVzIiwiX3VzZVF1ZXJpZXMyIiwiX3VzZUJhc2VuYW1lIiwiX3VzZUJhc2VuYW1lMiIsIm1lbW9yeUhpc3RvcnkiLCJjcmVhdGVIaXN0b3J5IiwiX3F1ZXJ5U3RyaW5nIiwiX3J1blRyYW5zaXRpb25Ib29rIiwiX3J1blRyYW5zaXRpb25Ib29rMiIsIl9Mb2NhdGlvblV0aWxzIiwiX1BhdGhVdGlscyIsImRlZmF1bHRTdHJpbmdpZnlRdWVyeSIsImRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nIiwicGFyc2UiLCJ1c2VRdWVyaWVzIiwic3RyaW5naWZ5UXVlcnkiLCJwYXJzZVF1ZXJ5U3RyaW5nIiwiZGVjb2RlUXVlcnkiLCJlbmNvZGVRdWVyeSIsInBhcnNlUGF0aCIsInF1ZXJ5U3RyaW5nIiwiY3JlYXRlUGF0aCIsIm5ld0xvY2F0aW9uIiwiY3JlYXRlUXVlcnkiLCJzdHJpY3RVcmlFbmNvZGUiLCJvYmplY3RBc3NpZ24iLCJlbmNvZGUiLCJvcHRzIiwic3RyaWN0IiwiZXh0cmFjdCIsInBhcnRzIiwic2hpZnQiLCJkZWZhdWx0cyIsInZhbDIiLCJydW5UcmFuc2l0aW9uSG9vayIsImxvY2F0aW9uc0FyZUVxdWFsIiwic3RhdGVzQXJlRXF1YWwiLCJpc0RhdGUiLCJ0eXBlb2ZBIiwidHlwZW9mQiIsImtleXNvZkEiLCJrZXlzb2ZCIiwiZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoIiwic3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgiLCJhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoIiwiX3BhcnNlUGF0aCIsIl9wYXJzZVBhdGgyIiwic3VmZml4IiwiX3BhcnNlUGF0aDMiLCJleHRyYWN0UGF0aCIsImhhc2hJbmRleCIsInNlYXJjaEluZGV4IiwiYmFzZW5hbWUiLCJ1c2VCYXNlbmFtZSIsImFkZEJhc2VuYW1lIiwicHJlcGVuZEJhc2VuYW1lIiwicG5hbWUiLCJub3JtYWxpemVkQmFzZW5hbWUiLCJub3JtYWxpemVkUGF0aG5hbWUiLCJfY3JlYXRlSGlzdG9yeSIsIl9jcmVhdGVIaXN0b3J5MiIsImNyZWF0ZVN0YXRlU3RvcmFnZSIsIm1lbW8iLCJyZWFkU3RhdGUiLCJpbml0IiwiY2FuR28iLCJ0cmFuc2l0aW9uVG8iLCJwdXNoTG9jYXRpb24iLCJzYXZlU3RhdGUiLCJyZXBsYWNlTG9jYXRpb24iLCJfb3B0aW9ucyIsInN0b3JhZ2UiLCJnZXRVc2VyQ29uZmlybWF0aW9uIiwia2V5TGVuZ3RoIiwicGVuZGluZ0xvY2F0aW9uIiwiYmVmb3JlTGlzdGVuZXJzIiwiYWxsS2V5cyIsImdldEN1cnJlbnRJbmRleCIsInVwZGF0ZUxvY2F0aW9uIiwibmV4dExvY2F0aW9uIiwiY3VycmVudEluZGV4IiwiY29uZmlybVRyYW5zaXRpb25UbyIsIm9rIiwicHJldlBhdGgiLCJuZXh0UGF0aCIsInByZXZJbmRleCIsImNyZWF0ZUtleSIsIm1pZGRsZXdhcmVzIiwibWlkZGxld2FyZSIsInJlbmRlclJvdXRlckNvbnRleHQiLCJyZW5kZXJSb3V0ZUNvbXBvbmVudCIsIndpdGhDb250ZXh0Iiwid2l0aENvbXBvbmVudCIsIm1ha2VDcmVhdGVFbGVtZW50IiwiYmFzZUNyZWF0ZUVsZW1lbnQiLCJwcmV2aW91cyIsIl9jcmVhdGVCcm93c2VySGlzdG9yeSIsIl9jcmVhdGVCcm93c2VySGlzdG9yeTIiLCJfY3JlYXRlUm91dGVySGlzdG9yeSIsIl9jcmVhdGVSb3V0ZXJIaXN0b3J5MiIsIl9FeGVjdXRpb25FbnZpcm9ubWVudCIsIl9Ccm93c2VyUHJvdG9jb2wiLCJCcm93c2VyUHJvdG9jb2wiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsIl9SZWZyZXNoUHJvdG9jb2wiLCJSZWZyZXNoUHJvdG9jb2wiLCJfRE9NVXRpbHMiLCJuZXdPYmoiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsInVzZVJlZnJlc2giLCJmb3JjZVJlZnJlc2giLCJzdXBwb3J0c0hpc3RvcnkiLCJQcm90b2NvbCIsImxpc3RlbmVyQ291bnQiLCJzdG9wTGlzdGVuZXIiLCJzdGFydExpc3RlbmVyIiwiYmVmb3JlIiwidW5saXN0ZW4iLCJfRE9NU3RhdGVTdG9yYWdlIiwiUG9wU3RhdGVFdmVudCIsIkhhc2hDaGFuZ2VFdmVudCIsIm5lZWRzSGFzaGNoYW5nZUxpc3RlbmVyIiwic3VwcG9ydHNQb3BzdGF0ZU9uSGFzaGNoYW5nZSIsIl9jcmVhdGVMb2NhdGlvbiIsImhpc3RvcnlTdGF0ZSIsImNvbmZpcm0iLCJoYW5kbGVQb3BTdGF0ZSIsImhhbmRsZVVucG9wcGVkSGFzaENoYW5nZSIsInVwZGF0ZVN0YXRlIiwicHVzaFN0YXRlIiwidWEiLCJzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCIsIlF1b3RhRXhjZWVkZWRFcnJvcnMiLCJRdW90YUV4Y2VlZGVkRXJyb3IiLCJRVU9UQV9FWENFRURFRF9FUlIiLCJTZWN1cml0eUVycm9ycyIsIlNlY3VyaXR5RXJyb3IiLCJLZXlQcmVmaXgiLCJzZXNzaW9uU3RvcmFnZSIsImpzb24iLCJfdXNlUm91dGVySGlzdG9yeSIsIl9jcmVhdGVIYXNoSGlzdG9yeSIsIl9jcmVhdGVIYXNoSGlzdG9yeTIiLCJfSGFzaFByb3RvY29sIiwiSGFzaFByb3RvY29sIiwiRGVmYXVsdFF1ZXJ5S2V5IiwiYWRkTGVhZGluZ1NsYXNoIiwiSGFzaFBhdGhDb2RlcnMiLCJoYXNoYmFuZyIsImVuY29kZVBhdGgiLCJkZWNvZGVQYXRoIiwibm9zbGFzaCIsInNsYXNoIiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJxdWVyeUtleSIsImhhc2hUeXBlIiwicGF0aENvZGVyIiwiZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQiLCJnZXRIYXNoUGF0aCIsInB1c2hIYXNoUGF0aCIsInJlcGxhY2VIYXNoUGF0aCIsInByZXZMb2NhdGlvbiIsImhhbmRsZUhhc2hDaGFuZ2UiLCJlbmNvZGVkUGF0aCIsInVwZGF0ZUhhc2giLCJNYWluIiwiTmF2IiwiVGltZXIiLCJDb3VudGRvd24iLCJjb3VudGRvd25TdGF0dXMiLCJzdGFydFRpbWVyIiwiY2xlYXJJbnRlcnZhbCIsInRpbWVyIiwic2V0SW50ZXJ2YWwiLCJuZXdDb3VudCIsInNlY29uZHMiLCJuZXdTdGF0dXMiLCJyZW5kZXJDb250cm9sQXJlYSIsImhhbmRsZVN0YXR1c0NoYW5nZSIsImhhbmRsZVNldENvdW50ZG93biIsIkNsb2NrIiwidG90YWxTZWNvbmRzIiwibWludXRlcyIsImZsb29yIiwiZm9ybWF0U2Vjb25kcyIsIkNvdW50ZG93bkZvcm0iLCJzdHJTZWNvbmRzIiwib25TZXRDb3VudGRvd24iLCJvblN1Ym1pdCIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsIkNvbnRyb2xzIiwib25TdGF0dXNDaGFuZ2UiLCJyZW5kZXJTdGFydFN0b3BCdXR0b24iXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdENBLDZDQUFpVyxFOzs7Ozs7QUNBalc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUEsaUJBQ1p2QixlQURZLEdBQ1EsS0FBSy8xRixLQURiLENBQ1orMUYsZUFEWTs7O0FBR3BCLGlCQUFJQSxvQkFBb0IsU0FBeEIsRUFBbUM7QUFDL0Isd0JBQU87QUFBQTtBQUFBLHVCQUFRLFdBQVUsa0JBQWxCLEVBQXFDLFNBQVM7QUFBQSxvQ0FBTSxPQUFLd0IsY0FBTCxDQUFvQixRQUFwQixDQUFOO0FBQUEsMEJBQTlDO0FBQUE7QUFBQSxrQkFBUDtBQUNILGNBRkQsTUFFTyxJQUFJeEIsb0JBQW9CLFFBQXhCLEVBQWtDO0FBQ3JDLHdCQUFPO0FBQUE7QUFBQSx1QkFBUSxXQUFVLGdCQUFsQixFQUFtQyxTQUFTO0FBQUEsb0NBQU0sT0FBS3dCLGNBQUwsQ0FBb0IsU0FBcEIsQ0FBTjtBQUFBLDBCQUE1QztBQUFBO0FBQUEsa0JBQVA7QUFDSDtBQUNKOzs7d0NBRWNqQixTLEVBQVc7QUFDdEIsa0JBQUt0MkYsS0FBTCxDQUFXdTNGLGNBQVgsQ0FBMEJqQixTQUExQjtBQUNIOzs7a0NBRVE7QUFBQTs7QUFDTCxvQkFDSTtBQUFBO0FBQUEsbUJBQUssV0FBVSxVQUFmO0FBQ0ssc0JBQUtrQixxQkFBTCxFQURMO0FBRUk7QUFBQTtBQUFBLHVCQUFRLFdBQVUscUJBQWxCLEVBQXdDLFNBQVM7QUFBQSxvQ0FBTSxPQUFLRCxjQUFMLENBQW9CLFNBQXBCLENBQU47QUFBQSwwQkFBakQ7QUFBQTtBQUFBO0FBRkosY0FESjtBQU1IOzs7O0dBMUJrQixnQkFBTWxqRyxTOztBQTZCN0JpakcsVUFBUzF2RixTQUFULEdBQXFCO0FBQ2pCbXVGLHNCQUFpQixnQkFBTXZoRyxTQUFOLENBQWdCb2xCLE1BQWhCLENBQXVCMEIsVUFEdkI7QUFFakJpOEUscUJBQWdCLGdCQUFNL2lHLFNBQU4sQ0FBZ0JrRyxJQUFoQixDQUFxQjRnQjtBQUZwQixFQUFyQjs7bUJBS2VnOEUsUSIsImZpbGUiOiIuL3B1YmxpYy9idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAwNjkyODllODhjMjU1ZjZiNjdhMyIsInJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXFBhcmFnb25cXFxcRGVza3RvcFxcXFxwcm9qZWN0c1xcXFxyZWFjdFxcXFxSZWFjdFRpbWVyXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxQYXJhZ29uXFxcXERlc2t0b3BcXFxccHJvamVjdHNcXFxccmVhY3RcXFxcUmVhY3RUaW1lclxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxQYXJhZ29uXFxcXERlc2t0b3BcXFxccHJvamVjdHNcXFxccmVhY3RcXFxcUmVhY3RUaW1lclxcXFxub2RlX21vZHVsZXNcXFxcYmFiZWwtbG9hZGVyXFxcXGxpYlxcXFxpbmRleC5qcz97XFxcInByZXNldHNcXFwiOltcXFwicmVhY3RcXFwiLFxcXCJlczIwMTVcXFwiXX0hQzpcXFxcVXNlcnNcXFxcUGFyYWdvblxcXFxEZXNrdG9wXFxcXHByb2plY3RzXFxcXHJlYWN0XFxcXFJlYWN0VGltZXJcXFxcbm9kZV9tb2R1bGVzXFxcXGpxdWVyeVxcXFxkaXN0XFxcXGpxdWVyeS5taW4uanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcclxuXHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgPT09IFwiZnVuY3Rpb25cIilcclxuXHRcdGV4ZWNTY3JpcHQoc3JjKTtcclxuXHRlbHNlXHJcblx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxuLyohIGpRdWVyeSB2Mi4yLjQgfCAoYykgalF1ZXJ5IEZvdW5kYXRpb24gfCBqcXVlcnkub3JnL2xpY2Vuc2UgKi9cXG4hZnVuY3Rpb24gKGEsIGIpIHtcXG4gIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgbW9kdWxlID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihtb2R1bGUpKSAmJiBcXFwib2JqZWN0XFxcIiA9PSBfdHlwZW9mKG1vZHVsZS5leHBvcnRzKSA/IG1vZHVsZS5leHBvcnRzID0gYS5kb2N1bWVudCA/IGIoYSwgITApIDogZnVuY3Rpb24gKGEpIHtcXG4gICAgaWYgKCFhLmRvY3VtZW50KSB0aHJvdyBuZXcgRXJyb3IoXFxcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcXFwiKTtyZXR1cm4gYihhKTtcXG4gIH0gOiBiKGEpO1xcbn0oXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIHdpbmRvdyA/IHdpbmRvdyA6IHVuZGVmaW5lZCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gIHZhciBjID0gW10sXFxuICAgICAgZCA9IGEuZG9jdW1lbnQsXFxuICAgICAgZSA9IGMuc2xpY2UsXFxuICAgICAgZiA9IGMuY29uY2F0LFxcbiAgICAgIGcgPSBjLnB1c2gsXFxuICAgICAgaCA9IGMuaW5kZXhPZixcXG4gICAgICBpID0ge30sXFxuICAgICAgaiA9IGkudG9TdHJpbmcsXFxuICAgICAgayA9IGkuaGFzT3duUHJvcGVydHksXFxuICAgICAgbCA9IHt9LFxcbiAgICAgIG0gPSBcXFwiMi4yLjRcXFwiLFxcbiAgICAgIG4gPSBmdW5jdGlvbiBuKGEsIGIpIHtcXG4gICAgcmV0dXJuIG5ldyBuLmZuLmluaXQoYSwgYik7XFxuICB9LFxcbiAgICAgIG8gPSAvXltcXFxcc1xcXFx1RkVGRlxcXFx4QTBdK3xbXFxcXHNcXFxcdUZFRkZcXFxceEEwXSskL2csXFxuICAgICAgcCA9IC9eLW1zLS8sXFxuICAgICAgcSA9IC8tKFtcXFxcZGEtel0pL2dpLFxcbiAgICAgIHIgPSBmdW5jdGlvbiByKGEsIGIpIHtcXG4gICAgcmV0dXJuIGIudG9VcHBlckNhc2UoKTtcXG4gIH07bi5mbiA9IG4ucHJvdG90eXBlID0geyBqcXVlcnk6IG0sIGNvbnN0cnVjdG9yOiBuLCBzZWxlY3RvcjogXFxcIlxcXCIsIGxlbmd0aDogMCwgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcXG4gICAgICByZXR1cm4gZS5jYWxsKHRoaXMpO1xcbiAgICB9LCBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgIT0gYSA/IDAgPiBhID8gdGhpc1thICsgdGhpcy5sZW5ndGhdIDogdGhpc1thXSA6IGUuY2FsbCh0aGlzKTtcXG4gICAgfSwgcHVzaFN0YWNrOiBmdW5jdGlvbiBwdXNoU3RhY2soYSkge1xcbiAgICAgIHZhciBiID0gbi5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGEpO3JldHVybiBiLnByZXZPYmplY3QgPSB0aGlzLCBiLmNvbnRleHQgPSB0aGlzLmNvbnRleHQsIGI7XFxuICAgIH0sIGVhY2g6IGZ1bmN0aW9uIGVhY2goYSkge1xcbiAgICAgIHJldHVybiBuLmVhY2godGhpcywgYSk7XFxuICAgIH0sIG1hcDogZnVuY3Rpb24gbWFwKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobi5tYXAodGhpcywgZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgICAgIHJldHVybiBhLmNhbGwoYiwgYywgYik7XFxuICAgICAgfSkpO1xcbiAgICB9LCBzbGljZTogZnVuY3Rpb24gc2xpY2UoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICAgIH0sIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lcSgwKTtcXG4gICAgfSwgbGFzdDogZnVuY3Rpb24gbGFzdCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lcSgtMSk7XFxuICAgIH0sIGVxOiBmdW5jdGlvbiBlcShhKSB7XFxuICAgICAgdmFyIGIgPSB0aGlzLmxlbmd0aCxcXG4gICAgICAgICAgYyA9ICthICsgKDAgPiBhID8gYiA6IDApO3JldHVybiB0aGlzLnB1c2hTdGFjayhjID49IDAgJiYgYiA+IGMgPyBbdGhpc1tjXV0gOiBbXSk7XFxuICAgIH0sIGVuZDogZnVuY3Rpb24gZW5kKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xcbiAgICB9LCBwdXNoOiBnLCBzb3J0OiBjLnNvcnQsIHNwbGljZTogYy5zcGxpY2UgfSwgbi5leHRlbmQgPSBuLmZuLmV4dGVuZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGEsXFxuICAgICAgICBiLFxcbiAgICAgICAgYyxcXG4gICAgICAgIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSBhcmd1bWVudHNbMF0gfHwge30sXFxuICAgICAgICBoID0gMSxcXG4gICAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoLFxcbiAgICAgICAgaiA9ICExO2ZvciAoXFxcImJvb2xlYW5cXFwiID09IHR5cGVvZiBnICYmIChqID0gZywgZyA9IGFyZ3VtZW50c1toXSB8fCB7fSwgaCsrKSwgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBnID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihnKSkgfHwgbi5pc0Z1bmN0aW9uKGcpIHx8IChnID0ge30pLCBoID09PSBpICYmIChnID0gdGhpcywgaC0tKTsgaSA+IGg7IGgrKykge1xcbiAgICAgIGlmIChudWxsICE9IChhID0gYXJndW1lbnRzW2hdKSkgZm9yIChiIGluIGEpIHtcXG4gICAgICAgIGMgPSBnW2JdLCBkID0gYVtiXSwgZyAhPT0gZCAmJiAoaiAmJiBkICYmIChuLmlzUGxhaW5PYmplY3QoZCkgfHwgKGUgPSBuLmlzQXJyYXkoZCkpKSA/IChlID8gKGUgPSAhMSwgZiA9IGMgJiYgbi5pc0FycmF5KGMpID8gYyA6IFtdKSA6IGYgPSBjICYmIG4uaXNQbGFpbk9iamVjdChjKSA/IGMgOiB7fSwgZ1tiXSA9IG4uZXh0ZW5kKGosIGYsIGQpKSA6IHZvaWQgMCAhPT0gZCAmJiAoZ1tiXSA9IGQpKTtcXG4gICAgICB9XFxuICAgIH1yZXR1cm4gZztcXG4gIH0sIG4uZXh0ZW5kKHsgZXhwYW5kbzogXFxcImpRdWVyeVxcXCIgKyAobSArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcXFxEL2csIFxcXCJcXFwiKSwgaXNSZWFkeTogITAsIGVycm9yOiBmdW5jdGlvbiBlcnJvcihhKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGEpO1xcbiAgICB9LCBub29wOiBmdW5jdGlvbiBub29wKCkge30sIGlzRnVuY3Rpb246IGZ1bmN0aW9uIGlzRnVuY3Rpb24oYSkge1xcbiAgICAgIHJldHVybiBcXFwiZnVuY3Rpb25cXFwiID09PSBuLnR5cGUoYSk7XFxuICAgIH0sIGlzQXJyYXk6IEFycmF5LmlzQXJyYXksIGlzV2luZG93OiBmdW5jdGlvbiBpc1dpbmRvdyhhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgIT0gYSAmJiBhID09PSBhLndpbmRvdztcXG4gICAgfSwgaXNOdW1lcmljOiBmdW5jdGlvbiBpc051bWVyaWMoYSkge1xcbiAgICAgIHZhciBiID0gYSAmJiBhLnRvU3RyaW5nKCk7cmV0dXJuICFuLmlzQXJyYXkoYSkgJiYgYiAtIHBhcnNlRmxvYXQoYikgKyAxID49IDA7XFxuICAgIH0sIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoYSkge1xcbiAgICAgIHZhciBiO2lmIChcXFwib2JqZWN0XFxcIiAhPT0gbi50eXBlKGEpIHx8IGEubm9kZVR5cGUgfHwgbi5pc1dpbmRvdyhhKSkgcmV0dXJuICExO2lmIChhLmNvbnN0cnVjdG9yICYmICFrLmNhbGwoYSwgXFxcImNvbnN0cnVjdG9yXFxcIikgJiYgIWsuY2FsbChhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSB8fCB7fSwgXFxcImlzUHJvdG90eXBlT2ZcXFwiKSkgcmV0dXJuICExO2ZvciAoYiBpbiBhKSB7fXJldHVybiB2b2lkIDAgPT09IGIgfHwgay5jYWxsKGEsIGIpO1xcbiAgICB9LCBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiBpc0VtcHR5T2JqZWN0KGEpIHtcXG4gICAgICB2YXIgYjtmb3IgKGIgaW4gYSkge1xcbiAgICAgICAgcmV0dXJuICExO1xcbiAgICAgIH1yZXR1cm4gITA7XFxuICAgIH0sIHR5cGU6IGZ1bmN0aW9uIHR5cGUoYSkge1xcbiAgICAgIHJldHVybiBudWxsID09IGEgPyBhICsgXFxcIlxcXCIgOiBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSB8fCBcXFwiZnVuY3Rpb25cXFwiID09IHR5cGVvZiBhID8gaVtqLmNhbGwoYSldIHx8IFxcXCJvYmplY3RcXFwiIDogdHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpO1xcbiAgICB9LCBnbG9iYWxFdmFsOiBmdW5jdGlvbiBnbG9iYWxFdmFsKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyA9IGV2YWw7YSA9IG4udHJpbShhKSwgYSAmJiAoMSA9PT0gYS5pbmRleE9mKFxcXCJ1c2Ugc3RyaWN0XFxcIikgPyAoYiA9IGQuY3JlYXRlRWxlbWVudChcXFwic2NyaXB0XFxcIiksIGIudGV4dCA9IGEsIGQuaGVhZC5hcHBlbmRDaGlsZChiKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpKSA6IGMoYSkpO1xcbiAgICB9LCBjYW1lbENhc2U6IGZ1bmN0aW9uIGNhbWVsQ2FzZShhKSB7XFxuICAgICAgcmV0dXJuIGEucmVwbGFjZShwLCBcXFwibXMtXFxcIikucmVwbGFjZShxLCByKTtcXG4gICAgfSwgbm9kZU5hbWU6IGZ1bmN0aW9uIG5vZGVOYW1lKGEsIGIpIHtcXG4gICAgICByZXR1cm4gYS5ub2RlTmFtZSAmJiBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IGIudG9Mb3dlckNhc2UoKTtcXG4gICAgfSwgZWFjaDogZnVuY3Rpb24gZWFjaChhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQgPSAwO2lmIChzKGEpKSB7XFxuICAgICAgICBmb3IgKGMgPSBhLmxlbmd0aDsgYyA+IGQ7IGQrKykge1xcbiAgICAgICAgICBpZiAoYi5jYWxsKGFbZF0sIGQsIGFbZF0pID09PSAhMSkgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGZvciAoZCBpbiBhKSB7XFxuICAgICAgICBpZiAoYi5jYWxsKGFbZF0sIGQsIGFbZF0pID09PSAhMSkgYnJlYWs7XFxuICAgICAgfXJldHVybiBhO1xcbiAgICB9LCB0cmltOiBmdW5jdGlvbiB0cmltKGEpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBhID8gXFxcIlxcXCIgOiAoYSArIFxcXCJcXFwiKS5yZXBsYWNlKG8sIFxcXCJcXFwiKTtcXG4gICAgfSwgbWFrZUFycmF5OiBmdW5jdGlvbiBtYWtlQXJyYXkoYSwgYikge1xcbiAgICAgIHZhciBjID0gYiB8fCBbXTtyZXR1cm4gbnVsbCAhPSBhICYmIChzKE9iamVjdChhKSkgPyBuLm1lcmdlKGMsIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhID8gW2FdIDogYSkgOiBnLmNhbGwoYywgYSkpLCBjO1xcbiAgICB9LCBpbkFycmF5OiBmdW5jdGlvbiBpbkFycmF5KGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBiID8gLTEgOiBoLmNhbGwoYiwgYSwgYyk7XFxuICAgIH0sIG1lcmdlOiBmdW5jdGlvbiBtZXJnZShhLCBiKSB7XFxuICAgICAgZm9yICh2YXIgYyA9ICtiLmxlbmd0aCwgZCA9IDAsIGUgPSBhLmxlbmd0aDsgYyA+IGQ7IGQrKykge1xcbiAgICAgICAgYVtlKytdID0gYltkXTtcXG4gICAgICB9cmV0dXJuIGEubGVuZ3RoID0gZSwgYTtcXG4gICAgfSwgZ3JlcDogZnVuY3Rpb24gZ3JlcChhLCBiLCBjKSB7XFxuICAgICAgZm9yICh2YXIgZCwgZSA9IFtdLCBmID0gMCwgZyA9IGEubGVuZ3RoLCBoID0gIWM7IGcgPiBmOyBmKyspIHtcXG4gICAgICAgIGQgPSAhYihhW2ZdLCBmKSwgZCAhPT0gaCAmJiBlLnB1c2goYVtmXSk7XFxuICAgICAgfXJldHVybiBlO1xcbiAgICB9LCBtYXA6IGZ1bmN0aW9uIG1hcChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGcgPSAwLFxcbiAgICAgICAgICBoID0gW107aWYgKHMoYSkpIGZvciAoZCA9IGEubGVuZ3RoOyBkID4gZzsgZysrKSB7XFxuICAgICAgICBlID0gYihhW2ddLCBnLCBjKSwgbnVsbCAhPSBlICYmIGgucHVzaChlKTtcXG4gICAgICB9IGVsc2UgZm9yIChnIGluIGEpIHtcXG4gICAgICAgIGUgPSBiKGFbZ10sIGcsIGMpLCBudWxsICE9IGUgJiYgaC5wdXNoKGUpO1xcbiAgICAgIH1yZXR1cm4gZi5hcHBseShbXSwgaCk7XFxuICAgIH0sIGd1aWQ6IDEsIHByb3h5OiBmdW5jdGlvbiBwcm94eShhLCBiKSB7XFxuICAgICAgdmFyIGMsIGQsIGY7cmV0dXJuIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiICYmIChjID0gYVtiXSwgYiA9IGEsIGEgPSBjKSwgbi5pc0Z1bmN0aW9uKGEpID8gKGQgPSBlLmNhbGwoYXJndW1lbnRzLCAyKSwgZiA9IGZ1bmN0aW9uIGYoKSB7XFxuICAgICAgICByZXR1cm4gYS5hcHBseShiIHx8IHRoaXMsIGQuY29uY2F0KGUuY2FsbChhcmd1bWVudHMpKSk7XFxuICAgICAgfSwgZi5ndWlkID0gYS5ndWlkID0gYS5ndWlkIHx8IG4uZ3VpZCsrLCBmKSA6IHZvaWQgMDtcXG4gICAgfSwgbm93OiBEYXRlLm5vdywgc3VwcG9ydDogbCB9KSwgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgU3ltYm9sICYmIChuLmZuW1N5bWJvbC5pdGVyYXRvcl0gPSBjW1N5bWJvbC5pdGVyYXRvcl0pLCBuLmVhY2goXFxcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBpW1xcXCJbb2JqZWN0IFxcXCIgKyBiICsgXFxcIl1cXFwiXSA9IGIudG9Mb3dlckNhc2UoKTtcXG4gIH0pO2Z1bmN0aW9uIHMoYSkge1xcbiAgICB2YXIgYiA9ICEhYSAmJiBcXFwibGVuZ3RoXFxcIiBpbiBhICYmIGEubGVuZ3RoLFxcbiAgICAgICAgYyA9IG4udHlwZShhKTtyZXR1cm4gXFxcImZ1bmN0aW9uXFxcIiA9PT0gYyB8fCBuLmlzV2luZG93KGEpID8gITEgOiBcXFwiYXJyYXlcXFwiID09PSBjIHx8IDAgPT09IGIgfHwgXFxcIm51bWJlclxcXCIgPT0gdHlwZW9mIGIgJiYgYiA+IDAgJiYgYiAtIDEgaW4gYTtcXG4gIH12YXIgdCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHZhciBiLFxcbiAgICAgICAgYyxcXG4gICAgICAgIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcsXFxuICAgICAgICBoLFxcbiAgICAgICAgaSxcXG4gICAgICAgIGosXFxuICAgICAgICBrLFxcbiAgICAgICAgbCxcXG4gICAgICAgIG0sXFxuICAgICAgICBuLFxcbiAgICAgICAgbyxcXG4gICAgICAgIHAsXFxuICAgICAgICBxLFxcbiAgICAgICAgcixcXG4gICAgICAgIHMsXFxuICAgICAgICB0LFxcbiAgICAgICAgdSA9IFxcXCJzaXp6bGVcXFwiICsgMSAqIG5ldyBEYXRlKCksXFxuICAgICAgICB2ID0gYS5kb2N1bWVudCxcXG4gICAgICAgIHcgPSAwLFxcbiAgICAgICAgeCA9IDAsXFxuICAgICAgICB5ID0gZ2EoKSxcXG4gICAgICAgIHogPSBnYSgpLFxcbiAgICAgICAgQSA9IGdhKCksXFxuICAgICAgICBCID0gZnVuY3Rpb24gQihhLCBiKSB7XFxuICAgICAgcmV0dXJuIGEgPT09IGIgJiYgKGwgPSAhMCksIDA7XFxuICAgIH0sXFxuICAgICAgICBDID0gMSA8PCAzMSxcXG4gICAgICAgIEQgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcXG4gICAgICAgIEUgPSBbXSxcXG4gICAgICAgIEYgPSBFLnBvcCxcXG4gICAgICAgIEcgPSBFLnB1c2gsXFxuICAgICAgICBIID0gRS5wdXNoLFxcbiAgICAgICAgSSA9IEUuc2xpY2UsXFxuICAgICAgICBKID0gZnVuY3Rpb24gSihhLCBiKSB7XFxuICAgICAgZm9yICh2YXIgYyA9IDAsIGQgPSBhLmxlbmd0aDsgZCA+IGM7IGMrKykge1xcbiAgICAgICAgaWYgKGFbY10gPT09IGIpIHJldHVybiBjO1xcbiAgICAgIH1yZXR1cm4gLTE7XFxuICAgIH0sXFxuICAgICAgICBLID0gXFxcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXFxcIixcXG4gICAgICAgIEwgPSBcXFwiW1xcXFxcXFxceDIwXFxcXFxcXFx0XFxcXFxcXFxyXFxcXFxcXFxuXFxcXFxcXFxmXVxcXCIsXFxuICAgICAgICBNID0gXFxcIig/OlxcXFxcXFxcXFxcXFxcXFwufFtcXFxcXFxcXHctXXxbXlxcXFxcXFxceDAwLVxcXFxcXFxceGEwXSkrXFxcIixcXG4gICAgICAgIE4gPSBcXFwiXFxcXFxcXFxbXFxcIiArIEwgKyBcXFwiKihcXFwiICsgTSArIFxcXCIpKD86XFxcIiArIEwgKyBcXFwiKihbKl4kfCF+XT89KVxcXCIgKyBMICsgXFxcIiooPzonKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCddKSopJ3xcXFxcXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIl0pKilcXFxcXFxcInwoXFxcIiArIE0gKyBcXFwiKSl8KVxcXCIgKyBMICsgXFxcIipcXFxcXFxcXF1cXFwiLFxcbiAgICAgICAgTyA9IFxcXCI6KFxcXCIgKyBNICsgXFxcIikoPzpcXFxcXFxcXCgoKCcoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcJ10pKiknfFxcXFxcXFwiKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwiXSkqKVxcXFxcXFwiKXwoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcKClbXFxcXFxcXFxdXXxcXFwiICsgTiArIFxcXCIpKil8LiopXFxcXFxcXFwpfClcXFwiLFxcbiAgICAgICAgUCA9IG5ldyBSZWdFeHAoTCArIFxcXCIrXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIFEgPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiK3woKD86XnxbXlxcXFxcXFxcXFxcXFxcXFxdKSg/OlxcXFxcXFxcXFxcXFxcXFwuKSopXFxcIiArIEwgKyBcXFwiKyRcXFwiLCBcXFwiZ1xcXCIpLFxcbiAgICAgICAgUiA9IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTCArIFxcXCIqLFxcXCIgKyBMICsgXFxcIipcXFwiKSxcXG4gICAgICAgIFMgPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiKihbPit+XXxcXFwiICsgTCArIFxcXCIpXFxcIiArIEwgKyBcXFwiKlxcXCIpLFxcbiAgICAgICAgVCA9IG5ldyBSZWdFeHAoXFxcIj1cXFwiICsgTCArIFxcXCIqKFteXFxcXFxcXFxdJ1xcXFxcXFwiXSo/KVxcXCIgKyBMICsgXFxcIipcXFxcXFxcXF1cXFwiLCBcXFwiZ1xcXCIpLFxcbiAgICAgICAgVSA9IG5ldyBSZWdFeHAoTyksXFxuICAgICAgICBWID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBNICsgXFxcIiRcXFwiKSxcXG4gICAgICAgIFcgPSB7IElEOiBuZXcgUmVnRXhwKFxcXCJeIyhcXFwiICsgTSArIFxcXCIpXFxcIiksIENMQVNTOiBuZXcgUmVnRXhwKFxcXCJeXFxcXFxcXFwuKFxcXCIgKyBNICsgXFxcIilcXFwiKSwgVEFHOiBuZXcgUmVnRXhwKFxcXCJeKFxcXCIgKyBNICsgXFxcInxbKl0pXFxcIiksIEFUVFI6IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTiksIFBTRVVETzogbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBPKSwgQ0hJTEQ6IG5ldyBSZWdFeHAoXFxcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFxcXFxcKFxcXCIgKyBMICsgXFxcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXFxcXFxkKilufClcXFwiICsgTCArIFxcXCIqKD86KFsrLV18KVxcXCIgKyBMICsgXFxcIiooXFxcXFxcXFxkKyl8KSlcXFwiICsgTCArIFxcXCIqXFxcXFxcXFwpfClcXFwiLCBcXFwiaVxcXCIpLCBib29sOiBuZXcgUmVnRXhwKFxcXCJeKD86XFxcIiArIEsgKyBcXFwiKSRcXFwiLCBcXFwiaVxcXCIpLCBuZWVkc0NvbnRleHQ6IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTCArIFxcXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcXFxcXChcXFwiICsgTCArIFxcXCIqKCg/Oi1cXFxcXFxcXGQpP1xcXFxcXFxcZCopXFxcIiArIEwgKyBcXFwiKlxcXFxcXFxcKXwpKD89W14tXXwkKVxcXCIsIFxcXCJpXFxcIikgfSxcXG4gICAgICAgIFggPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxcbiAgICAgICAgWSA9IC9eaFxcXFxkJC9pLFxcbiAgICAgICAgWiA9IC9eW157XStcXFxce1xcXFxzKlxcXFxbbmF0aXZlIFxcXFx3LyxcXG4gICAgICAgICQgPSAvXig/OiMoW1xcXFx3LV0rKXwoXFxcXHcrKXxcXFxcLihbXFxcXHctXSspKSQvLFxcbiAgICAgICAgXyA9IC9bK35dLyxcXG4gICAgICAgIGFhID0gLyd8XFxcXFxcXFwvZyxcXG4gICAgICAgIGJhID0gbmV3IFJlZ0V4cChcXFwiXFxcXFxcXFxcXFxcXFxcXChbXFxcXFxcXFxkYS1mXXsxLDZ9XFxcIiArIEwgKyBcXFwiP3woXFxcIiArIEwgKyBcXFwiKXwuKVxcXCIsIFxcXCJpZ1xcXCIpLFxcbiAgICAgICAgY2EgPSBmdW5jdGlvbiBjYShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBcXFwiMHhcXFwiICsgYiAtIDY1NTM2O3JldHVybiBkICE9PSBkIHx8IGMgPyBiIDogMCA+IGQgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGQgKyA2NTUzNikgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGQgPj4gMTAgfCA1NTI5NiwgMTAyMyAmIGQgfCA1NjMyMCk7XFxuICAgIH0sXFxuICAgICAgICBkYSA9IGZ1bmN0aW9uIGRhKCkge1xcbiAgICAgIG0oKTtcXG4gICAgfTt0cnkge1xcbiAgICAgIEguYXBwbHkoRSA9IEkuY2FsbCh2LmNoaWxkTm9kZXMpLCB2LmNoaWxkTm9kZXMpLCBFW3YuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlO1xcbiAgICB9IGNhdGNoIChlYSkge1xcbiAgICAgIEggPSB7IGFwcGx5OiBFLmxlbmd0aCA/IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIEcuYXBwbHkoYSwgSS5jYWxsKGIpKTtcXG4gICAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICB2YXIgYyA9IGEubGVuZ3RoLFxcbiAgICAgICAgICAgICAgZCA9IDA7d2hpbGUgKGFbYysrXSA9IGJbZCsrXSkge31hLmxlbmd0aCA9IGMgLSAxO1xcbiAgICAgICAgfSB9O1xcbiAgICB9ZnVuY3Rpb24gZmEoYSwgYiwgZCwgZSkge1xcbiAgICAgIHZhciBmLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICByLFxcbiAgICAgICAgICBzLFxcbiAgICAgICAgICB3ID0gYiAmJiBiLm93bmVyRG9jdW1lbnQsXFxuICAgICAgICAgIHggPSBiID8gYi5ub2RlVHlwZSA6IDk7aWYgKGQgPSBkIHx8IFtdLCBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSB8fCAhYSB8fCAxICE9PSB4ICYmIDkgIT09IHggJiYgMTEgIT09IHgpIHJldHVybiBkO2lmICghZSAmJiAoKGIgPyBiLm93bmVyRG9jdW1lbnQgfHwgYiA6IHYpICE9PSBuICYmIG0oYiksIGIgPSBiIHx8IG4sIHApKSB7XFxuICAgICAgICBpZiAoMTEgIT09IHggJiYgKG8gPSAkLmV4ZWMoYSkpKSBpZiAoZiA9IG9bMV0pIHtcXG4gICAgICAgICAgaWYgKDkgPT09IHgpIHtcXG4gICAgICAgICAgICBpZiAoIShqID0gYi5nZXRFbGVtZW50QnlJZChmKSkpIHJldHVybiBkO2lmIChqLmlkID09PSBmKSByZXR1cm4gZC5wdXNoKGopLCBkO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHcgJiYgKGogPSB3LmdldEVsZW1lbnRCeUlkKGYpKSAmJiB0KGIsIGopICYmIGouaWQgPT09IGYpIHJldHVybiBkLnB1c2goaiksIGQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAob1syXSkgcmV0dXJuIEguYXBwbHkoZCwgYi5nZXRFbGVtZW50c0J5VGFnTmFtZShhKSksIGQ7aWYgKChmID0gb1szXSkgJiYgYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkgcmV0dXJuIEguYXBwbHkoZCwgYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGYpKSwgZDtcXG4gICAgICAgIH1pZiAoYy5xc2EgJiYgIUFbYSArIFxcXCIgXFxcIl0gJiYgKCFxIHx8ICFxLnRlc3QoYSkpKSB7XFxuICAgICAgICAgIGlmICgxICE9PSB4KSB3ID0gYiwgcyA9IGE7ZWxzZSBpZiAoXFxcIm9iamVjdFxcXCIgIT09IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xcbiAgICAgICAgICAgIChrID0gYi5nZXRBdHRyaWJ1dGUoXFxcImlkXFxcIikpID8gayA9IGsucmVwbGFjZShhYSwgXFxcIlxcXFxcXFxcJCZcXFwiKSA6IGIuc2V0QXR0cmlidXRlKFxcXCJpZFxcXCIsIGsgPSB1KSwgciA9IGcoYSksIGggPSByLmxlbmd0aCwgbCA9IFYudGVzdChrKSA/IFxcXCIjXFxcIiArIGsgOiBcXFwiW2lkPSdcXFwiICsgayArIFxcXCInXVxcXCI7d2hpbGUgKGgtLSkge1xcbiAgICAgICAgICAgICAgcltoXSA9IGwgKyBcXFwiIFxcXCIgKyBxYShyW2hdKTtcXG4gICAgICAgICAgICB9cyA9IHIuam9pbihcXFwiLFxcXCIpLCB3ID0gXy50ZXN0KGEpICYmIG9hKGIucGFyZW50Tm9kZSkgfHwgYjtcXG4gICAgICAgICAgfWlmIChzKSB0cnkge1xcbiAgICAgICAgICAgIHJldHVybiBILmFwcGx5KGQsIHcucXVlcnlTZWxlY3RvckFsbChzKSksIGQ7XFxuICAgICAgICAgIH0gY2F0Y2ggKHkpIHt9IGZpbmFsbHkge1xcbiAgICAgICAgICAgIGsgPT09IHUgJiYgYi5yZW1vdmVBdHRyaWJ1dGUoXFxcImlkXFxcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIGkoYS5yZXBsYWNlKFEsIFxcXCIkMVxcXCIpLCBiLCBkLCBlKTtcXG4gICAgfWZ1bmN0aW9uIGdhKCkge1xcbiAgICAgIHZhciBhID0gW107ZnVuY3Rpb24gYihjLCBlKSB7XFxuICAgICAgICByZXR1cm4gYS5wdXNoKGMgKyBcXFwiIFxcXCIpID4gZC5jYWNoZUxlbmd0aCAmJiBkZWxldGUgYlthLnNoaWZ0KCldLCBiW2MgKyBcXFwiIFxcXCJdID0gZTtcXG4gICAgICB9cmV0dXJuIGI7XFxuICAgIH1mdW5jdGlvbiBoYShhKSB7XFxuICAgICAgcmV0dXJuIGFbdV0gPSAhMCwgYTtcXG4gICAgfWZ1bmN0aW9uIGlhKGEpIHtcXG4gICAgICB2YXIgYiA9IG4uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7dHJ5IHtcXG4gICAgICAgIHJldHVybiAhIWEoYik7XFxuICAgICAgfSBjYXRjaCAoYykge1xcbiAgICAgICAgcmV0dXJuICExO1xcbiAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICBiLnBhcmVudE5vZGUgJiYgYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLCBiID0gbnVsbDtcXG4gICAgICB9XFxuICAgIH1mdW5jdGlvbiBqYShhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBhLnNwbGl0KFxcXCJ8XFxcIiksXFxuICAgICAgICAgIGUgPSBjLmxlbmd0aDt3aGlsZSAoZS0tKSB7XFxuICAgICAgICBkLmF0dHJIYW5kbGVbY1tlXV0gPSBiO1xcbiAgICAgIH1cXG4gICAgfWZ1bmN0aW9uIGthKGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIgJiYgYSxcXG4gICAgICAgICAgZCA9IGMgJiYgMSA9PT0gYS5ub2RlVHlwZSAmJiAxID09PSBiLm5vZGVUeXBlICYmICh+Yi5zb3VyY2VJbmRleCB8fCBDKSAtICh+YS5zb3VyY2VJbmRleCB8fCBDKTtpZiAoZCkgcmV0dXJuIGQ7aWYgKGMpIHdoaWxlIChjID0gYy5uZXh0U2libGluZykge1xcbiAgICAgICAgaWYgKGMgPT09IGIpIHJldHVybiAtMTtcXG4gICAgICB9cmV0dXJuIGEgPyAxIDogLTE7XFxuICAgIH1mdW5jdGlvbiBsYShhKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICB2YXIgYyA9IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gXFxcImlucHV0XFxcIiA9PT0gYyAmJiBiLnR5cGUgPT09IGE7XFxuICAgICAgfTtcXG4gICAgfWZ1bmN0aW9uIG1hKGEpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIHZhciBjID0gYi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiAoXFxcImlucHV0XFxcIiA9PT0gYyB8fCBcXFwiYnV0dG9uXFxcIiA9PT0gYykgJiYgYi50eXBlID09PSBhO1xcbiAgICAgIH07XFxuICAgIH1mdW5jdGlvbiBuYShhKSB7XFxuICAgICAgcmV0dXJuIGhhKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICByZXR1cm4gYiA9ICtiLCBoYShmdW5jdGlvbiAoYywgZCkge1xcbiAgICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICAgIGYgPSBhKFtdLCBjLmxlbmd0aCwgYiksXFxuICAgICAgICAgICAgICBnID0gZi5sZW5ndGg7d2hpbGUgKGctLSkge1xcbiAgICAgICAgICAgIGNbZSA9IGZbZ11dICYmIChjW2VdID0gIShkW2VdID0gY1tlXSkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfWZ1bmN0aW9uIG9hKGEpIHtcXG4gICAgICByZXR1cm4gYSAmJiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5nZXRFbGVtZW50c0J5VGFnTmFtZSAmJiBhO1xcbiAgICB9YyA9IGZhLnN1cHBvcnQgPSB7fSwgZiA9IGZhLmlzWE1MID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICB2YXIgYiA9IGEgJiYgKGEub3duZXJEb2N1bWVudCB8fCBhKS5kb2N1bWVudEVsZW1lbnQ7cmV0dXJuIGIgPyBcXFwiSFRNTFxcXCIgIT09IGIubm9kZU5hbWUgOiAhMTtcXG4gICAgfSwgbSA9IGZhLnNldERvY3VtZW50ID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZyA9IGEgPyBhLm93bmVyRG9jdW1lbnQgfHwgYSA6IHY7cmV0dXJuIGcgIT09IG4gJiYgOSA9PT0gZy5ub2RlVHlwZSAmJiBnLmRvY3VtZW50RWxlbWVudCA/IChuID0gZywgbyA9IG4uZG9jdW1lbnRFbGVtZW50LCBwID0gIWYobiksIChlID0gbi5kZWZhdWx0VmlldykgJiYgZS50b3AgIT09IGUgJiYgKGUuYWRkRXZlbnRMaXN0ZW5lciA/IGUuYWRkRXZlbnRMaXN0ZW5lcihcXFwidW5sb2FkXFxcIiwgZGEsICExKSA6IGUuYXR0YWNoRXZlbnQgJiYgZS5hdHRhY2hFdmVudChcXFwib251bmxvYWRcXFwiLCBkYSkpLCBjLmF0dHJpYnV0ZXMgPSBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIGEuY2xhc3NOYW1lID0gXFxcImlcXFwiLCAhYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzTmFtZVxcXCIpO1xcbiAgICAgIH0pLCBjLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhLmFwcGVuZENoaWxkKG4uY3JlYXRlQ29tbWVudChcXFwiXFxcIikpLCAhYS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiKlxcXCIpLmxlbmd0aDtcXG4gICAgICB9KSwgYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gWi50ZXN0KG4uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSksIGMuZ2V0QnlJZCA9IGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gby5hcHBlbmRDaGlsZChhKS5pZCA9IHUsICFuLmdldEVsZW1lbnRzQnlOYW1lIHx8ICFuLmdldEVsZW1lbnRzQnlOYW1lKHUpLmxlbmd0aDtcXG4gICAgICB9KSwgYy5nZXRCeUlkID8gKGQuZmluZC5JRCA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICBpZiAoXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudEJ5SWQgJiYgcCkge1xcbiAgICAgICAgICB2YXIgYyA9IGIuZ2V0RWxlbWVudEJ5SWQoYSk7cmV0dXJuIGMgPyBbY10gOiBbXTtcXG4gICAgICAgIH1cXG4gICAgICB9LCBkLmZpbHRlci5JRCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShiYSwgY2EpO3JldHVybiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5nZXRBdHRyaWJ1dGUoXFxcImlkXFxcIikgPT09IGI7XFxuICAgICAgICB9O1xcbiAgICAgIH0pIDogKGRlbGV0ZSBkLmZpbmQuSUQsIGQuZmlsdGVyLklEID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBiID0gYS5yZXBsYWNlKGJhLCBjYSk7cmV0dXJuIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHZhciBjID0gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEuZ2V0QXR0cmlidXRlTm9kZSAmJiBhLmdldEF0dHJpYnV0ZU5vZGUoXFxcImlkXFxcIik7cmV0dXJuIGMgJiYgYy52YWx1ZSA9PT0gYjtcXG4gICAgICAgIH07XFxuICAgICAgfSksIGQuZmluZC5UQUcgPSBjLmdldEVsZW1lbnRzQnlUYWdOYW1lID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYi5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSkgOiBjLnFzYSA/IGIucXVlcnlTZWxlY3RvckFsbChhKSA6IHZvaWQgMDtcXG4gICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQgPSBbXSxcXG4gICAgICAgICAgICBlID0gMCxcXG4gICAgICAgICAgICBmID0gYi5nZXRFbGVtZW50c0J5VGFnTmFtZShhKTtpZiAoXFxcIipcXFwiID09PSBhKSB7XFxuICAgICAgICAgIHdoaWxlIChjID0gZltlKytdKSB7XFxuICAgICAgICAgICAgMSA9PT0gYy5ub2RlVHlwZSAmJiBkLnB1c2goYyk7XFxuICAgICAgICAgIH1yZXR1cm4gZDtcXG4gICAgICAgIH1yZXR1cm4gZjtcXG4gICAgICB9LCBkLmZpbmQuQ0xBU1MgPSBjLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIHAgPyBiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYSkgOiB2b2lkIDA7XFxuICAgICAgfSwgciA9IFtdLCBxID0gW10sIChjLnFzYSA9IFoudGVzdChuLnF1ZXJ5U2VsZWN0b3JBbGwpKSAmJiAoaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIG8uYXBwZW5kQ2hpbGQoYSkuaW5uZXJIVE1MID0gXFxcIjxhIGlkPSdcXFwiICsgdSArIFxcXCInPjwvYT48c2VsZWN0IGlkPSdcXFwiICsgdSArIFxcXCItXFxcXHJcXFxcXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cXFwiLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIlttc2FsbG93Y2FwdHVyZV49JyddXFxcIikubGVuZ3RoICYmIHEucHVzaChcXFwiWypeJF09XFxcIiArIEwgKyBcXFwiKig/OicnfFxcXFxcXFwiXFxcXFxcXCIpXFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiW3NlbGVjdGVkXVxcXCIpLmxlbmd0aCB8fCBxLnB1c2goXFxcIlxcXFxcXFxcW1xcXCIgKyBMICsgXFxcIiooPzp2YWx1ZXxcXFwiICsgSyArIFxcXCIpXFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiW2lkfj1cXFwiICsgdSArIFxcXCItXVxcXCIpLmxlbmd0aCB8fCBxLnB1c2goXFxcIn49XFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiOmNoZWNrZWRcXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCI6Y2hlY2tlZFxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImEjXFxcIiArIHUgKyBcXFwiKypcXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCIuIy4rWyt+XVxcXCIpO1xcbiAgICAgIH0pLCBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIGIgPSBuLmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIik7Yi5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBcXFwiaGlkZGVuXFxcIiksIGEuYXBwZW5kQ2hpbGQoYikuc2V0QXR0cmlidXRlKFxcXCJuYW1lXFxcIiwgXFxcIkRcXFwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbmFtZT1kXVxcXCIpLmxlbmd0aCAmJiBxLnB1c2goXFxcIm5hbWVcXFwiICsgTCArIFxcXCIqWypeJHwhfl0/PVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjplbmFibGVkXFxcIikubGVuZ3RoIHx8IHEucHVzaChcXFwiOmVuYWJsZWRcXFwiLCBcXFwiOmRpc2FibGVkXFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiKiw6eFxcXCIpLCBxLnB1c2goXFxcIiwuKjpcXFwiKTtcXG4gICAgICB9KSksIChjLm1hdGNoZXNTZWxlY3RvciA9IFoudGVzdChzID0gby5tYXRjaGVzIHx8IG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IG8ub01hdGNoZXNTZWxlY3RvciB8fCBvLm1zTWF0Y2hlc1NlbGVjdG9yKSkgJiYgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIGMuZGlzY29ubmVjdGVkTWF0Y2ggPSBzLmNhbGwoYSwgXFxcImRpdlxcXCIpLCBzLmNhbGwoYSwgXFxcIltzIT0nJ106eFxcXCIpLCByLnB1c2goXFxcIiE9XFxcIiwgTyk7XFxuICAgICAgfSksIHEgPSBxLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHEuam9pbihcXFwifFxcXCIpKSwgciA9IHIubGVuZ3RoICYmIG5ldyBSZWdFeHAoci5qb2luKFxcXCJ8XFxcIikpLCBiID0gWi50ZXN0KG8uY29tcGFyZURvY3VtZW50UG9zaXRpb24pLCB0ID0gYiB8fCBaLnRlc3Qoby5jb250YWlucykgPyBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgdmFyIGMgPSA5ID09PSBhLm5vZGVUeXBlID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxcbiAgICAgICAgICAgIGQgPSBiICYmIGIucGFyZW50Tm9kZTtyZXR1cm4gYSA9PT0gZCB8fCAhKCFkIHx8IDEgIT09IGQubm9kZVR5cGUgfHwgIShjLmNvbnRhaW5zID8gYy5jb250YWlucyhkKSA6IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgMTYgJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGQpKSk7XFxuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICBpZiAoYikgd2hpbGUgKGIgPSBiLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgaWYgKGIgPT09IGEpIHJldHVybiAhMDtcXG4gICAgICAgIH1yZXR1cm4gITE7XFxuICAgICAgfSwgQiA9IGIgPyBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKGEgPT09IGIpIHJldHVybiBsID0gITAsIDA7dmFyIGQgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO3JldHVybiBkID8gZCA6IChkID0gKGEub3duZXJEb2N1bWVudCB8fCBhKSA9PT0gKGIub3duZXJEb2N1bWVudCB8fCBiKSA/IGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgOiAxLCAxICYgZCB8fCAhYy5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhKSA9PT0gZCA/IGEgPT09IG4gfHwgYS5vd25lckRvY3VtZW50ID09PSB2ICYmIHQodiwgYSkgPyAtMSA6IGIgPT09IG4gfHwgYi5vd25lckRvY3VtZW50ID09PSB2ICYmIHQodiwgYikgPyAxIDogayA/IEooaywgYSkgLSBKKGssIGIpIDogMCA6IDQgJiBkID8gLTEgOiAxKTtcXG4gICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIGlmIChhID09PSBiKSByZXR1cm4gbCA9ICEwLCAwO3ZhciBjLFxcbiAgICAgICAgICAgIGQgPSAwLFxcbiAgICAgICAgICAgIGUgPSBhLnBhcmVudE5vZGUsXFxuICAgICAgICAgICAgZiA9IGIucGFyZW50Tm9kZSxcXG4gICAgICAgICAgICBnID0gW2FdLFxcbiAgICAgICAgICAgIGggPSBbYl07aWYgKCFlIHx8ICFmKSByZXR1cm4gYSA9PT0gbiA/IC0xIDogYiA9PT0gbiA/IDEgOiBlID8gLTEgOiBmID8gMSA6IGsgPyBKKGssIGEpIC0gSihrLCBiKSA6IDA7aWYgKGUgPT09IGYpIHJldHVybiBrYShhLCBiKTtjID0gYTt3aGlsZSAoYyA9IGMucGFyZW50Tm9kZSkge1xcbiAgICAgICAgICBnLnVuc2hpZnQoYyk7XFxuICAgICAgICB9YyA9IGI7d2hpbGUgKGMgPSBjLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgaC51bnNoaWZ0KGMpO1xcbiAgICAgICAgfXdoaWxlIChnW2RdID09PSBoW2RdKSB7XFxuICAgICAgICAgIGQrKztcXG4gICAgICAgIH1yZXR1cm4gZCA/IGthKGdbZF0sIGhbZF0pIDogZ1tkXSA9PT0gdiA/IC0xIDogaFtkXSA9PT0gdiA/IDEgOiAwO1xcbiAgICAgIH0sIG4pIDogbjtcXG4gICAgfSwgZmEubWF0Y2hlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGZhKGEsIG51bGwsIG51bGwsIGIpO1xcbiAgICB9LCBmYS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIGlmICgoYS5vd25lckRvY3VtZW50IHx8IGEpICE9PSBuICYmIG0oYSksIGIgPSBiLnJlcGxhY2UoVCwgXFxcIj0nJDEnXVxcXCIpLCBjLm1hdGNoZXNTZWxlY3RvciAmJiBwICYmICFBW2IgKyBcXFwiIFxcXCJdICYmICghciB8fCAhci50ZXN0KGIpKSAmJiAoIXEgfHwgIXEudGVzdChiKSkpIHRyeSB7XFxuICAgICAgICB2YXIgZCA9IHMuY2FsbChhLCBiKTtpZiAoZCB8fCBjLmRpc2Nvbm5lY3RlZE1hdGNoIHx8IGEuZG9jdW1lbnQgJiYgMTEgIT09IGEuZG9jdW1lbnQubm9kZVR5cGUpIHJldHVybiBkO1xcbiAgICAgIH0gY2F0Y2ggKGUpIHt9cmV0dXJuIGZhKGIsIG4sIG51bGwsIFthXSkubGVuZ3RoID4gMDtcXG4gICAgfSwgZmEuY29udGFpbnMgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHJldHVybiAoYS5vd25lckRvY3VtZW50IHx8IGEpICE9PSBuICYmIG0oYSksIHQoYSwgYik7XFxuICAgIH0sIGZhLmF0dHIgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIChhLm93bmVyRG9jdW1lbnQgfHwgYSkgIT09IG4gJiYgbShhKTt2YXIgZSA9IGQuYXR0ckhhbmRsZVtiLnRvTG93ZXJDYXNlKCldLFxcbiAgICAgICAgICBmID0gZSAmJiBELmNhbGwoZC5hdHRySGFuZGxlLCBiLnRvTG93ZXJDYXNlKCkpID8gZShhLCBiLCAhcCkgOiB2b2lkIDA7cmV0dXJuIHZvaWQgMCAhPT0gZiA/IGYgOiBjLmF0dHJpYnV0ZXMgfHwgIXAgPyBhLmdldEF0dHJpYnV0ZShiKSA6IChmID0gYS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSAmJiBmLnNwZWNpZmllZCA/IGYudmFsdWUgOiBudWxsO1xcbiAgICB9LCBmYS5lcnJvciA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcXFwiICsgYSk7XFxuICAgIH0sIGZhLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgIGUgPSAwLFxcbiAgICAgICAgICBmID0gMDtpZiAobCA9ICFjLmRldGVjdER1cGxpY2F0ZXMsIGsgPSAhYy5zb3J0U3RhYmxlICYmIGEuc2xpY2UoMCksIGEuc29ydChCKSwgbCkge1xcbiAgICAgICAgd2hpbGUgKGIgPSBhW2YrK10pIHtcXG4gICAgICAgICAgYiA9PT0gYVtmXSAmJiAoZSA9IGQucHVzaChmKSk7XFxuICAgICAgICB9d2hpbGUgKGUtLSkge1xcbiAgICAgICAgICBhLnNwbGljZShkW2VdLCAxKTtcXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIGsgPSBudWxsLCBhO1xcbiAgICB9LCBlID0gZmEuZ2V0VGV4dCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMgPSBcXFwiXFxcIixcXG4gICAgICAgICAgZCA9IDAsXFxuICAgICAgICAgIGYgPSBhLm5vZGVUeXBlO2lmIChmKSB7XFxuICAgICAgICBpZiAoMSA9PT0gZiB8fCA5ID09PSBmIHx8IDExID09PSBmKSB7XFxuICAgICAgICAgIGlmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYS50ZXh0Q29udGVudCkgcmV0dXJuIGEudGV4dENvbnRlbnQ7Zm9yIChhID0gYS5maXJzdENoaWxkOyBhOyBhID0gYS5uZXh0U2libGluZykge1xcbiAgICAgICAgICAgIGMgKz0gZShhKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmICgzID09PSBmIHx8IDQgPT09IGYpIHJldHVybiBhLm5vZGVWYWx1ZTtcXG4gICAgICB9IGVsc2Ugd2hpbGUgKGIgPSBhW2QrK10pIHtcXG4gICAgICAgIGMgKz0gZShiKTtcXG4gICAgICB9cmV0dXJuIGM7XFxuICAgIH0sIGQgPSBmYS5zZWxlY3RvcnMgPSB7IGNhY2hlTGVuZ3RoOiA1MCwgY3JlYXRlUHNldWRvOiBoYSwgbWF0Y2g6IFcsIGF0dHJIYW5kbGU6IHt9LCBmaW5kOiB7fSwgcmVsYXRpdmU6IHsgXFxcIj5cXFwiOiB7IGRpcjogXFxcInBhcmVudE5vZGVcXFwiLCBmaXJzdDogITAgfSwgXFxcIiBcXFwiOiB7IGRpcjogXFxcInBhcmVudE5vZGVcXFwiIH0sIFxcXCIrXFxcIjogeyBkaXI6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLCBmaXJzdDogITAgfSwgXFxcIn5cXFwiOiB7IGRpcjogXFxcInByZXZpb3VzU2libGluZ1xcXCIgfSB9LCBwcmVGaWx0ZXI6IHsgQVRUUjogZnVuY3Rpb24gQVRUUihhKSB7XFxuICAgICAgICAgIHJldHVybiBhWzFdID0gYVsxXS5yZXBsYWNlKGJhLCBjYSksIGFbM10gPSAoYVszXSB8fCBhWzRdIHx8IGFbNV0gfHwgXFxcIlxcXCIpLnJlcGxhY2UoYmEsIGNhKSwgXFxcIn49XFxcIiA9PT0gYVsyXSAmJiAoYVszXSA9IFxcXCIgXFxcIiArIGFbM10gKyBcXFwiIFxcXCIpLCBhLnNsaWNlKDAsIDQpO1xcbiAgICAgICAgfSwgQ0hJTEQ6IGZ1bmN0aW9uIENISUxEKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGFbMV0gPSBhWzFdLnRvTG93ZXJDYXNlKCksIFxcXCJudGhcXFwiID09PSBhWzFdLnNsaWNlKDAsIDMpID8gKGFbM10gfHwgZmEuZXJyb3IoYVswXSksIGFbNF0gPSArKGFbNF0gPyBhWzVdICsgKGFbNl0gfHwgMSkgOiAyICogKFxcXCJldmVuXFxcIiA9PT0gYVszXSB8fCBcXFwib2RkXFxcIiA9PT0gYVszXSkpLCBhWzVdID0gKyhhWzddICsgYVs4XSB8fCBcXFwib2RkXFxcIiA9PT0gYVszXSkpIDogYVszXSAmJiBmYS5lcnJvcihhWzBdKSwgYTtcXG4gICAgICAgIH0sIFBTRVVETzogZnVuY3Rpb24gUFNFVURPKGEpIHtcXG4gICAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgICBjID0gIWFbNl0gJiYgYVsyXTtyZXR1cm4gVy5DSElMRC50ZXN0KGFbMF0pID8gbnVsbCA6IChhWzNdID8gYVsyXSA9IGFbNF0gfHwgYVs1XSB8fCBcXFwiXFxcIiA6IGMgJiYgVS50ZXN0KGMpICYmIChiID0gZyhjLCAhMCkpICYmIChiID0gYy5pbmRleE9mKFxcXCIpXFxcIiwgYy5sZW5ndGggLSBiKSAtIGMubGVuZ3RoKSAmJiAoYVswXSA9IGFbMF0uc2xpY2UoMCwgYiksIGFbMl0gPSBjLnNsaWNlKDAsIGIpKSwgYS5zbGljZSgwLCAzKSk7XFxuICAgICAgICB9IH0sIGZpbHRlcjogeyBUQUc6IGZ1bmN0aW9uIFRBRyhhKSB7XFxuICAgICAgICAgIHZhciBiID0gYS5yZXBsYWNlKGJhLCBjYSkudG9Mb3dlckNhc2UoKTtyZXR1cm4gXFxcIipcXFwiID09PSBhID8gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiAhMDtcXG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGEubm9kZU5hbWUgJiYgYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBiO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSwgQ0xBU1M6IGZ1bmN0aW9uIENMQVNTKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSB5W2EgKyBcXFwiIFxcXCJdO3JldHVybiBiIHx8IChiID0gbmV3IFJlZ0V4cChcXFwiKF58XFxcIiArIEwgKyBcXFwiKVxcXCIgKyBhICsgXFxcIihcXFwiICsgTCArIFxcXCJ8JClcXFwiKSkgJiYgeShhLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiBiLnRlc3QoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEuY2xhc3NOYW1lICYmIGEuY2xhc3NOYW1lIHx8IFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBhLmdldEF0dHJpYnV0ZSAmJiBhLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSB8fCBcXFwiXFxcIik7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSwgQVRUUjogZnVuY3Rpb24gQVRUUihhLCBiLCBjKSB7XFxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xcbiAgICAgICAgICAgIHZhciBlID0gZmEuYXR0cihkLCBhKTtyZXR1cm4gbnVsbCA9PSBlID8gXFxcIiE9XFxcIiA9PT0gYiA6IGIgPyAoZSArPSBcXFwiXFxcIiwgXFxcIj1cXFwiID09PSBiID8gZSA9PT0gYyA6IFxcXCIhPVxcXCIgPT09IGIgPyBlICE9PSBjIDogXFxcIl49XFxcIiA9PT0gYiA/IGMgJiYgMCA9PT0gZS5pbmRleE9mKGMpIDogXFxcIio9XFxcIiA9PT0gYiA/IGMgJiYgZS5pbmRleE9mKGMpID4gLTEgOiBcXFwiJD1cXFwiID09PSBiID8gYyAmJiBlLnNsaWNlKC1jLmxlbmd0aCkgPT09IGMgOiBcXFwifj1cXFwiID09PSBiID8gKFxcXCIgXFxcIiArIGUucmVwbGFjZShQLCBcXFwiIFxcXCIpICsgXFxcIiBcXFwiKS5pbmRleE9mKGMpID4gLTEgOiBcXFwifD1cXFwiID09PSBiID8gZSA9PT0gYyB8fCBlLnNsaWNlKDAsIGMubGVuZ3RoICsgMSkgPT09IGMgKyBcXFwiLVxcXCIgOiAhMSkgOiAhMDtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sIENISUxEOiBmdW5jdGlvbiBDSElMRChhLCBiLCBjLCBkLCBlKSB7XFxuICAgICAgICAgIHZhciBmID0gXFxcIm50aFxcXCIgIT09IGEuc2xpY2UoMCwgMyksXFxuICAgICAgICAgICAgICBnID0gXFxcImxhc3RcXFwiICE9PSBhLnNsaWNlKC00KSxcXG4gICAgICAgICAgICAgIGggPSBcXFwib2YtdHlwZVxcXCIgPT09IGI7cmV0dXJuIDEgPT09IGQgJiYgMCA9PT0gZSA/IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgICAgcmV0dXJuICEhYS5wYXJlbnROb2RlO1xcbiAgICAgICAgICB9IDogZnVuY3Rpb24gKGIsIGMsIGkpIHtcXG4gICAgICAgICAgICB2YXIgaixcXG4gICAgICAgICAgICAgICAgayxcXG4gICAgICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICAgICAgbSxcXG4gICAgICAgICAgICAgICAgbixcXG4gICAgICAgICAgICAgICAgbyxcXG4gICAgICAgICAgICAgICAgcCA9IGYgIT09IGcgPyBcXFwibmV4dFNpYmxpbmdcXFwiIDogXFxcInByZXZpb3VzU2libGluZ1xcXCIsXFxuICAgICAgICAgICAgICAgIHEgPSBiLnBhcmVudE5vZGUsXFxuICAgICAgICAgICAgICAgIHIgPSBoICYmIGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcXG4gICAgICAgICAgICAgICAgcyA9ICFpICYmICFoLFxcbiAgICAgICAgICAgICAgICB0ID0gITE7aWYgKHEpIHtcXG4gICAgICAgICAgICAgIGlmIChmKSB7XFxuICAgICAgICAgICAgICAgIHdoaWxlIChwKSB7XFxuICAgICAgICAgICAgICAgICAgbSA9IGI7d2hpbGUgKG0gPSBtW3BdKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoaCA/IG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gciA6IDEgPT09IG0ubm9kZVR5cGUpIHJldHVybiAhMTtcXG4gICAgICAgICAgICAgICAgICB9byA9IHAgPSBcXFwib25seVxcXCIgPT09IGEgJiYgIW8gJiYgXFxcIm5leHRTaWJsaW5nXFxcIjtcXG4gICAgICAgICAgICAgICAgfXJldHVybiAhMDtcXG4gICAgICAgICAgICAgIH1pZiAobyA9IFtnID8gcS5maXJzdENoaWxkIDogcS5sYXN0Q2hpbGRdLCBnICYmIHMpIHtcXG4gICAgICAgICAgICAgICAgbSA9IHEsIGwgPSBtW3VdIHx8IChtW3VdID0ge30pLCBrID0gbFttLnVuaXF1ZUlEXSB8fCAobFttLnVuaXF1ZUlEXSA9IHt9KSwgaiA9IGtbYV0gfHwgW10sIG4gPSBqWzBdID09PSB3ICYmIGpbMV0sIHQgPSBuICYmIGpbMl0sIG0gPSBuICYmIHEuY2hpbGROb2Rlc1tuXTt3aGlsZSAobSA9ICsrbiAmJiBtICYmIG1bcF0gfHwgKHQgPSBuID0gMCkgfHwgby5wb3AoKSkge1xcbiAgICAgICAgICAgICAgICAgIGlmICgxID09PSBtLm5vZGVUeXBlICYmICsrdCAmJiBtID09PSBiKSB7XFxuICAgICAgICAgICAgICAgICAgICBrW2FdID0gW3csIG4sIHRdO2JyZWFrO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzICYmIChtID0gYiwgbCA9IG1bdV0gfHwgKG1bdV0gPSB7fSksIGsgPSBsW20udW5pcXVlSURdIHx8IChsW20udW5pcXVlSURdID0ge30pLCBqID0ga1thXSB8fCBbXSwgbiA9IGpbMF0gPT09IHcgJiYgalsxXSwgdCA9IG4pLCB0ID09PSAhMSkgd2hpbGUgKG0gPSArK24gJiYgbSAmJiBtW3BdIHx8ICh0ID0gbiA9IDApIHx8IG8ucG9wKCkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKChoID8gbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSByIDogMSA9PT0gbS5ub2RlVHlwZSkgJiYgKyt0ICYmIChzICYmIChsID0gbVt1XSB8fCAobVt1XSA9IHt9KSwgayA9IGxbbS51bmlxdWVJRF0gfHwgKGxbbS51bmlxdWVJRF0gPSB7fSksIGtbYV0gPSBbdywgdF0pLCBtID09PSBiKSkgYnJlYWs7XFxuICAgICAgICAgICAgICB9cmV0dXJuIHQgLT0gZSwgdCA9PT0gZCB8fCB0ICUgZCA9PT0gMCAmJiB0IC8gZCA+PSAwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sIFBTRVVETzogZnVuY3Rpb24gUFNFVURPKGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgICBlID0gZC5wc2V1ZG9zW2FdIHx8IGQuc2V0RmlsdGVyc1thLnRvTG93ZXJDYXNlKCldIHx8IGZhLmVycm9yKFxcXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFxcXCIgKyBhKTtyZXR1cm4gZVt1XSA/IGUoYikgOiBlLmxlbmd0aCA+IDEgPyAoYyA9IFthLCBhLCBcXFwiXFxcIiwgYl0sIGQuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShhLnRvTG93ZXJDYXNlKCkpID8gaGEoZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICAgICAgICB2YXIgZCxcXG4gICAgICAgICAgICAgICAgZiA9IGUoYSwgYiksXFxuICAgICAgICAgICAgICAgIGcgPSBmLmxlbmd0aDt3aGlsZSAoZy0tKSB7XFxuICAgICAgICAgICAgICBkID0gSihhLCBmW2ddKSwgYVtkXSA9ICEoY1tkXSA9IGZbZ10pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSkgOiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiBlKGEsIDAsIGMpO1xcbiAgICAgICAgICB9KSA6IGU7XFxuICAgICAgICB9IH0sIHBzZXVkb3M6IHsgbm90OiBoYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IFtdLFxcbiAgICAgICAgICAgICAgYyA9IFtdLFxcbiAgICAgICAgICAgICAgZCA9IGgoYS5yZXBsYWNlKFEsIFxcXCIkMVxcXCIpKTtyZXR1cm4gZFt1XSA/IGhhKGZ1bmN0aW9uIChhLCBiLCBjLCBlKSB7XFxuICAgICAgICAgICAgdmFyIGYsXFxuICAgICAgICAgICAgICAgIGcgPSBkKGEsIG51bGwsIGUsIFtdKSxcXG4gICAgICAgICAgICAgICAgaCA9IGEubGVuZ3RoO3doaWxlIChoLS0pIHtcXG4gICAgICAgICAgICAgIChmID0gZ1toXSkgJiYgKGFbaF0gPSAhKGJbaF0gPSBmKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChhLCBlLCBmKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPSBhLCBkKGIsIG51bGwsIGYsIGMpLCBiWzBdID0gbnVsbCwgIWMucG9wKCk7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSwgaGFzOiBoYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmEoYSwgYikubGVuZ3RoID4gMDtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0pLCBjb250YWluczogaGEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEgPSBhLnJlcGxhY2UoYmEsIGNhKSwgZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgICByZXR1cm4gKGIudGV4dENvbnRlbnQgfHwgYi5pbm5lclRleHQgfHwgZShiKSkuaW5kZXhPZihhKSA+IC0xO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksIGxhbmc6IGhhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHJldHVybiBWLnRlc3QoYSB8fCBcXFwiXFxcIikgfHwgZmEuZXJyb3IoXFxcInVuc3VwcG9ydGVkIGxhbmc6IFxcXCIgKyBhKSwgYSA9IGEucmVwbGFjZShiYSwgY2EpLnRvTG93ZXJDYXNlKCksIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgdmFyIGM7ZG8ge1xcbiAgICAgICAgICAgICAgaWYgKGMgPSBwID8gYi5sYW5nIDogYi5nZXRBdHRyaWJ1dGUoXFxcInhtbDpsYW5nXFxcIikgfHwgYi5nZXRBdHRyaWJ1dGUoXFxcImxhbmdcXFwiKSkgcmV0dXJuIGMgPSBjLnRvTG93ZXJDYXNlKCksIGMgPT09IGEgfHwgMCA9PT0gYy5pbmRleE9mKGEgKyBcXFwiLVxcXCIpO1xcbiAgICAgICAgICAgIH0gd2hpbGUgKChiID0gYi5wYXJlbnROb2RlKSAmJiAxID09PSBiLm5vZGVUeXBlKTtyZXR1cm4gITE7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSwgdGFyZ2V0OiBmdW5jdGlvbiB0YXJnZXQoYikge1xcbiAgICAgICAgICB2YXIgYyA9IGEubG9jYXRpb24gJiYgYS5sb2NhdGlvbi5oYXNoO3JldHVybiBjICYmIGMuc2xpY2UoMSkgPT09IGIuaWQ7XFxuICAgICAgICB9LCByb290OiBmdW5jdGlvbiByb290KGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEgPT09IG87XFxuICAgICAgICB9LCBmb2N1czogZnVuY3Rpb24gZm9jdXMoYSkge1xcbiAgICAgICAgICByZXR1cm4gYSA9PT0gbi5hY3RpdmVFbGVtZW50ICYmICghbi5oYXNGb2N1cyB8fCBuLmhhc0ZvY3VzKCkpICYmICEhKGEudHlwZSB8fCBhLmhyZWYgfHwgfmEudGFiSW5kZXgpO1xcbiAgICAgICAgfSwgZW5hYmxlZDogZnVuY3Rpb24gZW5hYmxlZChhKSB7XFxuICAgICAgICAgIHJldHVybiBhLmRpc2FibGVkID09PSAhMTtcXG4gICAgICAgIH0sIGRpc2FibGVkOiBmdW5jdGlvbiBkaXNhYmxlZChhKSB7XFxuICAgICAgICAgIHJldHVybiBhLmRpc2FibGVkID09PSAhMDtcXG4gICAgICAgIH0sIGNoZWNrZWQ6IGZ1bmN0aW9uIGNoZWNrZWQoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gXFxcImlucHV0XFxcIiA9PT0gYiAmJiAhIWEuY2hlY2tlZCB8fCBcXFwib3B0aW9uXFxcIiA9PT0gYiAmJiAhIWEuc2VsZWN0ZWQ7XFxuICAgICAgICB9LCBzZWxlY3RlZDogZnVuY3Rpb24gc2VsZWN0ZWQoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5wYXJlbnROb2RlICYmIGEucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCBhLnNlbGVjdGVkID09PSAhMDtcXG4gICAgICAgIH0sIGVtcHR5OiBmdW5jdGlvbiBlbXB0eShhKSB7XFxuICAgICAgICAgIGZvciAoYSA9IGEuZmlyc3RDaGlsZDsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgICAgICBpZiAoYS5ub2RlVHlwZSA8IDYpIHJldHVybiAhMTtcXG4gICAgICAgICAgfXJldHVybiAhMDtcXG4gICAgICAgIH0sIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGEpIHtcXG4gICAgICAgICAgcmV0dXJuICFkLnBzZXVkb3MuZW1wdHkoYSk7XFxuICAgICAgICB9LCBoZWFkZXI6IGZ1bmN0aW9uIGhlYWRlcihhKSB7XFxuICAgICAgICAgIHJldHVybiBZLnRlc3QoYS5ub2RlTmFtZSk7XFxuICAgICAgICB9LCBpbnB1dDogZnVuY3Rpb24gaW5wdXQoYSkge1xcbiAgICAgICAgICByZXR1cm4gWC50ZXN0KGEubm9kZU5hbWUpO1xcbiAgICAgICAgfSwgYnV0dG9uOiBmdW5jdGlvbiBidXR0b24oYSkge1xcbiAgICAgICAgICB2YXIgYiA9IGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gXFxcImlucHV0XFxcIiA9PT0gYiAmJiBcXFwiYnV0dG9uXFxcIiA9PT0gYS50eXBlIHx8IFxcXCJidXR0b25cXFwiID09PSBiO1xcbiAgICAgICAgfSwgdGV4dDogZnVuY3Rpb24gdGV4dChhKSB7XFxuICAgICAgICAgIHZhciBiO3JldHVybiBcXFwiaW5wdXRcXFwiID09PSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgJiYgXFxcInRleHRcXFwiID09PSBhLnR5cGUgJiYgKG51bGwgPT0gKGIgPSBhLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpKSB8fCBcXFwidGV4dFxcXCIgPT09IGIudG9Mb3dlckNhc2UoKSk7XFxuICAgICAgICB9LCBmaXJzdDogbmEoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gWzBdO1xcbiAgICAgICAgfSksIGxhc3Q6IG5hKGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIHJldHVybiBbYiAtIDFdO1xcbiAgICAgICAgfSksIGVxOiBuYShmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgICAgICByZXR1cm4gWzAgPiBjID8gYyArIGIgOiBjXTtcXG4gICAgICAgIH0pLCBldmVuOiBuYShmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYiA+IGM7IGMgKz0gMikge1xcbiAgICAgICAgICAgIGEucHVzaChjKTtcXG4gICAgICAgICAgfXJldHVybiBhO1xcbiAgICAgICAgfSksIG9kZDogbmEoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDE7IGIgPiBjOyBjICs9IDIpIHtcXG4gICAgICAgICAgICBhLnB1c2goYyk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pLCBsdDogbmEoZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgICAgZm9yICh2YXIgZCA9IDAgPiBjID8gYyArIGIgOiBjOyAtLWQgPj0gMDspIHtcXG4gICAgICAgICAgICBhLnB1c2goZCk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pLCBndDogbmEoZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgICAgZm9yICh2YXIgZCA9IDAgPiBjID8gYyArIGIgOiBjOyArK2QgPCBiOykge1xcbiAgICAgICAgICAgIGEucHVzaChkKTtcXG4gICAgICAgICAgfXJldHVybiBhO1xcbiAgICAgICAgfSkgfSB9LCBkLnBzZXVkb3MubnRoID0gZC5wc2V1ZG9zLmVxO2ZvciAoYiBpbiB7IHJhZGlvOiAhMCwgY2hlY2tib3g6ICEwLCBmaWxlOiAhMCwgcGFzc3dvcmQ6ICEwLCBpbWFnZTogITAgfSkge1xcbiAgICAgIGQucHNldWRvc1tiXSA9IGxhKGIpO1xcbiAgICB9Zm9yIChiIGluIHsgc3VibWl0OiAhMCwgcmVzZXQ6ICEwIH0pIHtcXG4gICAgICBkLnBzZXVkb3NbYl0gPSBtYShiKTtcXG4gICAgfWZ1bmN0aW9uIHBhKCkge31wYS5wcm90b3R5cGUgPSBkLmZpbHRlcnMgPSBkLnBzZXVkb3MsIGQuc2V0RmlsdGVycyA9IG5ldyBwYSgpLCBnID0gZmEudG9rZW5pemUgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrID0gelthICsgXFxcIiBcXFwiXTtpZiAoaykgcmV0dXJuIGIgPyAwIDogay5zbGljZSgwKTtoID0gYSwgaSA9IFtdLCBqID0gZC5wcmVGaWx0ZXI7d2hpbGUgKGgpIHtcXG4gICAgICAgIGMgJiYgIShlID0gUi5leGVjKGgpKSB8fCAoZSAmJiAoaCA9IGguc2xpY2UoZVswXS5sZW5ndGgpIHx8IGgpLCBpLnB1c2goZiA9IFtdKSksIGMgPSAhMSwgKGUgPSBTLmV4ZWMoaCkpICYmIChjID0gZS5zaGlmdCgpLCBmLnB1c2goeyB2YWx1ZTogYywgdHlwZTogZVswXS5yZXBsYWNlKFEsIFxcXCIgXFxcIikgfSksIGggPSBoLnNsaWNlKGMubGVuZ3RoKSk7Zm9yIChnIGluIGQuZmlsdGVyKSB7XFxuICAgICAgICAgICEoZSA9IFdbZ10uZXhlYyhoKSkgfHwgaltnXSAmJiAhKGUgPSBqW2ddKGUpKSB8fCAoYyA9IGUuc2hpZnQoKSwgZi5wdXNoKHsgdmFsdWU6IGMsIHR5cGU6IGcsIG1hdGNoZXM6IGUgfSksIGggPSBoLnNsaWNlKGMubGVuZ3RoKSk7XFxuICAgICAgICB9aWYgKCFjKSBicmVhaztcXG4gICAgICB9cmV0dXJuIGIgPyBoLmxlbmd0aCA6IGggPyBmYS5lcnJvcihhKSA6IHooYSwgaSkuc2xpY2UoMCk7XFxuICAgIH07ZnVuY3Rpb24gcWEoYSkge1xcbiAgICAgIGZvciAodmFyIGIgPSAwLCBjID0gYS5sZW5ndGgsIGQgPSBcXFwiXFxcIjsgYyA+IGI7IGIrKykge1xcbiAgICAgICAgZCArPSBhW2JdLnZhbHVlO1xcbiAgICAgIH1yZXR1cm4gZDtcXG4gICAgfWZ1bmN0aW9uIHJhKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCA9IGIuZGlyLFxcbiAgICAgICAgICBlID0gYyAmJiBcXFwicGFyZW50Tm9kZVxcXCIgPT09IGQsXFxuICAgICAgICAgIGYgPSB4Kys7cmV0dXJuIGIuZmlyc3QgPyBmdW5jdGlvbiAoYiwgYywgZikge1xcbiAgICAgICAgd2hpbGUgKGIgPSBiW2RdKSB7XFxuICAgICAgICAgIGlmICgxID09PSBiLm5vZGVUeXBlIHx8IGUpIHJldHVybiBhKGIsIGMsIGYpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gOiBmdW5jdGlvbiAoYiwgYywgZykge1xcbiAgICAgICAgdmFyIGgsXFxuICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICBqLFxcbiAgICAgICAgICAgIGsgPSBbdywgZl07aWYgKGcpIHtcXG4gICAgICAgICAgd2hpbGUgKGIgPSBiW2RdKSB7XFxuICAgICAgICAgICAgaWYgKCgxID09PSBiLm5vZGVUeXBlIHx8IGUpICYmIGEoYiwgYywgZykpIHJldHVybiAhMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHdoaWxlIChiID0gYltkXSkge1xcbiAgICAgICAgICBpZiAoMSA9PT0gYi5ub2RlVHlwZSB8fCBlKSB7XFxuICAgICAgICAgICAgaWYgKGogPSBiW3VdIHx8IChiW3VdID0ge30pLCBpID0galtiLnVuaXF1ZUlEXSB8fCAoaltiLnVuaXF1ZUlEXSA9IHt9KSwgKGggPSBpW2RdKSAmJiBoWzBdID09PSB3ICYmIGhbMV0gPT09IGYpIHJldHVybiBrWzJdID0gaFsyXTtpZiAoaVtkXSA9IGssIGtbMl0gPSBhKGIsIGMsIGcpKSByZXR1cm4gITA7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9ZnVuY3Rpb24gc2EoYSkge1xcbiAgICAgIHJldHVybiBhLmxlbmd0aCA+IDEgPyBmdW5jdGlvbiAoYiwgYywgZCkge1xcbiAgICAgICAgdmFyIGUgPSBhLmxlbmd0aDt3aGlsZSAoZS0tKSB7XFxuICAgICAgICAgIGlmICghYVtlXShiLCBjLCBkKSkgcmV0dXJuICExO1xcbiAgICAgICAgfXJldHVybiAhMDtcXG4gICAgICB9IDogYVswXTtcXG4gICAgfWZ1bmN0aW9uIHRhKGEsIGIsIGMpIHtcXG4gICAgICBmb3IgKHZhciBkID0gMCwgZSA9IGIubGVuZ3RoOyBlID4gZDsgZCsrKSB7XFxuICAgICAgICBmYShhLCBiW2RdLCBjKTtcXG4gICAgICB9cmV0dXJuIGM7XFxuICAgIH1mdW5jdGlvbiB1YShhLCBiLCBjLCBkLCBlKSB7XFxuICAgICAgZm9yICh2YXIgZiwgZyA9IFtdLCBoID0gMCwgaSA9IGEubGVuZ3RoLCBqID0gbnVsbCAhPSBiOyBpID4gaDsgaCsrKSB7XFxuICAgICAgICAoZiA9IGFbaF0pICYmIChjICYmICFjKGYsIGQsIGUpIHx8IChnLnB1c2goZiksIGogJiYgYi5wdXNoKGgpKSk7XFxuICAgICAgfXJldHVybiBnO1xcbiAgICB9ZnVuY3Rpb24gdmEoYSwgYiwgYywgZCwgZSwgZikge1xcbiAgICAgIHJldHVybiBkICYmICFkW3VdICYmIChkID0gdmEoZCkpLCBlICYmICFlW3VdICYmIChlID0gdmEoZSwgZikpLCBoYShmdW5jdGlvbiAoZiwgZywgaCwgaSkge1xcbiAgICAgICAgdmFyIGosXFxuICAgICAgICAgICAgayxcXG4gICAgICAgICAgICBsLFxcbiAgICAgICAgICAgIG0gPSBbXSxcXG4gICAgICAgICAgICBuID0gW10sXFxuICAgICAgICAgICAgbyA9IGcubGVuZ3RoLFxcbiAgICAgICAgICAgIHAgPSBmIHx8IHRhKGIgfHwgXFxcIipcXFwiLCBoLm5vZGVUeXBlID8gW2hdIDogaCwgW10pLFxcbiAgICAgICAgICAgIHEgPSAhYSB8fCAhZiAmJiBiID8gcCA6IHVhKHAsIG0sIGEsIGgsIGkpLFxcbiAgICAgICAgICAgIHIgPSBjID8gZSB8fCAoZiA/IGEgOiBvIHx8IGQpID8gW10gOiBnIDogcTtpZiAoYyAmJiBjKHEsIHIsIGgsIGkpLCBkKSB7XFxuICAgICAgICAgIGogPSB1YShyLCBuKSwgZChqLCBbXSwgaCwgaSksIGsgPSBqLmxlbmd0aDt3aGlsZSAoay0tKSB7XFxuICAgICAgICAgICAgKGwgPSBqW2tdKSAmJiAocltuW2tdXSA9ICEocVtuW2tdXSA9IGwpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfWlmIChmKSB7XFxuICAgICAgICAgIGlmIChlIHx8IGEpIHtcXG4gICAgICAgICAgICBpZiAoZSkge1xcbiAgICAgICAgICAgICAgaiA9IFtdLCBrID0gci5sZW5ndGg7d2hpbGUgKGstLSkge1xcbiAgICAgICAgICAgICAgICAobCA9IHJba10pICYmIGoucHVzaChxW2tdID0gbCk7XFxuICAgICAgICAgICAgICB9ZShudWxsLCByID0gW10sIGosIGkpO1xcbiAgICAgICAgICAgIH1rID0gci5sZW5ndGg7d2hpbGUgKGstLSkge1xcbiAgICAgICAgICAgICAgKGwgPSByW2tdKSAmJiAoaiA9IGUgPyBKKGYsIGwpIDogbVtrXSkgPiAtMSAmJiAoZltqXSA9ICEoZ1tqXSA9IGwpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSByID0gdWEociA9PT0gZyA/IHIuc3BsaWNlKG8sIHIubGVuZ3RoKSA6IHIpLCBlID8gZShudWxsLCBnLCByLCBpKSA6IEguYXBwbHkoZywgcik7XFxuICAgICAgfSk7XFxuICAgIH1mdW5jdGlvbiB3YShhKSB7XFxuICAgICAgZm9yICh2YXIgYiwgYywgZSwgZiA9IGEubGVuZ3RoLCBnID0gZC5yZWxhdGl2ZVthWzBdLnR5cGVdLCBoID0gZyB8fCBkLnJlbGF0aXZlW1xcXCIgXFxcIl0sIGkgPSBnID8gMSA6IDAsIGsgPSByYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XFxuICAgICAgfSwgaCwgITApLCBsID0gcmEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBKKGIsIGEpID4gLTE7XFxuICAgICAgfSwgaCwgITApLCBtID0gW2Z1bmN0aW9uIChhLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSA9ICFnICYmIChkIHx8IGMgIT09IGopIHx8ICgoYiA9IGMpLm5vZGVUeXBlID8gayhhLCBjLCBkKSA6IGwoYSwgYywgZCkpO3JldHVybiBiID0gbnVsbCwgZTtcXG4gICAgICB9XTsgZiA+IGk7IGkrKykge1xcbiAgICAgICAgaWYgKGMgPSBkLnJlbGF0aXZlW2FbaV0udHlwZV0pIG0gPSBbcmEoc2EobSksIGMpXTtlbHNlIHtcXG4gICAgICAgICAgaWYgKGMgPSBkLmZpbHRlclthW2ldLnR5cGVdLmFwcGx5KG51bGwsIGFbaV0ubWF0Y2hlcyksIGNbdV0pIHtcXG4gICAgICAgICAgICBmb3IgKGUgPSArK2k7IGYgPiBlOyBlKyspIHtcXG4gICAgICAgICAgICAgIGlmIChkLnJlbGF0aXZlW2FbZV0udHlwZV0pIGJyZWFrO1xcbiAgICAgICAgICAgIH1yZXR1cm4gdmEoaSA+IDEgJiYgc2EobSksIGkgPiAxICYmIHFhKGEuc2xpY2UoMCwgaSAtIDEpLmNvbmNhdCh7IHZhbHVlOiBcXFwiIFxcXCIgPT09IGFbaSAtIDJdLnR5cGUgPyBcXFwiKlxcXCIgOiBcXFwiXFxcIiB9KSkucmVwbGFjZShRLCBcXFwiJDFcXFwiKSwgYywgZSA+IGkgJiYgd2EoYS5zbGljZShpLCBlKSksIGYgPiBlICYmIHdhKGEgPSBhLnNsaWNlKGUpKSwgZiA+IGUgJiYgcWEoYSkpO1xcbiAgICAgICAgICB9bS5wdXNoKGMpO1xcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gc2EobSk7XFxuICAgIH1mdW5jdGlvbiB4YShhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiLmxlbmd0aCA+IDAsXFxuICAgICAgICAgIGUgPSBhLmxlbmd0aCA+IDAsXFxuICAgICAgICAgIGYgPSBmdW5jdGlvbiBmKF9mLCBnLCBoLCBpLCBrKSB7XFxuICAgICAgICB2YXIgbCxcXG4gICAgICAgICAgICBvLFxcbiAgICAgICAgICAgIHEsXFxuICAgICAgICAgICAgciA9IDAsXFxuICAgICAgICAgICAgcyA9IFxcXCIwXFxcIixcXG4gICAgICAgICAgICB0ID0gX2YgJiYgW10sXFxuICAgICAgICAgICAgdSA9IFtdLFxcbiAgICAgICAgICAgIHYgPSBqLFxcbiAgICAgICAgICAgIHggPSBfZiB8fCBlICYmIGQuZmluZC5UQUcoXFxcIipcXFwiLCBrKSxcXG4gICAgICAgICAgICB5ID0gdyArPSBudWxsID09IHYgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAuMSxcXG4gICAgICAgICAgICB6ID0geC5sZW5ndGg7Zm9yIChrICYmIChqID0gZyA9PT0gbiB8fCBnIHx8IGspOyBzICE9PSB6ICYmIG51bGwgIT0gKGwgPSB4W3NdKTsgcysrKSB7XFxuICAgICAgICAgIGlmIChlICYmIGwpIHtcXG4gICAgICAgICAgICBvID0gMCwgZyB8fCBsLm93bmVyRG9jdW1lbnQgPT09IG4gfHwgKG0obCksIGggPSAhcCk7d2hpbGUgKHEgPSBhW28rK10pIHtcXG4gICAgICAgICAgICAgIGlmIChxKGwsIGcgfHwgbiwgaCkpIHtcXG4gICAgICAgICAgICAgICAgaS5wdXNoKGwpO2JyZWFrO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1rICYmICh3ID0geSk7XFxuICAgICAgICAgIH1jICYmICgobCA9ICFxICYmIGwpICYmIHItLSwgX2YgJiYgdC5wdXNoKGwpKTtcXG4gICAgICAgIH1pZiAociArPSBzLCBjICYmIHMgIT09IHIpIHtcXG4gICAgICAgICAgbyA9IDA7d2hpbGUgKHEgPSBiW28rK10pIHtcXG4gICAgICAgICAgICBxKHQsIHUsIGcsIGgpO1xcbiAgICAgICAgICB9aWYgKF9mKSB7XFxuICAgICAgICAgICAgaWYgKHIgPiAwKSB3aGlsZSAocy0tKSB7XFxuICAgICAgICAgICAgICB0W3NdIHx8IHVbc10gfHwgKHVbc10gPSBGLmNhbGwoaSkpO1xcbiAgICAgICAgICAgIH11ID0gdWEodSk7XFxuICAgICAgICAgIH1ILmFwcGx5KGksIHUpLCBrICYmICFfZiAmJiB1Lmxlbmd0aCA+IDAgJiYgciArIGIubGVuZ3RoID4gMSAmJiBmYS51bmlxdWVTb3J0KGkpO1xcbiAgICAgICAgfXJldHVybiBrICYmICh3ID0geSwgaiA9IHYpLCB0O1xcbiAgICAgIH07cmV0dXJuIGMgPyBoYShmKSA6IGY7XFxuICAgIH1yZXR1cm4gaCA9IGZhLmNvbXBpbGUgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgIGUgPSBbXSxcXG4gICAgICAgICAgZiA9IEFbYSArIFxcXCIgXFxcIl07aWYgKCFmKSB7XFxuICAgICAgICBiIHx8IChiID0gZyhhKSksIGMgPSBiLmxlbmd0aDt3aGlsZSAoYy0tKSB7XFxuICAgICAgICAgIGYgPSB3YShiW2NdKSwgZlt1XSA/IGQucHVzaChmKSA6IGUucHVzaChmKTtcXG4gICAgICAgIH1mID0gQShhLCB4YShlLCBkKSksIGYuc2VsZWN0b3IgPSBhO1xcbiAgICAgIH1yZXR1cm4gZjtcXG4gICAgfSwgaSA9IGZhLnNlbGVjdCA9IGZ1bmN0aW9uIChhLCBiLCBlLCBmKSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0sXFxuICAgICAgICAgIG4gPSBcXFwiZnVuY3Rpb25cXFwiID09IHR5cGVvZiBhICYmIGEsXFxuICAgICAgICAgIG8gPSAhZiAmJiBnKGEgPSBuLnNlbGVjdG9yIHx8IGEpO2lmIChlID0gZSB8fCBbXSwgMSA9PT0gby5sZW5ndGgpIHtcXG4gICAgICAgIGlmIChqID0gb1swXSA9IG9bMF0uc2xpY2UoMCksIGoubGVuZ3RoID4gMiAmJiBcXFwiSURcXFwiID09PSAoayA9IGpbMF0pLnR5cGUgJiYgYy5nZXRCeUlkICYmIDkgPT09IGIubm9kZVR5cGUgJiYgcCAmJiBkLnJlbGF0aXZlW2pbMV0udHlwZV0pIHtcXG4gICAgICAgICAgaWYgKGIgPSAoZC5maW5kLklEKGsubWF0Y2hlc1swXS5yZXBsYWNlKGJhLCBjYSksIGIpIHx8IFtdKVswXSwgIWIpIHJldHVybiBlO24gJiYgKGIgPSBiLnBhcmVudE5vZGUpLCBhID0gYS5zbGljZShqLnNoaWZ0KCkudmFsdWUubGVuZ3RoKTtcXG4gICAgICAgIH1pID0gVy5uZWVkc0NvbnRleHQudGVzdChhKSA/IDAgOiBqLmxlbmd0aDt3aGlsZSAoaS0tKSB7XFxuICAgICAgICAgIGlmIChrID0galtpXSwgZC5yZWxhdGl2ZVtsID0gay50eXBlXSkgYnJlYWs7aWYgKChtID0gZC5maW5kW2xdKSAmJiAoZiA9IG0oay5tYXRjaGVzWzBdLnJlcGxhY2UoYmEsIGNhKSwgXy50ZXN0KGpbMF0udHlwZSkgJiYgb2EoYi5wYXJlbnROb2RlKSB8fCBiKSkpIHtcXG4gICAgICAgICAgICBpZiAoai5zcGxpY2UoaSwgMSksIGEgPSBmLmxlbmd0aCAmJiBxYShqKSwgIWEpIHJldHVybiBILmFwcGx5KGUsIGYpLCBlO2JyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiAobiB8fCBoKGEsIG8pKShmLCBiLCAhcCwgZSwgIWIgfHwgXy50ZXN0KGEpICYmIG9hKGIucGFyZW50Tm9kZSkgfHwgYiksIGU7XFxuICAgIH0sIGMuc29ydFN0YWJsZSA9IHUuc3BsaXQoXFxcIlxcXCIpLnNvcnQoQikuam9pbihcXFwiXFxcIikgPT09IHUsIGMuZGV0ZWN0RHVwbGljYXRlcyA9ICEhbCwgbSgpLCBjLnNvcnREZXRhY2hlZCA9IGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIDEgJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKG4uY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpO1xcbiAgICB9KSwgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gYS5pbm5lckhUTUwgPSBcXFwiPGEgaHJlZj0nIyc+PC9hPlxcXCIsIFxcXCIjXFxcIiA9PT0gYS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpO1xcbiAgICB9KSB8fCBqYShcXFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFxcXCIsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGMgPyB2b2lkIDAgOiBhLmdldEF0dHJpYnV0ZShiLCBcXFwidHlwZVxcXCIgPT09IGIudG9Mb3dlckNhc2UoKSA/IDEgOiAyKTtcXG4gICAgfSksIGMuYXR0cmlidXRlcyAmJiBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBhLmlubmVySFRNTCA9IFxcXCI8aW5wdXQvPlxcXCIsIGEuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIiwgXFxcIlxcXCIpLCBcXFwiXFxcIiA9PT0gYS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcXFwidmFsdWVcXFwiKTtcXG4gICAgfSkgfHwgamEoXFxcInZhbHVlXFxcIiwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gYyB8fCBcXFwiaW5wdXRcXFwiICE9PSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPyB2b2lkIDAgOiBhLmRlZmF1bHRWYWx1ZTtcXG4gICAgfSksIGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYS5nZXRBdHRyaWJ1dGUoXFxcImRpc2FibGVkXFxcIik7XFxuICAgIH0pIHx8IGphKEssIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQ7cmV0dXJuIGMgPyB2b2lkIDAgOiBhW2JdID09PSAhMCA/IGIudG9Mb3dlckNhc2UoKSA6IChkID0gYS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSAmJiBkLnNwZWNpZmllZCA/IGQudmFsdWUgOiBudWxsO1xcbiAgICB9KSwgZmE7XFxuICB9KGEpO24uZmluZCA9IHQsIG4uZXhwciA9IHQuc2VsZWN0b3JzLCBuLmV4cHJbXFxcIjpcXFwiXSA9IG4uZXhwci5wc2V1ZG9zLCBuLnVuaXF1ZVNvcnQgPSBuLnVuaXF1ZSA9IHQudW5pcXVlU29ydCwgbi50ZXh0ID0gdC5nZXRUZXh0LCBuLmlzWE1MRG9jID0gdC5pc1hNTCwgbi5jb250YWlucyA9IHQuY29udGFpbnM7dmFyIHUgPSBmdW5jdGlvbiB1KGEsIGIsIGMpIHtcXG4gICAgdmFyIGQgPSBbXSxcXG4gICAgICAgIGUgPSB2b2lkIDAgIT09IGM7d2hpbGUgKChhID0gYVtiXSkgJiYgOSAhPT0gYS5ub2RlVHlwZSkge1xcbiAgICAgIGlmICgxID09PSBhLm5vZGVUeXBlKSB7XFxuICAgICAgICBpZiAoZSAmJiBuKGEpLmlzKGMpKSBicmVhaztkLnB1c2goYSk7XFxuICAgICAgfVxcbiAgICB9cmV0dXJuIGQ7XFxuICB9LFxcbiAgICAgIHYgPSBmdW5jdGlvbiB2KGEsIGIpIHtcXG4gICAgZm9yICh2YXIgYyA9IFtdOyBhOyBhID0gYS5uZXh0U2libGluZykge1xcbiAgICAgIDEgPT09IGEubm9kZVR5cGUgJiYgYSAhPT0gYiAmJiBjLnB1c2goYSk7XFxuICAgIH1yZXR1cm4gYztcXG4gIH0sXFxuICAgICAgdyA9IG4uZXhwci5tYXRjaC5uZWVkc0NvbnRleHQsXFxuICAgICAgeCA9IC9ePChbXFxcXHctXSspXFxcXHMqXFxcXC8/Pig/OjxcXFxcL1xcXFwxPnwpJC8sXFxuICAgICAgeSA9IC9eLlteOiNcXFxcW1xcXFwuLF0qJC87ZnVuY3Rpb24geihhLCBiLCBjKSB7XFxuICAgIGlmIChuLmlzRnVuY3Rpb24oYikpIHJldHVybiBuLmdyZXAoYSwgZnVuY3Rpb24gKGEsIGQpIHtcXG4gICAgICByZXR1cm4gISFiLmNhbGwoYSwgZCwgYSkgIT09IGM7XFxuICAgIH0pO2lmIChiLm5vZGVUeXBlKSByZXR1cm4gbi5ncmVwKGEsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGEgPT09IGIgIT09IGM7XFxuICAgIH0pO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYikge1xcbiAgICAgIGlmICh5LnRlc3QoYikpIHJldHVybiBuLmZpbHRlcihiLCBhLCBjKTtiID0gbi5maWx0ZXIoYiwgYSk7XFxuICAgIH1yZXR1cm4gbi5ncmVwKGEsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGguY2FsbChiLCBhKSA+IC0xICE9PSBjO1xcbiAgICB9KTtcXG4gIH1uLmZpbHRlciA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gYlswXTtyZXR1cm4gYyAmJiAoYSA9IFxcXCI6bm90KFxcXCIgKyBhICsgXFxcIilcXFwiKSwgMSA9PT0gYi5sZW5ndGggJiYgMSA9PT0gZC5ub2RlVHlwZSA/IG4uZmluZC5tYXRjaGVzU2VsZWN0b3IoZCwgYSkgPyBbZF0gOiBbXSA6IG4uZmluZC5tYXRjaGVzKGEsIG4uZ3JlcChiLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiAxID09PSBhLm5vZGVUeXBlO1xcbiAgICB9KSk7XFxuICB9LCBuLmZuLmV4dGVuZCh7IGZpbmQ6IGZ1bmN0aW9uIGZpbmQoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gdGhpcy5sZW5ndGgsXFxuICAgICAgICAgIGQgPSBbXSxcXG4gICAgICAgICAgZSA9IHRoaXM7aWYgKFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBhKSByZXR1cm4gdGhpcy5wdXNoU3RhY2sobihhKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZm9yIChiID0gMDsgYyA+IGI7IGIrKykge1xcbiAgICAgICAgICBpZiAobi5jb250YWlucyhlW2JdLCB0aGlzKSkgcmV0dXJuICEwO1xcbiAgICAgICAgfVxcbiAgICAgIH0pKTtmb3IgKGIgPSAwOyBjID4gYjsgYisrKSB7XFxuICAgICAgICBuLmZpbmQoYSwgZVtiXSwgZCk7XFxuICAgICAgfXJldHVybiBkID0gdGhpcy5wdXNoU3RhY2soYyA+IDEgPyBuLnVuaXF1ZShkKSA6IGQpLCBkLnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcXFwiIFxcXCIgKyBhIDogYSwgZDtcXG4gICAgfSwgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayh6KHRoaXMsIGEgfHwgW10sICExKSk7XFxuICAgIH0sIG5vdDogZnVuY3Rpb24gbm90KGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soeih0aGlzLCBhIHx8IFtdLCAhMCkpO1xcbiAgICB9LCBpczogZnVuY3Rpb24gaXMoYSkge1xcbiAgICAgIHJldHVybiAhIXoodGhpcywgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEgJiYgdy50ZXN0KGEpID8gbihhKSA6IGEgfHwgW10sICExKS5sZW5ndGg7XFxuICAgIH0gfSk7dmFyIEEsXFxuICAgICAgQiA9IC9eKD86XFxcXHMqKDxbXFxcXHdcXFxcV10rPilbXj5dKnwjKFtcXFxcdy1dKikpJC8sXFxuICAgICAgQyA9IG4uZm4uaW5pdCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIHZhciBlLCBmO2lmICghYSkgcmV0dXJuIHRoaXM7aWYgKGMgPSBjIHx8IEEsIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhKSB7XFxuICAgICAgaWYgKGUgPSBcXFwiPFxcXCIgPT09IGFbMF0gJiYgXFxcIj5cXFwiID09PSBhW2EubGVuZ3RoIC0gMV0gJiYgYS5sZW5ndGggPj0gMyA/IFtudWxsLCBhLCBudWxsXSA6IEIuZXhlYyhhKSwgIWUgfHwgIWVbMV0gJiYgYikgcmV0dXJuICFiIHx8IGIuanF1ZXJ5ID8gKGIgfHwgYykuZmluZChhKSA6IHRoaXMuY29uc3RydWN0b3IoYikuZmluZChhKTtpZiAoZVsxXSkge1xcbiAgICAgICAgaWYgKGIgPSBiIGluc3RhbmNlb2YgbiA/IGJbMF0gOiBiLCBuLm1lcmdlKHRoaXMsIG4ucGFyc2VIVE1MKGVbMV0sIGIgJiYgYi5ub2RlVHlwZSA/IGIub3duZXJEb2N1bWVudCB8fCBiIDogZCwgITApKSwgeC50ZXN0KGVbMV0pICYmIG4uaXNQbGFpbk9iamVjdChiKSkgZm9yIChlIGluIGIpIHtcXG4gICAgICAgICAgbi5pc0Z1bmN0aW9uKHRoaXNbZV0pID8gdGhpc1tlXShiW2VdKSA6IHRoaXMuYXR0cihlLCBiW2VdKTtcXG4gICAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgICB9cmV0dXJuIGYgPSBkLmdldEVsZW1lbnRCeUlkKGVbMl0pLCBmICYmIGYucGFyZW50Tm9kZSAmJiAodGhpcy5sZW5ndGggPSAxLCB0aGlzWzBdID0gZiksIHRoaXMuY29udGV4dCA9IGQsIHRoaXMuc2VsZWN0b3IgPSBhLCB0aGlzO1xcbiAgICB9cmV0dXJuIGEubm9kZVR5cGUgPyAodGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IGEsIHRoaXMubGVuZ3RoID0gMSwgdGhpcykgOiBuLmlzRnVuY3Rpb24oYSkgPyB2b2lkIDAgIT09IGMucmVhZHkgPyBjLnJlYWR5KGEpIDogYShuKSA6ICh2b2lkIDAgIT09IGEuc2VsZWN0b3IgJiYgKHRoaXMuc2VsZWN0b3IgPSBhLnNlbGVjdG9yLCB0aGlzLmNvbnRleHQgPSBhLmNvbnRleHQpLCBuLm1ha2VBcnJheShhLCB0aGlzKSk7XFxuICB9O0MucHJvdG90eXBlID0gbi5mbiwgQSA9IG4oZCk7dmFyIEQgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcXG4gICAgICBFID0geyBjaGlsZHJlbjogITAsIGNvbnRlbnRzOiAhMCwgbmV4dDogITAsIHByZXY6ICEwIH07bi5mbi5leHRlbmQoeyBoYXM6IGZ1bmN0aW9uIGhhcyhhKSB7XFxuICAgICAgdmFyIGIgPSBuKGEsIHRoaXMpLFxcbiAgICAgICAgICBjID0gYi5sZW5ndGg7cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBjID4gYTsgYSsrKSB7XFxuICAgICAgICAgIGlmIChuLmNvbnRhaW5zKHRoaXMsIGJbYV0pKSByZXR1cm4gITA7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sIGNsb3Nlc3Q6IGZ1bmN0aW9uIGNsb3Nlc3QoYSwgYikge1xcbiAgICAgIGZvciAodmFyIGMsIGQgPSAwLCBlID0gdGhpcy5sZW5ndGgsIGYgPSBbXSwgZyA9IHcudGVzdChhKSB8fCBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSA/IG4oYSwgYiB8fCB0aGlzLmNvbnRleHQpIDogMDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgZm9yIChjID0gdGhpc1tkXTsgYyAmJiBjICE9PSBiOyBjID0gYy5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGlmIChjLm5vZGVUeXBlIDwgMTEgJiYgKGcgPyBnLmluZGV4KGMpID4gLTEgOiAxID09PSBjLm5vZGVUeXBlICYmIG4uZmluZC5tYXRjaGVzU2VsZWN0b3IoYywgYSkpKSB7XFxuICAgICAgICAgICAgZi5wdXNoKGMpO2JyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiB0aGlzLnB1c2hTdGFjayhmLmxlbmd0aCA+IDEgPyBuLnVuaXF1ZVNvcnQoZikgOiBmKTtcXG4gICAgfSwgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGEpIHtcXG4gICAgICByZXR1cm4gYSA/IFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhID8gaC5jYWxsKG4oYSksIHRoaXNbMF0pIDogaC5jYWxsKHRoaXMsIGEuanF1ZXJ5ID8gYVswXSA6IGEpIDogdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xcbiAgICB9LCBhZGQ6IGZ1bmN0aW9uIGFkZChhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4udW5pcXVlU29ydChuLm1lcmdlKHRoaXMuZ2V0KCksIG4oYSwgYikpKSk7XFxuICAgIH0sIGFkZEJhY2s6IGZ1bmN0aW9uIGFkZEJhY2soYSkge1xcbiAgICAgIHJldHVybiB0aGlzLmFkZChudWxsID09IGEgPyB0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKGEpKTtcXG4gICAgfSB9KTtmdW5jdGlvbiBGKGEsIGIpIHtcXG4gICAgd2hpbGUgKChhID0gYVtiXSkgJiYgMSAhPT0gYS5ub2RlVHlwZSkge31yZXR1cm4gYTtcXG4gIH1uLmVhY2goeyBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChhKSB7XFxuICAgICAgdmFyIGIgPSBhLnBhcmVudE5vZGU7cmV0dXJuIGIgJiYgMTEgIT09IGIubm9kZVR5cGUgPyBiIDogbnVsbDtcXG4gICAgfSwgcGFyZW50czogZnVuY3Rpb24gcGFyZW50cyhhKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcInBhcmVudE5vZGVcXFwiKTtcXG4gICAgfSwgcGFyZW50c1VudGlsOiBmdW5jdGlvbiBwYXJlbnRzVW50aWwoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJwYXJlbnROb2RlXFxcIiwgYyk7XFxuICAgIH0sIG5leHQ6IGZ1bmN0aW9uIG5leHQoYSkge1xcbiAgICAgIHJldHVybiBGKGEsIFxcXCJuZXh0U2libGluZ1xcXCIpO1xcbiAgICB9LCBwcmV2OiBmdW5jdGlvbiBwcmV2KGEpIHtcXG4gICAgICByZXR1cm4gRihhLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIik7XFxuICAgIH0sIG5leHRBbGw6IGZ1bmN0aW9uIG5leHRBbGwoYSkge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJuZXh0U2libGluZ1xcXCIpO1xcbiAgICB9LCBwcmV2QWxsOiBmdW5jdGlvbiBwcmV2QWxsKGEpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIik7XFxuICAgIH0sIG5leHRVbnRpbDogZnVuY3Rpb24gbmV4dFVudGlsKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwibmV4dFNpYmxpbmdcXFwiLCBjKTtcXG4gICAgfSwgcHJldlVudGlsOiBmdW5jdGlvbiBwcmV2VW50aWwoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLCBjKTtcXG4gICAgfSwgc2libGluZ3M6IGZ1bmN0aW9uIHNpYmxpbmdzKGEpIHtcXG4gICAgICByZXR1cm4gdigoYS5wYXJlbnROb2RlIHx8IHt9KS5maXJzdENoaWxkLCBhKTtcXG4gICAgfSwgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKGEpIHtcXG4gICAgICByZXR1cm4gdihhLmZpcnN0Q2hpbGQpO1xcbiAgICB9LCBjb250ZW50czogZnVuY3Rpb24gY29udGVudHMoYSkge1xcbiAgICAgIHJldHVybiBhLmNvbnRlbnREb2N1bWVudCB8fCBuLm1lcmdlKFtdLCBhLmNoaWxkTm9kZXMpO1xcbiAgICB9IH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZm5bYV0gPSBmdW5jdGlvbiAoYywgZCkge1xcbiAgICAgIHZhciBlID0gbi5tYXAodGhpcywgYiwgYyk7cmV0dXJuIFxcXCJVbnRpbFxcXCIgIT09IGEuc2xpY2UoLTUpICYmIChkID0gYyksIGQgJiYgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGQgJiYgKGUgPSBuLmZpbHRlcihkLCBlKSksIHRoaXMubGVuZ3RoID4gMSAmJiAoRVthXSB8fCBuLnVuaXF1ZVNvcnQoZSksIEQudGVzdChhKSAmJiBlLnJldmVyc2UoKSksIHRoaXMucHVzaFN0YWNrKGUpO1xcbiAgICB9O1xcbiAgfSk7dmFyIEcgPSAvXFxcXFMrL2c7ZnVuY3Rpb24gSChhKSB7XFxuICAgIHZhciBiID0ge307cmV0dXJuIG4uZWFjaChhLm1hdGNoKEcpIHx8IFtdLCBmdW5jdGlvbiAoYSwgYykge1xcbiAgICAgIGJbY10gPSAhMDtcXG4gICAgfSksIGI7XFxuICB9bi5DYWxsYmFja3MgPSBmdW5jdGlvbiAoYSkge1xcbiAgICBhID0gXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEgPyBIKGEpIDogbi5leHRlbmQoe30sIGEpO3ZhciBiLFxcbiAgICAgICAgYyxcXG4gICAgICAgIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZiA9IFtdLFxcbiAgICAgICAgZyA9IFtdLFxcbiAgICAgICAgaCA9IC0xLFxcbiAgICAgICAgaSA9IGZ1bmN0aW9uIGkoKSB7XFxuICAgICAgZm9yIChlID0gYS5vbmNlLCBkID0gYiA9ICEwOyBnLmxlbmd0aDsgaCA9IC0xKSB7XFxuICAgICAgICBjID0gZy5zaGlmdCgpO3doaWxlICgrK2ggPCBmLmxlbmd0aCkge1xcbiAgICAgICAgICBmW2hdLmFwcGx5KGNbMF0sIGNbMV0pID09PSAhMSAmJiBhLnN0b3BPbkZhbHNlICYmIChoID0gZi5sZW5ndGgsIGMgPSAhMSk7XFxuICAgICAgICB9XFxuICAgICAgfWEubWVtb3J5IHx8IChjID0gITEpLCBiID0gITEsIGUgJiYgKGYgPSBjID8gW10gOiBcXFwiXFxcIik7XFxuICAgIH0sXFxuICAgICAgICBqID0geyBhZGQ6IGZ1bmN0aW9uIGFkZCgpIHtcXG4gICAgICAgIHJldHVybiBmICYmIChjICYmICFiICYmIChoID0gZi5sZW5ndGggLSAxLCBnLnB1c2goYykpLCBmdW5jdGlvbiBkKGIpIHtcXG4gICAgICAgICAgbi5lYWNoKGIsIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgICAgICAgbi5pc0Z1bmN0aW9uKGMpID8gYS51bmlxdWUgJiYgai5oYXMoYykgfHwgZi5wdXNoKGMpIDogYyAmJiBjLmxlbmd0aCAmJiBcXFwic3RyaW5nXFxcIiAhPT0gbi50eXBlKGMpICYmIGQoYyk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfShhcmd1bWVudHMpLCBjICYmICFiICYmIGkoKSksIHRoaXM7XFxuICAgICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XFxuICAgICAgICByZXR1cm4gbi5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGM7d2hpbGUgKChjID0gbi5pbkFycmF5KGIsIGYsIGMpKSA+IC0xKSB7XFxuICAgICAgICAgICAgZi5zcGxpY2UoYywgMSksIGggPj0gYyAmJiBoLS07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pLCB0aGlzO1xcbiAgICAgIH0sIGhhczogZnVuY3Rpb24gaGFzKGEpIHtcXG4gICAgICAgIHJldHVybiBhID8gbi5pbkFycmF5KGEsIGYpID4gLTEgOiBmLmxlbmd0aCA+IDA7XFxuICAgICAgfSwgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xcbiAgICAgICAgcmV0dXJuIGYgJiYgKGYgPSBbXSksIHRoaXM7XFxuICAgICAgfSwgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcXG4gICAgICAgIHJldHVybiBlID0gZyA9IFtdLCBmID0gYyA9IFxcXCJcXFwiLCB0aGlzO1xcbiAgICAgIH0sIGRpc2FibGVkOiBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcXG4gICAgICAgIHJldHVybiAhZjtcXG4gICAgICB9LCBsb2NrOiBmdW5jdGlvbiBsb2NrKCkge1xcbiAgICAgICAgcmV0dXJuIGUgPSBnID0gW10sIGMgfHwgKGYgPSBjID0gXFxcIlxcXCIpLCB0aGlzO1xcbiAgICAgIH0sIGxvY2tlZDogZnVuY3Rpb24gbG9ja2VkKCkge1xcbiAgICAgICAgcmV0dXJuICEhZTtcXG4gICAgICB9LCBmaXJlV2l0aDogZnVuY3Rpb24gZmlyZVdpdGgoYSwgYykge1xcbiAgICAgICAgcmV0dXJuIGUgfHwgKGMgPSBjIHx8IFtdLCBjID0gW2EsIGMuc2xpY2UgPyBjLnNsaWNlKCkgOiBjXSwgZy5wdXNoKGMpLCBiIHx8IGkoKSksIHRoaXM7XFxuICAgICAgfSwgZmlyZTogZnVuY3Rpb24gZmlyZSgpIHtcXG4gICAgICAgIHJldHVybiBqLmZpcmVXaXRoKHRoaXMsIGFyZ3VtZW50cyksIHRoaXM7XFxuICAgICAgfSwgZmlyZWQ6IGZ1bmN0aW9uIGZpcmVkKCkge1xcbiAgICAgICAgcmV0dXJuICEhZDtcXG4gICAgICB9IH07cmV0dXJuIGo7XFxuICB9LCBuLmV4dGVuZCh7IERlZmVycmVkOiBmdW5jdGlvbiBEZWZlcnJlZChhKSB7XFxuICAgICAgdmFyIGIgPSBbW1xcXCJyZXNvbHZlXFxcIiwgXFxcImRvbmVcXFwiLCBuLkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSwgXFxcInJlc29sdmVkXFxcIl0sIFtcXFwicmVqZWN0XFxcIiwgXFxcImZhaWxcXFwiLCBuLkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSwgXFxcInJlamVjdGVkXFxcIl0sIFtcXFwibm90aWZ5XFxcIiwgXFxcInByb2dyZXNzXFxcIiwgbi5DYWxsYmFja3MoXFxcIm1lbW9yeVxcXCIpXV0sXFxuICAgICAgICAgIGMgPSBcXFwicGVuZGluZ1xcXCIsXFxuICAgICAgICAgIGQgPSB7IHN0YXRlOiBmdW5jdGlvbiBzdGF0ZSgpIHtcXG4gICAgICAgICAgcmV0dXJuIGM7XFxuICAgICAgICB9LCBhbHdheXM6IGZ1bmN0aW9uIGFsd2F5cygpIHtcXG4gICAgICAgICAgcmV0dXJuIGUuZG9uZShhcmd1bWVudHMpLmZhaWwoYXJndW1lbnRzKSwgdGhpcztcXG4gICAgICAgIH0sIHRoZW46IGZ1bmN0aW9uIHRoZW4oKSB7XFxuICAgICAgICAgIHZhciBhID0gYXJndW1lbnRzO3JldHVybiBuLkRlZmVycmVkKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICAgICAgbi5lYWNoKGIsIGZ1bmN0aW9uIChiLCBmKSB7XFxuICAgICAgICAgICAgICB2YXIgZyA9IG4uaXNGdW5jdGlvbihhW2JdKSAmJiBhW2JdO2VbZlsxXV0oZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGcgJiYgZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO2EgJiYgbi5pc0Z1bmN0aW9uKGEucHJvbWlzZSkgPyBhLnByb21pc2UoKS5wcm9ncmVzcyhjLm5vdGlmeSkuZG9uZShjLnJlc29sdmUpLmZhaWwoYy5yZWplY3QpIDogY1tmWzBdICsgXFxcIldpdGhcXFwiXSh0aGlzID09PSBkID8gYy5wcm9taXNlKCkgOiB0aGlzLCBnID8gW2FdIDogYXJndW1lbnRzKTtcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0pLCBhID0gbnVsbDtcXG4gICAgICAgICAgfSkucHJvbWlzZSgpO1xcbiAgICAgICAgfSwgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZShhKSB7XFxuICAgICAgICAgIHJldHVybiBudWxsICE9IGEgPyBuLmV4dGVuZChhLCBkKSA6IGQ7XFxuICAgICAgICB9IH0sXFxuICAgICAgICAgIGUgPSB7fTtyZXR1cm4gZC5waXBlID0gZC50aGVuLCBuLmVhY2goYiwgZnVuY3Rpb24gKGEsIGYpIHtcXG4gICAgICAgIHZhciBnID0gZlsyXSxcXG4gICAgICAgICAgICBoID0gZlszXTtkW2ZbMV1dID0gZy5hZGQsIGggJiYgZy5hZGQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBjID0gaDtcXG4gICAgICAgIH0sIGJbMSBeIGFdWzJdLmRpc2FibGUsIGJbMl1bMl0ubG9jayksIGVbZlswXV0gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiBlW2ZbMF0gKyBcXFwiV2l0aFxcXCJdKHRoaXMgPT09IGUgPyBkIDogdGhpcywgYXJndW1lbnRzKSwgdGhpcztcXG4gICAgICAgIH0sIGVbZlswXSArIFxcXCJXaXRoXFxcIl0gPSBnLmZpcmVXaXRoO1xcbiAgICAgIH0pLCBkLnByb21pc2UoZSksIGEgJiYgYS5jYWxsKGUsIGUpLCBlO1xcbiAgICB9LCB3aGVuOiBmdW5jdGlvbiB3aGVuKGEpIHtcXG4gICAgICB2YXIgYiA9IDAsXFxuICAgICAgICAgIGMgPSBlLmNhbGwoYXJndW1lbnRzKSxcXG4gICAgICAgICAgZCA9IGMubGVuZ3RoLFxcbiAgICAgICAgICBmID0gMSAhPT0gZCB8fCBhICYmIG4uaXNGdW5jdGlvbihhLnByb21pc2UpID8gZCA6IDAsXFxuICAgICAgICAgIGcgPSAxID09PSBmID8gYSA6IG4uRGVmZXJyZWQoKSxcXG4gICAgICAgICAgaCA9IGZ1bmN0aW9uIGgoYSwgYiwgYykge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XFxuICAgICAgICAgIGJbYV0gPSB0aGlzLCBjW2FdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBlLmNhbGwoYXJndW1lbnRzKSA6IGQsIGMgPT09IGkgPyBnLm5vdGlmeVdpdGgoYiwgYykgOiAtLWYgfHwgZy5yZXNvbHZlV2l0aChiLCBjKTtcXG4gICAgICAgIH07XFxuICAgICAgfSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgaztpZiAoZCA+IDEpIGZvciAoaSA9IG5ldyBBcnJheShkKSwgaiA9IG5ldyBBcnJheShkKSwgayA9IG5ldyBBcnJheShkKTsgZCA+IGI7IGIrKykge1xcbiAgICAgICAgY1tiXSAmJiBuLmlzRnVuY3Rpb24oY1tiXS5wcm9taXNlKSA/IGNbYl0ucHJvbWlzZSgpLnByb2dyZXNzKGgoYiwgaiwgaSkpLmRvbmUoaChiLCBrLCBjKSkuZmFpbChnLnJlamVjdCkgOiAtLWY7XFxuICAgICAgfXJldHVybiBmIHx8IGcucmVzb2x2ZVdpdGgoaywgYyksIGcucHJvbWlzZSgpO1xcbiAgICB9IH0pO3ZhciBJO24uZm4ucmVhZHkgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gbi5yZWFkeS5wcm9taXNlKCkuZG9uZShhKSwgdGhpcztcXG4gIH0sIG4uZXh0ZW5kKHsgaXNSZWFkeTogITEsIHJlYWR5V2FpdDogMSwgaG9sZFJlYWR5OiBmdW5jdGlvbiBob2xkUmVhZHkoYSkge1xcbiAgICAgIGEgPyBuLnJlYWR5V2FpdCsrIDogbi5yZWFkeSghMCk7XFxuICAgIH0sIHJlYWR5OiBmdW5jdGlvbiByZWFkeShhKSB7XFxuICAgICAgKGEgPT09ICEwID8gLS1uLnJlYWR5V2FpdCA6IG4uaXNSZWFkeSkgfHwgKG4uaXNSZWFkeSA9ICEwLCBhICE9PSAhMCAmJiAtLW4ucmVhZHlXYWl0ID4gMCB8fCAoSS5yZXNvbHZlV2l0aChkLCBbbl0pLCBuLmZuLnRyaWdnZXJIYW5kbGVyICYmIChuKGQpLnRyaWdnZXJIYW5kbGVyKFxcXCJyZWFkeVxcXCIpLCBuKGQpLm9mZihcXFwicmVhZHlcXFwiKSkpKTtcXG4gICAgfSB9KTtmdW5jdGlvbiBKKCkge1xcbiAgICBkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBKKSwgYS5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJsb2FkXFxcIiwgSiksIG4ucmVhZHkoKTtcXG4gIH1uLnJlYWR5LnByb21pc2UgPSBmdW5jdGlvbiAoYikge1xcbiAgICByZXR1cm4gSSB8fCAoSSA9IG4uRGVmZXJyZWQoKSwgXFxcImNvbXBsZXRlXFxcIiA9PT0gZC5yZWFkeVN0YXRlIHx8IFxcXCJsb2FkaW5nXFxcIiAhPT0gZC5yZWFkeVN0YXRlICYmICFkLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCA/IGEuc2V0VGltZW91dChuLnJlYWR5KSA6IChkLmFkZEV2ZW50TGlzdGVuZXIoXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBKKSwgYS5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkXFxcIiwgSikpKSwgSS5wcm9taXNlKGIpO1xcbiAgfSwgbi5yZWFkeS5wcm9taXNlKCk7dmFyIEsgPSBmdW5jdGlvbiBLKGEsIGIsIGMsIGQsIGUsIGYsIGcpIHtcXG4gICAgdmFyIGggPSAwLFxcbiAgICAgICAgaSA9IGEubGVuZ3RoLFxcbiAgICAgICAgaiA9IG51bGwgPT0gYztpZiAoXFxcIm9iamVjdFxcXCIgPT09IG4udHlwZShjKSkge1xcbiAgICAgIGUgPSAhMDtmb3IgKGggaW4gYykge1xcbiAgICAgICAgSyhhLCBiLCBoLCBjW2hdLCAhMCwgZiwgZyk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gZCAmJiAoZSA9ICEwLCBuLmlzRnVuY3Rpb24oZCkgfHwgKGcgPSAhMCksIGogJiYgKGcgPyAoYi5jYWxsKGEsIGQpLCBiID0gbnVsbCkgOiAoaiA9IGIsIGIgPSBmdW5jdGlvbiBiKGEsIF9iLCBjKSB7XFxuICAgICAgcmV0dXJuIGouY2FsbChuKGEpLCBjKTtcXG4gICAgfSkpLCBiKSkgZm9yICg7IGkgPiBoOyBoKyspIHtcXG4gICAgICBiKGFbaF0sIGMsIGcgPyBkIDogZC5jYWxsKGFbaF0sIGgsIGIoYVtoXSwgYykpKTtcXG4gICAgfXJldHVybiBlID8gYSA6IGogPyBiLmNhbGwoYSkgOiBpID8gYihhWzBdLCBjKSA6IGY7XFxuICB9LFxcbiAgICAgIEwgPSBmdW5jdGlvbiBMKGEpIHtcXG4gICAgcmV0dXJuIDEgPT09IGEubm9kZVR5cGUgfHwgOSA9PT0gYS5ub2RlVHlwZSB8fCAhK2Eubm9kZVR5cGU7XFxuICB9O2Z1bmN0aW9uIE0oKSB7XFxuICAgIHRoaXMuZXhwYW5kbyA9IG4uZXhwYW5kbyArIE0udWlkKys7XFxuICB9TS51aWQgPSAxLCBNLnByb3RvdHlwZSA9IHsgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIgfHwge307cmV0dXJuIGEubm9kZVR5cGUgPyBhW3RoaXMuZXhwYW5kb10gPSBjIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIHRoaXMuZXhwYW5kbywgeyB2YWx1ZTogYywgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0pLCBhW3RoaXMuZXhwYW5kb107XFxuICAgIH0sIGNhY2hlOiBmdW5jdGlvbiBjYWNoZShhKSB7XFxuICAgICAgaWYgKCFMKGEpKSByZXR1cm4ge307dmFyIGIgPSBhW3RoaXMuZXhwYW5kb107cmV0dXJuIGIgfHwgKGIgPSB7fSwgTChhKSAmJiAoYS5ub2RlVHlwZSA/IGFbdGhpcy5leHBhbmRvXSA9IGIgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgdGhpcy5leHBhbmRvLCB7IHZhbHVlOiBiLCBjb25maWd1cmFibGU6ICEwIH0pKSksIGI7XFxuICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSA9IHRoaXMuY2FjaGUoYSk7aWYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiKSBlW2JdID0gYztlbHNlIGZvciAoZCBpbiBiKSB7XFxuICAgICAgICBlW2RdID0gYltkXTtcXG4gICAgICB9cmV0dXJuIGU7XFxuICAgIH0sIGdldDogZnVuY3Rpb24gZ2V0KGEsIGIpIHtcXG4gICAgICByZXR1cm4gdm9pZCAwID09PSBiID8gdGhpcy5jYWNoZShhKSA6IGFbdGhpcy5leHBhbmRvXSAmJiBhW3RoaXMuZXhwYW5kb11bYl07XFxuICAgIH0sIGFjY2VzczogZnVuY3Rpb24gYWNjZXNzKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZDtyZXR1cm4gdm9pZCAwID09PSBiIHx8IGIgJiYgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGIgJiYgdm9pZCAwID09PSBjID8gKGQgPSB0aGlzLmdldChhLCBiKSwgdm9pZCAwICE9PSBkID8gZCA6IHRoaXMuZ2V0KGEsIG4uY2FtZWxDYXNlKGIpKSkgOiAodGhpcy5zZXQoYSwgYiwgYyksIHZvaWQgMCAhPT0gYyA/IGMgOiBiKTtcXG4gICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmID0gYVt0aGlzLmV4cGFuZG9dO2lmICh2b2lkIDAgIT09IGYpIHtcXG4gICAgICAgIGlmICh2b2lkIDAgPT09IGIpIHRoaXMucmVnaXN0ZXIoYSk7ZWxzZSB7XFxuICAgICAgICAgIG4uaXNBcnJheShiKSA/IGQgPSBiLmNvbmNhdChiLm1hcChuLmNhbWVsQ2FzZSkpIDogKGUgPSBuLmNhbWVsQ2FzZShiKSwgYiBpbiBmID8gZCA9IFtiLCBlXSA6IChkID0gZSwgZCA9IGQgaW4gZiA/IFtkXSA6IGQubWF0Y2goRykgfHwgW10pKSwgYyA9IGQubGVuZ3RoO3doaWxlIChjLS0pIHtcXG4gICAgICAgICAgICBkZWxldGUgZltkW2NdXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSh2b2lkIDAgPT09IGIgfHwgbi5pc0VtcHR5T2JqZWN0KGYpKSAmJiAoYS5ub2RlVHlwZSA/IGFbdGhpcy5leHBhbmRvXSA9IHZvaWQgMCA6IGRlbGV0ZSBhW3RoaXMuZXhwYW5kb10pO1xcbiAgICAgIH1cXG4gICAgfSwgaGFzRGF0YTogZnVuY3Rpb24gaGFzRGF0YShhKSB7XFxuICAgICAgdmFyIGIgPSBhW3RoaXMuZXhwYW5kb107cmV0dXJuIHZvaWQgMCAhPT0gYiAmJiAhbi5pc0VtcHR5T2JqZWN0KGIpO1xcbiAgICB9IH07dmFyIE4gPSBuZXcgTSgpLFxcbiAgICAgIE8gPSBuZXcgTSgpLFxcbiAgICAgIFAgPSAvXig/OlxcXFx7W1xcXFx3XFxcXFddKlxcXFx9fFxcXFxbW1xcXFx3XFxcXFddKlxcXFxdKSQvLFxcbiAgICAgIFEgPSAvW0EtWl0vZztmdW5jdGlvbiBSKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQ7aWYgKHZvaWQgMCA9PT0gYyAmJiAxID09PSBhLm5vZGVUeXBlKSBpZiAoZCA9IFxcXCJkYXRhLVxcXCIgKyBiLnJlcGxhY2UoUSwgXFxcIi0kJlxcXCIpLnRvTG93ZXJDYXNlKCksIGMgPSBhLmdldEF0dHJpYnV0ZShkKSwgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGMpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgYyA9IFxcXCJ0cnVlXFxcIiA9PT0gYyA/ICEwIDogXFxcImZhbHNlXFxcIiA9PT0gYyA/ICExIDogXFxcIm51bGxcXFwiID09PSBjID8gbnVsbCA6ICtjICsgXFxcIlxcXCIgPT09IGMgPyArYyA6IFAudGVzdChjKSA/IG4ucGFyc2VKU09OKGMpIDogYztcXG4gICAgICB9IGNhdGNoIChlKSB7fU8uc2V0KGEsIGIsIGMpO1xcbiAgICB9IGVsc2UgYyA9IHZvaWQgMDtyZXR1cm4gYztcXG4gIH1uLmV4dGVuZCh7IGhhc0RhdGE6IGZ1bmN0aW9uIGhhc0RhdGEoYSkge1xcbiAgICAgIHJldHVybiBPLmhhc0RhdGEoYSkgfHwgTi5oYXNEYXRhKGEpO1xcbiAgICB9LCBkYXRhOiBmdW5jdGlvbiBkYXRhKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gTy5hY2Nlc3MoYSwgYiwgYyk7XFxuICAgIH0sIHJlbW92ZURhdGE6IGZ1bmN0aW9uIHJlbW92ZURhdGEoYSwgYikge1xcbiAgICAgIE8ucmVtb3ZlKGEsIGIpO1xcbiAgICB9LCBfZGF0YTogZnVuY3Rpb24gX2RhdGEoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBOLmFjY2VzcyhhLCBiLCBjKTtcXG4gICAgfSwgX3JlbW92ZURhdGE6IGZ1bmN0aW9uIF9yZW1vdmVEYXRhKGEsIGIpIHtcXG4gICAgICBOLnJlbW92ZShhLCBiKTtcXG4gICAgfSB9KSwgbi5mbi5leHRlbmQoeyBkYXRhOiBmdW5jdGlvbiBkYXRhKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZiA9IHRoaXNbMF0sXFxuICAgICAgICAgIGcgPSBmICYmIGYuYXR0cmlidXRlcztpZiAodm9pZCAwID09PSBhKSB7XFxuICAgICAgICBpZiAodGhpcy5sZW5ndGggJiYgKGUgPSBPLmdldChmKSwgMSA9PT0gZi5ub2RlVHlwZSAmJiAhTi5nZXQoZiwgXFxcImhhc0RhdGFBdHRyc1xcXCIpKSkge1xcbiAgICAgICAgICBjID0gZy5sZW5ndGg7d2hpbGUgKGMtLSkge1xcbiAgICAgICAgICAgIGdbY10gJiYgKGQgPSBnW2NdLm5hbWUsIDAgPT09IGQuaW5kZXhPZihcXFwiZGF0YS1cXFwiKSAmJiAoZCA9IG4uY2FtZWxDYXNlKGQuc2xpY2UoNSkpLCBSKGYsIGQsIGVbZF0pKSk7XFxuICAgICAgICAgIH1OLnNldChmLCBcXFwiaGFzRGF0YUF0dHJzXFxcIiwgITApO1xcbiAgICAgICAgfXJldHVybiBlO1xcbiAgICAgIH1yZXR1cm4gXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKSkgPyB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgTy5zZXQodGhpcywgYSk7XFxuICAgICAgfSkgOiBLKHRoaXMsIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICB2YXIgYywgZDtpZiAoZiAmJiB2b2lkIDAgPT09IGIpIHtcXG4gICAgICAgICAgaWYgKGMgPSBPLmdldChmLCBhKSB8fCBPLmdldChmLCBhLnJlcGxhY2UoUSwgXFxcIi0kJlxcXCIpLnRvTG93ZXJDYXNlKCkpLCB2b2lkIDAgIT09IGMpIHJldHVybiBjO2lmIChkID0gbi5jYW1lbENhc2UoYSksIGMgPSBPLmdldChmLCBkKSwgdm9pZCAwICE9PSBjKSByZXR1cm4gYztpZiAoYyA9IFIoZiwgZCwgdm9pZCAwKSwgdm9pZCAwICE9PSBjKSByZXR1cm4gYztcXG4gICAgICAgIH0gZWxzZSBkID0gbi5jYW1lbENhc2UoYSksIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBjID0gTy5nZXQodGhpcywgZCk7Ty5zZXQodGhpcywgZCwgYiksIGEuaW5kZXhPZihcXFwiLVxcXCIpID4gLTEgJiYgdm9pZCAwICE9PSBjICYmIE8uc2V0KHRoaXMsIGEsIGIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgbnVsbCwgYiwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsICEwKTtcXG4gICAgfSwgcmVtb3ZlRGF0YTogZnVuY3Rpb24gcmVtb3ZlRGF0YShhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBPLnJlbW92ZSh0aGlzLCBhKTtcXG4gICAgICB9KTtcXG4gICAgfSB9KSwgbi5leHRlbmQoeyBxdWV1ZTogZnVuY3Rpb24gcXVldWUoYSwgYiwgYykge1xcbiAgICAgIHZhciBkO3JldHVybiBhID8gKGIgPSAoYiB8fCBcXFwiZnhcXFwiKSArIFxcXCJxdWV1ZVxcXCIsIGQgPSBOLmdldChhLCBiKSwgYyAmJiAoIWQgfHwgbi5pc0FycmF5KGMpID8gZCA9IE4uYWNjZXNzKGEsIGIsIG4ubWFrZUFycmF5KGMpKSA6IGQucHVzaChjKSksIGQgfHwgW10pIDogdm9pZCAwO1xcbiAgICB9LCBkZXF1ZXVlOiBmdW5jdGlvbiBkZXF1ZXVlKGEsIGIpIHtcXG4gICAgICBiID0gYiB8fCBcXFwiZnhcXFwiO3ZhciBjID0gbi5xdWV1ZShhLCBiKSxcXG4gICAgICAgICAgZCA9IGMubGVuZ3RoLFxcbiAgICAgICAgICBlID0gYy5zaGlmdCgpLFxcbiAgICAgICAgICBmID0gbi5fcXVldWVIb29rcyhhLCBiKSxcXG4gICAgICAgICAgZyA9IGZ1bmN0aW9uIGcoKSB7XFxuICAgICAgICBuLmRlcXVldWUoYSwgYik7XFxuICAgICAgfTtcXFwiaW5wcm9ncmVzc1xcXCIgPT09IGUgJiYgKGUgPSBjLnNoaWZ0KCksIGQtLSksIGUgJiYgKFxcXCJmeFxcXCIgPT09IGIgJiYgYy51bnNoaWZ0KFxcXCJpbnByb2dyZXNzXFxcIiksIGRlbGV0ZSBmLnN0b3AsIGUuY2FsbChhLCBnLCBmKSksICFkICYmIGYgJiYgZi5lbXB0eS5maXJlKCk7XFxuICAgIH0sIF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiBfcXVldWVIb29rcyhhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiICsgXFxcInF1ZXVlSG9va3NcXFwiO3JldHVybiBOLmdldChhLCBjKSB8fCBOLmFjY2VzcyhhLCBjLCB7IGVtcHR5OiBuLkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKS5hZGQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBOLnJlbW92ZShhLCBbYiArIFxcXCJxdWV1ZVxcXCIsIGNdKTtcXG4gICAgICAgIH0pIH0pO1xcbiAgICB9IH0pLCBuLmZuLmV4dGVuZCh7IHF1ZXVlOiBmdW5jdGlvbiBxdWV1ZShhLCBiKSB7XFxuICAgICAgdmFyIGMgPSAyO3JldHVybiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSAmJiAoYiA9IGEsIGEgPSBcXFwiZnhcXFwiLCBjLS0pLCBhcmd1bWVudHMubGVuZ3RoIDwgYyA/IG4ucXVldWUodGhpc1swXSwgYSkgOiB2b2lkIDAgPT09IGIgPyB0aGlzIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBjID0gbi5xdWV1ZSh0aGlzLCBhLCBiKTtuLl9xdWV1ZUhvb2tzKHRoaXMsIGEpLCBcXFwiZnhcXFwiID09PSBhICYmIFxcXCJpbnByb2dyZXNzXFxcIiAhPT0gY1swXSAmJiBuLmRlcXVldWUodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0sIGRlcXVldWU6IGZ1bmN0aW9uIGRlcXVldWUoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbi5kZXF1ZXVlKHRoaXMsIGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBjbGVhclF1ZXVlOiBmdW5jdGlvbiBjbGVhclF1ZXVlKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5xdWV1ZShhIHx8IFxcXCJmeFxcXCIsIFtdKTtcXG4gICAgfSwgcHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZShhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQgPSAxLFxcbiAgICAgICAgICBlID0gbi5EZWZlcnJlZCgpLFxcbiAgICAgICAgICBmID0gdGhpcyxcXG4gICAgICAgICAgZyA9IHRoaXMubGVuZ3RoLFxcbiAgICAgICAgICBoID0gZnVuY3Rpb24gaCgpIHtcXG4gICAgICAgIC0tZCB8fCBlLnJlc29sdmVXaXRoKGYsIFtmXSk7XFxuICAgICAgfTtcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSAmJiAoYiA9IGEsIGEgPSB2b2lkIDApLCBhID0gYSB8fCBcXFwiZnhcXFwiO3doaWxlIChnLS0pIHtcXG4gICAgICAgIGMgPSBOLmdldChmW2ddLCBhICsgXFxcInF1ZXVlSG9va3NcXFwiKSwgYyAmJiBjLmVtcHR5ICYmIChkKyssIGMuZW1wdHkuYWRkKGgpKTtcXG4gICAgICB9cmV0dXJuIGgoKSwgZS5wcm9taXNlKGIpO1xcbiAgICB9IH0pO3ZhciBTID0gL1srLV0/KD86XFxcXGQqXFxcXC58KVxcXFxkKyg/OltlRV1bKy1dP1xcXFxkK3wpLy5zb3VyY2UsXFxuICAgICAgVCA9IG5ldyBSZWdFeHAoXFxcIl4oPzooWystXSk9fCkoXFxcIiArIFMgKyBcXFwiKShbYS16JV0qKSRcXFwiLCBcXFwiaVxcXCIpLFxcbiAgICAgIFUgPSBbXFxcIlRvcFxcXCIsIFxcXCJSaWdodFxcXCIsIFxcXCJCb3R0b21cXFwiLCBcXFwiTGVmdFxcXCJdLFxcbiAgICAgIFYgPSBmdW5jdGlvbiBWKGEsIGIpIHtcXG4gICAgcmV0dXJuIGEgPSBiIHx8IGEsIFxcXCJub25lXFxcIiA9PT0gbi5jc3MoYSwgXFxcImRpc3BsYXlcXFwiKSB8fCAhbi5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsIGEpO1xcbiAgfTtmdW5jdGlvbiBXKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUsXFxuICAgICAgICBmID0gMSxcXG4gICAgICAgIGcgPSAyMCxcXG4gICAgICAgIGggPSBkID8gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBkLmN1cigpO1xcbiAgICB9IDogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBuLmNzcyhhLCBiLCBcXFwiXFxcIik7XFxuICAgIH0sXFxuICAgICAgICBpID0gaCgpLFxcbiAgICAgICAgaiA9IGMgJiYgY1szXSB8fCAobi5jc3NOdW1iZXJbYl0gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIpLFxcbiAgICAgICAgayA9IChuLmNzc051bWJlcltiXSB8fCBcXFwicHhcXFwiICE9PSBqICYmICtpKSAmJiBULmV4ZWMobi5jc3MoYSwgYikpO2lmIChrICYmIGtbM10gIT09IGopIHtcXG4gICAgICBqID0gaiB8fCBrWzNdLCBjID0gYyB8fCBbXSwgayA9ICtpIHx8IDE7ZG8ge1xcbiAgICAgICAgZiA9IGYgfHwgXFxcIi41XFxcIiwgayAvPSBmLCBuLnN0eWxlKGEsIGIsIGsgKyBqKTtcXG4gICAgICB9IHdoaWxlIChmICE9PSAoZiA9IGgoKSAvIGkpICYmIDEgIT09IGYgJiYgLS1nKTtcXG4gICAgfXJldHVybiBjICYmIChrID0gK2sgfHwgK2kgfHwgMCwgZSA9IGNbMV0gPyBrICsgKGNbMV0gKyAxKSAqIGNbMl0gOiArY1syXSwgZCAmJiAoZC51bml0ID0gaiwgZC5zdGFydCA9IGssIGQuZW5kID0gZSkpLCBlO1xcbiAgfXZhciBYID0gL14oPzpjaGVja2JveHxyYWRpbykkL2ksXFxuICAgICAgWSA9IC88KFtcXFxcdzotXSspLyxcXG4gICAgICBaID0gL14kfFxcXFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxcbiAgICAgICQgPSB7IG9wdGlvbjogWzEsIFxcXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XFxcIiwgXFxcIjwvc2VsZWN0PlxcXCJdLCB0aGVhZDogWzEsIFxcXCI8dGFibGU+XFxcIiwgXFxcIjwvdGFibGU+XFxcIl0sIGNvbDogWzIsIFxcXCI8dGFibGU+PGNvbGdyb3VwPlxcXCIsIFxcXCI8L2NvbGdyb3VwPjwvdGFibGU+XFxcIl0sIHRyOiBbMiwgXFxcIjx0YWJsZT48dGJvZHk+XFxcIiwgXFxcIjwvdGJvZHk+PC90YWJsZT5cXFwiXSwgdGQ6IFszLCBcXFwiPHRhYmxlPjx0Ym9keT48dHI+XFxcIiwgXFxcIjwvdHI+PC90Ym9keT48L3RhYmxlPlxcXCJdLCBfZGVmYXVsdDogWzAsIFxcXCJcXFwiLCBcXFwiXFxcIl0gfTskLm9wdGdyb3VwID0gJC5vcHRpb24sICQudGJvZHkgPSAkLnRmb290ID0gJC5jb2xncm91cCA9ICQuY2FwdGlvbiA9ICQudGhlYWQsICQudGggPSAkLnRkO2Z1bmN0aW9uIF8oYSwgYikge1xcbiAgICB2YXIgYyA9IFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBhLmdldEVsZW1lbnRzQnlUYWdOYW1lID8gYS5nZXRFbGVtZW50c0J5VGFnTmFtZShiIHx8IFxcXCIqXFxcIikgOiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5xdWVyeVNlbGVjdG9yQWxsID8gYS5xdWVyeVNlbGVjdG9yQWxsKGIgfHwgXFxcIipcXFwiKSA6IFtdO3JldHVybiB2b2lkIDAgPT09IGIgfHwgYiAmJiBuLm5vZGVOYW1lKGEsIGIpID8gbi5tZXJnZShbYV0sIGMpIDogYztcXG4gIH1mdW5jdGlvbiBhYShhLCBiKSB7XFxuICAgIGZvciAodmFyIGMgPSAwLCBkID0gYS5sZW5ndGg7IGQgPiBjOyBjKyspIHtcXG4gICAgICBOLnNldChhW2NdLCBcXFwiZ2xvYmFsRXZhbFxcXCIsICFiIHx8IE4uZ2V0KGJbY10sIFxcXCJnbG9iYWxFdmFsXFxcIikpO1xcbiAgICB9XFxuICB9dmFyIGJhID0gLzx8JiM/XFxcXHcrOy87ZnVuY3Rpb24gY2EoYSwgYiwgYywgZCwgZSkge1xcbiAgICBmb3IgKHZhciBmLCBnLCBoLCBpLCBqLCBrLCBsID0gYi5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIG0gPSBbXSwgbyA9IDAsIHAgPSBhLmxlbmd0aDsgcCA+IG87IG8rKykge1xcbiAgICAgIGlmIChmID0gYVtvXSwgZiB8fCAwID09PSBmKSBpZiAoXFxcIm9iamVjdFxcXCIgPT09IG4udHlwZShmKSkgbi5tZXJnZShtLCBmLm5vZGVUeXBlID8gW2ZdIDogZik7ZWxzZSBpZiAoYmEudGVzdChmKSkge1xcbiAgICAgICAgZyA9IGcgfHwgbC5hcHBlbmRDaGlsZChiLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpKSwgaCA9IChZLmV4ZWMoZikgfHwgW1xcXCJcXFwiLCBcXFwiXFxcIl0pWzFdLnRvTG93ZXJDYXNlKCksIGkgPSAkW2hdIHx8ICQuX2RlZmF1bHQsIGcuaW5uZXJIVE1MID0gaVsxXSArIG4uaHRtbFByZWZpbHRlcihmKSArIGlbMl0sIGsgPSBpWzBdO3doaWxlIChrLS0pIHtcXG4gICAgICAgICAgZyA9IGcubGFzdENoaWxkO1xcbiAgICAgICAgfW4ubWVyZ2UobSwgZy5jaGlsZE5vZGVzKSwgZyA9IGwuZmlyc3RDaGlsZCwgZy50ZXh0Q29udGVudCA9IFxcXCJcXFwiO1xcbiAgICAgIH0gZWxzZSBtLnB1c2goYi5jcmVhdGVUZXh0Tm9kZShmKSk7XFxuICAgIH1sLnRleHRDb250ZW50ID0gXFxcIlxcXCIsIG8gPSAwO3doaWxlIChmID0gbVtvKytdKSB7XFxuICAgICAgaWYgKGQgJiYgbi5pbkFycmF5KGYsIGQpID4gLTEpIGUgJiYgZS5wdXNoKGYpO2Vsc2UgaWYgKGogPSBuLmNvbnRhaW5zKGYub3duZXJEb2N1bWVudCwgZiksIGcgPSBfKGwuYXBwZW5kQ2hpbGQoZiksIFxcXCJzY3JpcHRcXFwiKSwgaiAmJiBhYShnKSwgYykge1xcbiAgICAgICAgayA9IDA7d2hpbGUgKGYgPSBnW2srK10pIHtcXG4gICAgICAgICAgWi50ZXN0KGYudHlwZSB8fCBcXFwiXFxcIikgJiYgYy5wdXNoKGYpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfXJldHVybiBsO1xcbiAgfSFmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhID0gZC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXFxuICAgICAgICBiID0gYS5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpKSxcXG4gICAgICAgIGMgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIik7Yy5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBcXFwicmFkaW9cXFwiKSwgYy5zZXRBdHRyaWJ1dGUoXFxcImNoZWNrZWRcXFwiLCBcXFwiY2hlY2tlZFxcXCIpLCBjLnNldEF0dHJpYnV0ZShcXFwibmFtZVxcXCIsIFxcXCJ0XFxcIiksIGIuYXBwZW5kQ2hpbGQoYyksIGwuY2hlY2tDbG9uZSA9IGIuY2xvbmVOb2RlKCEwKS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5jaGVja2VkLCBiLmlubmVySFRNTCA9IFxcXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XFxcIiwgbC5ub0Nsb25lQ2hlY2tlZCA9ICEhYi5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XFxuICB9KCk7dmFyIGRhID0gL15rZXkvLFxcbiAgICAgIGVhID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxcbiAgICAgIGZhID0gL14oW14uXSopKD86XFxcXC4oLispfCkvO2Z1bmN0aW9uIGdhKCkge1xcbiAgICByZXR1cm4gITA7XFxuICB9ZnVuY3Rpb24gaGEoKSB7XFxuICAgIHJldHVybiAhMTtcXG4gIH1mdW5jdGlvbiBpYSgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4gZC5hY3RpdmVFbGVtZW50O1xcbiAgICB9IGNhdGNoIChhKSB7fVxcbiAgfWZ1bmN0aW9uIGphKGEsIGIsIGMsIGQsIGUsIGYpIHtcXG4gICAgdmFyIGcsIGg7aWYgKFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYikpKSB7XFxuICAgICAgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGMgJiYgKGQgPSBkIHx8IGMsIGMgPSB2b2lkIDApO2ZvciAoaCBpbiBiKSB7XFxuICAgICAgICBqYShhLCBoLCBjLCBkLCBiW2hdLCBmKTtcXG4gICAgICB9cmV0dXJuIGE7XFxuICAgIH1pZiAobnVsbCA9PSBkICYmIG51bGwgPT0gZSA/IChlID0gYywgZCA9IGMgPSB2b2lkIDApIDogbnVsbCA9PSBlICYmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYyA/IChlID0gZCwgZCA9IHZvaWQgMCkgOiAoZSA9IGQsIGQgPSBjLCBjID0gdm9pZCAwKSksIGUgPT09ICExKSBlID0gaGE7ZWxzZSBpZiAoIWUpIHJldHVybiBhO3JldHVybiAxID09PSBmICYmIChnID0gZSwgZSA9IGZ1bmN0aW9uIGUoYSkge1xcbiAgICAgIHJldHVybiBuKCkub2ZmKGEpLCBnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH0sIGUuZ3VpZCA9IGcuZ3VpZCB8fCAoZy5ndWlkID0gbi5ndWlkKyspKSwgYS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBuLmV2ZW50LmFkZCh0aGlzLCBiLCBlLCBkLCBjKTtcXG4gICAgfSk7XFxuICB9bi5ldmVudCA9IHsgZ2xvYmFsOiB7fSwgYWRkOiBmdW5jdGlvbiBhZGQoYSwgYiwgYywgZCwgZSkge1xcbiAgICAgIHZhciBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICBwLFxcbiAgICAgICAgICBxLFxcbiAgICAgICAgICByID0gTi5nZXQoYSk7aWYgKHIpIHtcXG4gICAgICAgIGMuaGFuZGxlciAmJiAoZiA9IGMsIGMgPSBmLmhhbmRsZXIsIGUgPSBmLnNlbGVjdG9yKSwgYy5ndWlkIHx8IChjLmd1aWQgPSBuLmd1aWQrKyksIChpID0gci5ldmVudHMpIHx8IChpID0gci5ldmVudHMgPSB7fSksIChnID0gci5oYW5kbGUpIHx8IChnID0gci5oYW5kbGUgPSBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgICByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIG4gJiYgbi5ldmVudC50cmlnZ2VyZWQgIT09IGIudHlwZSA/IG4uZXZlbnQuZGlzcGF0Y2guYXBwbHkoYSwgYXJndW1lbnRzKSA6IHZvaWQgMDtcXG4gICAgICAgIH0pLCBiID0gKGIgfHwgXFxcIlxcXCIpLm1hdGNoKEcpIHx8IFtcXFwiXFxcIl0sIGogPSBiLmxlbmd0aDt3aGlsZSAoai0tKSB7XFxuICAgICAgICAgIGggPSBmYS5leGVjKGJbal0pIHx8IFtdLCBvID0gcSA9IGhbMV0sIHAgPSAoaFsyXSB8fCBcXFwiXFxcIikuc3BsaXQoXFxcIi5cXFwiKS5zb3J0KCksIG8gJiYgKGwgPSBuLmV2ZW50LnNwZWNpYWxbb10gfHwge30sIG8gPSAoZSA/IGwuZGVsZWdhdGVUeXBlIDogbC5iaW5kVHlwZSkgfHwgbywgbCA9IG4uZXZlbnQuc3BlY2lhbFtvXSB8fCB7fSwgayA9IG4uZXh0ZW5kKHsgdHlwZTogbywgb3JpZ1R5cGU6IHEsIGRhdGE6IGQsIGhhbmRsZXI6IGMsIGd1aWQ6IGMuZ3VpZCwgc2VsZWN0b3I6IGUsIG5lZWRzQ29udGV4dDogZSAmJiBuLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoZSksIG5hbWVzcGFjZTogcC5qb2luKFxcXCIuXFxcIikgfSwgZiksIChtID0gaVtvXSkgfHwgKG0gPSBpW29dID0gW10sIG0uZGVsZWdhdGVDb3VudCA9IDAsIGwuc2V0dXAgJiYgbC5zZXR1cC5jYWxsKGEsIGQsIHAsIGcpICE9PSAhMSB8fCBhLmFkZEV2ZW50TGlzdGVuZXIgJiYgYS5hZGRFdmVudExpc3RlbmVyKG8sIGcpKSwgbC5hZGQgJiYgKGwuYWRkLmNhbGwoYSwgayksIGsuaGFuZGxlci5ndWlkIHx8IChrLmhhbmRsZXIuZ3VpZCA9IGMuZ3VpZCkpLCBlID8gbS5zcGxpY2UobS5kZWxlZ2F0ZUNvdW50KyssIDAsIGspIDogbS5wdXNoKGspLCBuLmV2ZW50Lmdsb2JhbFtvXSA9ICEwKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgICB2YXIgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbSxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgcCxcXG4gICAgICAgICAgcSxcXG4gICAgICAgICAgciA9IE4uaGFzRGF0YShhKSAmJiBOLmdldChhKTtpZiAociAmJiAoaSA9IHIuZXZlbnRzKSkge1xcbiAgICAgICAgYiA9IChiIHx8IFxcXCJcXFwiKS5tYXRjaChHKSB8fCBbXFxcIlxcXCJdLCBqID0gYi5sZW5ndGg7d2hpbGUgKGotLSkge1xcbiAgICAgICAgICBpZiAoaCA9IGZhLmV4ZWMoYltqXSkgfHwgW10sIG8gPSBxID0gaFsxXSwgcCA9IChoWzJdIHx8IFxcXCJcXFwiKS5zcGxpdChcXFwiLlxcXCIpLnNvcnQoKSwgbykge1xcbiAgICAgICAgICAgIGwgPSBuLmV2ZW50LnNwZWNpYWxbb10gfHwge30sIG8gPSAoZCA/IGwuZGVsZWdhdGVUeXBlIDogbC5iaW5kVHlwZSkgfHwgbywgbSA9IGlbb10gfHwgW10sIGggPSBoWzJdICYmIG5ldyBSZWdFeHAoXFxcIihefFxcXFxcXFxcLilcXFwiICsgcC5qb2luKFxcXCJcXFxcXFxcXC4oPzouKlxcXFxcXFxcLnwpXFxcIikgKyBcXFwiKFxcXFxcXFxcLnwkKVxcXCIpLCBnID0gZiA9IG0ubGVuZ3RoO3doaWxlIChmLS0pIHtcXG4gICAgICAgICAgICAgIGsgPSBtW2ZdLCAhZSAmJiBxICE9PSBrLm9yaWdUeXBlIHx8IGMgJiYgYy5ndWlkICE9PSBrLmd1aWQgfHwgaCAmJiAhaC50ZXN0KGsubmFtZXNwYWNlKSB8fCBkICYmIGQgIT09IGsuc2VsZWN0b3IgJiYgKFxcXCIqKlxcXCIgIT09IGQgfHwgIWsuc2VsZWN0b3IpIHx8IChtLnNwbGljZShmLCAxKSwgay5zZWxlY3RvciAmJiBtLmRlbGVnYXRlQ291bnQtLSwgbC5yZW1vdmUgJiYgbC5yZW1vdmUuY2FsbChhLCBrKSk7XFxuICAgICAgICAgICAgfWcgJiYgIW0ubGVuZ3RoICYmIChsLnRlYXJkb3duICYmIGwudGVhcmRvd24uY2FsbChhLCBwLCByLmhhbmRsZSkgIT09ICExIHx8IG4ucmVtb3ZlRXZlbnQoYSwgbywgci5oYW5kbGUpLCBkZWxldGUgaVtvXSk7XFxuICAgICAgICAgIH0gZWxzZSBmb3IgKG8gaW4gaSkge1xcbiAgICAgICAgICAgIG4uZXZlbnQucmVtb3ZlKGEsIG8gKyBiW2pdLCBjLCBkLCAhMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1uLmlzRW1wdHlPYmplY3QoaSkgJiYgTi5yZW1vdmUoYSwgXFxcImhhbmRsZSBldmVudHNcXFwiKTtcXG4gICAgICB9XFxuICAgIH0sIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChhKSB7XFxuICAgICAgYSA9IG4uZXZlbnQuZml4KGEpO3ZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoID0gW10sXFxuICAgICAgICAgIGkgPSBlLmNhbGwoYXJndW1lbnRzKSxcXG4gICAgICAgICAgaiA9IChOLmdldCh0aGlzLCBcXFwiZXZlbnRzXFxcIikgfHwge30pW2EudHlwZV0gfHwgW10sXFxuICAgICAgICAgIGsgPSBuLmV2ZW50LnNwZWNpYWxbYS50eXBlXSB8fCB7fTtpZiAoaVswXSA9IGEsIGEuZGVsZWdhdGVUYXJnZXQgPSB0aGlzLCAhay5wcmVEaXNwYXRjaCB8fCBrLnByZURpc3BhdGNoLmNhbGwodGhpcywgYSkgIT09ICExKSB7XFxuICAgICAgICBoID0gbi5ldmVudC5oYW5kbGVycy5jYWxsKHRoaXMsIGEsIGopLCBiID0gMDt3aGlsZSAoKGYgPSBoW2IrK10pICYmICFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcXG4gICAgICAgICAgYS5jdXJyZW50VGFyZ2V0ID0gZi5lbGVtLCBjID0gMDt3aGlsZSAoKGcgPSBmLmhhbmRsZXJzW2MrK10pICYmICFhLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcXG4gICAgICAgICAgICBhLnJuYW1lc3BhY2UgJiYgIWEucm5hbWVzcGFjZS50ZXN0KGcubmFtZXNwYWNlKSB8fCAoYS5oYW5kbGVPYmogPSBnLCBhLmRhdGEgPSBnLmRhdGEsIGQgPSAoKG4uZXZlbnQuc3BlY2lhbFtnLm9yaWdUeXBlXSB8fCB7fSkuaGFuZGxlIHx8IGcuaGFuZGxlcikuYXBwbHkoZi5lbGVtLCBpKSwgdm9pZCAwICE9PSBkICYmIChhLnJlc3VsdCA9IGQpID09PSAhMSAmJiAoYS5wcmV2ZW50RGVmYXVsdCgpLCBhLnN0b3BQcm9wYWdhdGlvbigpKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1yZXR1cm4gay5wb3N0RGlzcGF0Y2ggJiYgay5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCBhKSwgYS5yZXN1bHQ7XFxuICAgICAgfVxcbiAgICB9LCBoYW5kbGVyczogZnVuY3Rpb24gaGFuZGxlcnMoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnID0gW10sXFxuICAgICAgICAgIGggPSBiLmRlbGVnYXRlQ291bnQsXFxuICAgICAgICAgIGkgPSBhLnRhcmdldDtpZiAoaCAmJiBpLm5vZGVUeXBlICYmIChcXFwiY2xpY2tcXFwiICE9PSBhLnR5cGUgfHwgaXNOYU4oYS5idXR0b24pIHx8IGEuYnV0dG9uIDwgMSkpIGZvciAoOyBpICE9PSB0aGlzOyBpID0gaS5wYXJlbnROb2RlIHx8IHRoaXMpIHtcXG4gICAgICAgIGlmICgxID09PSBpLm5vZGVUeXBlICYmIChpLmRpc2FibGVkICE9PSAhMCB8fCBcXFwiY2xpY2tcXFwiICE9PSBhLnR5cGUpKSB7XFxuICAgICAgICAgIGZvciAoZCA9IFtdLCBjID0gMDsgaCA+IGM7IGMrKykge1xcbiAgICAgICAgICAgIGYgPSBiW2NdLCBlID0gZi5zZWxlY3RvciArIFxcXCIgXFxcIiwgdm9pZCAwID09PSBkW2VdICYmIChkW2VdID0gZi5uZWVkc0NvbnRleHQgPyBuKGUsIHRoaXMpLmluZGV4KGkpID4gLTEgOiBuLmZpbmQoZSwgdGhpcywgbnVsbCwgW2ldKS5sZW5ndGgpLCBkW2VdICYmIGQucHVzaChmKTtcXG4gICAgICAgICAgfWQubGVuZ3RoICYmIGcucHVzaCh7IGVsZW06IGksIGhhbmRsZXJzOiBkIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gaCA8IGIubGVuZ3RoICYmIGcucHVzaCh7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBiLnNsaWNlKGgpIH0pLCBnO1xcbiAgICB9LCBwcm9wczogXFxcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGRldGFpbCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcXFwiLnNwbGl0KFxcXCIgXFxcIiksIGZpeEhvb2tzOiB7fSwga2V5SG9va3M6IHsgcHJvcHM6IFxcXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihhLCBiKSB7XFxuICAgICAgICByZXR1cm4gbnVsbCA9PSBhLndoaWNoICYmIChhLndoaWNoID0gbnVsbCAhPSBiLmNoYXJDb2RlID8gYi5jaGFyQ29kZSA6IGIua2V5Q29kZSksIGE7XFxuICAgICAgfSB9LCBtb3VzZUhvb2tzOiB7IHByb3BzOiBcXFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihhLCBiKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyA9IGIuYnV0dG9uO3JldHVybiBudWxsID09IGEucGFnZVggJiYgbnVsbCAhPSBiLmNsaWVudFggJiYgKGMgPSBhLnRhcmdldC5vd25lckRvY3VtZW50IHx8IGQsIGUgPSBjLmRvY3VtZW50RWxlbWVudCwgZiA9IGMuYm9keSwgYS5wYWdlWCA9IGIuY2xpZW50WCArIChlICYmIGUuc2Nyb2xsTGVmdCB8fCBmICYmIGYuc2Nyb2xsTGVmdCB8fCAwKSAtIChlICYmIGUuY2xpZW50TGVmdCB8fCBmICYmIGYuY2xpZW50TGVmdCB8fCAwKSwgYS5wYWdlWSA9IGIuY2xpZW50WSArIChlICYmIGUuc2Nyb2xsVG9wIHx8IGYgJiYgZi5zY3JvbGxUb3AgfHwgMCkgLSAoZSAmJiBlLmNsaWVudFRvcCB8fCBmICYmIGYuY2xpZW50VG9wIHx8IDApKSwgYS53aGljaCB8fCB2b2lkIDAgPT09IGcgfHwgKGEud2hpY2ggPSAxICYgZyA/IDEgOiAyICYgZyA/IDMgOiA0ICYgZyA/IDIgOiAwKSwgYTtcXG4gICAgICB9IH0sIGZpeDogZnVuY3Rpb24gZml4KGEpIHtcXG4gICAgICBpZiAoYVtuLmV4cGFuZG9dKSByZXR1cm4gYTt2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZiA9IGEudHlwZSxcXG4gICAgICAgICAgZyA9IGEsXFxuICAgICAgICAgIGggPSB0aGlzLmZpeEhvb2tzW2ZdO2ggfHwgKHRoaXMuZml4SG9va3NbZl0gPSBoID0gZWEudGVzdChmKSA/IHRoaXMubW91c2VIb29rcyA6IGRhLnRlc3QoZikgPyB0aGlzLmtleUhvb2tzIDoge30pLCBlID0gaC5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KGgucHJvcHMpIDogdGhpcy5wcm9wcywgYSA9IG5ldyBuLkV2ZW50KGcpLCBiID0gZS5sZW5ndGg7d2hpbGUgKGItLSkge1xcbiAgICAgICAgYyA9IGVbYl0sIGFbY10gPSBnW2NdO1xcbiAgICAgIH1yZXR1cm4gYS50YXJnZXQgfHwgKGEudGFyZ2V0ID0gZCksIDMgPT09IGEudGFyZ2V0Lm5vZGVUeXBlICYmIChhLnRhcmdldCA9IGEudGFyZ2V0LnBhcmVudE5vZGUpLCBoLmZpbHRlciA/IGguZmlsdGVyKGEsIGcpIDogYTtcXG4gICAgfSwgc3BlY2lhbDogeyBsb2FkOiB7IG5vQnViYmxlOiAhMCB9LCBmb2N1czogeyB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKCkge1xcbiAgICAgICAgICByZXR1cm4gdGhpcyAhPT0gaWEoKSAmJiB0aGlzLmZvY3VzID8gKHRoaXMuZm9jdXMoKSwgITEpIDogdm9pZCAwO1xcbiAgICAgICAgfSwgZGVsZWdhdGVUeXBlOiBcXFwiZm9jdXNpblxcXCIgfSwgYmx1cjogeyB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKCkge1xcbiAgICAgICAgICByZXR1cm4gdGhpcyA9PT0gaWEoKSAmJiB0aGlzLmJsdXIgPyAodGhpcy5ibHVyKCksICExKSA6IHZvaWQgMDtcXG4gICAgICAgIH0sIGRlbGVnYXRlVHlwZTogXFxcImZvY3Vzb3V0XFxcIiB9LCBjbGljazogeyB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKCkge1xcbiAgICAgICAgICByZXR1cm4gXFxcImNoZWNrYm94XFxcIiA9PT0gdGhpcy50eXBlICYmIHRoaXMuY2xpY2sgJiYgbi5ub2RlTmFtZSh0aGlzLCBcXFwiaW5wdXRcXFwiKSA/ICh0aGlzLmNsaWNrKCksICExKSA6IHZvaWQgMDtcXG4gICAgICAgIH0sIF9kZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdChhKSB7XFxuICAgICAgICAgIHJldHVybiBuLm5vZGVOYW1lKGEudGFyZ2V0LCBcXFwiYVxcXCIpO1xcbiAgICAgICAgfSB9LCBiZWZvcmV1bmxvYWQ6IHsgcG9zdERpc3BhdGNoOiBmdW5jdGlvbiBwb3N0RGlzcGF0Y2goYSkge1xcbiAgICAgICAgICB2b2lkIDAgIT09IGEucmVzdWx0ICYmIGEub3JpZ2luYWxFdmVudCAmJiAoYS5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gYS5yZXN1bHQpO1xcbiAgICAgICAgfSB9IH0gfSwgbi5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIGEucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiBhLnJlbW92ZUV2ZW50TGlzdGVuZXIoYiwgYyk7XFxuICB9LCBuLkV2ZW50ID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBuLkV2ZW50ID8gKGEgJiYgYS50eXBlID8gKHRoaXMub3JpZ2luYWxFdmVudCA9IGEsIHRoaXMudHlwZSA9IGEudHlwZSwgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBhLmRlZmF1bHRQcmV2ZW50ZWQgfHwgdm9pZCAwID09PSBhLmRlZmF1bHRQcmV2ZW50ZWQgJiYgYS5yZXR1cm5WYWx1ZSA9PT0gITEgPyBnYSA6IGhhKSA6IHRoaXMudHlwZSA9IGEsIGIgJiYgbi5leHRlbmQodGhpcywgYiksIHRoaXMudGltZVN0YW1wID0gYSAmJiBhLnRpbWVTdGFtcCB8fCBuLm5vdygpLCB2b2lkICh0aGlzW24uZXhwYW5kb10gPSAhMCkpIDogbmV3IG4uRXZlbnQoYSwgYik7XFxuICB9LCBuLkV2ZW50LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IG4uRXZlbnQsIGlzRGVmYXVsdFByZXZlbnRlZDogaGEsIGlzUHJvcGFnYXRpb25TdG9wcGVkOiBoYSwgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IGhhLCBpc1NpbXVsYXRlZDogITEsIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcXG4gICAgICB2YXIgYSA9IHRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGdhLCBhICYmICF0aGlzLmlzU2ltdWxhdGVkICYmIGEucHJldmVudERlZmF1bHQoKTtcXG4gICAgfSwgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XFxuICAgICAgdmFyIGEgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGdhLCBhICYmICF0aGlzLmlzU2ltdWxhdGVkICYmIGEuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgIH0sIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xcbiAgICAgIHZhciBhID0gdGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBnYSwgYSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBhLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICB9IH0sIG4uZWFjaCh7IG1vdXNlZW50ZXI6IFxcXCJtb3VzZW92ZXJcXFwiLCBtb3VzZWxlYXZlOiBcXFwibW91c2VvdXRcXFwiLCBwb2ludGVyZW50ZXI6IFxcXCJwb2ludGVyb3ZlclxcXCIsIHBvaW50ZXJsZWF2ZTogXFxcInBvaW50ZXJvdXRcXFwiIH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZXZlbnQuc3BlY2lhbFthXSA9IHsgZGVsZWdhdGVUeXBlOiBiLCBiaW5kVHlwZTogYiwgaGFuZGxlOiBmdW5jdGlvbiBoYW5kbGUoYSkge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZCA9IHRoaXMsXFxuICAgICAgICAgICAgZSA9IGEucmVsYXRlZFRhcmdldCxcXG4gICAgICAgICAgICBmID0gYS5oYW5kbGVPYmo7cmV0dXJuIGUgJiYgKGUgPT09IGQgfHwgbi5jb250YWlucyhkLCBlKSkgfHwgKGEudHlwZSA9IGYub3JpZ1R5cGUsIGMgPSBmLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgYS50eXBlID0gYiksIGM7XFxuICAgICAgfSB9O1xcbiAgfSksIG4uZm4uZXh0ZW5kKHsgb246IGZ1bmN0aW9uIG9uKGEsIGIsIGMsIGQpIHtcXG4gICAgICByZXR1cm4gamEodGhpcywgYSwgYiwgYywgZCk7XFxuICAgIH0sIG9uZTogZnVuY3Rpb24gb25lKGEsIGIsIGMsIGQpIHtcXG4gICAgICByZXR1cm4gamEodGhpcywgYSwgYiwgYywgZCwgMSk7XFxuICAgIH0sIG9mZjogZnVuY3Rpb24gb2ZmKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCwgZTtpZiAoYSAmJiBhLnByZXZlbnREZWZhdWx0ICYmIGEuaGFuZGxlT2JqKSByZXR1cm4gZCA9IGEuaGFuZGxlT2JqLCBuKGEuZGVsZWdhdGVUYXJnZXQpLm9mZihkLm5hbWVzcGFjZSA/IGQub3JpZ1R5cGUgKyBcXFwiLlxcXCIgKyBkLm5hbWVzcGFjZSA6IGQub3JpZ1R5cGUsIGQuc2VsZWN0b3IsIGQuaGFuZGxlciksIHRoaXM7aWYgKFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYSkpKSB7XFxuICAgICAgICBmb3IgKGUgaW4gYSkge1xcbiAgICAgICAgICB0aGlzLm9mZihlLCBiLCBhW2VdKTtcXG4gICAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgICB9cmV0dXJuIGIgIT09ICExICYmIFxcXCJmdW5jdGlvblxcXCIgIT0gdHlwZW9mIGIgfHwgKGMgPSBiLCBiID0gdm9pZCAwKSwgYyA9PT0gITEgJiYgKGMgPSBoYSksIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLmV2ZW50LnJlbW92ZSh0aGlzLCBhLCBjLCBiKTtcXG4gICAgICB9KTtcXG4gICAgfSB9KTt2YXIga2EgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFxcXHc6LV0rKVtePl0qKVxcXFwvPi9naSxcXG4gICAgICBsYSA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxcbiAgICAgIG1hID0gL2NoZWNrZWRcXFxccyooPzpbXj1dfD1cXFxccyouY2hlY2tlZC4pL2ksXFxuICAgICAgbmEgPSAvXnRydWVcXFxcLyguKikvLFxcbiAgICAgIG9hID0gL15cXFxccyo8ISg/OlxcXFxbQ0RBVEFcXFxcW3wtLSl8KD86XFxcXF1cXFxcXXwtLSk+XFxcXHMqJC9nO2Z1bmN0aW9uIHBhKGEsIGIpIHtcXG4gICAgcmV0dXJuIG4ubm9kZU5hbWUoYSwgXFxcInRhYmxlXFxcIikgJiYgbi5ub2RlTmFtZSgxMSAhPT0gYi5ub2RlVHlwZSA/IGIgOiBiLmZpcnN0Q2hpbGQsIFxcXCJ0clxcXCIpID8gYS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwidGJvZHlcXFwiKVswXSB8fCBhLmFwcGVuZENoaWxkKGEub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0Ym9keVxcXCIpKSA6IGE7XFxuICB9ZnVuY3Rpb24gcWEoYSkge1xcbiAgICByZXR1cm4gYS50eXBlID0gKG51bGwgIT09IGEuZ2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIikpICsgXFxcIi9cXFwiICsgYS50eXBlLCBhO1xcbiAgfWZ1bmN0aW9uIHJhKGEpIHtcXG4gICAgdmFyIGIgPSBuYS5leGVjKGEudHlwZSk7cmV0dXJuIGIgPyBhLnR5cGUgPSBiWzFdIDogYS5yZW1vdmVBdHRyaWJ1dGUoXFxcInR5cGVcXFwiKSwgYTtcXG4gIH1mdW5jdGlvbiBzYShhLCBiKSB7XFxuICAgIHZhciBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqO2lmICgxID09PSBiLm5vZGVUeXBlKSB7XFxuICAgICAgaWYgKE4uaGFzRGF0YShhKSAmJiAoZiA9IE4uYWNjZXNzKGEpLCBnID0gTi5zZXQoYiwgZiksIGogPSBmLmV2ZW50cykpIHtcXG4gICAgICAgIGRlbGV0ZSBnLmhhbmRsZSwgZy5ldmVudHMgPSB7fTtmb3IgKGUgaW4gaikge1xcbiAgICAgICAgICBmb3IgKGMgPSAwLCBkID0galtlXS5sZW5ndGg7IGQgPiBjOyBjKyspIHtcXG4gICAgICAgICAgICBuLmV2ZW50LmFkZChiLCBlLCBqW2VdW2NdKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1PLmhhc0RhdGEoYSkgJiYgKGggPSBPLmFjY2VzcyhhKSwgaSA9IG4uZXh0ZW5kKHt9LCBoKSwgTy5zZXQoYiwgaSkpO1xcbiAgICB9XFxuICB9ZnVuY3Rpb24gdGEoYSwgYikge1xcbiAgICB2YXIgYyA9IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXFwiaW5wdXRcXFwiID09PSBjICYmIFgudGVzdChhLnR5cGUpID8gYi5jaGVja2VkID0gYS5jaGVja2VkIDogXFxcImlucHV0XFxcIiAhPT0gYyAmJiBcXFwidGV4dGFyZWFcXFwiICE9PSBjIHx8IChiLmRlZmF1bHRWYWx1ZSA9IGEuZGVmYXVsdFZhbHVlKTtcXG4gIH1mdW5jdGlvbiB1YShhLCBiLCBjLCBkKSB7XFxuICAgIGIgPSBmLmFwcGx5KFtdLCBiKTt2YXIgZSxcXG4gICAgICAgIGcsXFxuICAgICAgICBoLFxcbiAgICAgICAgaSxcXG4gICAgICAgIGosXFxuICAgICAgICBrLFxcbiAgICAgICAgbSA9IDAsXFxuICAgICAgICBvID0gYS5sZW5ndGgsXFxuICAgICAgICBwID0gbyAtIDEsXFxuICAgICAgICBxID0gYlswXSxcXG4gICAgICAgIHIgPSBuLmlzRnVuY3Rpb24ocSk7aWYgKHIgfHwgbyA+IDEgJiYgXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIHEgJiYgIWwuY2hlY2tDbG9uZSAmJiBtYS50ZXN0KHEpKSByZXR1cm4gYS5lYWNoKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgdmFyIGYgPSBhLmVxKGUpO3IgJiYgKGJbMF0gPSBxLmNhbGwodGhpcywgZSwgZi5odG1sKCkpKSwgdWEoZiwgYiwgYywgZCk7XFxuICAgIH0pO2lmIChvICYmIChlID0gY2EoYiwgYVswXS5vd25lckRvY3VtZW50LCAhMSwgYSwgZCksIGcgPSBlLmZpcnN0Q2hpbGQsIDEgPT09IGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgKGUgPSBnKSwgZyB8fCBkKSkge1xcbiAgICAgIGZvciAoaCA9IG4ubWFwKF8oZSwgXFxcInNjcmlwdFxcXCIpLCBxYSksIGkgPSBoLmxlbmd0aDsgbyA+IG07IG0rKykge1xcbiAgICAgICAgaiA9IGUsIG0gIT09IHAgJiYgKGogPSBuLmNsb25lKGosICEwLCAhMCksIGkgJiYgbi5tZXJnZShoLCBfKGosIFxcXCJzY3JpcHRcXFwiKSkpLCBjLmNhbGwoYVttXSwgaiwgbSk7XFxuICAgICAgfWlmIChpKSBmb3IgKGsgPSBoW2gubGVuZ3RoIC0gMV0ub3duZXJEb2N1bWVudCwgbi5tYXAoaCwgcmEpLCBtID0gMDsgaSA+IG07IG0rKykge1xcbiAgICAgICAgaiA9IGhbbV0sIFoudGVzdChqLnR5cGUgfHwgXFxcIlxcXCIpICYmICFOLmFjY2VzcyhqLCBcXFwiZ2xvYmFsRXZhbFxcXCIpICYmIG4uY29udGFpbnMoaywgaikgJiYgKGouc3JjID8gbi5fZXZhbFVybCAmJiBuLl9ldmFsVXJsKGouc3JjKSA6IG4uZ2xvYmFsRXZhbChqLnRleHRDb250ZW50LnJlcGxhY2Uob2EsIFxcXCJcXFwiKSkpO1xcbiAgICAgIH1cXG4gICAgfXJldHVybiBhO1xcbiAgfWZ1bmN0aW9uIHZhKGEsIGIsIGMpIHtcXG4gICAgZm9yICh2YXIgZCwgZSA9IGIgPyBuLmZpbHRlcihiLCBhKSA6IGEsIGYgPSAwOyBudWxsICE9IChkID0gZVtmXSk7IGYrKykge1xcbiAgICAgIGMgfHwgMSAhPT0gZC5ub2RlVHlwZSB8fCBuLmNsZWFuRGF0YShfKGQpKSwgZC5wYXJlbnROb2RlICYmIChjICYmIG4uY29udGFpbnMoZC5vd25lckRvY3VtZW50LCBkKSAmJiBhYShfKGQsIFxcXCJzY3JpcHRcXFwiKSksIGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSk7XFxuICAgIH1yZXR1cm4gYTtcXG4gIH1uLmV4dGVuZCh7IGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uIGh0bWxQcmVmaWx0ZXIoYSkge1xcbiAgICAgIHJldHVybiBhLnJlcGxhY2Uoa2EsIFxcXCI8JDE+PC8kMj5cXFwiKTtcXG4gICAgfSwgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCA9IGEuY2xvbmVOb2RlKCEwKSxcXG4gICAgICAgICAgaSA9IG4uY29udGFpbnMoYS5vd25lckRvY3VtZW50LCBhKTtpZiAoIShsLm5vQ2xvbmVDaGVja2VkIHx8IDEgIT09IGEubm9kZVR5cGUgJiYgMTEgIT09IGEubm9kZVR5cGUgfHwgbi5pc1hNTERvYyhhKSkpIGZvciAoZyA9IF8oaCksIGYgPSBfKGEpLCBkID0gMCwgZSA9IGYubGVuZ3RoOyBlID4gZDsgZCsrKSB7XFxuICAgICAgICB0YShmW2RdLCBnW2RdKTtcXG4gICAgICB9aWYgKGIpIGlmIChjKSBmb3IgKGYgPSBmIHx8IF8oYSksIGcgPSBnIHx8IF8oaCksIGQgPSAwLCBlID0gZi5sZW5ndGg7IGUgPiBkOyBkKyspIHtcXG4gICAgICAgIHNhKGZbZF0sIGdbZF0pO1xcbiAgICAgIH0gZWxzZSBzYShhLCBoKTtyZXR1cm4gZyA9IF8oaCwgXFxcInNjcmlwdFxcXCIpLCBnLmxlbmd0aCA+IDAgJiYgYWEoZywgIWkgJiYgXyhhLCBcXFwic2NyaXB0XFxcIikpLCBoO1xcbiAgICB9LCBjbGVhbkRhdGE6IGZ1bmN0aW9uIGNsZWFuRGF0YShhKSB7XFxuICAgICAgZm9yICh2YXIgYiwgYywgZCwgZSA9IG4uZXZlbnQuc3BlY2lhbCwgZiA9IDA7IHZvaWQgMCAhPT0gKGMgPSBhW2ZdKTsgZisrKSB7XFxuICAgICAgICBpZiAoTChjKSkge1xcbiAgICAgICAgICBpZiAoYiA9IGNbTi5leHBhbmRvXSkge1xcbiAgICAgICAgICAgIGlmIChiLmV2ZW50cykgZm9yIChkIGluIGIuZXZlbnRzKSB7XFxuICAgICAgICAgICAgICBlW2RdID8gbi5ldmVudC5yZW1vdmUoYywgZCkgOiBuLnJlbW92ZUV2ZW50KGMsIGQsIGIuaGFuZGxlKTtcXG4gICAgICAgICAgICB9Y1tOLmV4cGFuZG9dID0gdm9pZCAwO1xcbiAgICAgICAgICB9Y1tPLmV4cGFuZG9dICYmIChjW08uZXhwYW5kb10gPSB2b2lkIDApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSB9KSwgbi5mbi5leHRlbmQoeyBkb21NYW5pcDogdWEsIGRldGFjaDogZnVuY3Rpb24gZGV0YWNoKGEpIHtcXG4gICAgICByZXR1cm4gdmEodGhpcywgYSwgITApO1xcbiAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShhKSB7XFxuICAgICAgcmV0dXJuIHZhKHRoaXMsIGEpO1xcbiAgICB9LCB0ZXh0OiBmdW5jdGlvbiB0ZXh0KGEpIHtcXG4gICAgICByZXR1cm4gSyh0aGlzLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gYSA/IG4udGV4dCh0aGlzKSA6IHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiAxMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiA5ICE9PSB0aGlzLm5vZGVUeXBlIHx8ICh0aGlzLnRleHRDb250ZW50ID0gYSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9LCBudWxsLCBhLCBhcmd1bWVudHMubGVuZ3RoKTtcXG4gICAgfSwgYXBwZW5kOiBmdW5jdGlvbiBhcHBlbmQoKSB7XFxuICAgICAgcmV0dXJuIHVhKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIGlmICgxID09PSB0aGlzLm5vZGVUeXBlIHx8IDExID09PSB0aGlzLm5vZGVUeXBlIHx8IDkgPT09IHRoaXMubm9kZVR5cGUpIHtcXG4gICAgICAgICAgdmFyIGIgPSBwYSh0aGlzLCBhKTtiLmFwcGVuZENoaWxkKGEpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LCBwcmVwZW5kOiBmdW5jdGlvbiBwcmVwZW5kKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBpZiAoMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCAxMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCA5ID09PSB0aGlzLm5vZGVUeXBlKSB7XFxuICAgICAgICAgIHZhciBiID0gcGEodGhpcywgYSk7Yi5pbnNlcnRCZWZvcmUoYSwgYi5maXJzdENoaWxkKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSwgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUoKSB7XFxuICAgICAgcmV0dXJuIHVhKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsIHRoaXMpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBhZnRlcjogZnVuY3Rpb24gYWZ0ZXIoKSB7XFxuICAgICAgcmV0dXJuIHVhKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsIHRoaXMubmV4dFNpYmxpbmcpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XFxuICAgICAgZm9yICh2YXIgYSwgYiA9IDA7IG51bGwgIT0gKGEgPSB0aGlzW2JdKTsgYisrKSB7XFxuICAgICAgICAxID09PSBhLm5vZGVUeXBlICYmIChuLmNsZWFuRGF0YShfKGEsICExKSksIGEudGV4dENvbnRlbnQgPSBcXFwiXFxcIik7XFxuICAgICAgfXJldHVybiB0aGlzO1xcbiAgICB9LCBjbG9uZTogZnVuY3Rpb24gY2xvbmUoYSwgYikge1xcbiAgICAgIHJldHVybiBhID0gbnVsbCA9PSBhID8gITEgOiBhLCBiID0gbnVsbCA9PSBiID8gYSA6IGIsIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBuLmNsb25lKHRoaXMsIGEsIGIpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBodG1sOiBmdW5jdGlvbiBodG1sKGEpIHtcXG4gICAgICByZXR1cm4gSyh0aGlzLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzWzBdIHx8IHt9LFxcbiAgICAgICAgICAgIGMgPSAwLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLmxlbmd0aDtpZiAodm9pZCAwID09PSBhICYmIDEgPT09IGIubm9kZVR5cGUpIHJldHVybiBiLmlubmVySFRNTDtpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEgJiYgIWxhLnRlc3QoYSkgJiYgISRbKFkuZXhlYyhhKSB8fCBbXFxcIlxcXCIsIFxcXCJcXFwiXSlbMV0udG9Mb3dlckNhc2UoKV0pIHtcXG4gICAgICAgICAgYSA9IG4uaHRtbFByZWZpbHRlcihhKTt0cnkge1xcbiAgICAgICAgICAgIGZvciAoOyBkID4gYzsgYysrKSB7XFxuICAgICAgICAgICAgICBiID0gdGhpc1tjXSB8fCB7fSwgMSA9PT0gYi5ub2RlVHlwZSAmJiAobi5jbGVhbkRhdGEoXyhiLCAhMSkpLCBiLmlubmVySFRNTCA9IGEpO1xcbiAgICAgICAgICAgIH1iID0gMDtcXG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgICAgIH1iICYmIHRoaXMuZW1wdHkoKS5hcHBlbmQoYSk7XFxuICAgICAgfSwgbnVsbCwgYSwgYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgIH0sIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcXG4gICAgICB2YXIgYSA9IFtdO3JldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICB2YXIgYyA9IHRoaXMucGFyZW50Tm9kZTtuLmluQXJyYXkodGhpcywgYSkgPCAwICYmIChuLmNsZWFuRGF0YShfKHRoaXMpKSwgYyAmJiBjLnJlcGxhY2VDaGlsZChiLCB0aGlzKSk7XFxuICAgICAgfSwgYSk7XFxuICAgIH0gfSksIG4uZWFjaCh7IGFwcGVuZFRvOiBcXFwiYXBwZW5kXFxcIiwgcHJlcGVuZFRvOiBcXFwicHJlcGVuZFxcXCIsIGluc2VydEJlZm9yZTogXFxcImJlZm9yZVxcXCIsIGluc2VydEFmdGVyOiBcXFwiYWZ0ZXJcXFwiLCByZXBsYWNlQWxsOiBcXFwicmVwbGFjZVdpdGhcXFwiIH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZm5bYV0gPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIGZvciAodmFyIGMsIGQgPSBbXSwgZSA9IG4oYSksIGYgPSBlLmxlbmd0aCAtIDEsIGggPSAwOyBmID49IGg7IGgrKykge1xcbiAgICAgICAgYyA9IGggPT09IGYgPyB0aGlzIDogdGhpcy5jbG9uZSghMCksIG4oZVtoXSlbYl0oYyksIGcuYXBwbHkoZCwgYy5nZXQoKSk7XFxuICAgICAgfXJldHVybiB0aGlzLnB1c2hTdGFjayhkKTtcXG4gICAgfTtcXG4gIH0pO3ZhciB3YSxcXG4gICAgICB4YSA9IHsgSFRNTDogXFxcImJsb2NrXFxcIiwgQk9EWTogXFxcImJsb2NrXFxcIiB9O2Z1bmN0aW9uIHlhKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBuKGIuY3JlYXRlRWxlbWVudChhKSkuYXBwZW5kVG8oYi5ib2R5KSxcXG4gICAgICAgIGQgPSBuLmNzcyhjWzBdLCBcXFwiZGlzcGxheVxcXCIpO3JldHVybiBjLmRldGFjaCgpLCBkO1xcbiAgfWZ1bmN0aW9uIHphKGEpIHtcXG4gICAgdmFyIGIgPSBkLFxcbiAgICAgICAgYyA9IHhhW2FdO3JldHVybiBjIHx8IChjID0geWEoYSwgYiksIFxcXCJub25lXFxcIiAhPT0gYyAmJiBjIHx8ICh3YSA9ICh3YSB8fCBuKFxcXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XFxcIikpLmFwcGVuZFRvKGIuZG9jdW1lbnRFbGVtZW50KSwgYiA9IHdhWzBdLmNvbnRlbnREb2N1bWVudCwgYi53cml0ZSgpLCBiLmNsb3NlKCksIGMgPSB5YShhLCBiKSwgd2EuZGV0YWNoKCkpLCB4YVthXSA9IGMpLCBjO1xcbiAgfXZhciBBYSA9IC9ebWFyZ2luLyxcXG4gICAgICBCYSA9IG5ldyBSZWdFeHAoXFxcIl4oXFxcIiArIFMgKyBcXFwiKSg/IXB4KVthLXolXSskXFxcIiwgXFxcImlcXFwiKSxcXG4gICAgICBDYSA9IGZ1bmN0aW9uIENhKGIpIHtcXG4gICAgdmFyIGMgPSBiLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7cmV0dXJuIGMgJiYgYy5vcGVuZXIgfHwgKGMgPSBhKSwgYy5nZXRDb21wdXRlZFN0eWxlKGIpO1xcbiAgfSxcXG4gICAgICBEYSA9IGZ1bmN0aW9uIERhKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyA9IHt9O2ZvciAoZiBpbiBiKSB7XFxuICAgICAgZ1tmXSA9IGEuc3R5bGVbZl0sIGEuc3R5bGVbZl0gPSBiW2ZdO1xcbiAgICB9ZSA9IGMuYXBwbHkoYSwgZCB8fCBbXSk7Zm9yIChmIGluIGIpIHtcXG4gICAgICBhLnN0eWxlW2ZdID0gZ1tmXTtcXG4gICAgfXJldHVybiBlO1xcbiAgfSxcXG4gICAgICBFYSA9IGQuZG9jdW1lbnRFbGVtZW50OyFmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBiLFxcbiAgICAgICAgYyxcXG4gICAgICAgIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyA9IGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIiksXFxuICAgICAgICBoID0gZC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtpZiAoaC5zdHlsZSkge1xcbiAgICAgIChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgaSA9IGZ1bmN0aW9uIGkoKSB7XFxuICAgICAgICAgIGguc3R5bGUuY3NzVGV4dCA9IFxcXCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jazttYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O3RvcDoxJTt3aWR0aDo1MCVcXFwiLCBoLmlubmVySFRNTCA9IFxcXCJcXFwiLCBFYS5hcHBlbmRDaGlsZChnKTt2YXIgZCA9IGEuZ2V0Q29tcHV0ZWRTdHlsZShoKTtiID0gXFxcIjElXFxcIiAhPT0gZC50b3AsIGYgPSBcXFwiMnB4XFxcIiA9PT0gZC5tYXJnaW5MZWZ0LCBjID0gXFxcIjRweFxcXCIgPT09IGQud2lkdGgsIGguc3R5bGUubWFyZ2luUmlnaHQgPSBcXFwiNTAlXFxcIiwgZSA9IFxcXCI0cHhcXFwiID09PSBkLm1hcmdpblJpZ2h0LCBFYS5yZW1vdmVDaGlsZChnKTtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBoLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXFxcImNvbnRlbnQtYm94XFxcIiwgaC5jbG9uZU5vZGUoITApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXFxcIlxcXCIsIGwuY2xlYXJDbG9uZVN0eWxlID0gXFxcImNvbnRlbnQtYm94XFxcIiA9PT0gaC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCwgZy5zdHlsZS5jc3NUZXh0ID0gXFxcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7cGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXFxcIiwgZy5hcHBlbmRDaGlsZChoKTtuLmV4dGVuZChsLCB7IHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uIHBpeGVsUG9zaXRpb24oKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGkoKSwgYjtcXG4gICAgICAgICAgfSwgYm94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uIGJveFNpemluZ1JlbGlhYmxlKCkge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGMgJiYgaSgpLCBjO1xcbiAgICAgICAgICB9LCBwaXhlbE1hcmdpblJpZ2h0OiBmdW5jdGlvbiBwaXhlbE1hcmdpblJpZ2h0KCkge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGMgJiYgaSgpLCBlO1xcbiAgICAgICAgICB9LCByZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uIHJlbGlhYmxlTWFyZ2luTGVmdCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBjICYmIGkoKSwgZjtcXG4gICAgICAgICAgfSwgcmVsaWFibGVNYXJnaW5SaWdodDogZnVuY3Rpb24gcmVsaWFibGVNYXJnaW5SaWdodCgpIHtcXG4gICAgICAgICAgICB2YXIgYixcXG4gICAgICAgICAgICAgICAgYyA9IGguYXBwZW5kQ2hpbGQoZC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSk7cmV0dXJuIGMuc3R5bGUuY3NzVGV4dCA9IGguc3R5bGUuY3NzVGV4dCA9IFxcXCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MFxcXCIsIGMuc3R5bGUubWFyZ2luUmlnaHQgPSBjLnN0eWxlLndpZHRoID0gXFxcIjBcXFwiLCBoLnN0eWxlLndpZHRoID0gXFxcIjFweFxcXCIsIEVhLmFwcGVuZENoaWxkKGcpLCBiID0gIXBhcnNlRmxvYXQoYS5nZXRDb21wdXRlZFN0eWxlKGMpLm1hcmdpblJpZ2h0KSwgRWEucmVtb3ZlQ2hpbGQoZyksIGgucmVtb3ZlQ2hpbGQoYyksIGI7XFxuICAgICAgICAgIH0gfSk7XFxuICAgICAgfSkoKTtcXG4gICAgfVxcbiAgfSgpO2Z1bmN0aW9uIEZhKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcsXFxuICAgICAgICBoID0gYS5zdHlsZTtyZXR1cm4gYyA9IGMgfHwgQ2EoYSksIGcgPSBjID8gYy5nZXRQcm9wZXJ0eVZhbHVlKGIpIHx8IGNbYl0gOiB2b2lkIDAsIFxcXCJcXFwiICE9PSBnICYmIHZvaWQgMCAhPT0gZyB8fCBuLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCwgYSkgfHwgKGcgPSBuLnN0eWxlKGEsIGIpKSwgYyAmJiAhbC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgQmEudGVzdChnKSAmJiBBYS50ZXN0KGIpICYmIChkID0gaC53aWR0aCwgZSA9IGgubWluV2lkdGgsIGYgPSBoLm1heFdpZHRoLCBoLm1pbldpZHRoID0gaC5tYXhXaWR0aCA9IGgud2lkdGggPSBnLCBnID0gYy53aWR0aCwgaC53aWR0aCA9IGQsIGgubWluV2lkdGggPSBlLCBoLm1heFdpZHRoID0gZiksIHZvaWQgMCAhPT0gZyA/IGcgKyBcXFwiXFxcIiA6IGc7XFxuICB9ZnVuY3Rpb24gR2EoYSwgYikge1xcbiAgICByZXR1cm4geyBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICAgIHJldHVybiBhKCkgPyB2b2lkIGRlbGV0ZSB0aGlzLmdldCA6ICh0aGlzLmdldCA9IGIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfSB9O1xcbiAgfXZhciBIYSA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcXG4gICAgICBJYSA9IHsgcG9zaXRpb246IFxcXCJhYnNvbHV0ZVxcXCIsIHZpc2liaWxpdHk6IFxcXCJoaWRkZW5cXFwiLCBkaXNwbGF5OiBcXFwiYmxvY2tcXFwiIH0sXFxuICAgICAgSmEgPSB7IGxldHRlclNwYWNpbmc6IFxcXCIwXFxcIiwgZm9udFdlaWdodDogXFxcIjQwMFxcXCIgfSxcXG4gICAgICBLYSA9IFtcXFwiV2Via2l0XFxcIiwgXFxcIk9cXFwiLCBcXFwiTW96XFxcIiwgXFxcIm1zXFxcIl0sXFxuICAgICAgTGEgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpLnN0eWxlO2Z1bmN0aW9uIE1hKGEpIHtcXG4gICAgaWYgKGEgaW4gTGEpIHJldHVybiBhO3ZhciBiID0gYVswXS50b1VwcGVyQ2FzZSgpICsgYS5zbGljZSgxKSxcXG4gICAgICAgIGMgPSBLYS5sZW5ndGg7d2hpbGUgKGMtLSkge1xcbiAgICAgIGlmIChhID0gS2FbY10gKyBiLCBhIGluIExhKSByZXR1cm4gYTtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIE5hKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQgPSBULmV4ZWMoYik7cmV0dXJuIGQgPyBNYXRoLm1heCgwLCBkWzJdIC0gKGMgfHwgMCkpICsgKGRbM10gfHwgXFxcInB4XFxcIikgOiBiO1xcbiAgfWZ1bmN0aW9uIE9hKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgZm9yICh2YXIgZiA9IGMgPT09IChkID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIpID8gNCA6IFxcXCJ3aWR0aFxcXCIgPT09IGIgPyAxIDogMCwgZyA9IDA7IDQgPiBmOyBmICs9IDIpIHtcXG4gICAgICBcXFwibWFyZ2luXFxcIiA9PT0gYyAmJiAoZyArPSBuLmNzcyhhLCBjICsgVVtmXSwgITAsIGUpKSwgZCA/IChcXFwiY29udGVudFxcXCIgPT09IGMgJiYgKGcgLT0gbi5jc3MoYSwgXFxcInBhZGRpbmdcXFwiICsgVVtmXSwgITAsIGUpKSwgXFxcIm1hcmdpblxcXCIgIT09IGMgJiYgKGcgLT0gbi5jc3MoYSwgXFxcImJvcmRlclxcXCIgKyBVW2ZdICsgXFxcIldpZHRoXFxcIiwgITAsIGUpKSkgOiAoZyArPSBuLmNzcyhhLCBcXFwicGFkZGluZ1xcXCIgKyBVW2ZdLCAhMCwgZSksIFxcXCJwYWRkaW5nXFxcIiAhPT0gYyAmJiAoZyArPSBuLmNzcyhhLCBcXFwiYm9yZGVyXFxcIiArIFVbZl0gKyBcXFwiV2lkdGhcXFwiLCAhMCwgZSkpKTtcXG4gICAgfXJldHVybiBnO1xcbiAgfWZ1bmN0aW9uIFBhKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQgPSAhMCxcXG4gICAgICAgIGUgPSBcXFwid2lkdGhcXFwiID09PSBiID8gYS5vZmZzZXRXaWR0aCA6IGEub2Zmc2V0SGVpZ2h0LFxcbiAgICAgICAgZiA9IENhKGEpLFxcbiAgICAgICAgZyA9IFxcXCJib3JkZXItYm94XFxcIiA9PT0gbi5jc3MoYSwgXFxcImJveFNpemluZ1xcXCIsICExLCBmKTtpZiAoMCA+PSBlIHx8IG51bGwgPT0gZSkge1xcbiAgICAgIGlmIChlID0gRmEoYSwgYiwgZiksICgwID4gZSB8fCBudWxsID09IGUpICYmIChlID0gYS5zdHlsZVtiXSksIEJhLnRlc3QoZSkpIHJldHVybiBlO2QgPSBnICYmIChsLmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZSA9PT0gYS5zdHlsZVtiXSksIGUgPSBwYXJzZUZsb2F0KGUpIHx8IDA7XFxuICAgIH1yZXR1cm4gZSArIE9hKGEsIGIsIGMgfHwgKGcgPyBcXFwiYm9yZGVyXFxcIiA6IFxcXCJjb250ZW50XFxcIiksIGQsIGYpICsgXFxcInB4XFxcIjtcXG4gIH1mdW5jdGlvbiBRYShhLCBiKSB7XFxuICAgIGZvciAodmFyIGMsIGQsIGUsIGYgPSBbXSwgZyA9IDAsIGggPSBhLmxlbmd0aDsgaCA+IGc7IGcrKykge1xcbiAgICAgIGQgPSBhW2ddLCBkLnN0eWxlICYmIChmW2ddID0gTi5nZXQoZCwgXFxcIm9sZGRpc3BsYXlcXFwiKSwgYyA9IGQuc3R5bGUuZGlzcGxheSwgYiA/IChmW2ddIHx8IFxcXCJub25lXFxcIiAhPT0gYyB8fCAoZC5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCIpLCBcXFwiXFxcIiA9PT0gZC5zdHlsZS5kaXNwbGF5ICYmIFYoZCkgJiYgKGZbZ10gPSBOLmFjY2VzcyhkLCBcXFwib2xkZGlzcGxheVxcXCIsIHphKGQubm9kZU5hbWUpKSkpIDogKGUgPSBWKGQpLCBcXFwibm9uZVxcXCIgPT09IGMgJiYgZSB8fCBOLnNldChkLCBcXFwib2xkZGlzcGxheVxcXCIsIGUgPyBjIDogbi5jc3MoZCwgXFxcImRpc3BsYXlcXFwiKSkpKTtcXG4gICAgfWZvciAoZyA9IDA7IGggPiBnOyBnKyspIHtcXG4gICAgICBkID0gYVtnXSwgZC5zdHlsZSAmJiAoYiAmJiBcXFwibm9uZVxcXCIgIT09IGQuc3R5bGUuZGlzcGxheSAmJiBcXFwiXFxcIiAhPT0gZC5zdHlsZS5kaXNwbGF5IHx8IChkLnN0eWxlLmRpc3BsYXkgPSBiID8gZltnXSB8fCBcXFwiXFxcIiA6IFxcXCJub25lXFxcIikpO1xcbiAgICB9cmV0dXJuIGE7XFxuICB9bi5leHRlbmQoeyBjc3NIb29rczogeyBvcGFjaXR5OiB7IGdldDogZnVuY3Rpb24gZ2V0KGEsIGIpIHtcXG4gICAgICAgICAgaWYgKGIpIHtcXG4gICAgICAgICAgICB2YXIgYyA9IEZhKGEsIFxcXCJvcGFjaXR5XFxcIik7cmV0dXJuIFxcXCJcXFwiID09PSBjID8gXFxcIjFcXFwiIDogYztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSB9IH0sIGNzc051bWJlcjogeyBhbmltYXRpb25JdGVyYXRpb25Db3VudDogITAsIGNvbHVtbkNvdW50OiAhMCwgZmlsbE9wYWNpdHk6ICEwLCBmbGV4R3JvdzogITAsIGZsZXhTaHJpbms6ICEwLCBmb250V2VpZ2h0OiAhMCwgbGluZUhlaWdodDogITAsIG9wYWNpdHk6ICEwLCBvcmRlcjogITAsIG9ycGhhbnM6ICEwLCB3aWRvd3M6ICEwLCB6SW5kZXg6ICEwLCB6b29tOiAhMCB9LCBjc3NQcm9wczogeyBcXFwiZmxvYXRcXFwiOiBcXFwiY3NzRmxvYXRcXFwiIH0sIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShhLCBiLCBjLCBkKSB7XFxuICAgICAgaWYgKGEgJiYgMyAhPT0gYS5ub2RlVHlwZSAmJiA4ICE9PSBhLm5vZGVUeXBlICYmIGEuc3R5bGUpIHtcXG4gICAgICAgIHZhciBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoID0gbi5jYW1lbENhc2UoYiksXFxuICAgICAgICAgICAgaSA9IGEuc3R5bGU7cmV0dXJuIGIgPSBuLmNzc1Byb3BzW2hdIHx8IChuLmNzc1Byb3BzW2hdID0gTWEoaCkgfHwgaCksIGcgPSBuLmNzc0hvb2tzW2JdIHx8IG4uY3NzSG9va3NbaF0sIHZvaWQgMCA9PT0gYyA/IGcgJiYgXFxcImdldFxcXCIgaW4gZyAmJiB2b2lkIDAgIT09IChlID0gZy5nZXQoYSwgITEsIGQpKSA/IGUgOiBpW2JdIDogKGYgPSB0eXBlb2YgYyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYyksIFxcXCJzdHJpbmdcXFwiID09PSBmICYmIChlID0gVC5leGVjKGMpKSAmJiBlWzFdICYmIChjID0gVyhhLCBiLCBlKSwgZiA9IFxcXCJudW1iZXJcXFwiKSwgbnVsbCAhPSBjICYmIGMgPT09IGMgJiYgKFxcXCJudW1iZXJcXFwiID09PSBmICYmIChjICs9IGUgJiYgZVszXSB8fCAobi5jc3NOdW1iZXJbaF0gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIpKSwgbC5jbGVhckNsb25lU3R5bGUgfHwgXFxcIlxcXCIgIT09IGMgfHwgMCAhPT0gYi5pbmRleE9mKFxcXCJiYWNrZ3JvdW5kXFxcIikgfHwgKGlbYl0gPSBcXFwiaW5oZXJpdFxcXCIpLCBnICYmIFxcXCJzZXRcXFwiIGluIGcgJiYgdm9pZCAwID09PSAoYyA9IGcuc2V0KGEsIGMsIGQpKSB8fCAoaVtiXSA9IGMpKSwgdm9pZCAwKTtcXG4gICAgICB9XFxuICAgIH0sIGNzczogZnVuY3Rpb24gY3NzKGEsIGIsIGMsIGQpIHtcXG4gICAgICB2YXIgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCA9IG4uY2FtZWxDYXNlKGIpO3JldHVybiBiID0gbi5jc3NQcm9wc1toXSB8fCAobi5jc3NQcm9wc1toXSA9IE1hKGgpIHx8IGgpLCBnID0gbi5jc3NIb29rc1tiXSB8fCBuLmNzc0hvb2tzW2hdLCBnICYmIFxcXCJnZXRcXFwiIGluIGcgJiYgKGUgPSBnLmdldChhLCAhMCwgYykpLCB2b2lkIDAgPT09IGUgJiYgKGUgPSBGYShhLCBiLCBkKSksIFxcXCJub3JtYWxcXFwiID09PSBlICYmIGIgaW4gSmEgJiYgKGUgPSBKYVtiXSksIFxcXCJcXFwiID09PSBjIHx8IGMgPyAoZiA9IHBhcnNlRmxvYXQoZSksIGMgPT09ICEwIHx8IGlzRmluaXRlKGYpID8gZiB8fCAwIDogZSkgOiBlO1xcbiAgICB9IH0pLCBuLmVhY2goW1xcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5jc3NIb29rc1tiXSA9IHsgZ2V0OiBmdW5jdGlvbiBnZXQoYSwgYywgZCkge1xcbiAgICAgICAgcmV0dXJuIGMgPyBIYS50ZXN0KG4uY3NzKGEsIFxcXCJkaXNwbGF5XFxcIikpICYmIDAgPT09IGEub2Zmc2V0V2lkdGggPyBEYShhLCBJYSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gUGEoYSwgYiwgZCk7XFxuICAgICAgICB9KSA6IFBhKGEsIGIsIGQpIDogdm9pZCAwO1xcbiAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KGEsIGMsIGQpIHtcXG4gICAgICAgIHZhciBlLFxcbiAgICAgICAgICAgIGYgPSBkICYmIENhKGEpLFxcbiAgICAgICAgICAgIGcgPSBkICYmIE9hKGEsIGIsIGQsIFxcXCJib3JkZXItYm94XFxcIiA9PT0gbi5jc3MoYSwgXFxcImJveFNpemluZ1xcXCIsICExLCBmKSwgZik7cmV0dXJuIGcgJiYgKGUgPSBULmV4ZWMoYykpICYmIFxcXCJweFxcXCIgIT09IChlWzNdIHx8IFxcXCJweFxcXCIpICYmIChhLnN0eWxlW2JdID0gYywgYyA9IG4uY3NzKGEsIGIpKSwgTmEoYSwgYywgZyk7XFxuICAgICAgfSB9O1xcbiAgfSksIG4uY3NzSG9va3MubWFyZ2luTGVmdCA9IEdhKGwucmVsaWFibGVNYXJnaW5MZWZ0LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICByZXR1cm4gYiA/IChwYXJzZUZsb2F0KEZhKGEsIFxcXCJtYXJnaW5MZWZ0XFxcIikpIHx8IGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIERhKGEsIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcXG4gICAgfSkpICsgXFxcInB4XFxcIiA6IHZvaWQgMDtcXG4gIH0pLCBuLmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gR2EobC5yZWxpYWJsZU1hcmdpblJpZ2h0LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICByZXR1cm4gYiA/IERhKGEsIHsgZGlzcGxheTogXFxcImlubGluZS1ibG9ja1xcXCIgfSwgRmEsIFthLCBcXFwibWFyZ2luUmlnaHRcXFwiXSkgOiB2b2lkIDA7XFxuICB9KSwgbi5lYWNoKHsgbWFyZ2luOiBcXFwiXFxcIiwgcGFkZGluZzogXFxcIlxcXCIsIGJvcmRlcjogXFxcIldpZHRoXFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmNzc0hvb2tzW2EgKyBiXSA9IHsgZXhwYW5kOiBmdW5jdGlvbiBleHBhbmQoYykge1xcbiAgICAgICAgZm9yICh2YXIgZCA9IDAsIGUgPSB7fSwgZiA9IFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBjID8gYy5zcGxpdChcXFwiIFxcXCIpIDogW2NdOyA0ID4gZDsgZCsrKSB7XFxuICAgICAgICAgIGVbYSArIFVbZF0gKyBiXSA9IGZbZF0gfHwgZltkIC0gMl0gfHwgZlswXTtcXG4gICAgICAgIH1yZXR1cm4gZTtcXG4gICAgICB9IH0sIEFhLnRlc3QoYSkgfHwgKG4uY3NzSG9va3NbYSArIGJdLnNldCA9IE5hKTtcXG4gIH0pLCBuLmZuLmV4dGVuZCh7IGNzczogZnVuY3Rpb24gY3NzKGEsIGIpIHtcXG4gICAgICByZXR1cm4gSyh0aGlzLCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgICAgdmFyIGQsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmID0ge30sXFxuICAgICAgICAgICAgZyA9IDA7aWYgKG4uaXNBcnJheShiKSkge1xcbiAgICAgICAgICBmb3IgKGQgPSBDYShhKSwgZSA9IGIubGVuZ3RoOyBlID4gZzsgZysrKSB7XFxuICAgICAgICAgICAgZltiW2ddXSA9IG4uY3NzKGEsIGJbZ10sICExLCBkKTtcXG4gICAgICAgICAgfXJldHVybiBmO1xcbiAgICAgICAgfXJldHVybiB2b2lkIDAgIT09IGMgPyBuLnN0eWxlKGEsIGIsIGMpIDogbi5jc3MoYSwgYik7XFxuICAgICAgfSwgYSwgYiwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xcbiAgICB9LCBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xcbiAgICAgIHJldHVybiBRYSh0aGlzLCAhMCk7XFxuICAgIH0sIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XFxuICAgICAgcmV0dXJuIFFhKHRoaXMpO1xcbiAgICB9LCB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZShhKSB7XFxuICAgICAgcmV0dXJuIFxcXCJib29sZWFuXFxcIiA9PSB0eXBlb2YgYSA/IGEgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIFYodGhpcykgPyBuKHRoaXMpLnNob3coKSA6IG4odGhpcykuaGlkZSgpO1xcbiAgICAgIH0pO1xcbiAgICB9IH0pO2Z1bmN0aW9uIFJhKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgcmV0dXJuIG5ldyBSYS5wcm90b3R5cGUuaW5pdChhLCBiLCBjLCBkLCBlKTtcXG4gIH1uLlR3ZWVuID0gUmEsIFJhLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IFJhLCBpbml0OiBmdW5jdGlvbiBpbml0KGEsIGIsIGMsIGQsIGUsIGYpIHtcXG4gICAgICB0aGlzLmVsZW0gPSBhLCB0aGlzLnByb3AgPSBjLCB0aGlzLmVhc2luZyA9IGUgfHwgbi5lYXNpbmcuX2RlZmF1bHQsIHRoaXMub3B0aW9ucyA9IGIsIHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCksIHRoaXMuZW5kID0gZCwgdGhpcy51bml0ID0gZiB8fCAobi5jc3NOdW1iZXJbY10gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIpO1xcbiAgICB9LCBjdXI6IGZ1bmN0aW9uIGN1cigpIHtcXG4gICAgICB2YXIgYSA9IFJhLnByb3BIb29rc1t0aGlzLnByb3BdO3JldHVybiBhICYmIGEuZ2V0ID8gYS5nZXQodGhpcykgOiBSYS5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpO1xcbiAgICB9LCBydW46IGZ1bmN0aW9uIHJ1bihhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMgPSBSYS5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gdGhpcy5vcHRpb25zLmR1cmF0aW9uID8gdGhpcy5wb3MgPSBiID0gbi5lYXNpbmdbdGhpcy5lYXNpbmddKGEsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIGEsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvbikgOiB0aGlzLnBvcyA9IGIgPSBhLCB0aGlzLm5vdyA9ICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQpICogYiArIHRoaXMuc3RhcnQsIHRoaXMub3B0aW9ucy5zdGVwICYmIHRoaXMub3B0aW9ucy5zdGVwLmNhbGwodGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyksIGMgJiYgYy5zZXQgPyBjLnNldCh0aGlzKSA6IFJhLnByb3BIb29rcy5fZGVmYXVsdC5zZXQodGhpcyksIHRoaXM7XFxuICAgIH0gfSwgUmEucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gUmEucHJvdG90eXBlLCBSYS5wcm9wSG9va3MgPSB7IF9kZWZhdWx0OiB7IGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICAgIHZhciBiO3JldHVybiAxICE9PSBhLmVsZW0ubm9kZVR5cGUgfHwgbnVsbCAhPSBhLmVsZW1bYS5wcm9wXSAmJiBudWxsID09IGEuZWxlbS5zdHlsZVthLnByb3BdID8gYS5lbGVtW2EucHJvcF0gOiAoYiA9IG4uY3NzKGEuZWxlbSwgYS5wcm9wLCBcXFwiXFxcIiksIGIgJiYgXFxcImF1dG9cXFwiICE9PSBiID8gYiA6IDApO1xcbiAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KGEpIHtcXG4gICAgICAgIG4uZnguc3RlcFthLnByb3BdID8gbi5meC5zdGVwW2EucHJvcF0oYSkgOiAxICE9PSBhLmVsZW0ubm9kZVR5cGUgfHwgbnVsbCA9PSBhLmVsZW0uc3R5bGVbbi5jc3NQcm9wc1thLnByb3BdXSAmJiAhbi5jc3NIb29rc1thLnByb3BdID8gYS5lbGVtW2EucHJvcF0gPSBhLm5vdyA6IG4uc3R5bGUoYS5lbGVtLCBhLnByb3AsIGEubm93ICsgYS51bml0KTtcXG4gICAgICB9IH0gfSwgUmEucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFJhLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0geyBzZXQ6IGZ1bmN0aW9uIHNldChhKSB7XFxuICAgICAgYS5lbGVtLm5vZGVUeXBlICYmIGEuZWxlbS5wYXJlbnROb2RlICYmIChhLmVsZW1bYS5wcm9wXSA9IGEubm93KTtcXG4gICAgfSB9LCBuLmVhc2luZyA9IHsgbGluZWFyOiBmdW5jdGlvbiBsaW5lYXIoYSkge1xcbiAgICAgIHJldHVybiBhO1xcbiAgICB9LCBzd2luZzogZnVuY3Rpb24gc3dpbmcoYSkge1xcbiAgICAgIHJldHVybiAuNSAtIE1hdGguY29zKGEgKiBNYXRoLlBJKSAvIDI7XFxuICAgIH0sIF9kZWZhdWx0OiBcXFwic3dpbmdcXFwiIH0sIG4uZnggPSBSYS5wcm90b3R5cGUuaW5pdCwgbi5meC5zdGVwID0ge307dmFyIFNhLFxcbiAgICAgIFRhLFxcbiAgICAgIFVhID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxcbiAgICAgIFZhID0gL3F1ZXVlSG9va3MkLztmdW5jdGlvbiBXYSgpIHtcXG4gICAgcmV0dXJuIGEuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgU2EgPSB2b2lkIDA7XFxuICAgIH0pLCBTYSA9IG4ubm93KCk7XFxuICB9ZnVuY3Rpb24gWGEoYSwgYikge1xcbiAgICB2YXIgYyxcXG4gICAgICAgIGQgPSAwLFxcbiAgICAgICAgZSA9IHsgaGVpZ2h0OiBhIH07Zm9yIChiID0gYiA/IDEgOiAwOyA0ID4gZDsgZCArPSAyIC0gYikge1xcbiAgICAgIGMgPSBVW2RdLCBlW1xcXCJtYXJnaW5cXFwiICsgY10gPSBlW1xcXCJwYWRkaW5nXFxcIiArIGNdID0gYTtcXG4gICAgfXJldHVybiBiICYmIChlLm9wYWNpdHkgPSBlLndpZHRoID0gYSksIGU7XFxuICB9ZnVuY3Rpb24gWWEoYSwgYiwgYykge1xcbiAgICBmb3IgKHZhciBkLCBlID0gKF9hLnR3ZWVuZXJzW2JdIHx8IFtdKS5jb25jYXQoX2EudHdlZW5lcnNbXFxcIipcXFwiXSksIGYgPSAwLCBnID0gZS5sZW5ndGg7IGcgPiBmOyBmKyspIHtcXG4gICAgICBpZiAoZCA9IGVbZl0uY2FsbChjLCBiLCBhKSkgcmV0dXJuIGQ7XFxuICAgIH1cXG4gIH1mdW5jdGlvbiBaYShhLCBiLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqLFxcbiAgICAgICAgayxcXG4gICAgICAgIGwgPSB0aGlzLFxcbiAgICAgICAgbSA9IHt9LFxcbiAgICAgICAgbyA9IGEuc3R5bGUsXFxuICAgICAgICBwID0gYS5ub2RlVHlwZSAmJiBWKGEpLFxcbiAgICAgICAgcSA9IE4uZ2V0KGEsIFxcXCJmeHNob3dcXFwiKTtjLnF1ZXVlIHx8IChoID0gbi5fcXVldWVIb29rcyhhLCBcXFwiZnhcXFwiKSwgbnVsbCA9PSBoLnVucXVldWVkICYmIChoLnVucXVldWVkID0gMCwgaSA9IGguZW1wdHkuZmlyZSwgaC5lbXB0eS5maXJlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIGgudW5xdWV1ZWQgfHwgaSgpO1xcbiAgICB9KSwgaC51bnF1ZXVlZCsrLCBsLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgbC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaC51bnF1ZXVlZC0tLCBuLnF1ZXVlKGEsIFxcXCJmeFxcXCIpLmxlbmd0aCB8fCBoLmVtcHR5LmZpcmUoKTtcXG4gICAgICB9KTtcXG4gICAgfSkpLCAxID09PSBhLm5vZGVUeXBlICYmIChcXFwiaGVpZ2h0XFxcIiBpbiBiIHx8IFxcXCJ3aWR0aFxcXCIgaW4gYikgJiYgKGMub3ZlcmZsb3cgPSBbby5vdmVyZmxvdywgby5vdmVyZmxvd1gsIG8ub3ZlcmZsb3dZXSwgaiA9IG4uY3NzKGEsIFxcXCJkaXNwbGF5XFxcIiksIGsgPSBcXFwibm9uZVxcXCIgPT09IGogPyBOLmdldChhLCBcXFwib2xkZGlzcGxheVxcXCIpIHx8IHphKGEubm9kZU5hbWUpIDogaiwgXFxcImlubGluZVxcXCIgPT09IGsgJiYgXFxcIm5vbmVcXFwiID09PSBuLmNzcyhhLCBcXFwiZmxvYXRcXFwiKSAmJiAoby5kaXNwbGF5ID0gXFxcImlubGluZS1ibG9ja1xcXCIpKSwgYy5vdmVyZmxvdyAmJiAoby5vdmVyZmxvdyA9IFxcXCJoaWRkZW5cXFwiLCBsLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgby5vdmVyZmxvdyA9IGMub3ZlcmZsb3dbMF0sIG8ub3ZlcmZsb3dYID0gYy5vdmVyZmxvd1sxXSwgby5vdmVyZmxvd1kgPSBjLm92ZXJmbG93WzJdO1xcbiAgICB9KSk7Zm9yIChkIGluIGIpIHtcXG4gICAgICBpZiAoZSA9IGJbZF0sIFVhLmV4ZWMoZSkpIHtcXG4gICAgICAgIGlmIChkZWxldGUgYltkXSwgZiA9IGYgfHwgXFxcInRvZ2dsZVxcXCIgPT09IGUsIGUgPT09IChwID8gXFxcImhpZGVcXFwiIDogXFxcInNob3dcXFwiKSkge1xcbiAgICAgICAgICBpZiAoXFxcInNob3dcXFwiICE9PSBlIHx8ICFxIHx8IHZvaWQgMCA9PT0gcVtkXSkgY29udGludWU7cCA9ICEwO1xcbiAgICAgICAgfW1bZF0gPSBxICYmIHFbZF0gfHwgbi5zdHlsZShhLCBkKTtcXG4gICAgICB9IGVsc2UgaiA9IHZvaWQgMDtcXG4gICAgfWlmIChuLmlzRW1wdHlPYmplY3QobSkpIFxcXCJpbmxpbmVcXFwiID09PSAoXFxcIm5vbmVcXFwiID09PSBqID8gemEoYS5ub2RlTmFtZSkgOiBqKSAmJiAoby5kaXNwbGF5ID0gaik7ZWxzZSB7XFxuICAgICAgcSA/IFxcXCJoaWRkZW5cXFwiIGluIHEgJiYgKHAgPSBxLmhpZGRlbikgOiBxID0gTi5hY2Nlc3MoYSwgXFxcImZ4c2hvd1xcXCIsIHt9KSwgZiAmJiAocS5oaWRkZW4gPSAhcCksIHAgPyBuKGEpLnNob3coKSA6IGwuZG9uZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuKGEpLmhpZGUoKTtcXG4gICAgICB9KSwgbC5kb25lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiO04ucmVtb3ZlKGEsIFxcXCJmeHNob3dcXFwiKTtmb3IgKGIgaW4gbSkge1xcbiAgICAgICAgICBuLnN0eWxlKGEsIGIsIG1bYl0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO2ZvciAoZCBpbiBtKSB7XFxuICAgICAgICBnID0gWWEocCA/IHFbZF0gOiAwLCBkLCBsKSwgZCBpbiBxIHx8IChxW2RdID0gZy5zdGFydCwgcCAmJiAoZy5lbmQgPSBnLnN0YXJ0LCBnLnN0YXJ0ID0gXFxcIndpZHRoXFxcIiA9PT0gZCB8fCBcXFwiaGVpZ2h0XFxcIiA9PT0gZCA/IDEgOiAwKSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9ZnVuY3Rpb24gJGEoYSwgYikge1xcbiAgICB2YXIgYywgZCwgZSwgZiwgZztmb3IgKGMgaW4gYSkge1xcbiAgICAgIGlmIChkID0gbi5jYW1lbENhc2UoYyksIGUgPSBiW2RdLCBmID0gYVtjXSwgbi5pc0FycmF5KGYpICYmIChlID0gZlsxXSwgZiA9IGFbY10gPSBmWzBdKSwgYyAhPT0gZCAmJiAoYVtkXSA9IGYsIGRlbGV0ZSBhW2NdKSwgZyA9IG4uY3NzSG9va3NbZF0sIGcgJiYgXFxcImV4cGFuZFxcXCIgaW4gZykge1xcbiAgICAgICAgZiA9IGcuZXhwYW5kKGYpLCBkZWxldGUgYVtkXTtmb3IgKGMgaW4gZikge1xcbiAgICAgICAgICBjIGluIGEgfHwgKGFbY10gPSBmW2NdLCBiW2NdID0gZSk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGJbZF0gPSBlO1xcbiAgICB9XFxuICB9ZnVuY3Rpb24gX2EoYSwgYiwgYykge1xcbiAgICB2YXIgZCxcXG4gICAgICAgIGUsXFxuICAgICAgICBmID0gMCxcXG4gICAgICAgIGcgPSBfYS5wcmVmaWx0ZXJzLmxlbmd0aCxcXG4gICAgICAgIGggPSBuLkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICBkZWxldGUgaS5lbGVtO1xcbiAgICB9KSxcXG4gICAgICAgIGkgPSBmdW5jdGlvbiBpKCkge1xcbiAgICAgIGlmIChlKSByZXR1cm4gITE7Zm9yICh2YXIgYiA9IFNhIHx8IFdhKCksIGMgPSBNYXRoLm1heCgwLCBqLnN0YXJ0VGltZSArIGouZHVyYXRpb24gLSBiKSwgZCA9IGMgLyBqLmR1cmF0aW9uIHx8IDAsIGYgPSAxIC0gZCwgZyA9IDAsIGkgPSBqLnR3ZWVucy5sZW5ndGg7IGkgPiBnOyBnKyspIHtcXG4gICAgICAgIGoudHdlZW5zW2ddLnJ1bihmKTtcXG4gICAgICB9cmV0dXJuIGgubm90aWZ5V2l0aChhLCBbaiwgZiwgY10pLCAxID4gZiAmJiBpID8gYyA6IChoLnJlc29sdmVXaXRoKGEsIFtqXSksICExKTtcXG4gICAgfSxcXG4gICAgICAgIGogPSBoLnByb21pc2UoeyBlbGVtOiBhLCBwcm9wczogbi5leHRlbmQoe30sIGIpLCBvcHRzOiBuLmV4dGVuZCghMCwgeyBzcGVjaWFsRWFzaW5nOiB7fSwgZWFzaW5nOiBuLmVhc2luZy5fZGVmYXVsdCB9LCBjKSwgb3JpZ2luYWxQcm9wZXJ0aWVzOiBiLCBvcmlnaW5hbE9wdGlvbnM6IGMsIHN0YXJ0VGltZTogU2EgfHwgV2EoKSwgZHVyYXRpb246IGMuZHVyYXRpb24sIHR3ZWVuczogW10sIGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiBjcmVhdGVUd2VlbihiLCBjKSB7XFxuICAgICAgICB2YXIgZCA9IG4uVHdlZW4oYSwgai5vcHRzLCBiLCBjLCBqLm9wdHMuc3BlY2lhbEVhc2luZ1tiXSB8fCBqLm9wdHMuZWFzaW5nKTtyZXR1cm4gai50d2VlbnMucHVzaChkKSwgZDtcXG4gICAgICB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKGIpIHtcXG4gICAgICAgIHZhciBjID0gMCxcXG4gICAgICAgICAgICBkID0gYiA/IGoudHdlZW5zLmxlbmd0aCA6IDA7aWYgKGUpIHJldHVybiB0aGlzO2ZvciAoZSA9ICEwOyBkID4gYzsgYysrKSB7XFxuICAgICAgICAgIGoudHdlZW5zW2NdLnJ1bigxKTtcXG4gICAgICAgIH1yZXR1cm4gYiA/IChoLm5vdGlmeVdpdGgoYSwgW2osIDEsIDBdKSwgaC5yZXNvbHZlV2l0aChhLCBbaiwgYl0pKSA6IGgucmVqZWN0V2l0aChhLCBbaiwgYl0pLCB0aGlzO1xcbiAgICAgIH0gfSksXFxuICAgICAgICBrID0gai5wcm9wcztmb3IgKCRhKGssIGoub3B0cy5zcGVjaWFsRWFzaW5nKTsgZyA+IGY7IGYrKykge1xcbiAgICAgIGlmIChkID0gX2EucHJlZmlsdGVyc1tmXS5jYWxsKGosIGEsIGssIGoub3B0cykpIHJldHVybiBuLmlzRnVuY3Rpb24oZC5zdG9wKSAmJiAobi5fcXVldWVIb29rcyhqLmVsZW0sIGoub3B0cy5xdWV1ZSkuc3RvcCA9IG4ucHJveHkoZC5zdG9wLCBkKSksIGQ7XFxuICAgIH1yZXR1cm4gbi5tYXAoaywgWWEsIGopLCBuLmlzRnVuY3Rpb24oai5vcHRzLnN0YXJ0KSAmJiBqLm9wdHMuc3RhcnQuY2FsbChhLCBqKSwgbi5meC50aW1lcihuLmV4dGVuZChpLCB7IGVsZW06IGEsIGFuaW06IGosIHF1ZXVlOiBqLm9wdHMucXVldWUgfSkpLCBqLnByb2dyZXNzKGoub3B0cy5wcm9ncmVzcykuZG9uZShqLm9wdHMuZG9uZSwgai5vcHRzLmNvbXBsZXRlKS5mYWlsKGoub3B0cy5mYWlsKS5hbHdheXMoai5vcHRzLmFsd2F5cyk7XFxuICB9bi5BbmltYXRpb24gPSBuLmV4dGVuZChfYSwgeyB0d2VlbmVyczogeyBcXFwiKlxcXCI6IFtmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNyZWF0ZVR3ZWVuKGEsIGIpO3JldHVybiBXKGMuZWxlbSwgYSwgVC5leGVjKGIpLCBjKSwgYztcXG4gICAgICB9XSB9LCB0d2VlbmVyOiBmdW5jdGlvbiB0d2VlbmVyKGEsIGIpIHtcXG4gICAgICBuLmlzRnVuY3Rpb24oYSkgPyAoYiA9IGEsIGEgPSBbXFxcIipcXFwiXSkgOiBhID0gYS5tYXRjaChHKTtmb3IgKHZhciBjLCBkID0gMCwgZSA9IGEubGVuZ3RoOyBlID4gZDsgZCsrKSB7XFxuICAgICAgICBjID0gYVtkXSwgX2EudHdlZW5lcnNbY10gPSBfYS50d2VlbmVyc1tjXSB8fCBbXSwgX2EudHdlZW5lcnNbY10udW5zaGlmdChiKTtcXG4gICAgICB9XFxuICAgIH0sIHByZWZpbHRlcnM6IFtaYV0sIHByZWZpbHRlcjogZnVuY3Rpb24gcHJlZmlsdGVyKGEsIGIpIHtcXG4gICAgICBiID8gX2EucHJlZmlsdGVycy51bnNoaWZ0KGEpIDogX2EucHJlZmlsdGVycy5wdXNoKGEpO1xcbiAgICB9IH0pLCBuLnNwZWVkID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQgPSBhICYmIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYSkpID8gbi5leHRlbmQoe30sIGEpIDogeyBjb21wbGV0ZTogYyB8fCAhYyAmJiBiIHx8IG4uaXNGdW5jdGlvbihhKSAmJiBhLCBkdXJhdGlvbjogYSwgZWFzaW5nOiBjICYmIGIgfHwgYiAmJiAhbi5pc0Z1bmN0aW9uKGIpICYmIGIgfTtyZXR1cm4gZC5kdXJhdGlvbiA9IG4uZngub2ZmID8gMCA6IFxcXCJudW1iZXJcXFwiID09IHR5cGVvZiBkLmR1cmF0aW9uID8gZC5kdXJhdGlvbiA6IGQuZHVyYXRpb24gaW4gbi5meC5zcGVlZHMgPyBuLmZ4LnNwZWVkc1tkLmR1cmF0aW9uXSA6IG4uZnguc3BlZWRzLl9kZWZhdWx0LCBudWxsICE9IGQucXVldWUgJiYgZC5xdWV1ZSAhPT0gITAgfHwgKGQucXVldWUgPSBcXFwiZnhcXFwiKSwgZC5vbGQgPSBkLmNvbXBsZXRlLCBkLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIG4uaXNGdW5jdGlvbihkLm9sZCkgJiYgZC5vbGQuY2FsbCh0aGlzKSwgZC5xdWV1ZSAmJiBuLmRlcXVldWUodGhpcywgZC5xdWV1ZSk7XFxuICAgIH0sIGQ7XFxuICB9LCBuLmZuLmV4dGVuZCh7IGZhZGVUbzogZnVuY3Rpb24gZmFkZVRvKGEsIGIsIGMsIGQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoVikuY3NzKFxcXCJvcGFjaXR5XFxcIiwgMCkuc2hvdygpLmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiBiIH0sIGEsIGMsIGQpO1xcbiAgICB9LCBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKGEsIGIsIGMsIGQpIHtcXG4gICAgICB2YXIgZSA9IG4uaXNFbXB0eU9iamVjdChhKSxcXG4gICAgICAgICAgZiA9IG4uc3BlZWQoYiwgYywgZCksXFxuICAgICAgICAgIGcgPSBmdW5jdGlvbiBnKCkge1xcbiAgICAgICAgdmFyIGIgPSBfYSh0aGlzLCBuLmV4dGVuZCh7fSwgYSksIGYpOyhlIHx8IE4uZ2V0KHRoaXMsIFxcXCJmaW5pc2hcXFwiKSkgJiYgYi5zdG9wKCEwKTtcXG4gICAgICB9O3JldHVybiBnLmZpbmlzaCA9IGcsIGUgfHwgZi5xdWV1ZSA9PT0gITEgPyB0aGlzLmVhY2goZykgOiB0aGlzLnF1ZXVlKGYucXVldWUsIGcpO1xcbiAgICB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCA9IGZ1bmN0aW9uIGQoYSkge1xcbiAgICAgICAgdmFyIGIgPSBhLnN0b3A7ZGVsZXRlIGEuc3RvcCwgYihjKTtcXG4gICAgICB9O3JldHVybiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSAmJiAoYyA9IGIsIGIgPSBhLCBhID0gdm9pZCAwKSwgYiAmJiBhICE9PSAhMSAmJiB0aGlzLnF1ZXVlKGEgfHwgXFxcImZ4XFxcIiwgW10pLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGIgPSAhMCxcXG4gICAgICAgICAgICBlID0gbnVsbCAhPSBhICYmIGEgKyBcXFwicXVldWVIb29rc1xcXCIsXFxuICAgICAgICAgICAgZiA9IG4udGltZXJzLFxcbiAgICAgICAgICAgIGcgPSBOLmdldCh0aGlzKTtpZiAoZSkgZ1tlXSAmJiBnW2VdLnN0b3AgJiYgZChnW2VdKTtlbHNlIGZvciAoZSBpbiBnKSB7XFxuICAgICAgICAgIGdbZV0gJiYgZ1tlXS5zdG9wICYmIFZhLnRlc3QoZSkgJiYgZChnW2VdKTtcXG4gICAgICAgIH1mb3IgKGUgPSBmLmxlbmd0aDsgZS0tOykge1xcbiAgICAgICAgICBmW2VdLmVsZW0gIT09IHRoaXMgfHwgbnVsbCAhPSBhICYmIGZbZV0ucXVldWUgIT09IGEgfHwgKGZbZV0uYW5pbS5zdG9wKGMpLCBiID0gITEsIGYuc3BsaWNlKGUsIDEpKTtcXG4gICAgICAgIH0hYiAmJiBjIHx8IG4uZGVxdWV1ZSh0aGlzLCBhKTtcXG4gICAgICB9KTtcXG4gICAgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goYSkge1xcbiAgICAgIHJldHVybiBhICE9PSAhMSAmJiAoYSA9IGEgfHwgXFxcImZ4XFxcIiksIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYixcXG4gICAgICAgICAgICBjID0gTi5nZXQodGhpcyksXFxuICAgICAgICAgICAgZCA9IGNbYSArIFxcXCJxdWV1ZVxcXCJdLFxcbiAgICAgICAgICAgIGUgPSBjW2EgKyBcXFwicXVldWVIb29rc1xcXCJdLFxcbiAgICAgICAgICAgIGYgPSBuLnRpbWVycyxcXG4gICAgICAgICAgICBnID0gZCA/IGQubGVuZ3RoIDogMDtmb3IgKGMuZmluaXNoID0gITAsIG4ucXVldWUodGhpcywgYSwgW10pLCBlICYmIGUuc3RvcCAmJiBlLnN0b3AuY2FsbCh0aGlzLCAhMCksIGIgPSBmLmxlbmd0aDsgYi0tOykge1xcbiAgICAgICAgICBmW2JdLmVsZW0gPT09IHRoaXMgJiYgZltiXS5xdWV1ZSA9PT0gYSAmJiAoZltiXS5hbmltLnN0b3AoITApLCBmLnNwbGljZShiLCAxKSk7XFxuICAgICAgICB9Zm9yIChiID0gMDsgZyA+IGI7IGIrKykge1xcbiAgICAgICAgICBkW2JdICYmIGRbYl0uZmluaXNoICYmIGRbYl0uZmluaXNoLmNhbGwodGhpcyk7XFxuICAgICAgICB9ZGVsZXRlIGMuZmluaXNoO1xcbiAgICAgIH0pO1xcbiAgICB9IH0pLCBuLmVhY2goW1xcXCJ0b2dnbGVcXFwiLCBcXFwic2hvd1xcXCIsIFxcXCJoaWRlXFxcIl0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHZhciBjID0gbi5mbltiXTtuLmZuW2JdID0gZnVuY3Rpb24gKGEsIGQsIGUpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBhIHx8IFxcXCJib29sZWFuXFxcIiA9PSB0eXBlb2YgYSA/IGMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXMuYW5pbWF0ZShYYShiLCAhMCksIGEsIGQsIGUpO1xcbiAgICB9O1xcbiAgfSksIG4uZWFjaCh7IHNsaWRlRG93bjogWGEoXFxcInNob3dcXFwiKSwgc2xpZGVVcDogWGEoXFxcImhpZGVcXFwiKSwgc2xpZGVUb2dnbGU6IFhhKFxcXCJ0b2dnbGVcXFwiKSwgZmFkZUluOiB7IG9wYWNpdHk6IFxcXCJzaG93XFxcIiB9LCBmYWRlT3V0OiB7IG9wYWNpdHk6IFxcXCJoaWRlXFxcIiB9LCBmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFxcXCJ0b2dnbGVcXFwiIH0gfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5mblthXSA9IGZ1bmN0aW9uIChhLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZShiLCBhLCBjLCBkKTtcXG4gICAgfTtcXG4gIH0pLCBuLnRpbWVycyA9IFtdLCBuLmZ4LnRpY2sgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhLFxcbiAgICAgICAgYiA9IDAsXFxuICAgICAgICBjID0gbi50aW1lcnM7Zm9yIChTYSA9IG4ubm93KCk7IGIgPCBjLmxlbmd0aDsgYisrKSB7XFxuICAgICAgYSA9IGNbYl0sIGEoKSB8fCBjW2JdICE9PSBhIHx8IGMuc3BsaWNlKGItLSwgMSk7XFxuICAgIH1jLmxlbmd0aCB8fCBuLmZ4LnN0b3AoKSwgU2EgPSB2b2lkIDA7XFxuICB9LCBuLmZ4LnRpbWVyID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgbi50aW1lcnMucHVzaChhKSwgYSgpID8gbi5meC5zdGFydCgpIDogbi50aW1lcnMucG9wKCk7XFxuICB9LCBuLmZ4LmludGVydmFsID0gMTMsIG4uZnguc3RhcnQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIFRhIHx8IChUYSA9IGEuc2V0SW50ZXJ2YWwobi5meC50aWNrLCBuLmZ4LmludGVydmFsKSk7XFxuICB9LCBuLmZ4LnN0b3AgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGEuY2xlYXJJbnRlcnZhbChUYSksIFRhID0gbnVsbDtcXG4gIH0sIG4uZnguc3BlZWRzID0geyBzbG93OiA2MDAsIGZhc3Q6IDIwMCwgX2RlZmF1bHQ6IDQwMCB9LCBuLmZuLmRlbGF5ID0gZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgcmV0dXJuIGIgPSBuLmZ4ID8gbi5meC5zcGVlZHNbYl0gfHwgYiA6IGIsIGMgPSBjIHx8IFxcXCJmeFxcXCIsIHRoaXMucXVldWUoYywgZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICB2YXIgZSA9IGEuc2V0VGltZW91dChjLCBiKTtkLnN0b3AgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBhLmNsZWFyVGltZW91dChlKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGEgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIiksXFxuICAgICAgICBiID0gZC5jcmVhdGVFbGVtZW50KFxcXCJzZWxlY3RcXFwiKSxcXG4gICAgICAgIGMgPSBiLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudChcXFwib3B0aW9uXFxcIikpO2EudHlwZSA9IFxcXCJjaGVja2JveFxcXCIsIGwuY2hlY2tPbiA9IFxcXCJcXFwiICE9PSBhLnZhbHVlLCBsLm9wdFNlbGVjdGVkID0gYy5zZWxlY3RlZCwgYi5kaXNhYmxlZCA9ICEwLCBsLm9wdERpc2FibGVkID0gIWMuZGlzYWJsZWQsIGEgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIiksIGEudmFsdWUgPSBcXFwidFxcXCIsIGEudHlwZSA9IFxcXCJyYWRpb1xcXCIsIGwucmFkaW9WYWx1ZSA9IFxcXCJ0XFxcIiA9PT0gYS52YWx1ZTtcXG4gIH0oKTt2YXIgYWIsXFxuICAgICAgYmIgPSBuLmV4cHIuYXR0ckhhbmRsZTtuLmZuLmV4dGVuZCh7IGF0dHI6IGZ1bmN0aW9uIGF0dHIoYSwgYikge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIG4uYXR0ciwgYSwgYiwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xcbiAgICB9LCByZW1vdmVBdHRyOiBmdW5jdGlvbiByZW1vdmVBdHRyKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG4ucmVtb3ZlQXR0cih0aGlzLCBhKTtcXG4gICAgICB9KTtcXG4gICAgfSB9KSwgbi5leHRlbmQoeyBhdHRyOiBmdW5jdGlvbiBhdHRyKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZiA9IGEubm9kZVR5cGU7aWYgKDMgIT09IGYgJiYgOCAhPT0gZiAmJiAyICE9PSBmKSByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgPT0gdHlwZW9mIGEuZ2V0QXR0cmlidXRlID8gbi5wcm9wKGEsIGIsIGMpIDogKDEgPT09IGYgJiYgbi5pc1hNTERvYyhhKSB8fCAoYiA9IGIudG9Mb3dlckNhc2UoKSwgZSA9IG4uYXR0ckhvb2tzW2JdIHx8IChuLmV4cHIubWF0Y2guYm9vbC50ZXN0KGIpID8gYWIgOiB2b2lkIDApKSwgdm9pZCAwICE9PSBjID8gbnVsbCA9PT0gYyA/IHZvaWQgbi5yZW1vdmVBdHRyKGEsIGIpIDogZSAmJiBcXFwic2V0XFxcIiBpbiBlICYmIHZvaWQgMCAhPT0gKGQgPSBlLnNldChhLCBjLCBiKSkgPyBkIDogKGEuc2V0QXR0cmlidXRlKGIsIGMgKyBcXFwiXFxcIiksIGMpIDogZSAmJiBcXFwiZ2V0XFxcIiBpbiBlICYmIG51bGwgIT09IChkID0gZS5nZXQoYSwgYikpID8gZCA6IChkID0gbi5maW5kLmF0dHIoYSwgYiksIG51bGwgPT0gZCA/IHZvaWQgMCA6IGQpKTtcXG4gICAgfSwgYXR0ckhvb2tzOiB7IHR5cGU6IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSwgYikge1xcbiAgICAgICAgICBpZiAoIWwucmFkaW9WYWx1ZSAmJiBcXFwicmFkaW9cXFwiID09PSBiICYmIG4ubm9kZU5hbWUoYSwgXFxcImlucHV0XFxcIikpIHtcXG4gICAgICAgICAgICB2YXIgYyA9IGEudmFsdWU7cmV0dXJuIGEuc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgYiksIGMgJiYgKGEudmFsdWUgPSBjKSwgYjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSB9IH0sIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIHJlbW92ZUF0dHIoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlID0gMCxcXG4gICAgICAgICAgZiA9IGIgJiYgYi5tYXRjaChHKTtpZiAoZiAmJiAxID09PSBhLm5vZGVUeXBlKSB3aGlsZSAoYyA9IGZbZSsrXSkge1xcbiAgICAgICAgZCA9IG4ucHJvcEZpeFtjXSB8fCBjLCBuLmV4cHIubWF0Y2guYm9vbC50ZXN0KGMpICYmIChhW2RdID0gITEpLCBhLnJlbW92ZUF0dHJpYnV0ZShjKTtcXG4gICAgICB9XFxuICAgIH0gfSksIGFiID0geyBzZXQ6IGZ1bmN0aW9uIHNldChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGIgPT09ICExID8gbi5yZW1vdmVBdHRyKGEsIGMpIDogYS5zZXRBdHRyaWJ1dGUoYywgYyksIGM7XFxuICAgIH0gfSwgbi5lYWNoKG4uZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFxcXHcrL2cpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IGJiW2JdIHx8IG4uZmluZC5hdHRyO2JiW2JdID0gZnVuY3Rpb24gKGEsIGIsIGQpIHtcXG4gICAgICB2YXIgZSwgZjtyZXR1cm4gZCB8fCAoZiA9IGJiW2JdLCBiYltiXSA9IGUsIGUgPSBudWxsICE9IGMoYSwgYiwgZCkgPyBiLnRvTG93ZXJDYXNlKCkgOiBudWxsLCBiYltiXSA9IGYpLCBlO1xcbiAgICB9O1xcbiAgfSk7dmFyIGNiID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcXG4gICAgICBkYiA9IC9eKD86YXxhcmVhKSQvaTtuLmZuLmV4dGVuZCh7IHByb3A6IGZ1bmN0aW9uIHByb3AoYSwgYikge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIG4ucHJvcCwgYSwgYiwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xcbiAgICB9LCByZW1vdmVQcm9wOiBmdW5jdGlvbiByZW1vdmVQcm9wKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGRlbGV0ZSB0aGlzW24ucHJvcEZpeFthXSB8fCBhXTtcXG4gICAgICB9KTtcXG4gICAgfSB9KSwgbi5leHRlbmQoeyBwcm9wOiBmdW5jdGlvbiBwcm9wKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZiA9IGEubm9kZVR5cGU7aWYgKDMgIT09IGYgJiYgOCAhPT0gZiAmJiAyICE9PSBmKSByZXR1cm4gMSA9PT0gZiAmJiBuLmlzWE1MRG9jKGEpIHx8IChiID0gbi5wcm9wRml4W2JdIHx8IGIsIGUgPSBuLnByb3BIb29rc1tiXSksIHZvaWQgMCAhPT0gYyA/IGUgJiYgXFxcInNldFxcXCIgaW4gZSAmJiB2b2lkIDAgIT09IChkID0gZS5zZXQoYSwgYywgYikpID8gZCA6IGFbYl0gPSBjIDogZSAmJiBcXFwiZ2V0XFxcIiBpbiBlICYmIG51bGwgIT09IChkID0gZS5nZXQoYSwgYikpID8gZCA6IGFbYl07XFxuICAgIH0sIHByb3BIb29rczogeyB0YWJJbmRleDogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICAgIHZhciBiID0gbi5maW5kLmF0dHIoYSwgXFxcInRhYmluZGV4XFxcIik7cmV0dXJuIGIgPyBwYXJzZUludChiLCAxMCkgOiBjYi50ZXN0KGEubm9kZU5hbWUpIHx8IGRiLnRlc3QoYS5ub2RlTmFtZSkgJiYgYS5ocmVmID8gMCA6IC0xO1xcbiAgICAgICAgfSB9IH0sIHByb3BGaXg6IHsgXFxcImZvclxcXCI6IFxcXCJodG1sRm9yXFxcIiwgXFxcImNsYXNzXFxcIjogXFxcImNsYXNzTmFtZVxcXCIgfSB9KSwgbC5vcHRTZWxlY3RlZCB8fCAobi5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7IGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICB2YXIgYiA9IGEucGFyZW50Tm9kZTtyZXR1cm4gYiAmJiBiLnBhcmVudE5vZGUgJiYgYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsIG51bGw7XFxuICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KGEpIHtcXG4gICAgICB2YXIgYiA9IGEucGFyZW50Tm9kZTtiICYmIChiLnNlbGVjdGVkSW5kZXgsIGIucGFyZW50Tm9kZSAmJiBiLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCk7XFxuICAgIH0gfSksIG4uZWFjaChbXFxcInRhYkluZGV4XFxcIiwgXFxcInJlYWRPbmx5XFxcIiwgXFxcIm1heExlbmd0aFxcXCIsIFxcXCJjZWxsU3BhY2luZ1xcXCIsIFxcXCJjZWxsUGFkZGluZ1xcXCIsIFxcXCJyb3dTcGFuXFxcIiwgXFxcImNvbFNwYW5cXFwiLCBcXFwidXNlTWFwXFxcIiwgXFxcImZyYW1lQm9yZGVyXFxcIiwgXFxcImNvbnRlbnRFZGl0YWJsZVxcXCJdLCBmdW5jdGlvbiAoKSB7XFxuICAgIG4ucHJvcEZpeFt0aGlzLnRvTG93ZXJDYXNlKCldID0gdGhpcztcXG4gIH0pO3ZhciBlYiA9IC9bXFxcXHRcXFxcclxcXFxuXFxcXGZdL2c7ZnVuY3Rpb24gZmIoYSkge1xcbiAgICByZXR1cm4gYS5nZXRBdHRyaWJ1dGUgJiYgYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikgfHwgXFxcIlxcXCI7XFxuICB9bi5mbi5leHRlbmQoeyBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpID0gMDtpZiAobi5pc0Z1bmN0aW9uKGEpKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICBuKHRoaXMpLmFkZENsYXNzKGEuY2FsbCh0aGlzLCBiLCBmYih0aGlzKSkpO1xcbiAgICAgIH0pO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSAmJiBhKSB7XFxuICAgICAgICBiID0gYS5tYXRjaChHKSB8fCBbXTt3aGlsZSAoYyA9IHRoaXNbaSsrXSkge1xcbiAgICAgICAgICBpZiAoZSA9IGZiKGMpLCBkID0gMSA9PT0gYy5ub2RlVHlwZSAmJiAoXFxcIiBcXFwiICsgZSArIFxcXCIgXFxcIikucmVwbGFjZShlYiwgXFxcIiBcXFwiKSkge1xcbiAgICAgICAgICAgIGcgPSAwO3doaWxlIChmID0gYltnKytdKSB7XFxuICAgICAgICAgICAgICBkLmluZGV4T2YoXFxcIiBcXFwiICsgZiArIFxcXCIgXFxcIikgPCAwICYmIChkICs9IGYgKyBcXFwiIFxcXCIpO1xcbiAgICAgICAgICAgIH1oID0gbi50cmltKGQpLCBlICE9PSBoICYmIGMuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIGgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiB0aGlzO1xcbiAgICB9LCByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpID0gMDtpZiAobi5pc0Z1bmN0aW9uKGEpKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICBuKHRoaXMpLnJlbW92ZUNsYXNzKGEuY2FsbCh0aGlzLCBiLCBmYih0aGlzKSkpO1xcbiAgICAgIH0pO2lmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuYXR0cihcXFwiY2xhc3NcXFwiLCBcXFwiXFxcIik7aWYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmIGEpIHtcXG4gICAgICAgIGIgPSBhLm1hdGNoKEcpIHx8IFtdO3doaWxlIChjID0gdGhpc1tpKytdKSB7XFxuICAgICAgICAgIGlmIChlID0gZmIoYyksIGQgPSAxID09PSBjLm5vZGVUeXBlICYmIChcXFwiIFxcXCIgKyBlICsgXFxcIiBcXFwiKS5yZXBsYWNlKGViLCBcXFwiIFxcXCIpKSB7XFxuICAgICAgICAgICAgZyA9IDA7d2hpbGUgKGYgPSBiW2crK10pIHtcXG4gICAgICAgICAgICAgIHdoaWxlIChkLmluZGV4T2YoXFxcIiBcXFwiICsgZiArIFxcXCIgXFxcIikgPiAtMSkge1xcbiAgICAgICAgICAgICAgICBkID0gZC5yZXBsYWNlKFxcXCIgXFxcIiArIGYgKyBcXFwiIFxcXCIsIFxcXCIgXFxcIik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfWggPSBuLnRyaW0oZCksIGUgIT09IGggJiYgYy5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgaCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIHRoaXM7XFxuICAgIH0sIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyhhLCBiKSB7XFxuICAgICAgdmFyIGMgPSB0eXBlb2YgYSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYSk7cmV0dXJuIFxcXCJib29sZWFuXFxcIiA9PSB0eXBlb2YgYiAmJiBcXFwic3RyaW5nXFxcIiA9PT0gYyA/IGIgPyB0aGlzLmFkZENsYXNzKGEpIDogdGhpcy5yZW1vdmVDbGFzcyhhKSA6IG4uaXNGdW5jdGlvbihhKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoYykge1xcbiAgICAgICAgbih0aGlzKS50b2dnbGVDbGFzcyhhLmNhbGwodGhpcywgYywgZmIodGhpcyksIGIpLCBiKTtcXG4gICAgICB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYiwgZCwgZSwgZjtpZiAoXFxcInN0cmluZ1xcXCIgPT09IGMpIHtcXG4gICAgICAgICAgZCA9IDAsIGUgPSBuKHRoaXMpLCBmID0gYS5tYXRjaChHKSB8fCBbXTt3aGlsZSAoYiA9IGZbZCsrXSkge1xcbiAgICAgICAgICAgIGUuaGFzQ2xhc3MoYikgPyBlLnJlbW92ZUNsYXNzKGIpIDogZS5hZGRDbGFzcyhiKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHZvaWQgMCAhPT0gYSAmJiBcXFwiYm9vbGVhblxcXCIgIT09IGMgfHwgKGIgPSBmYih0aGlzKSwgYiAmJiBOLnNldCh0aGlzLCBcXFwiX19jbGFzc05hbWVfX1xcXCIsIGIpLCB0aGlzLnNldEF0dHJpYnV0ZSAmJiB0aGlzLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLCBiIHx8IGEgPT09ICExID8gXFxcIlxcXCIgOiBOLmdldCh0aGlzLCBcXFwiX19jbGFzc05hbWVfX1xcXCIpIHx8IFxcXCJcXFwiKSk7XFxuICAgICAgfSk7XFxuICAgIH0sIGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGQgPSAwO2IgPSBcXFwiIFxcXCIgKyBhICsgXFxcIiBcXFwiO3doaWxlIChjID0gdGhpc1tkKytdKSB7XFxuICAgICAgICBpZiAoMSA9PT0gYy5ub2RlVHlwZSAmJiAoXFxcIiBcXFwiICsgZmIoYykgKyBcXFwiIFxcXCIpLnJlcGxhY2UoZWIsIFxcXCIgXFxcIikuaW5kZXhPZihiKSA+IC0xKSByZXR1cm4gITA7XFxuICAgICAgfXJldHVybiAhMTtcXG4gICAgfSB9KTt2YXIgZ2IgPSAvXFxcXHIvZyxcXG4gICAgICBoYiA9IC9bXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXSsvZztuLmZuLmV4dGVuZCh7IHZhbDogZnVuY3Rpb24gdmFsKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSA9IHRoaXNbMF07e1xcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkID0gbi5pc0Z1bmN0aW9uKGEpLCB0aGlzLmVhY2goZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgICAgdmFyIGU7MSA9PT0gdGhpcy5ub2RlVHlwZSAmJiAoZSA9IGQgPyBhLmNhbGwodGhpcywgYywgbih0aGlzKS52YWwoKSkgOiBhLCBudWxsID09IGUgPyBlID0gXFxcIlxcXCIgOiBcXFwibnVtYmVyXFxcIiA9PSB0eXBlb2YgZSA/IGUgKz0gXFxcIlxcXCIgOiBuLmlzQXJyYXkoZSkgJiYgKGUgPSBuLm1hcChlLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsID09IGEgPyBcXFwiXFxcIiA6IGEgKyBcXFwiXFxcIjtcXG4gICAgICAgICAgfSkpLCBiID0gbi52YWxIb29rc1t0aGlzLnR5cGVdIHx8IG4udmFsSG9va3NbdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSwgYiAmJiBcXFwic2V0XFxcIiBpbiBiICYmIHZvaWQgMCAhPT0gYi5zZXQodGhpcywgZSwgXFxcInZhbHVlXFxcIikgfHwgKHRoaXMudmFsdWUgPSBlKSk7XFxuICAgICAgICB9KTtpZiAoZSkgcmV0dXJuIGIgPSBuLnZhbEhvb2tzW2UudHlwZV0gfHwgbi52YWxIb29rc1tlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLCBiICYmIFxcXCJnZXRcXFwiIGluIGIgJiYgdm9pZCAwICE9PSAoYyA9IGIuZ2V0KGUsIFxcXCJ2YWx1ZVxcXCIpKSA/IGMgOiAoYyA9IGUudmFsdWUsIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBjID8gYy5yZXBsYWNlKGdiLCBcXFwiXFxcIikgOiBudWxsID09IGMgPyBcXFwiXFxcIiA6IGMpO1xcbiAgICAgIH1cXG4gICAgfSB9KSwgbi5leHRlbmQoeyB2YWxIb29rczogeyBvcHRpb246IHsgZ2V0OiBmdW5jdGlvbiBnZXQoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IG4uZmluZC5hdHRyKGEsIFxcXCJ2YWx1ZVxcXCIpO3JldHVybiBudWxsICE9IGIgPyBiIDogbi50cmltKG4udGV4dChhKSkucmVwbGFjZShoYiwgXFxcIiBcXFwiKTtcXG4gICAgICAgIH0gfSwgc2VsZWN0OiB7IGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICAgICAgZm9yICh2YXIgYiwgYywgZCA9IGEub3B0aW9ucywgZSA9IGEuc2VsZWN0ZWRJbmRleCwgZiA9IFxcXCJzZWxlY3Qtb25lXFxcIiA9PT0gYS50eXBlIHx8IDAgPiBlLCBnID0gZiA/IG51bGwgOiBbXSwgaCA9IGYgPyBlICsgMSA6IGQubGVuZ3RoLCBpID0gMCA+IGUgPyBoIDogZiA/IGUgOiAwOyBoID4gaTsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKGMgPSBkW2ldLCAoYy5zZWxlY3RlZCB8fCBpID09PSBlKSAmJiAobC5vcHREaXNhYmxlZCA/ICFjLmRpc2FibGVkIDogbnVsbCA9PT0gYy5nZXRBdHRyaWJ1dGUoXFxcImRpc2FibGVkXFxcIikpICYmICghYy5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFuLm5vZGVOYW1lKGMucGFyZW50Tm9kZSwgXFxcIm9wdGdyb3VwXFxcIikpKSB7XFxuICAgICAgICAgICAgICBpZiAoYiA9IG4oYykudmFsKCksIGYpIHJldHVybiBiO2cucHVzaChiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1yZXR1cm4gZztcXG4gICAgICAgIH0sIHNldDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgICBkLFxcbiAgICAgICAgICAgICAgZSA9IGEub3B0aW9ucyxcXG4gICAgICAgICAgICAgIGYgPSBuLm1ha2VBcnJheShiKSxcXG4gICAgICAgICAgICAgIGcgPSBlLmxlbmd0aDt3aGlsZSAoZy0tKSB7XFxuICAgICAgICAgICAgZCA9IGVbZ10sIChkLnNlbGVjdGVkID0gbi5pbkFycmF5KG4udmFsSG9va3Mub3B0aW9uLmdldChkKSwgZikgPiAtMSkgJiYgKGMgPSAhMCk7XFxuICAgICAgICAgIH1yZXR1cm4gYyB8fCAoYS5zZWxlY3RlZEluZGV4ID0gLTEpLCBmO1xcbiAgICAgICAgfSB9IH0gfSksIG4uZWFjaChbXFxcInJhZGlvXFxcIiwgXFxcImNoZWNrYm94XFxcIl0sIGZ1bmN0aW9uICgpIHtcXG4gICAgbi52YWxIb29rc1t0aGlzXSA9IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSwgYikge1xcbiAgICAgICAgcmV0dXJuIG4uaXNBcnJheShiKSA/IGEuY2hlY2tlZCA9IG4uaW5BcnJheShuKGEpLnZhbCgpLCBiKSA+IC0xIDogdm9pZCAwO1xcbiAgICAgIH0gfSwgbC5jaGVja09uIHx8IChuLnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT09IGEuZ2V0QXR0cmlidXRlKFxcXCJ2YWx1ZVxcXCIpID8gXFxcIm9uXFxcIiA6IGEudmFsdWU7XFxuICAgIH0pO1xcbiAgfSk7dmFyIGliID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvO24uZXh0ZW5kKG4uZXZlbnQsIHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihiLCBjLCBlLCBmKSB7XFxuICAgICAgdmFyIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0sXFxuICAgICAgICAgIG8sXFxuICAgICAgICAgIHAgPSBbZSB8fCBkXSxcXG4gICAgICAgICAgcSA9IGsuY2FsbChiLCBcXFwidHlwZVxcXCIpID8gYi50eXBlIDogYixcXG4gICAgICAgICAgciA9IGsuY2FsbChiLCBcXFwibmFtZXNwYWNlXFxcIikgPyBiLm5hbWVzcGFjZS5zcGxpdChcXFwiLlxcXCIpIDogW107aWYgKGggPSBpID0gZSA9IGUgfHwgZCwgMyAhPT0gZS5ub2RlVHlwZSAmJiA4ICE9PSBlLm5vZGVUeXBlICYmICFpYi50ZXN0KHEgKyBuLmV2ZW50LnRyaWdnZXJlZCkgJiYgKHEuaW5kZXhPZihcXFwiLlxcXCIpID4gLTEgJiYgKHIgPSBxLnNwbGl0KFxcXCIuXFxcIiksIHEgPSByLnNoaWZ0KCksIHIuc29ydCgpKSwgbCA9IHEuaW5kZXhPZihcXFwiOlxcXCIpIDwgMCAmJiBcXFwib25cXFwiICsgcSwgYiA9IGJbbi5leHBhbmRvXSA/IGIgOiBuZXcgbi5FdmVudChxLCBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGIgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGIpKSAmJiBiKSwgYi5pc1RyaWdnZXIgPSBmID8gMiA6IDMsIGIubmFtZXNwYWNlID0gci5qb2luKFxcXCIuXFxcIiksIGIucm5hbWVzcGFjZSA9IGIubmFtZXNwYWNlID8gbmV3IFJlZ0V4cChcXFwiKF58XFxcXFxcXFwuKVxcXCIgKyByLmpvaW4oXFxcIlxcXFxcXFxcLig/Oi4qXFxcXFxcXFwufClcXFwiKSArIFxcXCIoXFxcXFxcXFwufCQpXFxcIikgOiBudWxsLCBiLnJlc3VsdCA9IHZvaWQgMCwgYi50YXJnZXQgfHwgKGIudGFyZ2V0ID0gZSksIGMgPSBudWxsID09IGMgPyBbYl0gOiBuLm1ha2VBcnJheShjLCBbYl0pLCBvID0gbi5ldmVudC5zcGVjaWFsW3FdIHx8IHt9LCBmIHx8ICFvLnRyaWdnZXIgfHwgby50cmlnZ2VyLmFwcGx5KGUsIGMpICE9PSAhMSkpIHtcXG4gICAgICAgIGlmICghZiAmJiAhby5ub0J1YmJsZSAmJiAhbi5pc1dpbmRvdyhlKSkge1xcbiAgICAgICAgICBmb3IgKGogPSBvLmRlbGVnYXRlVHlwZSB8fCBxLCBpYi50ZXN0KGogKyBxKSB8fCAoaCA9IGgucGFyZW50Tm9kZSk7IGg7IGggPSBoLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgICBwLnB1c2goaCksIGkgPSBoO1xcbiAgICAgICAgICB9aSA9PT0gKGUub3duZXJEb2N1bWVudCB8fCBkKSAmJiBwLnB1c2goaS5kZWZhdWx0VmlldyB8fCBpLnBhcmVudFdpbmRvdyB8fCBhKTtcXG4gICAgICAgIH1nID0gMDt3aGlsZSAoKGggPSBwW2crK10pICYmICFiLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcXG4gICAgICAgICAgYi50eXBlID0gZyA+IDEgPyBqIDogby5iaW5kVHlwZSB8fCBxLCBtID0gKE4uZ2V0KGgsIFxcXCJldmVudHNcXFwiKSB8fCB7fSlbYi50eXBlXSAmJiBOLmdldChoLCBcXFwiaGFuZGxlXFxcIiksIG0gJiYgbS5hcHBseShoLCBjKSwgbSA9IGwgJiYgaFtsXSwgbSAmJiBtLmFwcGx5ICYmIEwoaCkgJiYgKGIucmVzdWx0ID0gbS5hcHBseShoLCBjKSwgYi5yZXN1bHQgPT09ICExICYmIGIucHJldmVudERlZmF1bHQoKSk7XFxuICAgICAgICB9cmV0dXJuIGIudHlwZSA9IHEsIGYgfHwgYi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBvLl9kZWZhdWx0ICYmIG8uX2RlZmF1bHQuYXBwbHkocC5wb3AoKSwgYykgIT09ICExIHx8ICFMKGUpIHx8IGwgJiYgbi5pc0Z1bmN0aW9uKGVbcV0pICYmICFuLmlzV2luZG93KGUpICYmIChpID0gZVtsXSwgaSAmJiAoZVtsXSA9IG51bGwpLCBuLmV2ZW50LnRyaWdnZXJlZCA9IHEsIGVbcV0oKSwgbi5ldmVudC50cmlnZ2VyZWQgPSB2b2lkIDAsIGkgJiYgKGVbbF0gPSBpKSksIGIucmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfSwgc2ltdWxhdGU6IGZ1bmN0aW9uIHNpbXVsYXRlKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCA9IG4uZXh0ZW5kKG5ldyBuLkV2ZW50KCksIGMsIHsgdHlwZTogYSwgaXNTaW11bGF0ZWQ6ICEwIH0pO24uZXZlbnQudHJpZ2dlcihkLCBudWxsLCBiKTtcXG4gICAgfSB9KSwgbi5mbi5leHRlbmQoeyB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKGEsIGIpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG4uZXZlbnQudHJpZ2dlcihhLCBiLCB0aGlzKTtcXG4gICAgICB9KTtcXG4gICAgfSwgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uIHRyaWdnZXJIYW5kbGVyKGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IHRoaXNbMF07cmV0dXJuIGMgPyBuLmV2ZW50LnRyaWdnZXIoYSwgYiwgYywgITApIDogdm9pZCAwO1xcbiAgICB9IH0pLCBuLmVhY2goXFxcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcXFwiLnNwbGl0KFxcXCIgXFxcIiksIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZm5bYl0gPSBmdW5jdGlvbiAoYSwgYykge1xcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/IHRoaXMub24oYiwgbnVsbCwgYSwgYykgOiB0aGlzLnRyaWdnZXIoYik7XFxuICAgIH07XFxuICB9KSwgbi5mbi5leHRlbmQoeyBob3ZlcjogZnVuY3Rpb24gaG92ZXIoYSwgYikge1xcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlZW50ZXIoYSkubW91c2VsZWF2ZShiIHx8IGEpO1xcbiAgICB9IH0pLCBsLmZvY3VzaW4gPSBcXFwib25mb2N1c2luXFxcIiBpbiBhLCBsLmZvY3VzaW4gfHwgbi5lYWNoKHsgZm9jdXM6IFxcXCJmb2N1c2luXFxcIiwgYmx1cjogXFxcImZvY3Vzb3V0XFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IGZ1bmN0aW9uIGMoYSkge1xcbiAgICAgIG4uZXZlbnQuc2ltdWxhdGUoYiwgYS50YXJnZXQsIG4uZXZlbnQuZml4KGEpKTtcXG4gICAgfTtuLmV2ZW50LnNwZWNpYWxbYl0gPSB7IHNldHVwOiBmdW5jdGlvbiBzZXR1cCgpIHtcXG4gICAgICAgIHZhciBkID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXFxuICAgICAgICAgICAgZSA9IE4uYWNjZXNzKGQsIGIpO2UgfHwgZC5hZGRFdmVudExpc3RlbmVyKGEsIGMsICEwKSwgTi5hY2Nlc3MoZCwgYiwgKGUgfHwgMCkgKyAxKTtcXG4gICAgICB9LCB0ZWFyZG93bjogZnVuY3Rpb24gdGVhcmRvd24oKSB7XFxuICAgICAgICB2YXIgZCA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxcbiAgICAgICAgICAgIGUgPSBOLmFjY2VzcyhkLCBiKSAtIDE7ZSA/IE4uYWNjZXNzKGQsIGIsIGUpIDogKGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihhLCBjLCAhMCksIE4ucmVtb3ZlKGQsIGIpKTtcXG4gICAgICB9IH07XFxuICB9KTt2YXIgamIgPSBhLmxvY2F0aW9uLFxcbiAgICAgIGtiID0gbi5ub3coKSxcXG4gICAgICBsYiA9IC9cXFxcPy87bi5wYXJzZUpTT04gPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gSlNPTi5wYXJzZShhICsgXFxcIlxcXCIpO1xcbiAgfSwgbi5wYXJzZVhNTCA9IGZ1bmN0aW9uIChiKSB7XFxuICAgIHZhciBjO2lmICghYiB8fCBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYikgcmV0dXJuIG51bGw7dHJ5IHtcXG4gICAgICBjID0gbmV3IGEuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGIsIFxcXCJ0ZXh0L3htbFxcXCIpO1xcbiAgICB9IGNhdGNoIChkKSB7XFxuICAgICAgYyA9IHZvaWQgMDtcXG4gICAgfXJldHVybiBjICYmICFjLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJwYXJzZXJlcnJvclxcXCIpLmxlbmd0aCB8fCBuLmVycm9yKFxcXCJJbnZhbGlkIFhNTDogXFxcIiArIGIpLCBjO1xcbiAgfTt2YXIgbWIgPSAvIy4qJC8sXFxuICAgICAgbmIgPSAvKFs/Jl0pXz1bXiZdKi8sXFxuICAgICAgb2IgPSAvXiguKj8pOlsgXFxcXHRdKihbXlxcXFxyXFxcXG5dKikkL2dtLFxcbiAgICAgIHBiID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXFxuICAgICAgcWIgPSAvXig/OkdFVHxIRUFEKSQvLFxcbiAgICAgIHJiID0gL15cXFxcL1xcXFwvLyxcXG4gICAgICBzYiA9IHt9LFxcbiAgICAgIHRiID0ge30sXFxuICAgICAgdWIgPSBcXFwiKi9cXFwiLmNvbmNhdChcXFwiKlxcXCIpLFxcbiAgICAgIHZiID0gZC5jcmVhdGVFbGVtZW50KFxcXCJhXFxcIik7dmIuaHJlZiA9IGpiLmhyZWY7ZnVuY3Rpb24gd2IoYSkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgICBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYiAmJiAoYyA9IGIsIGIgPSBcXFwiKlxcXCIpO3ZhciBkLFxcbiAgICAgICAgICBlID0gMCxcXG4gICAgICAgICAgZiA9IGIudG9Mb3dlckNhc2UoKS5tYXRjaChHKSB8fCBbXTtpZiAobi5pc0Z1bmN0aW9uKGMpKSB3aGlsZSAoZCA9IGZbZSsrXSkge1xcbiAgICAgICAgXFxcIitcXFwiID09PSBkWzBdID8gKGQgPSBkLnNsaWNlKDEpIHx8IFxcXCIqXFxcIiwgKGFbZF0gPSBhW2RdIHx8IFtdKS51bnNoaWZ0KGMpKSA6IChhW2RdID0gYVtkXSB8fCBbXSkucHVzaChjKTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9ZnVuY3Rpb24geGIoYSwgYiwgYywgZCkge1xcbiAgICB2YXIgZSA9IHt9LFxcbiAgICAgICAgZiA9IGEgPT09IHRiO2Z1bmN0aW9uIGcoaCkge1xcbiAgICAgIHZhciBpO3JldHVybiBlW2hdID0gITAsIG4uZWFjaChhW2hdIHx8IFtdLCBmdW5jdGlvbiAoYSwgaCkge1xcbiAgICAgICAgdmFyIGogPSBoKGIsIGMsIGQpO3JldHVybiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgaiB8fCBmIHx8IGVbal0gPyBmID8gIShpID0gaikgOiB2b2lkIDAgOiAoYi5kYXRhVHlwZXMudW5zaGlmdChqKSwgZyhqKSwgITEpO1xcbiAgICAgIH0pLCBpO1xcbiAgICB9cmV0dXJuIGcoYi5kYXRhVHlwZXNbMF0pIHx8ICFlW1xcXCIqXFxcIl0gJiYgZyhcXFwiKlxcXCIpO1xcbiAgfWZ1bmN0aW9uIHliKGEsIGIpIHtcXG4gICAgdmFyIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSA9IG4uYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O2ZvciAoYyBpbiBiKSB7XFxuICAgICAgdm9pZCAwICE9PSBiW2NdICYmICgoZVtjXSA/IGEgOiBkIHx8IChkID0ge30pKVtjXSA9IGJbY10pO1xcbiAgICB9cmV0dXJuIGQgJiYgbi5leHRlbmQoITAsIGEsIGQpLCBhO1xcbiAgfWZ1bmN0aW9uIHpiKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcsXFxuICAgICAgICBoID0gYS5jb250ZW50cyxcXG4gICAgICAgIGkgPSBhLmRhdGFUeXBlczt3aGlsZSAoXFxcIipcXFwiID09PSBpWzBdKSB7XFxuICAgICAgaS5zaGlmdCgpLCB2b2lkIDAgPT09IGQgJiYgKGQgPSBhLm1pbWVUeXBlIHx8IGIuZ2V0UmVzcG9uc2VIZWFkZXIoXFxcIkNvbnRlbnQtVHlwZVxcXCIpKTtcXG4gICAgfWlmIChkKSBmb3IgKGUgaW4gaCkge1xcbiAgICAgIGlmIChoW2VdICYmIGhbZV0udGVzdChkKSkge1xcbiAgICAgICAgaS51bnNoaWZ0KGUpO2JyZWFrO1xcbiAgICAgIH1cXG4gICAgfWlmIChpWzBdIGluIGMpIGYgPSBpWzBdO2Vsc2Uge1xcbiAgICAgIGZvciAoZSBpbiBjKSB7XFxuICAgICAgICBpZiAoIWlbMF0gfHwgYS5jb252ZXJ0ZXJzW2UgKyBcXFwiIFxcXCIgKyBpWzBdXSkge1xcbiAgICAgICAgICBmID0gZTticmVhaztcXG4gICAgICAgIH1nIHx8IChnID0gZSk7XFxuICAgICAgfWYgPSBmIHx8IGc7XFxuICAgIH1yZXR1cm4gZiA/IChmICE9PSBpWzBdICYmIGkudW5zaGlmdChmKSwgY1tmXSkgOiB2b2lkIDA7XFxuICB9ZnVuY3Rpb24gQWIoYSwgYiwgYywgZCkge1xcbiAgICB2YXIgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqID0ge30sXFxuICAgICAgICBrID0gYS5kYXRhVHlwZXMuc2xpY2UoKTtpZiAoa1sxXSkgZm9yIChnIGluIGEuY29udmVydGVycykge1xcbiAgICAgIGpbZy50b0xvd2VyQ2FzZSgpXSA9IGEuY29udmVydGVyc1tnXTtcXG4gICAgfWYgPSBrLnNoaWZ0KCk7d2hpbGUgKGYpIHtcXG4gICAgICBpZiAoYS5yZXNwb25zZUZpZWxkc1tmXSAmJiAoY1thLnJlc3BvbnNlRmllbGRzW2ZdXSA9IGIpLCAhaSAmJiBkICYmIGEuZGF0YUZpbHRlciAmJiAoYiA9IGEuZGF0YUZpbHRlcihiLCBhLmRhdGFUeXBlKSksIGkgPSBmLCBmID0gay5zaGlmdCgpKSBpZiAoXFxcIipcXFwiID09PSBmKSBmID0gaTtlbHNlIGlmIChcXFwiKlxcXCIgIT09IGkgJiYgaSAhPT0gZikge1xcbiAgICAgICAgaWYgKGcgPSBqW2kgKyBcXFwiIFxcXCIgKyBmXSB8fCBqW1xcXCIqIFxcXCIgKyBmXSwgIWcpIGZvciAoZSBpbiBqKSB7XFxuICAgICAgICAgIGlmIChoID0gZS5zcGxpdChcXFwiIFxcXCIpLCBoWzFdID09PSBmICYmIChnID0galtpICsgXFxcIiBcXFwiICsgaFswXV0gfHwgaltcXFwiKiBcXFwiICsgaFswXV0pKSB7XFxuICAgICAgICAgICAgZyA9PT0gITAgPyBnID0galtlXSA6IGpbZV0gIT09ICEwICYmIChmID0gaFswXSwgay51bnNoaWZ0KGhbMV0pKTticmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfWlmIChnICE9PSAhMCkgaWYgKGcgJiYgYVtcXFwidGhyb3dzXFxcIl0pIGIgPSBnKGIpO2Vsc2UgdHJ5IHtcXG4gICAgICAgICAgYiA9IGcoYik7XFxuICAgICAgICB9IGNhdGNoIChsKSB7XFxuICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcXFwicGFyc2VyZXJyb3JcXFwiLCBlcnJvcjogZyA/IGwgOiBcXFwiTm8gY29udmVyc2lvbiBmcm9tIFxcXCIgKyBpICsgXFxcIiB0byBcXFwiICsgZiB9O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfXJldHVybiB7IHN0YXRlOiBcXFwic3VjY2Vzc1xcXCIsIGRhdGE6IGIgfTtcXG4gIH1uLmV4dGVuZCh7IGFjdGl2ZTogMCwgbGFzdE1vZGlmaWVkOiB7fSwgZXRhZzoge30sIGFqYXhTZXR0aW5nczogeyB1cmw6IGpiLmhyZWYsIHR5cGU6IFxcXCJHRVRcXFwiLCBpc0xvY2FsOiBwYi50ZXN0KGpiLnByb3RvY29sKSwgZ2xvYmFsOiAhMCwgcHJvY2Vzc0RhdGE6ICEwLCBhc3luYzogITAsIGNvbnRlbnRUeXBlOiBcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XFxcIiwgYWNjZXB0czogeyBcXFwiKlxcXCI6IHViLCB0ZXh0OiBcXFwidGV4dC9wbGFpblxcXCIsIGh0bWw6IFxcXCJ0ZXh0L2h0bWxcXFwiLCB4bWw6IFxcXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXFxcIiwganNvbjogXFxcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFxcXCIgfSwgY29udGVudHM6IHsgeG1sOiAvXFxcXGJ4bWxcXFxcYi8sIGh0bWw6IC9cXFxcYmh0bWwvLCBqc29uOiAvXFxcXGJqc29uXFxcXGIvIH0sIHJlc3BvbnNlRmllbGRzOiB7IHhtbDogXFxcInJlc3BvbnNlWE1MXFxcIiwgdGV4dDogXFxcInJlc3BvbnNlVGV4dFxcXCIsIGpzb246IFxcXCJyZXNwb25zZUpTT05cXFwiIH0sIGNvbnZlcnRlcnM6IHsgXFxcIiogdGV4dFxcXCI6IFN0cmluZywgXFxcInRleHQgaHRtbFxcXCI6ICEwLCBcXFwidGV4dCBqc29uXFxcIjogbi5wYXJzZUpTT04sIFxcXCJ0ZXh0IHhtbFxcXCI6IG4ucGFyc2VYTUwgfSwgZmxhdE9wdGlvbnM6IHsgdXJsOiAhMCwgY29udGV4dDogITAgfSB9LCBhamF4U2V0dXA6IGZ1bmN0aW9uIGFqYXhTZXR1cChhLCBiKSB7XFxuICAgICAgcmV0dXJuIGIgPyB5Yih5YihhLCBuLmFqYXhTZXR0aW5ncyksIGIpIDogeWIobi5hamF4U2V0dGluZ3MsIGEpO1xcbiAgICB9LCBhamF4UHJlZmlsdGVyOiB3YihzYiksIGFqYXhUcmFuc3BvcnQ6IHdiKHRiKSwgYWpheDogZnVuY3Rpb24gYWpheChiLCBjKSB7XFxuICAgICAgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBiID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihiKSkgJiYgKGMgPSBiLCBiID0gdm9pZCAwKSwgYyA9IGMgfHwge307dmFyIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0gPSBuLmFqYXhTZXR1cCh7fSwgYyksXFxuICAgICAgICAgIG8gPSBtLmNvbnRleHQgfHwgbSxcXG4gICAgICAgICAgcCA9IG0uY29udGV4dCAmJiAoby5ub2RlVHlwZSB8fCBvLmpxdWVyeSkgPyBuKG8pIDogbi5ldmVudCxcXG4gICAgICAgICAgcSA9IG4uRGVmZXJyZWQoKSxcXG4gICAgICAgICAgciA9IG4uQ2FsbGJhY2tzKFxcXCJvbmNlIG1lbW9yeVxcXCIpLFxcbiAgICAgICAgICBzID0gbS5zdGF0dXNDb2RlIHx8IHt9LFxcbiAgICAgICAgICB0ID0ge30sXFxuICAgICAgICAgIHUgPSB7fSxcXG4gICAgICAgICAgdiA9IDAsXFxuICAgICAgICAgIHcgPSBcXFwiY2FuY2VsZWRcXFwiLFxcbiAgICAgICAgICB4ID0geyByZWFkeVN0YXRlOiAwLCBnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24gZ2V0UmVzcG9uc2VIZWFkZXIoYSkge1xcbiAgICAgICAgICB2YXIgYjtpZiAoMiA9PT0gdikge1xcbiAgICAgICAgICAgIGlmICghaCkge1xcbiAgICAgICAgICAgICAgaCA9IHt9O3doaWxlIChiID0gb2IuZXhlYyhnKSkge1xcbiAgICAgICAgICAgICAgICBoW2JbMV0udG9Mb3dlckNhc2UoKV0gPSBiWzJdO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1iID0gaFthLnRvTG93ZXJDYXNlKCldO1xcbiAgICAgICAgICB9cmV0dXJuIG51bGwgPT0gYiA/IG51bGwgOiBiO1xcbiAgICAgICAgfSwgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiBnZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB7XFxuICAgICAgICAgIHJldHVybiAyID09PSB2ID8gZyA6IG51bGw7XFxuICAgICAgICB9LCBzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSBhLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHYgfHwgKGEgPSB1W2NdID0gdVtjXSB8fCBhLCB0W2FdID0gYiksIHRoaXM7XFxuICAgICAgICB9LCBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiBvdmVycmlkZU1pbWVUeXBlKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIHYgfHwgKG0ubWltZVR5cGUgPSBhKSwgdGhpcztcXG4gICAgICAgIH0sIHN0YXR1c0NvZGU6IGZ1bmN0aW9uIHN0YXR1c0NvZGUoYSkge1xcbiAgICAgICAgICB2YXIgYjtpZiAoYSkgaWYgKDIgPiB2KSBmb3IgKGIgaW4gYSkge1xcbiAgICAgICAgICAgIHNbYl0gPSBbc1tiXSwgYVtiXV07XFxuICAgICAgICAgIH0gZWxzZSB4LmFsd2F5cyhhW3guc3RhdHVzXSk7cmV0dXJuIHRoaXM7XFxuICAgICAgICB9LCBhYm9ydDogZnVuY3Rpb24gYWJvcnQoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IGEgfHwgdztyZXR1cm4gZSAmJiBlLmFib3J0KGIpLCB6KDAsIGIpLCB0aGlzO1xcbiAgICAgICAgfSB9O2lmIChxLnByb21pc2UoeCkuY29tcGxldGUgPSByLmFkZCwgeC5zdWNjZXNzID0geC5kb25lLCB4LmVycm9yID0geC5mYWlsLCBtLnVybCA9ICgoYiB8fCBtLnVybCB8fCBqYi5ocmVmKSArIFxcXCJcXFwiKS5yZXBsYWNlKG1iLCBcXFwiXFxcIikucmVwbGFjZShyYiwgamIucHJvdG9jb2wgKyBcXFwiLy9cXFwiKSwgbS50eXBlID0gYy5tZXRob2QgfHwgYy50eXBlIHx8IG0ubWV0aG9kIHx8IG0udHlwZSwgbS5kYXRhVHlwZXMgPSBuLnRyaW0obS5kYXRhVHlwZSB8fCBcXFwiKlxcXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2goRykgfHwgW1xcXCJcXFwiXSwgbnVsbCA9PSBtLmNyb3NzRG9tYWluKSB7XFxuICAgICAgICBqID0gZC5jcmVhdGVFbGVtZW50KFxcXCJhXFxcIik7dHJ5IHtcXG4gICAgICAgICAgai5ocmVmID0gbS51cmwsIGouaHJlZiA9IGouaHJlZiwgbS5jcm9zc0RvbWFpbiA9IHZiLnByb3RvY29sICsgXFxcIi8vXFxcIiArIHZiLmhvc3QgIT0gai5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyBqLmhvc3Q7XFxuICAgICAgICB9IGNhdGNoICh5KSB7XFxuICAgICAgICAgIG0uY3Jvc3NEb21haW4gPSAhMDtcXG4gICAgICAgIH1cXG4gICAgICB9aWYgKG0uZGF0YSAmJiBtLnByb2Nlc3NEYXRhICYmIFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBtLmRhdGEgJiYgKG0uZGF0YSA9IG4ucGFyYW0obS5kYXRhLCBtLnRyYWRpdGlvbmFsKSksIHhiKHNiLCBtLCBjLCB4KSwgMiA9PT0gdikgcmV0dXJuIHg7ayA9IG4uZXZlbnQgJiYgbS5nbG9iYWwsIGsgJiYgMCA9PT0gbi5hY3RpdmUrKyAmJiBuLmV2ZW50LnRyaWdnZXIoXFxcImFqYXhTdGFydFxcXCIpLCBtLnR5cGUgPSBtLnR5cGUudG9VcHBlckNhc2UoKSwgbS5oYXNDb250ZW50ID0gIXFiLnRlc3QobS50eXBlKSwgZiA9IG0udXJsLCBtLmhhc0NvbnRlbnQgfHwgKG0uZGF0YSAmJiAoZiA9IG0udXJsICs9IChsYi50ZXN0KGYpID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiKSArIG0uZGF0YSwgZGVsZXRlIG0uZGF0YSksIG0uY2FjaGUgPT09ICExICYmIChtLnVybCA9IG5iLnRlc3QoZikgPyBmLnJlcGxhY2UobmIsIFxcXCIkMV89XFxcIiArIGtiKyspIDogZiArIChsYi50ZXN0KGYpID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiKSArIFxcXCJfPVxcXCIgKyBrYisrKSksIG0uaWZNb2RpZmllZCAmJiAobi5sYXN0TW9kaWZpZWRbZl0gJiYgeC5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJJZi1Nb2RpZmllZC1TaW5jZVxcXCIsIG4ubGFzdE1vZGlmaWVkW2ZdKSwgbi5ldGFnW2ZdICYmIHguc2V0UmVxdWVzdEhlYWRlcihcXFwiSWYtTm9uZS1NYXRjaFxcXCIsIG4uZXRhZ1tmXSkpLCAobS5kYXRhICYmIG0uaGFzQ29udGVudCAmJiBtLmNvbnRlbnRUeXBlICE9PSAhMSB8fCBjLmNvbnRlbnRUeXBlKSAmJiB4LnNldFJlcXVlc3RIZWFkZXIoXFxcIkNvbnRlbnQtVHlwZVxcXCIsIG0uY29udGVudFR5cGUpLCB4LnNldFJlcXVlc3RIZWFkZXIoXFxcIkFjY2VwdFxcXCIsIG0uZGF0YVR5cGVzWzBdICYmIG0uYWNjZXB0c1ttLmRhdGFUeXBlc1swXV0gPyBtLmFjY2VwdHNbbS5kYXRhVHlwZXNbMF1dICsgKFxcXCIqXFxcIiAhPT0gbS5kYXRhVHlwZXNbMF0gPyBcXFwiLCBcXFwiICsgdWIgKyBcXFwiOyBxPTAuMDFcXFwiIDogXFxcIlxcXCIpIDogbS5hY2NlcHRzW1xcXCIqXFxcIl0pO2ZvciAobCBpbiBtLmhlYWRlcnMpIHtcXG4gICAgICAgIHguc2V0UmVxdWVzdEhlYWRlcihsLCBtLmhlYWRlcnNbbF0pO1xcbiAgICAgIH1pZiAobS5iZWZvcmVTZW5kICYmIChtLmJlZm9yZVNlbmQuY2FsbChvLCB4LCBtKSA9PT0gITEgfHwgMiA9PT0gdikpIHJldHVybiB4LmFib3J0KCk7dyA9IFxcXCJhYm9ydFxcXCI7Zm9yIChsIGluIHsgc3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxIH0pIHtcXG4gICAgICAgIHhbbF0obVtsXSk7XFxuICAgICAgfWlmIChlID0geGIodGIsIG0sIGMsIHgpKSB7XFxuICAgICAgICBpZiAoeC5yZWFkeVN0YXRlID0gMSwgayAmJiBwLnRyaWdnZXIoXFxcImFqYXhTZW5kXFxcIiwgW3gsIG1dKSwgMiA9PT0gdikgcmV0dXJuIHg7bS5hc3luYyAmJiBtLnRpbWVvdXQgPiAwICYmIChpID0gYS5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgeC5hYm9ydChcXFwidGltZW91dFxcXCIpO1xcbiAgICAgICAgfSwgbS50aW1lb3V0KSk7dHJ5IHtcXG4gICAgICAgICAgdiA9IDEsIGUuc2VuZCh0LCB6KTtcXG4gICAgICAgIH0gY2F0Y2ggKHkpIHtcXG4gICAgICAgICAgaWYgKCEoMiA+IHYpKSB0aHJvdyB5O3ooLTEsIHkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB6KC0xLCBcXFwiTm8gVHJhbnNwb3J0XFxcIik7ZnVuY3Rpb24geihiLCBjLCBkLCBoKSB7XFxuICAgICAgICB2YXIgaixcXG4gICAgICAgICAgICBsLFxcbiAgICAgICAgICAgIHQsXFxuICAgICAgICAgICAgdSxcXG4gICAgICAgICAgICB3LFxcbiAgICAgICAgICAgIHkgPSBjOzIgIT09IHYgJiYgKHYgPSAyLCBpICYmIGEuY2xlYXJUaW1lb3V0KGkpLCBlID0gdm9pZCAwLCBnID0gaCB8fCBcXFwiXFxcIiwgeC5yZWFkeVN0YXRlID0gYiA+IDAgPyA0IDogMCwgaiA9IGIgPj0gMjAwICYmIDMwMCA+IGIgfHwgMzA0ID09PSBiLCBkICYmICh1ID0gemIobSwgeCwgZCkpLCB1ID0gQWIobSwgdSwgeCwgaiksIGogPyAobS5pZk1vZGlmaWVkICYmICh3ID0geC5nZXRSZXNwb25zZUhlYWRlcihcXFwiTGFzdC1Nb2RpZmllZFxcXCIpLCB3ICYmIChuLmxhc3RNb2RpZmllZFtmXSA9IHcpLCB3ID0geC5nZXRSZXNwb25zZUhlYWRlcihcXFwiZXRhZ1xcXCIpLCB3ICYmIChuLmV0YWdbZl0gPSB3KSksIDIwNCA9PT0gYiB8fCBcXFwiSEVBRFxcXCIgPT09IG0udHlwZSA/IHkgPSBcXFwibm9jb250ZW50XFxcIiA6IDMwNCA9PT0gYiA/IHkgPSBcXFwibm90bW9kaWZpZWRcXFwiIDogKHkgPSB1LnN0YXRlLCBsID0gdS5kYXRhLCB0ID0gdS5lcnJvciwgaiA9ICF0KSkgOiAodCA9IHksICFiICYmIHkgfHwgKHkgPSBcXFwiZXJyb3JcXFwiLCAwID4gYiAmJiAoYiA9IDApKSksIHguc3RhdHVzID0gYiwgeC5zdGF0dXNUZXh0ID0gKGMgfHwgeSkgKyBcXFwiXFxcIiwgaiA/IHEucmVzb2x2ZVdpdGgobywgW2wsIHksIHhdKSA6IHEucmVqZWN0V2l0aChvLCBbeCwgeSwgdF0pLCB4LnN0YXR1c0NvZGUocyksIHMgPSB2b2lkIDAsIGsgJiYgcC50cmlnZ2VyKGogPyBcXFwiYWpheFN1Y2Nlc3NcXFwiIDogXFxcImFqYXhFcnJvclxcXCIsIFt4LCBtLCBqID8gbCA6IHRdKSwgci5maXJlV2l0aChvLCBbeCwgeV0pLCBrICYmIChwLnRyaWdnZXIoXFxcImFqYXhDb21wbGV0ZVxcXCIsIFt4LCBtXSksIC0tbi5hY3RpdmUgfHwgbi5ldmVudC50cmlnZ2VyKFxcXCJhamF4U3RvcFxcXCIpKSk7XFxuICAgICAgfXJldHVybiB4O1xcbiAgICB9LCBnZXRKU09OOiBmdW5jdGlvbiBnZXRKU09OKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gbi5nZXQoYSwgYiwgYywgXFxcImpzb25cXFwiKTtcXG4gICAgfSwgZ2V0U2NyaXB0OiBmdW5jdGlvbiBnZXRTY3JpcHQoYSwgYikge1xcbiAgICAgIHJldHVybiBuLmdldChhLCB2b2lkIDAsIGIsIFxcXCJzY3JpcHRcXFwiKTtcXG4gICAgfSB9KSwgbi5lYWNoKFtcXFwiZ2V0XFxcIiwgXFxcInBvc3RcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbltiXSA9IGZ1bmN0aW9uIChhLCBjLCBkLCBlKSB7XFxuICAgICAgcmV0dXJuIG4uaXNGdW5jdGlvbihjKSAmJiAoZSA9IGUgfHwgZCwgZCA9IGMsIGMgPSB2b2lkIDApLCBuLmFqYXgobi5leHRlbmQoeyB1cmw6IGEsIHR5cGU6IGIsIGRhdGFUeXBlOiBlLCBkYXRhOiBjLCBzdWNjZXNzOiBkIH0sIG4uaXNQbGFpbk9iamVjdChhKSAmJiBhKSk7XFxuICAgIH07XFxuICB9KSwgbi5fZXZhbFVybCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiBuLmFqYXgoeyB1cmw6IGEsIHR5cGU6IFxcXCJHRVRcXFwiLCBkYXRhVHlwZTogXFxcInNjcmlwdFxcXCIsIGFzeW5jOiAhMSwgZ2xvYmFsOiAhMSwgXFxcInRocm93c1xcXCI6ICEwIH0pO1xcbiAgfSwgbi5mbi5leHRlbmQoeyB3cmFwQWxsOiBmdW5jdGlvbiB3cmFwQWxsKGEpIHtcXG4gICAgICB2YXIgYjtyZXR1cm4gbi5pc0Z1bmN0aW9uKGEpID8gdGhpcy5lYWNoKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICBuKHRoaXMpLndyYXBBbGwoYS5jYWxsKHRoaXMsIGIpKTtcXG4gICAgICB9KSA6ICh0aGlzWzBdICYmIChiID0gbihhLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKCEwKSwgdGhpc1swXS5wYXJlbnROb2RlICYmIGIuaW5zZXJ0QmVmb3JlKHRoaXNbMF0pLCBiLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXM7d2hpbGUgKGEuZmlyc3RFbGVtZW50Q2hpbGQpIHtcXG4gICAgICAgICAgYSA9IGEuZmlyc3RFbGVtZW50Q2hpbGQ7XFxuICAgICAgICB9cmV0dXJuIGE7XFxuICAgICAgfSkuYXBwZW5kKHRoaXMpKSwgdGhpcyk7XFxuICAgIH0sIHdyYXBJbm5lcjogZnVuY3Rpb24gd3JhcElubmVyKGEpIHtcXG4gICAgICByZXR1cm4gbi5pc0Z1bmN0aW9uKGEpID8gdGhpcy5lYWNoKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICBuKHRoaXMpLndyYXBJbm5lcihhLmNhbGwodGhpcywgYikpO1xcbiAgICAgIH0pIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiID0gbih0aGlzKSxcXG4gICAgICAgICAgICBjID0gYi5jb250ZW50cygpO2MubGVuZ3RoID8gYy53cmFwQWxsKGEpIDogYi5hcHBlbmQoYSk7XFxuICAgICAgfSk7XFxuICAgIH0sIHdyYXA6IGZ1bmN0aW9uIHdyYXAoYSkge1xcbiAgICAgIHZhciBiID0gbi5pc0Z1bmN0aW9uKGEpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgIG4odGhpcykud3JhcEFsbChiID8gYS5jYWxsKHRoaXMsIGMpIDogYSk7XFxuICAgICAgfSk7XFxuICAgIH0sIHVud3JhcDogZnVuY3Rpb24gdW53cmFwKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbi5ub2RlTmFtZSh0aGlzLCBcXFwiYm9keVxcXCIpIHx8IG4odGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKTtcXG4gICAgICB9KS5lbmQoKTtcXG4gICAgfSB9KSwgbi5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuICFuLmV4cHIuZmlsdGVycy52aXNpYmxlKGEpO1xcbiAgfSwgbi5leHByLmZpbHRlcnMudmlzaWJsZSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiBhLm9mZnNldFdpZHRoID4gMCB8fCBhLm9mZnNldEhlaWdodCA+IDAgfHwgYS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDA7XFxuICB9O3ZhciBCYiA9IC8lMjAvZyxcXG4gICAgICBDYiA9IC9cXFxcW1xcXFxdJC8sXFxuICAgICAgRGIgPSAvXFxcXHI/XFxcXG4vZyxcXG4gICAgICBFYiA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcXG4gICAgICBGYiA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtmdW5jdGlvbiBHYihhLCBiLCBjLCBkKSB7XFxuICAgIHZhciBlO2lmIChuLmlzQXJyYXkoYikpIG4uZWFjaChiLCBmdW5jdGlvbiAoYiwgZSkge1xcbiAgICAgIGMgfHwgQ2IudGVzdChhKSA/IGQoYSwgZSkgOiBHYihhICsgXFxcIltcXFwiICsgKFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgZSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoZSkpICYmIG51bGwgIT0gZSA/IGIgOiBcXFwiXFxcIikgKyBcXFwiXVxcXCIsIGUsIGMsIGQpO1xcbiAgICB9KTtlbHNlIGlmIChjIHx8IFxcXCJvYmplY3RcXFwiICE9PSBuLnR5cGUoYikpIGQoYSwgYik7ZWxzZSBmb3IgKGUgaW4gYikge1xcbiAgICAgIEdiKGEgKyBcXFwiW1xcXCIgKyBlICsgXFxcIl1cXFwiLCBiW2VdLCBjLCBkKTtcXG4gICAgfVxcbiAgfW4ucGFyYW0gPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyxcXG4gICAgICAgIGQgPSBbXSxcXG4gICAgICAgIGUgPSBmdW5jdGlvbiBlKGEsIGIpIHtcXG4gICAgICBiID0gbi5pc0Z1bmN0aW9uKGIpID8gYigpIDogbnVsbCA9PSBiID8gXFxcIlxcXCIgOiBiLCBkW2QubGVuZ3RoXSA9IGVuY29kZVVSSUNvbXBvbmVudChhKSArIFxcXCI9XFxcIiArIGVuY29kZVVSSUNvbXBvbmVudChiKTtcXG4gICAgfTtpZiAodm9pZCAwID09PSBiICYmIChiID0gbi5hamF4U2V0dGluZ3MgJiYgbi5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWwpLCBuLmlzQXJyYXkoYSkgfHwgYS5qcXVlcnkgJiYgIW4uaXNQbGFpbk9iamVjdChhKSkgbi5lYWNoKGEsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBlKHRoaXMubmFtZSwgdGhpcy52YWx1ZSk7XFxuICAgIH0pO2Vsc2UgZm9yIChjIGluIGEpIHtcXG4gICAgICBHYihjLCBhW2NdLCBiLCBlKTtcXG4gICAgfXJldHVybiBkLmpvaW4oXFxcIiZcXFwiKS5yZXBsYWNlKEJiLCBcXFwiK1xcXCIpO1xcbiAgfSwgbi5mbi5leHRlbmQoeyBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcXG4gICAgICByZXR1cm4gbi5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpO1xcbiAgICB9LCBzZXJpYWxpemVBcnJheTogZnVuY3Rpb24gc2VyaWFsaXplQXJyYXkoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBhID0gbi5wcm9wKHRoaXMsIFxcXCJlbGVtZW50c1xcXCIpO3JldHVybiBhID8gbi5tYWtlQXJyYXkoYSkgOiB0aGlzO1xcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMudHlwZTtyZXR1cm4gdGhpcy5uYW1lICYmICFuKHRoaXMpLmlzKFxcXCI6ZGlzYWJsZWRcXFwiKSAmJiBGYi50ZXN0KHRoaXMubm9kZU5hbWUpICYmICFFYi50ZXN0KGEpICYmICh0aGlzLmNoZWNrZWQgfHwgIVgudGVzdChhKSk7XFxuICAgICAgfSkubWFwKGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICB2YXIgYyA9IG4odGhpcykudmFsKCk7cmV0dXJuIG51bGwgPT0gYyA/IG51bGwgOiBuLmlzQXJyYXkoYykgPyBuLm1hcChjLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICByZXR1cm4geyBuYW1lOiBiLm5hbWUsIHZhbHVlOiBhLnJlcGxhY2UoRGIsIFxcXCJcXFxcclxcXFxuXFxcIikgfTtcXG4gICAgICAgIH0pIDogeyBuYW1lOiBiLm5hbWUsIHZhbHVlOiBjLnJlcGxhY2UoRGIsIFxcXCJcXFxcclxcXFxuXFxcIikgfTtcXG4gICAgICB9KS5nZXQoKTtcXG4gICAgfSB9KSwgbi5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24gKCkge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiBuZXcgYS5YTUxIdHRwUmVxdWVzdCgpO1xcbiAgICB9IGNhdGNoIChiKSB7fVxcbiAgfTt2YXIgSGIgPSB7IDA6IDIwMCwgMTIyMzogMjA0IH0sXFxuICAgICAgSWIgPSBuLmFqYXhTZXR0aW5ncy54aHIoKTtsLmNvcnMgPSAhIUliICYmIFxcXCJ3aXRoQ3JlZGVudGlhbHNcXFwiIGluIEliLCBsLmFqYXggPSBJYiA9ICEhSWIsIG4uYWpheFRyYW5zcG9ydChmdW5jdGlvbiAoYikge1xcbiAgICB2YXIgX2MsIGQ7cmV0dXJuIGwuY29ycyB8fCBJYiAmJiAhYi5jcm9zc0RvbWFpbiA/IHsgc2VuZDogZnVuY3Rpb24gc2VuZChlLCBmKSB7XFxuICAgICAgICB2YXIgZyxcXG4gICAgICAgICAgICBoID0gYi54aHIoKTtpZiAoaC5vcGVuKGIudHlwZSwgYi51cmwsIGIuYXN5bmMsIGIudXNlcm5hbWUsIGIucGFzc3dvcmQpLCBiLnhockZpZWxkcykgZm9yIChnIGluIGIueGhyRmllbGRzKSB7XFxuICAgICAgICAgIGhbZ10gPSBiLnhockZpZWxkc1tnXTtcXG4gICAgICAgIH1iLm1pbWVUeXBlICYmIGgub3ZlcnJpZGVNaW1lVHlwZSAmJiBoLm92ZXJyaWRlTWltZVR5cGUoYi5taW1lVHlwZSksIGIuY3Jvc3NEb21haW4gfHwgZVtcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCJdIHx8IChlW1xcXCJYLVJlcXVlc3RlZC1XaXRoXFxcIl0gPSBcXFwiWE1MSHR0cFJlcXVlc3RcXFwiKTtmb3IgKGcgaW4gZSkge1xcbiAgICAgICAgICBoLnNldFJlcXVlc3RIZWFkZXIoZywgZVtnXSk7XFxuICAgICAgICB9X2MgPSBmdW5jdGlvbiBjKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfYyAmJiAoX2MgPSBkID0gaC5vbmxvYWQgPSBoLm9uZXJyb3IgPSBoLm9uYWJvcnQgPSBoLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGwsIFxcXCJhYm9ydFxcXCIgPT09IGEgPyBoLmFib3J0KCkgOiBcXFwiZXJyb3JcXFwiID09PSBhID8gXFxcIm51bWJlclxcXCIgIT0gdHlwZW9mIGguc3RhdHVzID8gZigwLCBcXFwiZXJyb3JcXFwiKSA6IGYoaC5zdGF0dXMsIGguc3RhdHVzVGV4dCkgOiBmKEhiW2guc3RhdHVzXSB8fCBoLnN0YXR1cywgaC5zdGF0dXNUZXh0LCBcXFwidGV4dFxcXCIgIT09IChoLnJlc3BvbnNlVHlwZSB8fCBcXFwidGV4dFxcXCIpIHx8IFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBoLnJlc3BvbnNlVGV4dCA/IHsgYmluYXJ5OiBoLnJlc3BvbnNlIH0gOiB7IHRleHQ6IGgucmVzcG9uc2VUZXh0IH0sIGguZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sIGgub25sb2FkID0gX2MoKSwgZCA9IGgub25lcnJvciA9IF9jKFxcXCJlcnJvclxcXCIpLCB2b2lkIDAgIT09IGgub25hYm9ydCA/IGgub25hYm9ydCA9IGQgOiBoLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgNCA9PT0gaC5yZWFkeVN0YXRlICYmIGEuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX2MgJiYgZCgpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0sIF9jID0gX2MoXFxcImFib3J0XFxcIik7dHJ5IHtcXG4gICAgICAgICAgaC5zZW5kKGIuaGFzQ29udGVudCAmJiBiLmRhdGEgfHwgbnVsbCk7XFxuICAgICAgICB9IGNhdGNoIChpKSB7XFxuICAgICAgICAgIGlmIChfYykgdGhyb3cgaTtcXG4gICAgICAgIH1cXG4gICAgICB9LCBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XFxuICAgICAgICBfYyAmJiBfYygpO1xcbiAgICAgIH0gfSA6IHZvaWQgMDtcXG4gIH0pLCBuLmFqYXhTZXR1cCh7IGFjY2VwdHM6IHsgc2NyaXB0OiBcXFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcXFwiIH0sIGNvbnRlbnRzOiB7IHNjcmlwdDogL1xcXFxiKD86amF2YXxlY21hKXNjcmlwdFxcXFxiLyB9LCBjb252ZXJ0ZXJzOiB7IFxcXCJ0ZXh0IHNjcmlwdFxcXCI6IGZ1bmN0aW9uIHRleHRTY3JpcHQoYSkge1xcbiAgICAgICAgcmV0dXJuIG4uZ2xvYmFsRXZhbChhKSwgYTtcXG4gICAgICB9IH0gfSksIG4uYWpheFByZWZpbHRlcihcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24gKGEpIHtcXG4gICAgdm9pZCAwID09PSBhLmNhY2hlICYmIChhLmNhY2hlID0gITEpLCBhLmNyb3NzRG9tYWluICYmIChhLnR5cGUgPSBcXFwiR0VUXFxcIik7XFxuICB9KSwgbi5hamF4VHJhbnNwb3J0KFxcXCJzY3JpcHRcXFwiLCBmdW5jdGlvbiAoYSkge1xcbiAgICBpZiAoYS5jcm9zc0RvbWFpbikge1xcbiAgICAgIHZhciBiLCBfYzI7cmV0dXJuIHsgc2VuZDogZnVuY3Rpb24gc2VuZChlLCBmKSB7XFxuICAgICAgICAgIGIgPSBuKFxcXCI8c2NyaXB0PlxcXCIpLnByb3AoeyBjaGFyc2V0OiBhLnNjcmlwdENoYXJzZXQsIHNyYzogYS51cmwgfSkub24oXFxcImxvYWQgZXJyb3JcXFwiLCBfYzIgPSBmdW5jdGlvbiBjKGEpIHtcXG4gICAgICAgICAgICBiLnJlbW92ZSgpLCBfYzIgPSBudWxsLCBhICYmIGYoXFxcImVycm9yXFxcIiA9PT0gYS50eXBlID8gNDA0IDogMjAwLCBhLnR5cGUpO1xcbiAgICAgICAgICB9KSwgZC5oZWFkLmFwcGVuZENoaWxkKGJbMF0pO1xcbiAgICAgICAgfSwgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xcbiAgICAgICAgICBfYzIgJiYgX2MyKCk7XFxuICAgICAgICB9IH07XFxuICAgIH1cXG4gIH0pO3ZhciBKYiA9IFtdLFxcbiAgICAgIEtiID0gLyg9KVxcXFw/KD89JnwkKXxcXFxcP1xcXFw/LztuLmFqYXhTZXR1cCh7IGpzb25wOiBcXFwiY2FsbGJhY2tcXFwiLCBqc29ucENhbGxiYWNrOiBmdW5jdGlvbiBqc29ucENhbGxiYWNrKCkge1xcbiAgICAgIHZhciBhID0gSmIucG9wKCkgfHwgbi5leHBhbmRvICsgXFxcIl9cXFwiICsga2IrKztyZXR1cm4gdGhpc1thXSA9ICEwLCBhO1xcbiAgICB9IH0pLCBuLmFqYXhQcmVmaWx0ZXIoXFxcImpzb24ganNvbnBcXFwiLCBmdW5jdGlvbiAoYiwgYywgZCkge1xcbiAgICB2YXIgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCA9IGIuanNvbnAgIT09ICExICYmIChLYi50ZXN0KGIudXJsKSA/IFxcXCJ1cmxcXFwiIDogXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGIuZGF0YSAmJiAwID09PSAoYi5jb250ZW50VHlwZSB8fCBcXFwiXFxcIikuaW5kZXhPZihcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXFxcIikgJiYgS2IudGVzdChiLmRhdGEpICYmIFxcXCJkYXRhXFxcIik7cmV0dXJuIGggfHwgXFxcImpzb25wXFxcIiA9PT0gYi5kYXRhVHlwZXNbMF0gPyAoZSA9IGIuanNvbnBDYWxsYmFjayA9IG4uaXNGdW5jdGlvbihiLmpzb25wQ2FsbGJhY2spID8gYi5qc29ucENhbGxiYWNrKCkgOiBiLmpzb25wQ2FsbGJhY2ssIGggPyBiW2hdID0gYltoXS5yZXBsYWNlKEtiLCBcXFwiJDFcXFwiICsgZSkgOiBiLmpzb25wICE9PSAhMSAmJiAoYi51cmwgKz0gKGxiLnRlc3QoYi51cmwpID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiKSArIGIuanNvbnAgKyBcXFwiPVxcXCIgKyBlKSwgYi5jb252ZXJ0ZXJzW1xcXCJzY3JpcHQganNvblxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBnIHx8IG4uZXJyb3IoZSArIFxcXCIgd2FzIG5vdCBjYWxsZWRcXFwiKSwgZ1swXTtcXG4gICAgfSwgYi5kYXRhVHlwZXNbMF0gPSBcXFwianNvblxcXCIsIGYgPSBhW2VdLCBhW2VdID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIGcgPSBhcmd1bWVudHM7XFxuICAgIH0sIGQuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICB2b2lkIDAgPT09IGYgPyBuKGEpLnJlbW92ZVByb3AoZSkgOiBhW2VdID0gZiwgYltlXSAmJiAoYi5qc29ucENhbGxiYWNrID0gYy5qc29ucENhbGxiYWNrLCBKYi5wdXNoKGUpKSwgZyAmJiBuLmlzRnVuY3Rpb24oZikgJiYgZihnWzBdKSwgZyA9IGYgPSB2b2lkIDA7XFxuICAgIH0pLCBcXFwic2NyaXB0XFxcIikgOiB2b2lkIDA7XFxuICB9KSwgbi5wYXJzZUhUTUwgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBpZiAoIWEgfHwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEpIHJldHVybiBudWxsO1xcXCJib29sZWFuXFxcIiA9PSB0eXBlb2YgYiAmJiAoYyA9IGIsIGIgPSAhMSksIGIgPSBiIHx8IGQ7dmFyIGUgPSB4LmV4ZWMoYSksXFxuICAgICAgICBmID0gIWMgJiYgW107cmV0dXJuIGUgPyBbYi5jcmVhdGVFbGVtZW50KGVbMV0pXSA6IChlID0gY2EoW2FdLCBiLCBmKSwgZiAmJiBmLmxlbmd0aCAmJiBuKGYpLnJlbW92ZSgpLCBuLm1lcmdlKFtdLCBlLmNoaWxkTm9kZXMpKTtcXG4gIH07dmFyIExiID0gbi5mbi5sb2FkO24uZm4ubG9hZCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIGlmIChcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSAmJiBMYikgcmV0dXJuIExiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7dmFyIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSB0aGlzLFxcbiAgICAgICAgaCA9IGEuaW5kZXhPZihcXFwiIFxcXCIpO3JldHVybiBoID4gLTEgJiYgKGQgPSBuLnRyaW0oYS5zbGljZShoKSksIGEgPSBhLnNsaWNlKDAsIGgpKSwgbi5pc0Z1bmN0aW9uKGIpID8gKGMgPSBiLCBiID0gdm9pZCAwKSA6IGIgJiYgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBiID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihiKSkgJiYgKGUgPSBcXFwiUE9TVFxcXCIpLCBnLmxlbmd0aCA+IDAgJiYgbi5hamF4KHsgdXJsOiBhLCB0eXBlOiBlIHx8IFxcXCJHRVRcXFwiLCBkYXRhVHlwZTogXFxcImh0bWxcXFwiLCBkYXRhOiBiIH0pLmRvbmUoZnVuY3Rpb24gKGEpIHtcXG4gICAgICBmID0gYXJndW1lbnRzLCBnLmh0bWwoZCA/IG4oXFxcIjxkaXY+XFxcIikuYXBwZW5kKG4ucGFyc2VIVE1MKGEpKS5maW5kKGQpIDogYSk7XFxuICAgIH0pLmFsd2F5cyhjICYmIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgZy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGMuYXBwbHkodGhpcywgZiB8fCBbYS5yZXNwb25zZVRleHQsIGIsIGFdKTtcXG4gICAgICB9KTtcXG4gICAgfSksIHRoaXM7XFxuICB9LCBuLmVhY2goW1xcXCJhamF4U3RhcnRcXFwiLCBcXFwiYWpheFN0b3BcXFwiLCBcXFwiYWpheENvbXBsZXRlXFxcIiwgXFxcImFqYXhFcnJvclxcXCIsIFxcXCJhamF4U3VjY2Vzc1xcXCIsIFxcXCJhamF4U2VuZFxcXCJdLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2JdID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5vbihiLCBhKTtcXG4gICAgfTtcXG4gIH0pLCBuLmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiBuLmdyZXAobi50aW1lcnMsIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgcmV0dXJuIGEgPT09IGIuZWxlbTtcXG4gICAgfSkubGVuZ3RoO1xcbiAgfTtmdW5jdGlvbiBNYihhKSB7XFxuICAgIHJldHVybiBuLmlzV2luZG93KGEpID8gYSA6IDkgPT09IGEubm9kZVR5cGUgJiYgYS5kZWZhdWx0VmlldztcXG4gIH1uLm9mZnNldCA9IHsgc2V0T2Zmc2V0OiBmdW5jdGlvbiBzZXRPZmZzZXQoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrID0gbi5jc3MoYSwgXFxcInBvc2l0aW9uXFxcIiksXFxuICAgICAgICAgIGwgPSBuKGEpLFxcbiAgICAgICAgICBtID0ge307XFxcInN0YXRpY1xcXCIgPT09IGsgJiYgKGEuc3R5bGUucG9zaXRpb24gPSBcXFwicmVsYXRpdmVcXFwiKSwgaCA9IGwub2Zmc2V0KCksIGYgPSBuLmNzcyhhLCBcXFwidG9wXFxcIiksIGkgPSBuLmNzcyhhLCBcXFwibGVmdFxcXCIpLCBqID0gKFxcXCJhYnNvbHV0ZVxcXCIgPT09IGsgfHwgXFxcImZpeGVkXFxcIiA9PT0gaykgJiYgKGYgKyBpKS5pbmRleE9mKFxcXCJhdXRvXFxcIikgPiAtMSwgaiA/IChkID0gbC5wb3NpdGlvbigpLCBnID0gZC50b3AsIGUgPSBkLmxlZnQpIDogKGcgPSBwYXJzZUZsb2F0KGYpIHx8IDAsIGUgPSBwYXJzZUZsb2F0KGkpIHx8IDApLCBuLmlzRnVuY3Rpb24oYikgJiYgKGIgPSBiLmNhbGwoYSwgYywgbi5leHRlbmQoe30sIGgpKSksIG51bGwgIT0gYi50b3AgJiYgKG0udG9wID0gYi50b3AgLSBoLnRvcCArIGcpLCBudWxsICE9IGIubGVmdCAmJiAobS5sZWZ0ID0gYi5sZWZ0IC0gaC5sZWZ0ICsgZSksIFxcXCJ1c2luZ1xcXCIgaW4gYiA/IGIudXNpbmcuY2FsbChhLCBtKSA6IGwuY3NzKG0pO1xcbiAgICB9IH0sIG4uZm4uZXh0ZW5kKHsgb2Zmc2V0OiBmdW5jdGlvbiBvZmZzZXQoYSkge1xcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdm9pZCAwID09PSBhID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbi5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsIGEsIGIpO1xcbiAgICAgIH0pO3ZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkID0gdGhpc1swXSxcXG4gICAgICAgICAgZSA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXFxuICAgICAgICAgIGYgPSBkICYmIGQub3duZXJEb2N1bWVudDtpZiAoZikgcmV0dXJuIGIgPSBmLmRvY3VtZW50RWxlbWVudCwgbi5jb250YWlucyhiLCBkKSA/IChlID0gZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYyA9IE1iKGYpLCB7IHRvcDogZS50b3AgKyBjLnBhZ2VZT2Zmc2V0IC0gYi5jbGllbnRUb3AsIGxlZnQ6IGUubGVmdCArIGMucGFnZVhPZmZzZXQgLSBiLmNsaWVudExlZnQgfSkgOiBlO1xcbiAgICB9LCBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24oKSB7XFxuICAgICAgaWYgKHRoaXNbMF0pIHtcXG4gICAgICAgIHZhciBhLFxcbiAgICAgICAgICAgIGIsXFxuICAgICAgICAgICAgYyA9IHRoaXNbMF0sXFxuICAgICAgICAgICAgZCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07cmV0dXJuIFxcXCJmaXhlZFxcXCIgPT09IG4uY3NzKGMsIFxcXCJwb3NpdGlvblxcXCIpID8gYiA9IGMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiAoYSA9IHRoaXMub2Zmc2V0UGFyZW50KCksIGIgPSB0aGlzLm9mZnNldCgpLCBuLm5vZGVOYW1lKGFbMF0sIFxcXCJodG1sXFxcIikgfHwgKGQgPSBhLm9mZnNldCgpKSwgZC50b3AgKz0gbi5jc3MoYVswXSwgXFxcImJvcmRlclRvcFdpZHRoXFxcIiwgITApLCBkLmxlZnQgKz0gbi5jc3MoYVswXSwgXFxcImJvcmRlckxlZnRXaWR0aFxcXCIsICEwKSksIHsgdG9wOiBiLnRvcCAtIGQudG9wIC0gbi5jc3MoYywgXFxcIm1hcmdpblRvcFxcXCIsICEwKSwgbGVmdDogYi5sZWZ0IC0gZC5sZWZ0IC0gbi5jc3MoYywgXFxcIm1hcmdpbkxlZnRcXFwiLCAhMCkgfTtcXG4gICAgICB9XFxuICAgIH0sIG9mZnNldFBhcmVudDogZnVuY3Rpb24gb2Zmc2V0UGFyZW50KCkge1xcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMub2Zmc2V0UGFyZW50O3doaWxlIChhICYmIFxcXCJzdGF0aWNcXFwiID09PSBuLmNzcyhhLCBcXFwicG9zaXRpb25cXFwiKSkge1xcbiAgICAgICAgICBhID0gYS5vZmZzZXRQYXJlbnQ7XFxuICAgICAgICB9cmV0dXJuIGEgfHwgRWE7XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZWFjaCh7IHNjcm9sbExlZnQ6IFxcXCJwYWdlWE9mZnNldFxcXCIsIHNjcm9sbFRvcDogXFxcInBhZ2VZT2Zmc2V0XFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IFxcXCJwYWdlWU9mZnNldFxcXCIgPT09IGI7bi5mblthXSA9IGZ1bmN0aW9uIChkKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEsIGQsIGUpIHtcXG4gICAgICAgIHZhciBmID0gTWIoYSk7cmV0dXJuIHZvaWQgMCA9PT0gZSA/IGYgPyBmW2JdIDogYVtkXSA6IHZvaWQgKGYgPyBmLnNjcm9sbFRvKGMgPyBmLnBhZ2VYT2Zmc2V0IDogZSwgYyA/IGUgOiBmLnBhZ2VZT2Zmc2V0KSA6IGFbZF0gPSBlKTtcXG4gICAgICB9LCBhLCBkLCBhcmd1bWVudHMubGVuZ3RoKTtcXG4gICAgfTtcXG4gIH0pLCBuLmVhY2goW1xcXCJ0b3BcXFwiLCBcXFwibGVmdFxcXCJdLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmNzc0hvb2tzW2JdID0gR2EobC5waXhlbFBvc2l0aW9uLCBmdW5jdGlvbiAoYSwgYykge1xcbiAgICAgIHJldHVybiBjID8gKGMgPSBGYShhLCBiKSwgQmEudGVzdChjKSA/IG4oYSkucG9zaXRpb24oKVtiXSArIFxcXCJweFxcXCIgOiBjKSA6IHZvaWQgMDtcXG4gICAgfSk7XFxuICB9KSwgbi5lYWNoKHsgSGVpZ2h0OiBcXFwiaGVpZ2h0XFxcIiwgV2lkdGg6IFxcXCJ3aWR0aFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5lYWNoKHsgcGFkZGluZzogXFxcImlubmVyXFxcIiArIGEsIGNvbnRlbnQ6IGIsIFxcXCJcXFwiOiBcXFwib3V0ZXJcXFwiICsgYSB9LCBmdW5jdGlvbiAoYywgZCkge1xcbiAgICAgIG4uZm5bZF0gPSBmdW5jdGlvbiAoZCwgZSkge1xcbiAgICAgICAgdmFyIGYgPSBhcmd1bWVudHMubGVuZ3RoICYmIChjIHx8IFxcXCJib29sZWFuXFxcIiAhPSB0eXBlb2YgZCksXFxuICAgICAgICAgICAgZyA9IGMgfHwgKGQgPT09ICEwIHx8IGUgPT09ICEwID8gXFxcIm1hcmdpblxcXCIgOiBcXFwiYm9yZGVyXFxcIik7cmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGIsIGMsIGQpIHtcXG4gICAgICAgICAgdmFyIGU7cmV0dXJuIG4uaXNXaW5kb3coYikgPyBiLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcXFwiY2xpZW50XFxcIiArIGFdIDogOSA9PT0gYi5ub2RlVHlwZSA/IChlID0gYi5kb2N1bWVudEVsZW1lbnQsIE1hdGgubWF4KGIuYm9keVtcXFwic2Nyb2xsXFxcIiArIGFdLCBlW1xcXCJzY3JvbGxcXFwiICsgYV0sIGIuYm9keVtcXFwib2Zmc2V0XFxcIiArIGFdLCBlW1xcXCJvZmZzZXRcXFwiICsgYV0sIGVbXFxcImNsaWVudFxcXCIgKyBhXSkpIDogdm9pZCAwID09PSBkID8gbi5jc3MoYiwgYywgZykgOiBuLnN0eWxlKGIsIGMsIGQsIGcpO1xcbiAgICAgICAgfSwgYiwgZiA/IGQgOiB2b2lkIDAsIGYsIG51bGwpO1xcbiAgICAgIH07XFxuICAgIH0pO1xcbiAgfSksIG4uZm4uZXh0ZW5kKHsgYmluZDogZnVuY3Rpb24gYmluZChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub24oYSwgbnVsbCwgYiwgYyk7XFxuICAgIH0sIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGEsIGIpIHtcXG4gICAgICByZXR1cm4gdGhpcy5vZmYoYSwgbnVsbCwgYik7XFxuICAgIH0sIGRlbGVnYXRlOiBmdW5jdGlvbiBkZWxlZ2F0ZShhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub24oYiwgYSwgYywgZCk7XFxuICAgIH0sIHVuZGVsZWdhdGU6IGZ1bmN0aW9uIHVuZGVsZWdhdGUoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiAxID09PSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5vZmYoYSwgXFxcIioqXFxcIikgOiB0aGlzLm9mZihiLCBhIHx8IFxcXCIqKlxcXCIsIGMpO1xcbiAgICB9LCBzaXplOiBmdW5jdGlvbiBzaXplKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcXG4gICAgfSB9KSwgbi5mbi5hbmRTZWxmID0gbi5mbi5hZGRCYWNrLCBcXFwiZnVuY3Rpb25cXFwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCAmJiBkZWZpbmUoXFxcImpxdWVyeVxcXCIsIFtdLCBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBuO1xcbiAgfSk7dmFyIE5iID0gYS5qUXVlcnksXFxuICAgICAgT2IgPSBhLiQ7cmV0dXJuIG4ubm9Db25mbGljdCA9IGZ1bmN0aW9uIChiKSB7XFxuICAgIHJldHVybiBhLiQgPT09IG4gJiYgKGEuJCA9IE9iKSwgYiAmJiBhLmpRdWVyeSA9PT0gbiAmJiAoYS5qUXVlcnkgPSBOYiksIG47XFxuICB9LCBiIHx8IChhLmpRdWVyeSA9IGEuJCA9IG4pLCBuO1xcbn0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2JhYmVsLWxvYWRlci9saWI/e1wicHJlc2V0c1wiOltcInJlYWN0XCIsXCJlczIwMTVcIl19IS4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXFBhcmFnb25cXFxcRGVza3RvcFxcXFxwcm9qZWN0c1xcXFxyZWFjdFxcXFxSZWFjdFRpbWVyXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxQYXJhZ29uXFxcXERlc2t0b3BcXFxccHJvamVjdHNcXFxccmVhY3RcXFxcUmVhY3RUaW1lclxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxQYXJhZ29uXFxcXERlc2t0b3BcXFxccHJvamVjdHNcXFxccmVhY3RcXFxcUmVhY3RUaW1lclxcXFxub2RlX21vZHVsZXNcXFxcYmFiZWwtbG9hZGVyXFxcXGxpYlxcXFxpbmRleC5qcz97XFxcInByZXNldHNcXFwiOltcXFwicmVhY3RcXFwiLFxcXCJlczIwMTVcXFwiXX0hQzpcXFxcVXNlcnNcXFxcUGFyYWdvblxcXFxEZXNrdG9wXFxcXHByb2plY3RzXFxcXHJlYWN0XFxcXFJlYWN0VGltZXJcXFxcbm9kZV9tb2R1bGVzXFxcXGZvdW5kYXRpb24tc2l0ZXNcXFxcZGlzdFxcXFxmb3VuZGF0aW9uLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJcXFwidXNlIHN0cmljdFxcXCI7dmFyIF90eXBlb2Y9dHlwZW9mIFN5bWJvbD09PVxcXCJmdW5jdGlvblxcXCImJnR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PT1cXFwic3ltYm9sXFxcIj9mdW5jdGlvbihvYmope3JldHVybiB0eXBlb2Ygb2JqO306ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqJiZ0eXBlb2YgU3ltYm9sPT09XFxcImZ1bmN0aW9uXFxcIiYmb2JqLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZvYmohPT1TeW1ib2wucHJvdG90eXBlP1xcXCJzeW1ib2xcXFwiOnR5cGVvZiBvYmo7fTtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9IWZ1bmN0aW9uKHQpe1xcXCJ1c2Ugc3RyaWN0XFxcIjtmdW5jdGlvbiBlKHQpe2lmKHZvaWQgMD09PUZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lKXt2YXIgZT0vZnVuY3Rpb25cXFxccyhbXihdezEsfSlcXFxcKC8saT1lLmV4ZWModC50b1N0cmluZygpKTtyZXR1cm4gaSYmaS5sZW5ndGg+MT9pWzFdLnRyaW0oKTpcXFwiXFxcIjt9cmV0dXJuIHZvaWQgMD09PXQucHJvdG90eXBlP3QuY29uc3RydWN0b3IubmFtZTp0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO31mdW5jdGlvbiBpKHQpe3JldHVybiEhL3RydWUvLnRlc3QodCl8fCEvZmFsc2UvLnRlc3QodCkmJihpc05hTigxKnQpP3Q6cGFyc2VGbG9hdCh0KSk7fWZ1bmN0aW9uIG4odCl7cmV0dXJuIHQucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZyxcXFwiJDEtJDJcXFwiKS50b0xvd2VyQ2FzZSgpO312YXIgcz1cXFwiNi4yLjRcXFwiLG89e3ZlcnNpb246cyxfcGx1Z2luczp7fSxfdXVpZHM6W10scnRsOmZ1bmN0aW9uIHJ0bCgpe3JldHVyblxcXCJydGxcXFwiPT09dChcXFwiaHRtbFxcXCIpLmF0dHIoXFxcImRpclxcXCIpO30scGx1Z2luOmZ1bmN0aW9uIHBsdWdpbih0LGkpe3ZhciBzPWl8fGUodCksbz1uKHMpO3RoaXMuX3BsdWdpbnNbb109dGhpc1tzXT10O30scmVnaXN0ZXJQbHVnaW46ZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4odCxpKXt2YXIgcz1pP24oaSk6ZSh0LmNvbnN0cnVjdG9yKS50b0xvd2VyQ2FzZSgpO3QudXVpZD10aGlzLkdldFlvRGlnaXRzKDYscyksdC4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLVxcXCIrcyl8fHQuJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1cXFwiK3MsdC51dWlkKSx0LiRlbGVtZW50LmRhdGEoXFxcInpmUGx1Z2luXFxcIil8fHQuJGVsZW1lbnQuZGF0YShcXFwiemZQbHVnaW5cXFwiLHQpLHQuJGVsZW1lbnQudHJpZ2dlcihcXFwiaW5pdC56Zi5cXFwiK3MpLHRoaXMuX3V1aWRzLnB1c2godC51dWlkKTt9LHVucmVnaXN0ZXJQbHVnaW46ZnVuY3Rpb24gdW5yZWdpc3RlclBsdWdpbih0KXt2YXIgaT1uKGUodC4kZWxlbWVudC5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIpLmNvbnN0cnVjdG9yKSk7dGhpcy5fdXVpZHMuc3BsaWNlKHRoaXMuX3V1aWRzLmluZGV4T2YodC51dWlkKSwxKSx0LiRlbGVtZW50LnJlbW92ZUF0dHIoXFxcImRhdGEtXFxcIitpKS5yZW1vdmVEYXRhKFxcXCJ6ZlBsdWdpblxcXCIpLnRyaWdnZXIoXFxcImRlc3Ryb3llZC56Zi5cXFwiK2kpO2Zvcih2YXIgcyBpbiB0KXt0W3NdPW51bGw7fX0scmVJbml0OmZ1bmN0aW9uIHJlSW5pdChlKXt2YXIgaT1lIGluc3RhbmNlb2YgdDt0cnl7aWYoaSllLmVhY2goZnVuY3Rpb24oKXt0KHRoaXMpLmRhdGEoXFxcInpmUGx1Z2luXFxcIikuX2luaXQoKTt9KTtlbHNle3ZhciBzPXR5cGVvZiBlPT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZihlKSxvPXRoaXMsYT17b2JqZWN0OmZ1bmN0aW9uIG9iamVjdChlKXtlLmZvckVhY2goZnVuY3Rpb24oZSl7ZT1uKGUpLHQoXFxcIltkYXRhLVxcXCIrZStcXFwiXVxcXCIpLmZvdW5kYXRpb24oXFxcIl9pbml0XFxcIik7fSk7fSxzdHJpbmc6ZnVuY3Rpb24gc3RyaW5nKCl7ZT1uKGUpLHQoXFxcIltkYXRhLVxcXCIrZStcXFwiXVxcXCIpLmZvdW5kYXRpb24oXFxcIl9pbml0XFxcIik7fSx1bmRlZmluZWQ6ZnVuY3Rpb24gdW5kZWZpbmVkKCl7dGhpcy5vYmplY3QoT2JqZWN0LmtleXMoby5fcGx1Z2lucykpO319O2Fbc10oZSk7fX1jYXRjaChyKXtjb25zb2xlLmVycm9yKHIpO31maW5hbGx5e3JldHVybiBlO319LEdldFlvRGlnaXRzOmZ1bmN0aW9uIEdldFlvRGlnaXRzKHQsZSl7cmV0dXJuIHQ9dHx8NixNYXRoLnJvdW5kKE1hdGgucG93KDM2LHQrMSktTWF0aC5yYW5kb20oKSpNYXRoLnBvdygzNix0KSkudG9TdHJpbmcoMzYpLnNsaWNlKDEpKyhlP1xcXCItXFxcIitlOlxcXCJcXFwiKTt9LHJlZmxvdzpmdW5jdGlvbiByZWZsb3coZSxuKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIG4/bj1PYmplY3Qua2V5cyh0aGlzLl9wbHVnaW5zKTpcXFwic3RyaW5nXFxcIj09dHlwZW9mIG4mJihuPVtuXSk7dmFyIHM9dGhpczt0LmVhY2gobixmdW5jdGlvbihuLG8pe3ZhciBhPXMuX3BsdWdpbnNbb10scj10KGUpLmZpbmQoXFxcIltkYXRhLVxcXCIrbytcXFwiXVxcXCIpLmFkZEJhY2soXFxcIltkYXRhLVxcXCIrbytcXFwiXVxcXCIpO3IuZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyksbj17fTtpZihlLmRhdGEoXFxcInpmUGx1Z2luXFxcIikpcmV0dXJuIHZvaWQgY29uc29sZS53YXJuKFxcXCJUcmllZCB0byBpbml0aWFsaXplIFxcXCIrbytcXFwiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlxcXCIpO2lmKGUuYXR0cihcXFwiZGF0YS1vcHRpb25zXFxcIikpe2UuYXR0cihcXFwiZGF0YS1vcHRpb25zXFxcIikuc3BsaXQoXFxcIjtcXFwiKS5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7dmFyIHM9dC5zcGxpdChcXFwiOlxcXCIpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmltKCk7fSk7c1swXSYmKG5bc1swXV09aShzWzFdKSk7fSk7fXRyeXtlLmRhdGEoXFxcInpmUGx1Z2luXFxcIixuZXcgYSh0KHRoaXMpLG4pKTt9Y2F0Y2gocyl7Y29uc29sZS5lcnJvcihzKTt9ZmluYWxseXtyZXR1cm47fX0pO30pO30sZ2V0Rm5OYW1lOmUsdHJhbnNpdGlvbmVuZDpmdW5jdGlvbiB0cmFuc2l0aW9uZW5kKHQpe3ZhciBlLGk9e3RyYW5zaXRpb246XFxcInRyYW5zaXRpb25lbmRcXFwiLFdlYmtpdFRyYW5zaXRpb246XFxcIndlYmtpdFRyYW5zaXRpb25FbmRcXFwiLE1velRyYW5zaXRpb246XFxcInRyYW5zaXRpb25lbmRcXFwiLE9UcmFuc2l0aW9uOlxcXCJvdHJhbnNpdGlvbmVuZFxcXCJ9LG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7Zm9yKHZhciBzIGluIGkpe1xcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygbi5zdHlsZVtzXSYmKGU9aVtzXSk7fXJldHVybiBlP2U6KGU9c2V0VGltZW91dChmdW5jdGlvbigpe3QudHJpZ2dlckhhbmRsZXIoXFxcInRyYW5zaXRpb25lbmRcXFwiLFt0XSk7fSwxKSxcXFwidHJhbnNpdGlvbmVuZFxcXCIpO319O28udXRpbD17dGhyb3R0bGU6ZnVuY3Rpb24gdGhyb3R0bGUodCxlKXt2YXIgaT1udWxsO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXMscz1hcmd1bWVudHM7bnVsbD09PWkmJihpPXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0LmFwcGx5KG4scyksaT1udWxsO30sZSkpO307fX07dmFyIGE9ZnVuY3Rpb24gYShpKXt2YXIgbj10eXBlb2YgaT09PVxcXCJ1bmRlZmluZWRcXFwiP1xcXCJ1bmRlZmluZWRcXFwiOl90eXBlb2YoaSkscz10KFxcXCJtZXRhLmZvdW5kYXRpb24tbXFcXFwiKSxhPXQoXFxcIi5uby1qc1xcXCIpO2lmKHMubGVuZ3RofHx0KCc8bWV0YSBjbGFzcz1cXFwiZm91bmRhdGlvbi1tcVxcXCI+JykuYXBwZW5kVG8oZG9jdW1lbnQuaGVhZCksYS5sZW5ndGgmJmEucmVtb3ZlQ2xhc3MoXFxcIm5vLWpzXFxcIiksXFxcInVuZGVmaW5lZFxcXCI9PT1uKW8uTWVkaWFRdWVyeS5faW5pdCgpLG8ucmVmbG93KHRoaXMpO2Vsc2V7aWYoXFxcInN0cmluZ1xcXCIhPT1uKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIldlJ3JlIHNvcnJ5LCBcXFwiK24rXFxcIiBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIuIFlvdSBtdXN0IHVzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG1ldGhvZCB5b3Ugd2lzaCB0byBpbnZva2UuXFxcIik7dmFyIHI9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGw9dGhpcy5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIpO2lmKHZvaWQgMD09PWx8fHZvaWQgMD09PWxbaV0pdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJXZSdyZSBzb3JyeSwgJ1xcXCIraStcXFwiJyBpcyBub3QgYW4gYXZhaWxhYmxlIG1ldGhvZCBmb3IgXFxcIisobD9lKGwpOlxcXCJ0aGlzIGVsZW1lbnRcXFwiKStcXFwiLlxcXCIpOzE9PT10aGlzLmxlbmd0aD9sW2ldLmFwcGx5KGwscik6dGhpcy5lYWNoKGZ1bmN0aW9uKGUsbil7bFtpXS5hcHBseSh0KG4pLmRhdGEoXFxcInpmUGx1Z2luXFxcIikscik7fSk7fXJldHVybiB0aGlzO307d2luZG93LkZvdW5kYXRpb249byx0LmZuLmZvdW5kYXRpb249YSxmdW5jdGlvbigpe0RhdGUubm93JiZ3aW5kb3cuRGF0ZS5ub3d8fCh3aW5kb3cuRGF0ZS5ub3c9RGF0ZS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7fSk7Zm9yKHZhciB0PVtcXFwid2Via2l0XFxcIixcXFwibW96XFxcIl0sZT0wO2U8dC5sZW5ndGgmJiF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOysrZSl7dmFyIGk9dFtlXTt3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lPXdpbmRvd1tpK1xcXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcXFwiXSx3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU9d2luZG93W2krXFxcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXFxcIl18fHdpbmRvd1tpK1xcXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcXFwiXTt9aWYoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KXx8IXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpe3ZhciBuPTA7d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT1mdW5jdGlvbih0KXt2YXIgZT1EYXRlLm5vdygpLGk9TWF0aC5tYXgobisxNixlKTtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe3Qobj1pKTt9LGktZSk7fSx3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU9Y2xlYXJUaW1lb3V0O313aW5kb3cucGVyZm9ybWFuY2UmJndpbmRvdy5wZXJmb3JtYW5jZS5ub3d8fCh3aW5kb3cucGVyZm9ybWFuY2U9e3N0YXJ0OkRhdGUubm93KCksbm93OmZ1bmN0aW9uIG5vdygpe3JldHVybiBEYXRlLm5vdygpLXRoaXMuc3RhcnQ7fX0pO30oKSxGdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKHQpe2lmKFxcXCJmdW5jdGlvblxcXCIhPXR5cGVvZiB0aGlzKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIC0gd2hhdCBpcyB0cnlpbmcgdG8gYmUgYm91bmQgaXMgbm90IGNhbGxhYmxlXFxcIik7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGk9dGhpcyxuPWZ1bmN0aW9uIG4oKXt9LHM9ZnVuY3Rpb24gcygpe3JldHVybiBpLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBuP3RoaXM6dCxlLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7fTtyZXR1cm4gdGhpcy5wcm90b3R5cGUmJihuLnByb3RvdHlwZT10aGlzLnByb3RvdHlwZSkscy5wcm90b3R5cGU9bmV3IG4oKSxzO30pO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUsbixzKXt2YXIgbyxhLHIsbCx1PWkodCk7aWYoZSl7dmFyIGQ9aShlKTthPXUub2Zmc2V0LnRvcCt1LmhlaWdodDw9ZC5oZWlnaHQrZC5vZmZzZXQudG9wLG89dS5vZmZzZXQudG9wPj1kLm9mZnNldC50b3Ascj11Lm9mZnNldC5sZWZ0Pj1kLm9mZnNldC5sZWZ0LGw9dS5vZmZzZXQubGVmdCt1LndpZHRoPD1kLndpZHRoK2Qub2Zmc2V0LmxlZnQ7fWVsc2UgYT11Lm9mZnNldC50b3ArdS5oZWlnaHQ8PXUud2luZG93RGltcy5oZWlnaHQrdS53aW5kb3dEaW1zLm9mZnNldC50b3Asbz11Lm9mZnNldC50b3A+PXUud2luZG93RGltcy5vZmZzZXQudG9wLHI9dS5vZmZzZXQubGVmdD49dS53aW5kb3dEaW1zLm9mZnNldC5sZWZ0LGw9dS5vZmZzZXQubGVmdCt1LndpZHRoPD11LndpbmRvd0RpbXMud2lkdGg7dmFyIGg9W2EsbyxyLGxdO3JldHVybiBuP3I9PT1sPT0hMDpzP289PT1hPT0hMDpoLmluZGV4T2YoITEpPT09LTE7fWZ1bmN0aW9uIGkodCxlKXtpZih0PXQubGVuZ3RoP3RbMF06dCx0PT09d2luZG93fHx0PT09ZG9jdW1lbnQpdGhyb3cgbmV3IEVycm9yKFxcXCJJJ20gc29ycnksIERhdmUuIEknbSBhZnJhaWQgSSBjYW4ndCBkbyB0aGF0LlxcXCIpO3ZhciBpPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbj10LnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkscz1kb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLG89d2luZG93LnBhZ2VZT2Zmc2V0LGE9d2luZG93LnBhZ2VYT2Zmc2V0O3JldHVybnt3aWR0aDppLndpZHRoLGhlaWdodDppLmhlaWdodCxvZmZzZXQ6e3RvcDppLnRvcCtvLGxlZnQ6aS5sZWZ0K2F9LHBhcmVudERpbXM6e3dpZHRoOm4ud2lkdGgsaGVpZ2h0Om4uaGVpZ2h0LG9mZnNldDp7dG9wOm4udG9wK28sbGVmdDpuLmxlZnQrYX19LHdpbmRvd0RpbXM6e3dpZHRoOnMud2lkdGgsaGVpZ2h0OnMuaGVpZ2h0LG9mZnNldDp7dG9wOm8sbGVmdDphfX19O31mdW5jdGlvbiBuKHQsZSxuLHMsbyxhKXt2YXIgcj1pKHQpLGw9ZT9pKGUpOm51bGw7c3dpdGNoKG4pe2Nhc2VcXFwidG9wXFxcIjpyZXR1cm57bGVmdDpGb3VuZGF0aW9uLnJ0bCgpP2wub2Zmc2V0LmxlZnQtci53aWR0aCtsLndpZHRoOmwub2Zmc2V0LmxlZnQsdG9wOmwub2Zmc2V0LnRvcC0oci5oZWlnaHQrcyl9O2Nhc2VcXFwibGVmdFxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdC0oci53aWR0aCtvKSx0b3A6bC5vZmZzZXQudG9wfTtjYXNlXFxcInJpZ2h0XFxcIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0K2wud2lkdGgrbyx0b3A6bC5vZmZzZXQudG9wfTtjYXNlXFxcImNlbnRlciB0b3BcXFwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQrbC53aWR0aC8yLXIud2lkdGgvMix0b3A6bC5vZmZzZXQudG9wLShyLmhlaWdodCtzKX07Y2FzZVxcXCJjZW50ZXIgYm90dG9tXFxcIjpyZXR1cm57bGVmdDphP286bC5vZmZzZXQubGVmdCtsLndpZHRoLzItci53aWR0aC8yLHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHQrc307Y2FzZVxcXCJjZW50ZXIgbGVmdFxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdC0oci53aWR0aCtvKSx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0LzItci5oZWlnaHQvMn07Y2FzZVxcXCJjZW50ZXIgcmlnaHRcXFwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQrbC53aWR0aCtvKzEsdG9wOmwub2Zmc2V0LnRvcCtsLmhlaWdodC8yLXIuaGVpZ2h0LzJ9O2Nhc2VcXFwiY2VudGVyXFxcIjpyZXR1cm57bGVmdDpyLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQrci53aW5kb3dEaW1zLndpZHRoLzItci53aWR0aC8yLHRvcDpyLndpbmRvd0RpbXMub2Zmc2V0LnRvcCtyLndpbmRvd0RpbXMuaGVpZ2h0LzItci5oZWlnaHQvMn07Y2FzZVxcXCJyZXZlYWxcXFwiOnJldHVybntsZWZ0OihyLndpbmRvd0RpbXMud2lkdGgtci53aWR0aCkvMix0b3A6ci53aW5kb3dEaW1zLm9mZnNldC50b3Arc307Y2FzZVxcXCJyZXZlYWwgZnVsbFxcXCI6cmV0dXJue2xlZnQ6ci53aW5kb3dEaW1zLm9mZnNldC5sZWZ0LHRvcDpyLndpbmRvd0RpbXMub2Zmc2V0LnRvcH07Y2FzZVxcXCJsZWZ0IGJvdHRvbVxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdCx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0fTtjYXNlXFxcInJpZ2h0IGJvdHRvbVxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdCtsLndpZHRoK28tci53aWR0aCx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0fTtkZWZhdWx0OnJldHVybntsZWZ0OkZvdW5kYXRpb24ucnRsKCk/bC5vZmZzZXQubGVmdC1yLndpZHRoK2wud2lkdGg6bC5vZmZzZXQubGVmdCtvLHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHQrc307fX1Gb3VuZGF0aW9uLkJveD17SW1Ob3RUb3VjaGluZ1lvdTplLEdldERpbWVuc2lvbnM6aSxHZXRPZmZzZXRzOm59O30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXt2YXIgZT17fTtmb3IodmFyIGkgaW4gdCl7ZVt0W2ldXT10W2ldO31yZXR1cm4gZTt9dmFyIGk9ezk6XFxcIlRBQlxcXCIsMTM6XFxcIkVOVEVSXFxcIiwyNzpcXFwiRVNDQVBFXFxcIiwzMjpcXFwiU1BBQ0VcXFwiLDM3OlxcXCJBUlJPV19MRUZUXFxcIiwzODpcXFwiQVJST1dfVVBcXFwiLDM5OlxcXCJBUlJPV19SSUdIVFxcXCIsNDA6XFxcIkFSUk9XX0RPV05cXFwifSxuPXt9LHM9e2tleXM6ZShpKSxwYXJzZUtleTpmdW5jdGlvbiBwYXJzZUtleSh0KXt2YXIgZT1pW3Qud2hpY2h8fHQua2V5Q29kZV18fFN0cmluZy5mcm9tQ2hhckNvZGUodC53aGljaCkudG9VcHBlckNhc2UoKTtyZXR1cm4gdC5zaGlmdEtleSYmKGU9XFxcIlNISUZUX1xcXCIrZSksdC5jdHJsS2V5JiYoZT1cXFwiQ1RSTF9cXFwiK2UpLHQuYWx0S2V5JiYoZT1cXFwiQUxUX1xcXCIrZSksZTt9LGhhbmRsZUtleTpmdW5jdGlvbiBoYW5kbGVLZXkoZSxpLHMpe3ZhciBvLGEscixsPW5baV0sdT10aGlzLnBhcnNlS2V5KGUpO2lmKCFsKXJldHVybiBjb25zb2xlLndhcm4oXFxcIkNvbXBvbmVudCBub3QgZGVmaW5lZCFcXFwiKTtpZihvPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgbC5sdHI/bDpGb3VuZGF0aW9uLnJ0bCgpP3QuZXh0ZW5kKHt9LGwubHRyLGwucnRsKTp0LmV4dGVuZCh7fSxsLnJ0bCxsLmx0ciksYT1vW3VdLHI9c1thXSxyJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygcil7dmFyIGQ9ci5hcHBseSgpOyhzLmhhbmRsZWR8fFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBzLmhhbmRsZWQpJiZzLmhhbmRsZWQoZCk7fWVsc2Uocy51bmhhbmRsZWR8fFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBzLnVuaGFuZGxlZCkmJnMudW5oYW5kbGVkKCk7fSxmaW5kRm9jdXNhYmxlOmZ1bmN0aW9uIGZpbmRGb2N1c2FibGUoZSl7cmV0dXJuIGUuZmluZChcXFwiYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgKlt0YWJpbmRleF0sICpbY29udGVudGVkaXRhYmxlXVxcXCIpLmZpbHRlcihmdW5jdGlvbigpe3JldHVybiEoIXQodGhpcykuaXMoXFxcIjp2aXNpYmxlXFxcIil8fHQodGhpcykuYXR0cihcXFwidGFiaW5kZXhcXFwiKTwwKTt9KTt9LHJlZ2lzdGVyOmZ1bmN0aW9uIHJlZ2lzdGVyKHQsZSl7blt0XT1lO319O0ZvdW5kYXRpb24uS2V5Ym9hcmQ9czt9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7dmFyIGU9e307cmV0dXJuXFxcInN0cmluZ1xcXCIhPXR5cGVvZiB0P2U6KHQ9dC50cmltKCkuc2xpY2UoMSwtMSkpP2U9dC5zcGxpdChcXFwiJlxcXCIpLnJlZHVjZShmdW5jdGlvbih0LGUpe3ZhciBpPWUucmVwbGFjZSgvXFxcXCsvZyxcXFwiIFxcXCIpLnNwbGl0KFxcXCI9XFxcIiksbj1pWzBdLHM9aVsxXTtyZXR1cm4gbj1kZWNvZGVVUklDb21wb25lbnQobikscz12b2lkIDA9PT1zP251bGw6ZGVjb2RlVVJJQ29tcG9uZW50KHMpLHQuaGFzT3duUHJvcGVydHkobik/QXJyYXkuaXNBcnJheSh0W25dKT90W25dLnB1c2gocyk6dFtuXT1bdFtuXSxzXTp0W25dPXMsdDt9LHt9KTplO312YXIgaT17cXVlcmllczpbXSxjdXJyZW50OlxcXCJcXFwiLF9pbml0OmZ1bmN0aW9uIF9pbml0KCl7dmFyIGksbj10aGlzLHM9dChcXFwiLmZvdW5kYXRpb24tbXFcXFwiKS5jc3MoXFxcImZvbnQtZmFtaWx5XFxcIik7aT1lKHMpO2Zvcih2YXIgbyBpbiBpKXtpLmhhc093blByb3BlcnR5KG8pJiZuLnF1ZXJpZXMucHVzaCh7bmFtZTpvLHZhbHVlOlxcXCJvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogXFxcIitpW29dK1xcXCIpXFxcIn0pO310aGlzLmN1cnJlbnQ9dGhpcy5fZ2V0Q3VycmVudFNpemUoKSx0aGlzLl93YXRjaGVyKCk7fSxhdExlYXN0OmZ1bmN0aW9uIGF0TGVhc3QodCl7dmFyIGU9dGhpcy5nZXQodCk7cmV0dXJuISFlJiZ3aW5kb3cubWF0Y2hNZWRpYShlKS5tYXRjaGVzO30sZ2V0OmZ1bmN0aW9uIGdldCh0KXtmb3IodmFyIGUgaW4gdGhpcy5xdWVyaWVzKXtpZih0aGlzLnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoZSkpe3ZhciBpPXRoaXMucXVlcmllc1tlXTtpZih0PT09aS5uYW1lKXJldHVybiBpLnZhbHVlO319cmV0dXJuIG51bGw7fSxfZ2V0Q3VycmVudFNpemU6ZnVuY3Rpb24gX2dldEN1cnJlbnRTaXplKCl7Zm9yKHZhciB0LGU9MDtlPHRoaXMucXVlcmllcy5sZW5ndGg7ZSsrKXt2YXIgaT10aGlzLnF1ZXJpZXNbZV07d2luZG93Lm1hdGNoTWVkaWEoaS52YWx1ZSkubWF0Y2hlcyYmKHQ9aSk7fXJldHVyblxcXCJvYmplY3RcXFwiPT0odHlwZW9mIHQ9PT1cXFwidW5kZWZpbmVkXFxcIj9cXFwidW5kZWZpbmVkXFxcIjpfdHlwZW9mKHQpKT90Lm5hbWU6dDt9LF93YXRjaGVyOmZ1bmN0aW9uIF93YXRjaGVyKCl7dmFyIGU9dGhpczt0KHdpbmRvdykub24oXFxcInJlc2l6ZS56Zi5tZWRpYXF1ZXJ5XFxcIixmdW5jdGlvbigpe3ZhciBpPWUuX2dldEN1cnJlbnRTaXplKCksbj1lLmN1cnJlbnQ7aSE9PW4mJihlLmN1cnJlbnQ9aSx0KHdpbmRvdykudHJpZ2dlcihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIixbaSxuXSkpO30pO319O0ZvdW5kYXRpb24uTWVkaWFRdWVyeT1pLHdpbmRvdy5tYXRjaE1lZGlhfHwod2luZG93Lm1hdGNoTWVkaWE9ZnVuY3Rpb24oKXtcXFwidXNlIHN0cmljdFxcXCI7dmFyIHQ9d2luZG93LnN0eWxlTWVkaWF8fHdpbmRvdy5tZWRpYTtpZighdCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic3R5bGVcXFwiKSxpPWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJzY3JpcHRcXFwiKVswXSxuPW51bGw7ZS50eXBlPVxcXCJ0ZXh0L2Nzc1xcXCIsZS5pZD1cXFwibWF0Y2htZWRpYWpzLXRlc3RcXFwiLGkmJmkucGFyZW50Tm9kZSYmaS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLGkpLG49XFxcImdldENvbXB1dGVkU3R5bGVcXFwiaW4gd2luZG93JiZ3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLG51bGwpfHxlLmN1cnJlbnRTdHlsZSx0PXttYXRjaE1lZGl1bTpmdW5jdGlvbiBtYXRjaE1lZGl1bSh0KXt2YXIgaT1cXFwiQG1lZGlhIFxcXCIrdCtcXFwieyAjbWF0Y2htZWRpYWpzLXRlc3QgeyB3aWR0aDogMXB4OyB9IH1cXFwiO3JldHVybiBlLnN0eWxlU2hlZXQ/ZS5zdHlsZVNoZWV0LmNzc1RleHQ9aTplLnRleHRDb250ZW50PWksXFxcIjFweFxcXCI9PT1uLndpZHRoO319O31yZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJue21hdGNoZXM6dC5tYXRjaE1lZGl1bShlfHxcXFwiYWxsXFxcIiksbWVkaWE6ZXx8XFxcImFsbFxcXCJ9O307fSgpKSxGb3VuZGF0aW9uLk1lZGlhUXVlcnk9aTt9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlLGkpe2Z1bmN0aW9uIG4ocil7YXx8KGE9d2luZG93LnBlcmZvcm1hbmNlLm5vdygpKSxvPXItYSxpLmFwcGx5KGUpLG88dD9zPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobixlKTood2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHMpLGUudHJpZ2dlcihcXFwiZmluaXNoZWQuemYuYW5pbWF0ZVxcXCIsW2VdKS50cmlnZ2VySGFuZGxlcihcXFwiZmluaXNoZWQuemYuYW5pbWF0ZVxcXCIsW2VdKSk7fXZhciBzLG8sYT1udWxsO3M9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuKTt9ZnVuY3Rpb24gaShlLGksbyxhKXtmdW5jdGlvbiByKCl7ZXx8aS5oaWRlKCksbCgpLGEmJmEuYXBwbHkoaSk7fWZ1bmN0aW9uIGwoKXtpWzBdLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbj0wLGkucmVtb3ZlQ2xhc3ModStcXFwiIFxcXCIrZCtcXFwiIFxcXCIrbyk7fWlmKGk9dChpKS5lcSgwKSxpLmxlbmd0aCl7dmFyIHU9ZT9uWzBdOm5bMV0sZD1lP3NbMF06c1sxXTtsKCksaS5hZGRDbGFzcyhvKS5jc3MoXFxcInRyYW5zaXRpb25cXFwiLFxcXCJub25lXFxcIikscmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7aS5hZGRDbGFzcyh1KSxlJiZpLnNob3coKTt9KSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtpWzBdLm9mZnNldFdpZHRoLGkuY3NzKFxcXCJ0cmFuc2l0aW9uXFxcIixcXFwiXFxcIikuYWRkQ2xhc3MoZCk7fSksaS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKGkpLHIpO319dmFyIG49W1xcXCJtdWktZW50ZXJcXFwiLFxcXCJtdWktbGVhdmVcXFwiXSxzPVtcXFwibXVpLWVudGVyLWFjdGl2ZVxcXCIsXFxcIm11aS1sZWF2ZS1hY3RpdmVcXFwiXSxvPXthbmltYXRlSW46ZnVuY3Rpb24gYW5pbWF0ZUluKHQsZSxuKXtpKCEwLHQsZSxuKTt9LGFuaW1hdGVPdXQ6ZnVuY3Rpb24gYW5pbWF0ZU91dCh0LGUsbil7aSghMSx0LGUsbik7fX07Rm91bmRhdGlvbi5Nb3ZlPWUsRm91bmRhdGlvbi5Nb3Rpb249bzt9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe3ZhciBlPXtGZWF0aGVyOmZ1bmN0aW9uIEZlYXRoZXIoZSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlxcXCJ6ZlxcXCI7ZS5hdHRyKFxcXCJyb2xlXFxcIixcXFwibWVudWJhclxcXCIpO3ZhciBuPWUuZmluZChcXFwibGlcXFwiKS5hdHRyKHtyb2xlOlxcXCJtZW51aXRlbVxcXCJ9KSxzPVxcXCJpcy1cXFwiK2krXFxcIi1zdWJtZW51XFxcIixvPXMrXFxcIi1pdGVtXFxcIixhPVxcXCJpcy1cXFwiK2krXFxcIi1zdWJtZW51LXBhcmVudFxcXCI7ZS5maW5kKFxcXCJhOmZpcnN0XFxcIikuYXR0cihcXFwidGFiaW5kZXhcXFwiLDApLG4uZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyksaT1lLmNoaWxkcmVuKFxcXCJ1bFxcXCIpO2kubGVuZ3RoJiYoZS5hZGRDbGFzcyhhKS5hdHRyKHtcXFwiYXJpYS1oYXNwb3B1cFxcXCI6ITAsXFxcImFyaWEtZXhwYW5kZWRcXFwiOiExLFxcXCJhcmlhLWxhYmVsXFxcIjplLmNoaWxkcmVuKFxcXCJhOmZpcnN0XFxcIikudGV4dCgpfSksaS5hZGRDbGFzcyhcXFwic3VibWVudSBcXFwiK3MpLmF0dHIoe1xcXCJkYXRhLXN1Ym1lbnVcXFwiOlxcXCJcXFwiLFxcXCJhcmlhLWhpZGRlblxcXCI6ITAscm9sZTpcXFwibWVudVxcXCJ9KSksZS5wYXJlbnQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubGVuZ3RoJiZlLmFkZENsYXNzKFxcXCJpcy1zdWJtZW51LWl0ZW0gXFxcIitvKTt9KTt9LEJ1cm46ZnVuY3Rpb24gQnVybih0LGUpe3ZhciBpPSh0LmZpbmQoXFxcImxpXFxcIikucmVtb3ZlQXR0cihcXFwidGFiaW5kZXhcXFwiKSxcXFwiaXMtXFxcIitlK1xcXCItc3VibWVudVxcXCIpLG49aStcXFwiLWl0ZW1cXFwiLHM9XFxcImlzLVxcXCIrZStcXFwiLXN1Ym1lbnUtcGFyZW50XFxcIjt0LmZpbmQoXFxcIj5saSwgLm1lbnUsIC5tZW51ID4gbGlcXFwiKS5yZW1vdmVDbGFzcyhpK1xcXCIgXFxcIituK1xcXCIgXFxcIitzK1xcXCIgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUgaXMtYWN0aXZlXFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1zdWJtZW51XFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiXFxcIik7fX07Rm91bmRhdGlvbi5OZXN0PWU7fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSxpKXt2YXIgbixzLG89dGhpcyxhPWUuZHVyYXRpb24scj1PYmplY3Qua2V5cyh0LmRhdGEoKSlbMF18fFxcXCJ0aW1lclxcXCIsbD0tMTt0aGlzLmlzUGF1c2VkPSExLHRoaXMucmVzdGFydD1mdW5jdGlvbigpe2w9LTEsY2xlYXJUaW1lb3V0KHMpLHRoaXMuc3RhcnQoKTt9LHRoaXMuc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPSExLGNsZWFyVGltZW91dChzKSxsPWw8PTA/YTpsLHQuZGF0YShcXFwicGF1c2VkXFxcIiwhMSksbj1EYXRlLm5vdygpLHM9c2V0VGltZW91dChmdW5jdGlvbigpe2UuaW5maW5pdGUmJm8ucmVzdGFydCgpLGkmJlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBpJiZpKCk7fSxsKSx0LnRyaWdnZXIoXFxcInRpbWVyc3RhcnQuemYuXFxcIityKTt9LHRoaXMucGF1c2U9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPSEwLGNsZWFyVGltZW91dChzKSx0LmRhdGEoXFxcInBhdXNlZFxcXCIsITApO3ZhciBlPURhdGUubm93KCk7bC09ZS1uLHQudHJpZ2dlcihcXFwidGltZXJwYXVzZWQuemYuXFxcIityKTt9O31mdW5jdGlvbiBpKGUsaSl7ZnVuY3Rpb24gbigpe3MtLSwwPT09cyYmaSgpO312YXIgcz1lLmxlbmd0aDswPT09cyYmaSgpLGUuZWFjaChmdW5jdGlvbigpe3RoaXMuY29tcGxldGU/bigpOlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgdGhpcy5uYXR1cmFsV2lkdGgmJnRoaXMubmF0dXJhbFdpZHRoPjA/bigpOnQodGhpcykub25lKFxcXCJsb2FkXFxcIixmdW5jdGlvbigpe24oKTt9KTt9KTt9Rm91bmRhdGlvbi5UaW1lcj1lLEZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQ9aTt9KGpRdWVyeSksZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3RoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwidG91Y2htb3ZlXFxcIixpKSx0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcInRvdWNoZW5kXFxcIixlKSx1PSExO31mdW5jdGlvbiBpKGkpe2lmKHQuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0JiZpLnByZXZlbnREZWZhdWx0KCksdSl7dmFyIG4scz1pLnRvdWNoZXNbMF0ucGFnZVgsYT0oaS50b3VjaGVzWzBdLnBhZ2VZLG8tcyk7bD1uZXcgRGF0ZSgpLmdldFRpbWUoKS1yLE1hdGguYWJzKGEpPj10LnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkJiZsPD10LnNwb3RTd2lwZS50aW1lVGhyZXNob2xkJiYobj1hPjA/XFxcImxlZnRcXFwiOlxcXCJyaWdodFxcXCIpLG4mJihpLnByZXZlbnREZWZhdWx0KCksZS5jYWxsKHRoaXMpLHQodGhpcykudHJpZ2dlcihcXFwic3dpcGVcXFwiLG4pLnRyaWdnZXIoXFxcInN3aXBlXFxcIituKSk7fX1mdW5jdGlvbiBuKHQpezE9PXQudG91Y2hlcy5sZW5ndGgmJihvPXQudG91Y2hlc1swXS5wYWdlWCxhPXQudG91Y2hlc1swXS5wYWdlWSx1PSEwLHI9bmV3IERhdGUoKS5nZXRUaW1lKCksdGhpcy5hZGRFdmVudExpc3RlbmVyKFxcXCJ0b3VjaG1vdmVcXFwiLGksITEpLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcXFwidG91Y2hlbmRcXFwiLGUsITEpKTt9ZnVuY3Rpb24gcygpe3RoaXMuYWRkRXZlbnRMaXN0ZW5lciYmdGhpcy5hZGRFdmVudExpc3RlbmVyKFxcXCJ0b3VjaHN0YXJ0XFxcIixuLCExKTt9dC5zcG90U3dpcGU9e3ZlcnNpb246XFxcIjEuMC4wXFxcIixlbmFibGVkOlxcXCJvbnRvdWNoc3RhcnRcXFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHByZXZlbnREZWZhdWx0OiExLG1vdmVUaHJlc2hvbGQ6NzUsdGltZVRocmVzaG9sZDoyMDB9O3ZhciBvLGEscixsLHU9ITE7dC5ldmVudC5zcGVjaWFsLnN3aXBlPXtzZXR1cDpzfSx0LmVhY2goW1xcXCJsZWZ0XFxcIixcXFwidXBcXFwiLFxcXCJkb3duXFxcIixcXFwicmlnaHRcXFwiXSxmdW5jdGlvbigpe3QuZXZlbnQuc3BlY2lhbFtcXFwic3dpcGVcXFwiK3RoaXNdPXtzZXR1cDpmdW5jdGlvbiBzZXR1cCgpe3QodGhpcykub24oXFxcInN3aXBlXFxcIix0Lm5vb3ApO319O30pO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7dC5mbi5hZGRUb3VjaD1mdW5jdGlvbigpe3RoaXMuZWFjaChmdW5jdGlvbihpLG4pe3QobikuYmluZChcXFwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWxcXFwiLGZ1bmN0aW9uKCl7ZShldmVudCk7fSk7fSk7dmFyIGU9ZnVuY3Rpb24gZSh0KXt2YXIgZSxpPXQuY2hhbmdlZFRvdWNoZXMsbj1pWzBdLHM9e3RvdWNoc3RhcnQ6XFxcIm1vdXNlZG93blxcXCIsdG91Y2htb3ZlOlxcXCJtb3VzZW1vdmVcXFwiLHRvdWNoZW5kOlxcXCJtb3VzZXVwXFxcIn0sbz1zW3QudHlwZV07XFxcIk1vdXNlRXZlbnRcXFwiaW4gd2luZG93JiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygd2luZG93Lk1vdXNlRXZlbnQ/ZT1uZXcgd2luZG93Lk1vdXNlRXZlbnQobyx7YnViYmxlczohMCxjYW5jZWxhYmxlOiEwLHNjcmVlblg6bi5zY3JlZW5YLHNjcmVlblk6bi5zY3JlZW5ZLGNsaWVudFg6bi5jbGllbnRYLGNsaWVudFk6bi5jbGllbnRZfSk6KGU9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXFxcIk1vdXNlRXZlbnRcXFwiKSxlLmluaXRNb3VzZUV2ZW50KG8sITAsITAsd2luZG93LDEsbi5zY3JlZW5YLG4uc2NyZWVuWSxuLmNsaWVudFgsbi5jbGllbnRZLCExLCExLCExLCExLDAsbnVsbCkpLG4udGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSk7fTt9O30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe28oKSxuKCkscygpLGkoKTt9ZnVuY3Rpb24gaShlKXt2YXIgaT10KFxcXCJbZGF0YS15ZXRpLWJveF1cXFwiKSxuPVtcXFwiZHJvcGRvd25cXFwiLFxcXCJ0b29sdGlwXFxcIixcXFwicmV2ZWFsXFxcIl07aWYoZSYmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZT9uLnB1c2goZSk6XFxcIm9iamVjdFxcXCI9PSh0eXBlb2YgZT09PVxcXCJ1bmRlZmluZWRcXFwiP1xcXCJ1bmRlZmluZWRcXFwiOl90eXBlb2YoZSkpJiZcXFwic3RyaW5nXFxcIj09dHlwZW9mIGVbMF0/bi5jb25jYXQoZSk6Y29uc29sZS5lcnJvcihcXFwiUGx1Z2luIG5hbWVzIG11c3QgYmUgc3RyaW5nc1xcXCIpKSxpLmxlbmd0aCl7dmFyIHM9bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXFxcImNsb3NlbWUuemYuXFxcIit0O30pLmpvaW4oXFxcIiBcXFwiKTt0KHdpbmRvdykub2ZmKHMpLm9uKHMsZnVuY3Rpb24oZSxpKXt2YXIgbj1lLm5hbWVzcGFjZS5zcGxpdChcXFwiLlxcXCIpWzBdLHM9dChcXFwiW2RhdGEtXFxcIituK1xcXCJdXFxcIikubm90KCdbZGF0YS15ZXRpLWJveD1cXFwiJytpKydcXFwiXScpO3MuZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyk7ZS50cmlnZ2VySGFuZGxlcihcXFwiY2xvc2UuemYudHJpZ2dlclxcXCIsW2VdKTt9KTt9KTt9fWZ1bmN0aW9uIG4oZSl7dmFyIGk9dm9pZCAwLG49dChcXFwiW2RhdGEtcmVzaXplXVxcXCIpO24ubGVuZ3RoJiZ0KHdpbmRvdykub2ZmKFxcXCJyZXNpemUuemYudHJpZ2dlclxcXCIpLm9uKFxcXCJyZXNpemUuemYudHJpZ2dlclxcXCIsZnVuY3Rpb24ocyl7aSYmY2xlYXJUaW1lb3V0KGkpLGk9c2V0VGltZW91dChmdW5jdGlvbigpe2F8fG4uZWFjaChmdW5jdGlvbigpe3QodGhpcykudHJpZ2dlckhhbmRsZXIoXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiKTt9KSxuLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIixcXFwicmVzaXplXFxcIik7fSxlfHwxMCk7fSk7fWZ1bmN0aW9uIHMoZSl7dmFyIGk9dm9pZCAwLG49dChcXFwiW2RhdGEtc2Nyb2xsXVxcXCIpO24ubGVuZ3RoJiZ0KHdpbmRvdykub2ZmKFxcXCJzY3JvbGwuemYudHJpZ2dlclxcXCIpLm9uKFxcXCJzY3JvbGwuemYudHJpZ2dlclxcXCIsZnVuY3Rpb24ocyl7aSYmY2xlYXJUaW1lb3V0KGkpLGk9c2V0VGltZW91dChmdW5jdGlvbigpe2F8fG4uZWFjaChmdW5jdGlvbigpe3QodGhpcykudHJpZ2dlckhhbmRsZXIoXFxcInNjcm9sbG1lLnpmLnRyaWdnZXJcXFwiKTt9KSxuLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIixcXFwic2Nyb2xsXFxcIik7fSxlfHwxMCk7fSk7fWZ1bmN0aW9uIG8oKXtpZighYSlyZXR1cm4hMTt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbZGF0YS1yZXNpemVdLCBbZGF0YS1zY3JvbGxdLCBbZGF0YS1tdXRhdGVdXFxcIiksaT1mdW5jdGlvbiBpKGUpe3ZhciBpPXQoZVswXS50YXJnZXQpO3N3aXRjaChpLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIikpe2Nhc2VcXFwicmVzaXplXFxcIjppLnRyaWdnZXJIYW5kbGVyKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIixbaV0pO2JyZWFrO2Nhc2VcXFwic2Nyb2xsXFxcIjppLnRyaWdnZXJIYW5kbGVyKFxcXCJzY3JvbGxtZS56Zi50cmlnZ2VyXFxcIixbaSx3aW5kb3cucGFnZVlPZmZzZXRdKTticmVhaztkZWZhdWx0OnJldHVybiExO319O2lmKGUubGVuZ3RoKWZvcih2YXIgbj0wO248PWUubGVuZ3RoLTE7bisrKXt2YXIgcz1uZXcgYShpKTtzLm9ic2VydmUoZVtuXSx7YXR0cmlidXRlczohMCxjaGlsZExpc3Q6ITEsY2hhcmFjdGVyRGF0YTohMSxzdWJ0cmVlOiExLGF0dHJpYnV0ZUZpbHRlcjpbXFxcImRhdGEtZXZlbnRzXFxcIl19KTt9fXZhciBhPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtcXFwiV2ViS2l0XFxcIixcXFwiTW96XFxcIixcXFwiT1xcXCIsXFxcIk1zXFxcIixcXFwiXFxcIl0sZT0wO2U8dC5sZW5ndGg7ZSsrKXtpZih0W2VdK1xcXCJNdXRhdGlvbk9ic2VydmVyXFxcImluIHdpbmRvdylyZXR1cm4gd2luZG93W3RbZV0rXFxcIk11dGF0aW9uT2JzZXJ2ZXJcXFwiXTt9cmV0dXJuITE7fSgpLHI9ZnVuY3Rpb24gcihlLGkpe2UuZGF0YShpKS5zcGxpdChcXFwiIFxcXCIpLmZvckVhY2goZnVuY3Rpb24obil7dChcXFwiI1xcXCIrbilbXFxcImNsb3NlXFxcIj09PWk/XFxcInRyaWdnZXJcXFwiOlxcXCJ0cmlnZ2VySGFuZGxlclxcXCJdKGkrXFxcIi56Zi50cmlnZ2VyXFxcIixbZV0pO30pO307dChkb2N1bWVudCkub24oXFxcImNsaWNrLnpmLnRyaWdnZXJcXFwiLFxcXCJbZGF0YS1vcGVuXVxcXCIsZnVuY3Rpb24oKXtyKHQodGhpcyksXFxcIm9wZW5cXFwiKTt9KSx0KGRvY3VtZW50KS5vbihcXFwiY2xpY2suemYudHJpZ2dlclxcXCIsXFxcIltkYXRhLWNsb3NlXVxcXCIsZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpLmRhdGEoXFxcImNsb3NlXFxcIik7ZT9yKHQodGhpcyksXFxcImNsb3NlXFxcIik6dCh0aGlzKS50cmlnZ2VyKFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIik7fSksdChkb2N1bWVudCkub24oXFxcImNsaWNrLnpmLnRyaWdnZXJcXFwiLFxcXCJbZGF0YS10b2dnbGVdXFxcIixmdW5jdGlvbigpe3IodCh0aGlzKSxcXFwidG9nZ2xlXFxcIik7fSksdChkb2N1bWVudCkub24oXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiLFxcXCJbZGF0YS1jbG9zYWJsZV1cXFwiLGZ1bmN0aW9uKGUpe2Uuc3RvcFByb3BhZ2F0aW9uKCk7dmFyIGk9dCh0aGlzKS5kYXRhKFxcXCJjbG9zYWJsZVxcXCIpO1xcXCJcXFwiIT09aT9Gb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHQodGhpcyksaSxmdW5jdGlvbigpe3QodGhpcykudHJpZ2dlcihcXFwiY2xvc2VkLnpmXFxcIik7fSk6dCh0aGlzKS5mYWRlT3V0KCkudHJpZ2dlcihcXFwiY2xvc2VkLnpmXFxcIik7fSksdChkb2N1bWVudCkub24oXFxcImZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyXFxcIixcXFwiW2RhdGEtdG9nZ2xlLWZvY3VzXVxcXCIsZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpLmRhdGEoXFxcInRvZ2dsZS1mb2N1c1xcXCIpO3QoXFxcIiNcXFwiK2UpLnRyaWdnZXJIYW5kbGVyKFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCIsW3QodGhpcyldKTt9KSx0KHdpbmRvdykub24oXFxcImxvYWRcXFwiLGZ1bmN0aW9uKCl7ZSgpO30pLEZvdW5kYXRpb24uSUhlYXJZb3U9ZTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGkpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiQWJpZGVcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRpbnB1dHM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdFxcXCIpLHRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50Lm9mZihcXFwiLmFiaWRlXFxcIikub24oXFxcInJlc2V0LnpmLmFiaWRlXFxcIixmdW5jdGlvbigpe2UucmVzZXRGb3JtKCk7fSkub24oXFxcInN1Ym1pdC56Zi5hYmlkZVxcXCIsZnVuY3Rpb24oKXtyZXR1cm4gZS52YWxpZGF0ZUZvcm0oKTt9KSxcXFwiZmllbGRDaGFuZ2VcXFwiPT09dGhpcy5vcHRpb25zLnZhbGlkYXRlT24mJnRoaXMuJGlucHV0cy5vZmYoXFxcImNoYW5nZS56Zi5hYmlkZVxcXCIpLm9uKFxcXCJjaGFuZ2UuemYuYWJpZGVcXFwiLGZ1bmN0aW9uKGkpe2UudmFsaWRhdGVJbnB1dCh0KGkudGFyZ2V0KSk7fSksdGhpcy5vcHRpb25zLmxpdmVWYWxpZGF0ZSYmdGhpcy4kaW5wdXRzLm9mZihcXFwiaW5wdXQuemYuYWJpZGVcXFwiKS5vbihcXFwiaW5wdXQuemYuYWJpZGVcXFwiLGZ1bmN0aW9uKGkpe2UudmFsaWRhdGVJbnB1dCh0KGkudGFyZ2V0KSk7fSk7fX0se2tleTpcXFwiX3JlZmxvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9pbml0KCk7fX0se2tleTpcXFwicmVxdWlyZWRDaGVja1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7aWYoIXQuYXR0cihcXFwicmVxdWlyZWRcXFwiKSlyZXR1cm4hMDt2YXIgZT0hMDtzd2l0Y2godFswXS50eXBlKXtjYXNlXFxcImNoZWNrYm94XFxcIjplPXRbMF0uY2hlY2tlZDticmVhaztjYXNlXFxcInNlbGVjdFxcXCI6Y2FzZVxcXCJzZWxlY3Qtb25lXFxcIjpjYXNlXFxcInNlbGVjdC1tdWx0aXBsZVxcXCI6dmFyIGk9dC5maW5kKFxcXCJvcHRpb246c2VsZWN0ZWRcXFwiKTtpLmxlbmd0aCYmaS52YWwoKXx8KGU9ITEpO2JyZWFrO2RlZmF1bHQ6dC52YWwoKSYmdC52YWwoKS5sZW5ndGh8fChlPSExKTt9cmV0dXJuIGU7fX0se2tleTpcXFwiZmluZEZvcm1FcnJvclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dC5zaWJsaW5ncyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO3JldHVybiBlLmxlbmd0aHx8KGU9dC5wYXJlbnQoKS5maW5kKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3RvcikpLGU7fX0se2tleTpcXFwiZmluZExhYmVsXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10WzBdLmlkLGk9dGhpcy4kZWxlbWVudC5maW5kKCdsYWJlbFtmb3I9XFxcIicrZSsnXFxcIl0nKTtyZXR1cm4gaS5sZW5ndGg/aTp0LmNsb3Nlc3QoXFxcImxhYmVsXFxcIik7fX0se2tleTpcXFwiZmluZFJhZGlvTGFiZWxzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzLG49ZS5tYXAoZnVuY3Rpb24oZSxuKXt2YXIgcz1uLmlkLG89aS4kZWxlbWVudC5maW5kKCdsYWJlbFtmb3I9XFxcIicrcysnXFxcIl0nKTtyZXR1cm4gby5sZW5ndGh8fChvPXQobikuY2xvc2VzdChcXFwibGFiZWxcXFwiKSksb1swXTt9KTtyZXR1cm4gdChuKTt9fSx7a2V5OlxcXCJhZGRFcnJvckNsYXNzZXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXMuZmluZExhYmVsKHQpLGk9dGhpcy5maW5kRm9ybUVycm9yKHQpO2UubGVuZ3RoJiZlLmFkZENsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpLGkubGVuZ3RoJiZpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyksdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5hdHRyKFxcXCJkYXRhLWludmFsaWRcXFwiLFxcXCJcXFwiKTt9fSx7a2V5OlxcXCJyZW1vdmVSYWRpb0Vycm9yQ2xhc3Nlc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKCc6cmFkaW9bbmFtZT1cXFwiJyt0KydcXFwiXScpLGk9dGhpcy5maW5kUmFkaW9MYWJlbHMoZSksbj10aGlzLmZpbmRGb3JtRXJyb3IoZSk7aS5sZW5ndGgmJmkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyksbi5sZW5ndGgmJm4ucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKSxlLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLnJlbW92ZUF0dHIoXFxcImRhdGEtaW52YWxpZFxcXCIpO319LHtrZXk6XFxcInJlbW92ZUVycm9yQ2xhc3Nlc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7aWYoXFxcInJhZGlvXFxcIj09dFswXS50eXBlKXJldHVybiB0aGlzLnJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKHQuYXR0cihcXFwibmFtZVxcXCIpKTt2YXIgZT10aGlzLmZpbmRMYWJlbCh0KSxpPXRoaXMuZmluZEZvcm1FcnJvcih0KTtlLmxlbmd0aCYmZS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKSxpLmxlbmd0aCYmaS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpLHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIik7fX0se2tleTpcXFwidmFsaWRhdGVJbnB1dFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy5yZXF1aXJlZENoZWNrKHQpLGk9ITEsbj0hMCxzPXQuYXR0cihcXFwiZGF0YS12YWxpZGF0b3JcXFwiKSxvPSEwO2lmKHQuaXMoXFxcIltkYXRhLWFiaWRlLWlnbm9yZV1cXFwiKXx8dC5pcygnW3R5cGU9XFxcImhpZGRlblxcXCJdJykpcmV0dXJuITA7c3dpdGNoKHRbMF0udHlwZSl7Y2FzZVxcXCJyYWRpb1xcXCI6aT10aGlzLnZhbGlkYXRlUmFkaW8odC5hdHRyKFxcXCJuYW1lXFxcIikpO2JyZWFrO2Nhc2VcXFwiY2hlY2tib3hcXFwiOmk9ZTticmVhaztjYXNlXFxcInNlbGVjdFxcXCI6Y2FzZVxcXCJzZWxlY3Qtb25lXFxcIjpjYXNlXFxcInNlbGVjdC1tdWx0aXBsZVxcXCI6aT1lO2JyZWFrO2RlZmF1bHQ6aT10aGlzLnZhbGlkYXRlVGV4dCh0KTt9cyYmKG49dGhpcy5tYXRjaFZhbGlkYXRpb24odCxzLHQuYXR0cihcXFwicmVxdWlyZWRcXFwiKSkpLHQuYXR0cihcXFwiZGF0YS1lcXVhbHRvXFxcIikmJihvPXRoaXMub3B0aW9ucy52YWxpZGF0b3JzLmVxdWFsVG8odCkpO3ZhciBhPVtlLGksbixvXS5pbmRleE9mKCExKT09PS0xLHI9KGE/XFxcInZhbGlkXFxcIjpcXFwiaW52YWxpZFxcXCIpK1xcXCIuemYuYWJpZGVcXFwiO3JldHVybiB0aGlzW2E/XFxcInJlbW92ZUVycm9yQ2xhc3Nlc1xcXCI6XFxcImFkZEVycm9yQ2xhc3Nlc1xcXCJdKHQpLHQudHJpZ2dlcihyLFt0XSksYTt9fSx7a2V5OlxcXCJ2YWxpZGF0ZUZvcm1cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9W10saT10aGlzO3RoaXMuJGlucHV0cy5lYWNoKGZ1bmN0aW9uKCl7ZS5wdXNoKGkudmFsaWRhdGVJbnB1dCh0KHRoaXMpKSk7fSk7dmFyIG49ZS5pbmRleE9mKCExKT09PS0xO3JldHVybiB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWFiaWRlLWVycm9yXVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsbj9cXFwibm9uZVxcXCI6XFxcImJsb2NrXFxcIiksdGhpcy4kZWxlbWVudC50cmlnZ2VyKChuP1xcXCJmb3JtdmFsaWRcXFwiOlxcXCJmb3JtaW52YWxpZFxcXCIpK1xcXCIuemYuYWJpZGVcXFwiLFt0aGlzLiRlbGVtZW50XSksbjt9fSx7a2V5OlxcXCJ2YWxpZGF0ZVRleHRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSl7ZT1lfHx0LmF0dHIoXFxcInBhdHRlcm5cXFwiKXx8dC5hdHRyKFxcXCJ0eXBlXFxcIik7dmFyIGk9dC52YWwoKSxuPSExO3JldHVybiBpLmxlbmd0aD9uPXRoaXMub3B0aW9ucy5wYXR0ZXJucy5oYXNPd25Qcm9wZXJ0eShlKT90aGlzLm9wdGlvbnMucGF0dGVybnNbZV0udGVzdChpKTplPT09dC5hdHRyKFxcXCJ0eXBlXFxcIil8fG5ldyBSZWdFeHAoZSkudGVzdChpKTp0LnByb3AoXFxcInJlcXVpcmVkXFxcIil8fChuPSEwKSxuO319LHtrZXk6XFxcInZhbGlkYXRlUmFkaW9cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXMuJGVsZW1lbnQuZmluZCgnOnJhZGlvW25hbWU9XFxcIicrZSsnXFxcIl0nKSxuPSExLHM9ITE7cmV0dXJuIGkuZWFjaChmdW5jdGlvbihlLGkpe3QoaSkuYXR0cihcXFwicmVxdWlyZWRcXFwiKSYmKHM9ITApO30pLHN8fChuPSEwKSxufHxpLmVhY2goZnVuY3Rpb24oZSxpKXt0KGkpLnByb3AoXFxcImNoZWNrZWRcXFwiKSYmKG49ITApO30pLG47fX0se2tleTpcXFwibWF0Y2hWYWxpZGF0aW9uXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGUsaSl7dmFyIG49dGhpcztpPSEhaTt2YXIgcz1lLnNwbGl0KFxcXCIgXFxcIikubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBuLm9wdGlvbnMudmFsaWRhdG9yc1tlXSh0LGksdC5wYXJlbnQoKSk7fSk7cmV0dXJuIHMuaW5kZXhPZighMSk9PT0tMTt9fSx7a2V5OlxcXCJyZXNldEZvcm1cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudCxpPXRoaXMub3B0aW9uczt0KFxcXCIuXFxcIitpLmxhYmVsRXJyb3JDbGFzcyxlKS5ub3QoXFxcInNtYWxsXFxcIikucmVtb3ZlQ2xhc3MoaS5sYWJlbEVycm9yQ2xhc3MpLHQoXFxcIi5cXFwiK2kuaW5wdXRFcnJvckNsYXNzLGUpLm5vdChcXFwic21hbGxcXFwiKS5yZW1vdmVDbGFzcyhpLmlucHV0RXJyb3JDbGFzcyksdChpLmZvcm1FcnJvclNlbGVjdG9yK1xcXCIuXFxcIitpLmZvcm1FcnJvckNsYXNzKS5yZW1vdmVDbGFzcyhpLmZvcm1FcnJvckNsYXNzKSxlLmZpbmQoXFxcIltkYXRhLWFiaWRlLWVycm9yXVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcIm5vbmVcXFwiKSx0KFxcXCI6aW5wdXRcXFwiLGUpLm5vdChcXFwiOmJ1dHRvbiwgOnN1Ym1pdCwgOnJlc2V0LCA6aGlkZGVuLCA6cmFkaW8sIDpjaGVja2JveCwgW2RhdGEtYWJpZGUtaWdub3JlXVxcXCIpLnZhbChcXFwiXFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiksdChcXFwiOmlucHV0OnJhZGlvXFxcIixlKS5ub3QoXFxcIltkYXRhLWFiaWRlLWlnbm9yZV1cXFwiKS5wcm9wKFxcXCJjaGVja2VkXFxcIiwhMSkucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiksdChcXFwiOmlucHV0OmNoZWNrYm94XFxcIixlKS5ub3QoXFxcIltkYXRhLWFiaWRlLWlnbm9yZV1cXFwiKS5wcm9wKFxcXCJjaGVja2VkXFxcIiwhMSkucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiksZS50cmlnZ2VyKFxcXCJmb3JtcmVzZXQuemYuYWJpZGVcXFwiLFtlXSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuYWJpZGVcXFwiKS5maW5kKFxcXCJbZGF0YS1hYmlkZS1lcnJvcl1cXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJub25lXFxcIiksdGhpcy4kaW5wdXRzLm9mZihcXFwiLmFiaWRlXFxcIikuZWFjaChmdW5jdGlvbigpe2UucmVtb3ZlRXJyb3JDbGFzc2VzKHQodGhpcykpO30pLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e3ZhbGlkYXRlT246XFxcImZpZWxkQ2hhbmdlXFxcIixsYWJlbEVycm9yQ2xhc3M6XFxcImlzLWludmFsaWQtbGFiZWxcXFwiLGlucHV0RXJyb3JDbGFzczpcXFwiaXMtaW52YWxpZC1pbnB1dFxcXCIsZm9ybUVycm9yU2VsZWN0b3I6XFxcIi5mb3JtLWVycm9yXFxcIixmb3JtRXJyb3JDbGFzczpcXFwiaXMtdmlzaWJsZVxcXCIsbGl2ZVZhbGlkYXRlOiExLHBhdHRlcm5zOnthbHBoYTovXlthLXpBLVpdKyQvLGFscGhhX251bWVyaWM6L15bYS16QS1aMC05XSskLyxpbnRlZ2VyOi9eWy0rXT9cXFxcZCskLyxudW1iZXI6L15bLStdP1xcXFxkKig/OltcXFxcLlxcXFwsXVxcXFxkKyk/JC8sY2FyZDovXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxcXGR7M30pXFxcXGR7MTF9KSQvLGN2djovXihbMC05XSl7Myw0fSQvLGVtYWlsOi9eW2EtekEtWjAtOS4hIyQlJicqK1xcXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcXFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSskLyx1cmw6L14oaHR0cHM/fGZ0cHxmaWxlfHNzaCk6XFxcXC9cXFxcLygoKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OikqQCk/KCgoXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKVxcXFwuKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSlcXFxcLihcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pXFxcXC4oXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKSl8KCgoW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCgoW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSooW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKSlcXFxcLikrKChbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KChbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKihbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkpKVxcXFwuPykoOlxcXFxkKik/KShcXFxcLygoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApKyhcXFxcLygoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCkqKSopPyk/KFxcXFw/KCgoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCl8W1xcXFx1RTAwMC1cXFxcdUY4RkZdfFxcXFwvfFxcXFw/KSopPyhcXFxcIygoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApfFxcXFwvfFxcXFw/KSopPyQvLGRvbWFpbjovXihbYS16QS1aMC05XShbYS16QS1aMC05XFxcXC1dezAsNjF9W2EtekEtWjAtOV0pP1xcXFwuKStbYS16QS1aXXsyLDh9JC8sZGF0ZXRpbWU6L14oWzAtMl1bMC05XXszfSlcXFxcLShbMC0xXVswLTldKVxcXFwtKFswLTNdWzAtOV0pVChbMC01XVswLTldKVxcXFw6KFswLTVdWzAtOV0pXFxcXDooWzAtNV1bMC05XSkoWnwoW1xcXFwtXFxcXCtdKFswLTFdWzAtOV0pXFxcXDowMCkpJC8sZGF0ZTovKD86MTl8MjApWzAtOV17Mn0tKD86KD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfDFbMC05XXwyWzAtOV0pfCg/Oig/ITAyKSg/OjBbMS05XXwxWzAtMl0pLSg/OjMwKSl8KD86KD86MFsxMzU3OF18MVswMl0pLTMxKSkkLyx0aW1lOi9eKDBbMC05XXwxWzAtOV18MlswLTNdKSg6WzAtNV1bMC05XSl7Mn0kLyxkYXRlSVNPOi9eXFxcXGR7NH1bXFxcXC9cXFxcLV1cXFxcZHsxLDJ9W1xcXFwvXFxcXC1dXFxcXGR7MSwyfSQvLG1vbnRoX2RheV95ZWFyOi9eKDBbMS05XXwxWzAxMl0pWy0gXFxcXC8uXSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcXFwvLl1cXFxcZHs0fSQvLGRheV9tb250aF95ZWFyOi9eKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFxcXC8uXSgwWzEtOV18MVswMTJdKVstIFxcXFwvLl1cXFxcZHs0fSQvLGNvbG9yOi9eIz8oW2EtZkEtRjAtOV17Nn18W2EtZkEtRjAtOV17M30pJC99LHZhbGlkYXRvcnM6e2VxdWFsVG86ZnVuY3Rpb24gZXF1YWxUbyhlLGksbil7cmV0dXJuIHQoXFxcIiNcXFwiK2UuYXR0cihcXFwiZGF0YS1lcXVhbHRvXFxcIikpLnZhbCgpPT09ZS52YWwoKTt9fX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiQWJpZGVcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkFjY29yZGlvblxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkFjY29yZGlvblxcXCIse0VOVEVSOlxcXCJ0b2dnbGVcXFwiLFNQQUNFOlxcXCJ0b2dnbGVcXFwiLEFSUk9XX0RPV046XFxcIm5leHRcXFwiLEFSUk9XX1VQOlxcXCJwcmV2aW91c1xcXCJ9KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmF0dHIoXFxcInJvbGVcXFwiLFxcXCJ0YWJsaXN0XFxcIiksdGhpcy4kdGFicz10aGlzLiRlbGVtZW50LmNoaWxkcmVuKFxcXCJsaSwgW2RhdGEtYWNjb3JkaW9uLWl0ZW1dXFxcIiksdGhpcy4kdGFicy5lYWNoKGZ1bmN0aW9uKGUsaSl7dmFyIG49dChpKSxzPW4uY2hpbGRyZW4oXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpLG89c1swXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJhY2NvcmRpb25cXFwiKSxhPWkuaWR8fG8rXFxcIi1sYWJlbFxcXCI7bi5maW5kKFxcXCJhOmZpcnN0XFxcIikuYXR0cih7XFxcImFyaWEtY29udHJvbHNcXFwiOm8scm9sZTpcXFwidGFiXFxcIixpZDphLFxcXCJhcmlhLWV4cGFuZGVkXFxcIjohMSxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6ITF9KSxzLmF0dHIoe3JvbGU6XFxcInRhYnBhbmVsXFxcIixcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjphLFxcXCJhcmlhLWhpZGRlblxcXCI6ITAsaWQ6b30pO30pO3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpLmNoaWxkcmVuKFxcXCJbZGF0YS10YWItY29udGVudF1cXFwiKTtlLmxlbmd0aCYmdGhpcy5kb3duKGUsITApLHRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49aS5jaGlsZHJlbihcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIik7bi5sZW5ndGgmJmkuY2hpbGRyZW4oXFxcImFcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmFjY29yZGlvbiBrZXlkb3duLnpmLmFjY29yZGlvblxcXCIpLm9uKFxcXCJjbGljay56Zi5hY2NvcmRpb25cXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxlLnRvZ2dsZShuKTt9KS5vbihcXFwia2V5ZG93bi56Zi5hY2NvcmRpb25cXFwiLGZ1bmN0aW9uKHQpe0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KHQsXFxcIkFjY29yZGlvblxcXCIse3RvZ2dsZTpmdW5jdGlvbiB0b2dnbGUoKXtlLnRvZ2dsZShuKTt9LG5leHQ6ZnVuY3Rpb24gbmV4dCgpe3ZhciB0PWkubmV4dCgpLmZpbmQoXFxcImFcXFwiKS5mb2N1cygpO2Uub3B0aW9ucy5tdWx0aUV4cGFuZHx8dC50cmlnZ2VyKFxcXCJjbGljay56Zi5hY2NvcmRpb25cXFwiKTt9LHByZXZpb3VzOmZ1bmN0aW9uIHByZXZpb3VzKCl7dmFyIHQ9aS5wcmV2KCkuZmluZChcXFwiYVxcXCIpLmZvY3VzKCk7ZS5vcHRpb25zLm11bHRpRXhwYW5kfHx0LnRyaWdnZXIoXFxcImNsaWNrLnpmLmFjY29yZGlvblxcXCIpO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7dC5wcmV2ZW50RGVmYXVsdCgpLHQuc3RvcFByb3BhZ2F0aW9uKCk7fX0pO30pO30pO319LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dC5wYXJlbnQoKS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIik/dGhpcy51cCh0KTp0aGlzLmRvd24odCk7fX0se2tleTpcXFwiZG93blxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSxpKXt2YXIgbj10aGlzO2lmKGUuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCExKS5wYXJlbnQoXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpLmFkZEJhY2soKS5wYXJlbnQoKS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksIXRoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCYmIWkpe3ZhciBzPXRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oXFxcIi5pcy1hY3RpdmVcXFwiKS5jaGlsZHJlbihcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIik7cy5sZW5ndGgmJnRoaXMudXAocy5ub3QoZSkpO31lLnNsaWRlRG93bih0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCxmdW5jdGlvbigpe24uJGVsZW1lbnQudHJpZ2dlcihcXFwiZG93bi56Zi5hY2NvcmRpb25cXFwiLFtlXSk7fSksdChcXFwiI1xcXCIrZS5hdHRyKFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiKSkuYXR0cih7XFxcImFyaWEtZXhwYW5kZWRcXFwiOiEwLFxcXCJhcmlhLXNlbGVjdGVkXFxcIjohMH0pO319LHtrZXk6XFxcInVwXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT1lLnBhcmVudCgpLnNpYmxpbmdzKCksbj10aGlzOyh0aGlzLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWR8fGkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpKSYmZS5wYXJlbnQoKS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikmJihlLnNsaWRlVXAobi5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXtuLiRlbGVtZW50LnRyaWdnZXIoXFxcInVwLnpmLmFjY29yZGlvblxcXCIsW2VdKTt9KSxlLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLHQoXFxcIiNcXFwiK2UuYXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMSxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6ITF9KSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpLnN0b3AoITApLnNsaWRlVXAoMCkuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiXFxcIiksdGhpcy4kZWxlbWVudC5maW5kKFxcXCJhXFxcIikub2ZmKFxcXCIuemYuYWNjb3JkaW9uXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17c2xpZGVTcGVlZDoyNTAsbXVsdGlFeHBhbmQ6ITEsYWxsb3dBbGxDbG9zZWQ6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkFjY29yZGlvblxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCxcXFwiYWNjb3JkaW9uXFxcIiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiQWNjb3JkaW9uTWVudVxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkFjY29yZGlvbk1lbnVcXFwiLHtFTlRFUjpcXFwidG9nZ2xlXFxcIixTUEFDRTpcXFwidG9nZ2xlXFxcIixBUlJPV19SSUdIVDpcXFwib3BlblxcXCIsQVJST1dfVVA6XFxcInVwXFxcIixBUlJPV19ET1dOOlxcXCJkb3duXFxcIixBUlJPV19MRUZUOlxcXCJjbG9zZVxcXCIsRVNDQVBFOlxcXCJjbG9zZUFsbFxcXCJ9KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubm90KFxcXCIuaXMtYWN0aXZlXFxcIikuc2xpZGVVcCgwKSx0aGlzLiRlbGVtZW50LmF0dHIoe3JvbGU6XFxcIm1lbnVcXFwiLFxcXCJhcmlhLW11bHRpc2VsZWN0YWJsZVxcXCI6dGhpcy5vcHRpb25zLm11bHRpT3Blbn0pLHRoaXMuJG1lbnVMaW5rcz10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnRcXFwiKSx0aGlzLiRtZW51TGlua3MuZWFjaChmdW5jdGlvbigpe3ZhciBlPXRoaXMuaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwiYWNjLW1lbnUtbGlua1xcXCIpLGk9dCh0aGlzKSxuPWkuY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikscz1uWzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcImFjYy1tZW51XFxcIiksbz1uLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKTtpLmF0dHIoe1xcXCJhcmlhLWNvbnRyb2xzXFxcIjpzLFxcXCJhcmlhLWV4cGFuZGVkXFxcIjpvLHJvbGU6XFxcIm1lbnVpdGVtXFxcIixpZDplfSksbi5hdHRyKHtcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjplLFxcXCJhcmlhLWhpZGRlblxcXCI6IW8scm9sZTpcXFwibWVudVxcXCIsaWQ6c30pO30pO3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpO2lmKGUubGVuZ3RoKXt2YXIgaT10aGlzO2UuZWFjaChmdW5jdGlvbigpe2kuZG93bih0KHRoaXMpKTt9KTt9dGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQuZmluZChcXFwibGlcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKTtpLmxlbmd0aCYmdCh0aGlzKS5jaGlsZHJlbihcXFwiYVxcXCIpLm9mZihcXFwiY2xpY2suemYuYWNjb3JkaW9uTWVudVxcXCIpLm9uKFxcXCJjbGljay56Zi5hY2NvcmRpb25NZW51XFxcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksZS50b2dnbGUoaSk7fSk7fSkub24oXFxcImtleWRvd24uemYuYWNjb3JkaW9ubWVudVxcXCIsZnVuY3Rpb24oaSl7dmFyIG4scyxvPXQodGhpcyksYT1vLnBhcmVudChcXFwidWxcXFwiKS5jaGlsZHJlbihcXFwibGlcXFwiKSxyPW8uY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIik7YS5lYWNoKGZ1bmN0aW9uKGUpe2lmKHQodGhpcykuaXMobykpcmV0dXJuIG49YS5lcShNYXRoLm1heCgwLGUtMSkpLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpLHM9YS5lcShNYXRoLm1pbihlKzEsYS5sZW5ndGgtMSkpLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpLHQodGhpcykuY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdOnZpc2libGVcXFwiKS5sZW5ndGgmJihzPW8uZmluZChcXFwibGk6Zmlyc3QtY2hpbGRcXFwiKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKSksdCh0aGlzKS5pcyhcXFwiOmZpcnN0LWNoaWxkXFxcIik/bj1vLnBhcmVudHMoXFxcImxpXFxcIikuZmlyc3QoKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKTpuLnBhcmVudHMoXFxcImxpXFxcIikuZmlyc3QoKS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV06dmlzaWJsZVxcXCIpLmxlbmd0aCYmKG49bi5wYXJlbnRzKFxcXCJsaVxcXCIpLmZpbmQoXFxcImxpOmxhc3QtY2hpbGRcXFwiKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKSksdm9pZCh0KHRoaXMpLmlzKFxcXCI6bGFzdC1jaGlsZFxcXCIpJiYocz1vLnBhcmVudHMoXFxcImxpXFxcIikuZmlyc3QoKS5uZXh0KFxcXCJsaVxcXCIpLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpKSk7fSksRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiQWNjb3JkaW9uTWVudVxcXCIse29wZW46ZnVuY3Rpb24gb3Blbigpe3IuaXMoXFxcIjpoaWRkZW5cXFwiKSYmKGUuZG93bihyKSxyLmZpbmQoXFxcImxpXFxcIikuZmlyc3QoKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKS5mb2N1cygpKTt9LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ci5sZW5ndGgmJiFyLmlzKFxcXCI6aGlkZGVuXFxcIik/ZS51cChyKTpvLnBhcmVudChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5sZW5ndGgmJihlLnVwKG8ucGFyZW50KFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpKSxvLnBhcmVudHMoXFxcImxpXFxcIikuZmlyc3QoKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKS5mb2N1cygpKTt9LHVwOmZ1bmN0aW9uIHVwKCl7cmV0dXJuIG4uZm9jdXMoKSwhMDt9LGRvd246ZnVuY3Rpb24gZG93bigpe3JldHVybiBzLmZvY3VzKCksITA7fSx0b2dnbGU6ZnVuY3Rpb24gdG9nZ2xlKCl7by5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5sZW5ndGgmJmUudG9nZ2xlKG8uY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikpO30sY2xvc2VBbGw6ZnVuY3Rpb24gY2xvc2VBbGwoKXtlLmhpZGVBbGwoKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCh0KXt0JiZpLnByZXZlbnREZWZhdWx0KCksaS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTt9fSk7fSk7fX0se2tleTpcXFwiaGlkZUFsbFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikuc2xpZGVVcCh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCk7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0LmlzKFxcXCI6YW5pbWF0ZWRcXFwiKXx8KHQuaXMoXFxcIjpoaWRkZW5cXFwiKT90aGlzLmRvd24odCk6dGhpcy51cCh0KSk7fX0se2tleTpcXFwiZG93blxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpczt0aGlzLm9wdGlvbnMubXVsdGlPcGVufHx0aGlzLnVwKHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpLm5vdCh0LnBhcmVudHNVbnRpbCh0aGlzLiRlbGVtZW50KS5hZGQodCkpKSx0LmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiExfSkucGFyZW50KFxcXCIuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50XFxcIikuYXR0cih7XFxcImFyaWEtZXhwYW5kZWRcXFwiOiEwfSksdC5zbGlkZURvd24oZS5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXtlLiRlbGVtZW50LnRyaWdnZXIoXFxcImRvd24uemYuYWNjb3JkaW9uTWVudVxcXCIsW3RdKTt9KTt9fSx7a2V5OlxcXCJ1cFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpczt0LnNsaWRlVXAoZS5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXtlLiRlbGVtZW50LnRyaWdnZXIoXFxcInVwLnpmLmFjY29yZGlvbk1lbnVcXFwiLFt0XSk7fSk7dmFyIGk9dC5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLnNsaWRlVXAoMCkuYWRkQmFjaygpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCk7aS5wYXJlbnQoXFxcIi5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnRcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikuc2xpZGVEb3duKDApLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcIlxcXCIpLHRoaXMuJGVsZW1lbnQuZmluZChcXFwiYVxcXCIpLm9mZihcXFwiY2xpY2suemYuYWNjb3JkaW9uTWVudVxcXCIpLEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsXFxcImFjY29yZGlvblxcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e3NsaWRlU3BlZWQ6MjUwLG11bHRpT3BlbjohMH0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiQWNjb3JkaW9uTWVudVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCxcXFwiZHJpbGxkb3duXFxcIiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiRHJpbGxkb3duXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiRHJpbGxkb3duXFxcIix7RU5URVI6XFxcIm9wZW5cXFwiLFNQQUNFOlxcXCJvcGVuXFxcIixBUlJPV19SSUdIVDpcXFwibmV4dFxcXCIsQVJST1dfVVA6XFxcInVwXFxcIixBUlJPV19ET1dOOlxcXCJkb3duXFxcIixBUlJPV19MRUZUOlxcXCJwcmV2aW91c1xcXCIsRVNDQVBFOlxcXCJjbG9zZVxcXCIsVEFCOlxcXCJkb3duXFxcIixTSElGVF9UQUI6XFxcInVwXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJHN1Ym1lbnVBbmNob3JzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwibGkuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikuY2hpbGRyZW4oXFxcImFcXFwiKSx0aGlzLiRzdWJtZW51cz10aGlzLiRzdWJtZW51QW5jaG9ycy5wYXJlbnQoXFxcImxpXFxcIikuY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIiksdGhpcy4kbWVudUl0ZW1zPXRoaXMuJGVsZW1lbnQuZmluZChcXFwibGlcXFwiKS5ub3QoXFxcIi5qcy1kcmlsbGRvd24tYmFja1xcXCIpLmF0dHIoXFxcInJvbGVcXFwiLFxcXCJtZW51aXRlbVxcXCIpLmZpbmQoXFxcImFcXFwiKSx0aGlzLl9wcmVwYXJlTWVudSgpLHRoaXMuX2tleWJvYXJkRXZlbnRzKCk7fX0se2tleTpcXFwiX3ByZXBhcmVNZW51XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLnBhcmVudCgpO2Uub3B0aW9ucy5wYXJlbnRMaW5rJiZpLmNsb25lKCkucHJlcGVuZFRvKG4uY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikpLndyYXAoJzxsaSBjbGFzcz1cXFwiaXMtc3VibWVudS1wYXJlbnQtaXRlbSBpcy1zdWJtZW51LWl0ZW0gaXMtZHJpbGxkb3duLXN1Ym1lbnUtaXRlbVxcXCIgcm9sZT1cXFwibWVudS1pdGVtXFxcIj48L2xpPicpLGkuZGF0YShcXFwic2F2ZWRIcmVmXFxcIixpLmF0dHIoXFxcImhyZWZcXFwiKSkucmVtb3ZlQXR0cihcXFwiaHJlZlxcXCIpLmF0dHIoXFxcInRhYmluZGV4XFxcIiwwKSxpLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITAsdGFiaW5kZXg6MCxyb2xlOlxcXCJtZW51XFxcIn0pLGUuX2V2ZW50cyhpKTt9KSx0aGlzLiRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkuZmluZChcXFwiLmpzLWRyaWxsZG93bi1iYWNrXFxcIik7bi5sZW5ndGh8fGkucHJlcGVuZChlLm9wdGlvbnMuYmFja0J1dHRvbiksZS5fYmFjayhpKTt9KSx0aGlzLiRlbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKFxcXCJpcy1kcmlsbGRvd25cXFwiKXx8KHRoaXMuJHdyYXBwZXI9dCh0aGlzLm9wdGlvbnMud3JhcHBlcikuYWRkQ2xhc3MoXFxcImlzLWRyaWxsZG93blxcXCIpLHRoaXMuJHdyYXBwZXI9dGhpcy4kZWxlbWVudC53cmFwKHRoaXMuJHdyYXBwZXIpLnBhcmVudCgpLmNzcyh0aGlzLl9nZXRNYXhEaW1zKCkpKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzO2Uub2ZmKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiKS5vbihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIixmdW5jdGlvbihuKXtpZih0KG4udGFyZ2V0KS5wYXJlbnRzVW50aWwoXFxcInVsXFxcIixcXFwibGlcXFwiKS5oYXNDbGFzcyhcXFwiaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikmJihuLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLG4ucHJldmVudERlZmF1bHQoKSksaS5fc2hvdyhlLnBhcmVudChcXFwibGlcXFwiKSksaS5vcHRpb25zLmNsb3NlT25DbGljayl7dmFyIHM9dChcXFwiYm9keVxcXCIpO3Mub2ZmKFxcXCIuemYuZHJpbGxkb3duXFxcIikub24oXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIsZnVuY3Rpb24oZSl7ZS50YXJnZXQ9PT1pLiRlbGVtZW50WzBdfHx0LmNvbnRhaW5zKGkuJGVsZW1lbnRbMF0sZS50YXJnZXQpfHwoZS5wcmV2ZW50RGVmYXVsdCgpLGkuX2hpZGVBbGwoKSxzLm9mZihcXFwiLnpmLmRyaWxsZG93blxcXCIpKTt9KTt9fSk7fX0se2tleTpcXFwiX2tleWJvYXJkRXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kbWVudUl0ZW1zLmFkZCh0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5qcy1kcmlsbGRvd24tYmFjayA+IGFcXFwiKSkub24oXFxcImtleWRvd24uemYuZHJpbGxkb3duXFxcIixmdW5jdGlvbihpKXt2YXIgbixzLG89dCh0aGlzKSxhPW8ucGFyZW50KFxcXCJsaVxcXCIpLnBhcmVudChcXFwidWxcXFwiKS5jaGlsZHJlbihcXFwibGlcXFwiKS5jaGlsZHJlbihcXFwiYVxcXCIpO2EuZWFjaChmdW5jdGlvbihlKXtpZih0KHRoaXMpLmlzKG8pKXJldHVybiBuPWEuZXEoTWF0aC5tYXgoMCxlLTEpKSx2b2lkKHM9YS5lcShNYXRoLm1pbihlKzEsYS5sZW5ndGgtMSkpKTt9KSxGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJEcmlsbGRvd25cXFwiLHtuZXh0OmZ1bmN0aW9uIG5leHQoKXtpZihvLmlzKGUuJHN1Ym1lbnVBbmNob3JzKSlyZXR1cm4gZS5fc2hvdyhvLnBhcmVudChcXFwibGlcXFwiKSksby5wYXJlbnQoXFxcImxpXFxcIikub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZChvKSxmdW5jdGlvbigpe28ucGFyZW50KFxcXCJsaVxcXCIpLmZpbmQoXFxcInVsIGxpIGFcXFwiKS5maWx0ZXIoZS4kbWVudUl0ZW1zKS5maXJzdCgpLmZvY3VzKCk7fSksITA7fSxwcmV2aW91czpmdW5jdGlvbiBwcmV2aW91cygpe3JldHVybiBlLl9oaWRlKG8ucGFyZW50KFxcXCJsaVxcXCIpLnBhcmVudChcXFwidWxcXFwiKSksby5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQobyksZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7by5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpLnBhcmVudChcXFwibGlcXFwiKS5jaGlsZHJlbihcXFwiYVxcXCIpLmZpcnN0KCkuZm9jdXMoKTt9LDEpO30pLCEwO30sdXA6ZnVuY3Rpb24gdXAoKXtyZXR1cm4gbi5mb2N1cygpLCEwO30sZG93bjpmdW5jdGlvbiBkb3duKCl7cmV0dXJuIHMuZm9jdXMoKSwhMDt9LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ZS5fYmFjaygpO30sb3BlbjpmdW5jdGlvbiBvcGVuKCl7cmV0dXJuIG8uaXMoZS4kbWVudUl0ZW1zKT9vLmlzKGUuJHN1Ym1lbnVBbmNob3JzKT8oZS5fc2hvdyhvLnBhcmVudChcXFwibGlcXFwiKSksby5wYXJlbnQoXFxcImxpXFxcIikub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZChvKSxmdW5jdGlvbigpe28ucGFyZW50KFxcXCJsaVxcXCIpLmZpbmQoXFxcInVsIGxpIGFcXFwiKS5maWx0ZXIoZS4kbWVudUl0ZW1zKS5maXJzdCgpLmZvY3VzKCk7fSksITApOnZvaWQgMDooZS5faGlkZShvLnBhcmVudChcXFwibGlcXFwiKS5wYXJlbnQoXFxcInVsXFxcIikpLG8ucGFyZW50KFxcXCJsaVxcXCIpLnBhcmVudChcXFwidWxcXFwiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKG8pLGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe28ucGFyZW50KFxcXCJsaVxcXCIpLnBhcmVudChcXFwidWxcXFwiKS5wYXJlbnQoXFxcImxpXFxcIikuY2hpbGRyZW4oXFxcImFcXFwiKS5maXJzdCgpLmZvY3VzKCk7fSwxKTt9KSwhMCk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQodCl7dCYmaS5wcmV2ZW50RGVmYXVsdCgpLGkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7fX0pO30pO319LHtrZXk6XFxcIl9oaWRlQWxsXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWFjdGl2ZVxcXCIpLmFkZENsYXNzKFxcXCJpcy1jbG9zaW5nXFxcIik7dC5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHQpLGZ1bmN0aW9uKGUpe3QucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1jbG9zaW5nXFxcIik7fSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZWQuemYuZHJpbGxkb3duXFxcIik7fX0se2tleTpcXFwiX2JhY2tcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXM7dC5vZmYoXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIpLHQuY2hpbGRyZW4oXFxcIi5qcy1kcmlsbGRvd24tYmFja1xcXCIpLm9uKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiLGZ1bmN0aW9uKGkpe2kuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksZS5faGlkZSh0KTt2YXIgbj10LnBhcmVudChcXFwibGlcXFwiKS5wYXJlbnQoXFxcInVsXFxcIikucGFyZW50KFxcXCJsaVxcXCIpO24ubGVuZ3RoJiZlLl9zaG93KG4pO30pO319LHtrZXk6XFxcIl9tZW51TGlua0V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzO3RoaXMuJG1lbnVJdGVtcy5ub3QoXFxcIi5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIpLm9uKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiLGZ1bmN0aW9uKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0Ll9oaWRlQWxsKCk7fSwwKTt9KTt9fSx7a2V5OlxcXCJfc2hvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dC5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMCksdC5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCExKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcIm9wZW4uemYuZHJpbGxkb3duXFxcIixbdF0pO319LHtrZXk6XFxcIl9oaWRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0LnBhcmVudChcXFwibGlcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSksdC5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsITApLmFkZENsYXNzKFxcXCJpcy1jbG9zaW5nXFxcIikub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCh0KSxmdW5jdGlvbigpe3QucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1jbG9zaW5nXFxcIiksdC5ibHVyKCk7fSksdC50cmlnZ2VyKFxcXCJoaWRlLnpmLmRyaWxsZG93blxcXCIsW3RdKTt9fSx7a2V5OlxcXCJfZ2V0TWF4RGltc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD0wLGU9e307cmV0dXJuIHRoaXMuJHN1Ym1lbnVzLmFkZCh0aGlzLiRlbGVtZW50KS5lYWNoKGZ1bmN0aW9uKGUsaSl7dmFyIG49aS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7bj50JiYodD1uKTt9KSxlW1xcXCJtaW4taGVpZ2h0XFxcIl09dCtcXFwicHhcXFwiLGVbXFxcIm1heC13aWR0aFxcXCJdPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgrXFxcInB4XFxcIixlO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5faGlkZUFsbCgpLEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsXFxcImRyaWxsZG93blxcXCIpLHRoaXMuJGVsZW1lbnQudW53cmFwKCkuZmluZChcXFwiLmpzLWRyaWxsZG93bi1iYWNrLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbVxcXCIpLnJlbW92ZSgpLmVuZCgpLmZpbmQoXFxcIi5pcy1hY3RpdmUsIC5pcy1jbG9zaW5nLCAuaXMtZHJpbGxkb3duLXN1Ym1lbnVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWNsb3NpbmcgaXMtZHJpbGxkb3duLXN1Ym1lbnVcXFwiKS5lbmQoKS5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtaGlkZGVuIHRhYmluZGV4IHJvbGVcXFwiKSx0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uKCl7dCh0aGlzKS5vZmYoXFxcIi56Zi5kcmlsbGRvd25cXFwiKTt9KSx0aGlzLiRlbGVtZW50LmZpbmQoXFxcImFcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzKTtlLnJlbW92ZUF0dHIoXFxcInRhYmluZGV4XFxcIiksZS5kYXRhKFxcXCJzYXZlZEhyZWZcXFwiKSYmZS5hdHRyKFxcXCJocmVmXFxcIixlLmRhdGEoXFxcInNhdmVkSHJlZlxcXCIpKS5yZW1vdmVEYXRhKFxcXCJzYXZlZEhyZWZcXFwiKTt9KSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtiYWNrQnV0dG9uOic8bGkgY2xhc3M9XFxcImpzLWRyaWxsZG93bi1iYWNrXFxcIj48YSB0YWJpbmRleD1cXFwiMFxcXCI+QmFjazwvYT48L2xpPicsd3JhcHBlcjpcXFwiPGRpdj48L2Rpdj5cXFwiLHBhcmVudExpbms6ITEsY2xvc2VPbkNsaWNrOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJEcmlsbGRvd25cXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkRyb3Bkb3duXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiRHJvcGRvd25cXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEVTQ0FQRTpcXFwiY2xvc2VcXFwiLFRBQjpcXFwidGFiX2ZvcndhcmRcXFwiLFNISUZUX1RBQjpcXFwidGFiX2JhY2t3YXJkXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKTt0aGlzLiRhbmNob3I9dCh0KCdbZGF0YS10b2dnbGU9XFxcIicrZSsnXFxcIl0nKS5sZW5ndGg/J1tkYXRhLXRvZ2dsZT1cXFwiJytlKydcXFwiXSc6J1tkYXRhLW9wZW49XFxcIicrZSsnXFxcIl0nKSx0aGlzLiRhbmNob3IuYXR0cih7XFxcImFyaWEtY29udHJvbHNcXFwiOmUsXFxcImRhdGEtaXMtZm9jdXNcXFwiOiExLFxcXCJkYXRhLXlldGktYm94XFxcIjplLFxcXCJhcmlhLWhhc3BvcHVwXFxcIjohMCxcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITF9KSx0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcz10aGlzLmdldFBvc2l0aW9uQ2xhc3MoKSx0aGlzLmNvdW50ZXI9NCx0aGlzLnVzZWRQb3NpdGlvbnM9W10sdGhpcy4kZWxlbWVudC5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOlxcXCJ0cnVlXFxcIixcXFwiZGF0YS15ZXRpLWJveFxcXCI6ZSxcXFwiZGF0YS1yZXNpemVcXFwiOmUsXFxcImFyaWEtbGFiZWxsZWRieVxcXCI6dGhpcy4kYW5jaG9yWzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcImRkLWFuY2hvclxcXCIpfSksdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiZ2V0UG9zaXRpb25DbGFzc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbSkvZyk7dD10P3RbMF06XFxcIlxcXCI7dmFyIGU9L2Zsb2F0LShcXFxcUyspLy5leGVjKHRoaXMuJGFuY2hvclswXS5jbGFzc05hbWUpO2U9ZT9lWzFdOlxcXCJcXFwiO3ZhciBpPWU/ZStcXFwiIFxcXCIrdDp0O3JldHVybiBpO319LHtrZXk6XFxcIl9yZXBvc2l0aW9uXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0aGlzLnVzZWRQb3NpdGlvbnMucHVzaCh0P3Q6XFxcImJvdHRvbVxcXCIpLCF0JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwidG9wXFxcIik8MD90aGlzLiRlbGVtZW50LmFkZENsYXNzKFxcXCJ0b3BcXFwiKTpcXFwidG9wXFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCk6XFxcImxlZnRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInJpZ2h0XFxcIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJyaWdodFxcXCIpOlxcXCJyaWdodFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcXFwibGVmdFxcXCIpOiF0JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwidG9wXFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLiRlbGVtZW50LmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6XFxcInRvcFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6XFxcImxlZnRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInJpZ2h0XFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCk6XFxcInJpZ2h0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCk6dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KSx0aGlzLmNsYXNzQ2hhbmdlZD0hMCx0aGlzLmNvdW50ZXItLTt9fSx7a2V5OlxcXCJfc2V0UG9zaXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYoXFxcImZhbHNlXFxcIj09PXRoaXMuJGFuY2hvci5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIikpcmV0dXJuITE7dmFyIHQ9dGhpcy5nZXRQb3NpdGlvbkNsYXNzKCksZT1Gb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGVsZW1lbnQpLGk9KEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kYW5jaG9yKSxcXFwibGVmdFxcXCI9PT10P1xcXCJsZWZ0XFxcIjpcXFwicmlnaHRcXFwiPT09dD9cXFwibGVmdFxcXCI6XFxcInRvcFxcXCIpLG49XFxcInRvcFxcXCI9PT1pP1xcXCJoZWlnaHRcXFwiOlxcXCJ3aWR0aFxcXCI7XFxcImhlaWdodFxcXCI9PT1uP3RoaXMub3B0aW9ucy52T2Zmc2V0OnRoaXMub3B0aW9ucy5oT2Zmc2V0O2lmKGUud2lkdGg+PWUud2luZG93RGltcy53aWR0aHx8IXRoaXMuY291bnRlciYmIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy4kZWxlbWVudCkpcmV0dXJuIHRoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCx0aGlzLiRhbmNob3IsXFxcImNlbnRlciBib3R0b21cXFwiLHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0LCEwKSkuY3NzKHt3aWR0aDplLndpbmRvd0RpbXMud2lkdGgtMip0aGlzLm9wdGlvbnMuaE9mZnNldCxoZWlnaHQ6XFxcImF1dG9cXFwifSksdGhpcy5jbGFzc0NoYW5nZWQ9ITAsITE7Zm9yKHRoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCx0aGlzLiRhbmNob3IsdCx0aGlzLm9wdGlvbnMudk9mZnNldCx0aGlzLm9wdGlvbnMuaE9mZnNldCkpOyFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMuJGVsZW1lbnQsITEsITApJiZ0aGlzLmNvdW50ZXI7KXt0aGlzLl9yZXBvc2l0aW9uKHQpLHRoaXMuX3NldFBvc2l0aW9uKCk7fX19LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50Lm9uKHtcXFwib3Blbi56Zi50cmlnZ2VyXFxcIjp0aGlzLm9wZW4uYmluZCh0aGlzKSxcXFwiY2xvc2UuemYudHJpZ2dlclxcXCI6dGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCI6dGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCI6dGhpcy5fc2V0UG9zaXRpb24uYmluZCh0aGlzKX0pLHRoaXMub3B0aW9ucy5ob3ZlciYmKHRoaXMuJGFuY2hvci5vZmYoXFxcIm1vdXNlZW50ZXIuemYuZHJvcGRvd24gbW91c2VsZWF2ZS56Zi5kcm9wZG93blxcXCIpLm9uKFxcXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbigpe3QoJ2JvZHlbZGF0YS13aGF0aW5wdXQ9XFxcIm1vdXNlXFxcIl0nKS5pcyhcXFwiKlxcXCIpJiYoY2xlYXJUaW1lb3V0KGUudGltZW91dCksZS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLm9wZW4oKSxlLiRhbmNob3IuZGF0YShcXFwiaG92ZXJcXFwiLCEwKTt9LGUub3B0aW9ucy5ob3ZlckRlbGF5KSk7fSkub24oXFxcIm1vdXNlbGVhdmUuemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KGUudGltZW91dCksZS50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmNsb3NlKCksZS4kYW5jaG9yLmRhdGEoXFxcImhvdmVyXFxcIiwhMSk7fSxlLm9wdGlvbnMuaG92ZXJEZWxheSk7fSksdGhpcy5vcHRpb25zLmhvdmVyUGFuZSYmdGhpcy4kZWxlbWVudC5vZmYoXFxcIm1vdXNlZW50ZXIuemYuZHJvcGRvd24gbW91c2VsZWF2ZS56Zi5kcm9wZG93blxcXCIpLm9uKFxcXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbigpe2NsZWFyVGltZW91dChlLnRpbWVvdXQpO30pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbigpe2NsZWFyVGltZW91dChlLnRpbWVvdXQpLGUudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5jbG9zZSgpLGUuJGFuY2hvci5kYXRhKFxcXCJob3ZlclxcXCIsITEpO30sZS5vcHRpb25zLmhvdmVyRGVsYXkpO30pKSx0aGlzLiRhbmNob3IuYWRkKHRoaXMuJGVsZW1lbnQpLm9uKFxcXCJrZXlkb3duLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbihpKXt2YXIgbj10KHRoaXMpLHM9Rm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKGUuJGVsZW1lbnQpO0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXFxcIkRyb3Bkb3duXFxcIix7dGFiX2ZvcndhcmQ6ZnVuY3Rpb24gdGFiX2ZvcndhcmQoKXtlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKHMuZXEoLTEpKSYmKGUub3B0aW9ucy50cmFwRm9jdXM/KHMuZXEoMCkuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpOmUuY2xvc2UoKSk7fSx0YWJfYmFja3dhcmQ6ZnVuY3Rpb24gdGFiX2JhY2t3YXJkKCl7KGUuJGVsZW1lbnQuZmluZChcXFwiOmZvY3VzXFxcIikuaXMocy5lcSgwKSl8fGUuJGVsZW1lbnQuaXMoXFxcIjpmb2N1c1xcXCIpKSYmKGUub3B0aW9ucy50cmFwRm9jdXM/KHMuZXEoLTEpLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpKTplLmNsb3NlKCkpO30sb3BlbjpmdW5jdGlvbiBvcGVuKCl7bi5pcyhlLiRhbmNob3IpJiYoZS5vcGVuKCksZS4kZWxlbWVudC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsLTEpLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpKTt9LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ZS5jbG9zZSgpLGUuJGFuY2hvci5mb2N1cygpO319KTt9KTt9fSx7a2V5OlxcXCJfYWRkQm9keUhhbmRsZXJcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dChkb2N1bWVudC5ib2R5KS5ub3QodGhpcy4kZWxlbWVudCksaT10aGlzO2Uub2ZmKFxcXCJjbGljay56Zi5kcm9wZG93blxcXCIpLm9uKFxcXCJjbGljay56Zi5kcm9wZG93blxcXCIsZnVuY3Rpb24odCl7aS4kYW5jaG9yLmlzKHQudGFyZ2V0KXx8aS4kYW5jaG9yLmZpbmQodC50YXJnZXQpLmxlbmd0aHx8aS4kZWxlbWVudC5maW5kKHQudGFyZ2V0KS5sZW5ndGh8fChpLmNsb3NlKCksZS5vZmYoXFxcImNsaWNrLnpmLmRyb3Bkb3duXFxcIikpO30pO319LHtrZXk6XFxcIm9wZW5cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZW1lLnpmLmRyb3Bkb3duXFxcIix0aGlzLiRlbGVtZW50LmF0dHIoXFxcImlkXFxcIikpLHRoaXMuJGFuY2hvci5hZGRDbGFzcyhcXFwiaG92ZXJcXFwiKS5hdHRyKHtcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITB9KSx0aGlzLl9zZXRQb3NpdGlvbigpLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcImlzLW9wZW5cXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiExfSksdGhpcy5vcHRpb25zLmF1dG9Gb2N1cyl7dmFyIHQ9Rm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO3QubGVuZ3RoJiZ0LmVxKDApLmZvY3VzKCk7fXRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuX2FkZEJvZHlIYW5kbGVyKCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzaG93LnpmLmRyb3Bkb3duXFxcIixbdGhpcy4kZWxlbWVudF0pO319LHtrZXk6XFxcImNsb3NlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikpcmV0dXJuITE7aWYodGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtb3BlblxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITB9KSx0aGlzLiRhbmNob3IucmVtb3ZlQ2xhc3MoXFxcImhvdmVyXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITEpLHRoaXMuY2xhc3NDaGFuZ2VkKXt2YXIgdD10aGlzLmdldFBvc2l0aW9uQ2xhc3MoKTt0JiZ0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MpLmNzcyh7aGVpZ2h0OlxcXCJcXFwiLHdpZHRoOlxcXCJcXFwifSksdGhpcy5jbGFzc0NoYW5nZWQ9ITEsdGhpcy5jb3VudGVyPTQsdGhpcy51c2VkUG9zaXRpb25zLmxlbmd0aD0wO310aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImhpZGUuemYuZHJvcGRvd25cXFwiLFt0aGlzLiRlbGVtZW50XSk7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSl7aWYodGhpcy4kYW5jaG9yLmRhdGEoXFxcImhvdmVyXFxcIikpcmV0dXJuO3RoaXMuY2xvc2UoKTt9ZWxzZSB0aGlzLm9wZW4oKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudHJpZ2dlclxcXCIpLmhpZGUoKSx0aGlzLiRhbmNob3Iub2ZmKFxcXCIuemYuZHJvcGRvd25cXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtob3ZlckRlbGF5OjI1MCxob3ZlcjohMSxob3ZlclBhbmU6ITEsdk9mZnNldDoxLGhPZmZzZXQ6MSxwb3NpdGlvbkNsYXNzOlxcXCJcXFwiLHRyYXBGb2N1czohMSxhdXRvRm9jdXM6ITEsY2xvc2VPbkNsaWNrOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJEcm9wZG93blxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCxcXFwiZHJvcGRvd25cXFwiKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJEcm9wZG93bk1lbnVcXFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJEcm9wZG93bk1lbnVcXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEFSUk9XX1JJR0hUOlxcXCJuZXh0XFxcIixBUlJPV19VUDpcXFwidXBcXFwiLEFSUk9XX0RPV046XFxcImRvd25cXFwiLEFSUk9XX0xFRlQ6XFxcInByZXZpb3VzXFxcIixFU0NBUEU6XFxcImNsb3NlXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMuJGVsZW1lbnQuZmluZChcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKTt0aGlzLiRlbGVtZW50LmNoaWxkcmVuKFxcXCIuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5jaGlsZHJlbihcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKS5hZGRDbGFzcyhcXFwiZmlyc3Qtc3ViXFxcIiksdGhpcy4kbWVudUl0ZW1zPXRoaXMuJGVsZW1lbnQuZmluZCgnW3JvbGU9XFxcIm1lbnVpdGVtXFxcIl0nKSx0aGlzLiR0YWJzPXRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJ1tyb2xlPVxcXCJtZW51aXRlbVxcXCJdJyksdGhpcy4kdGFicy5maW5kKFxcXCJ1bC5pcy1kcm9wZG93bi1zdWJtZW51XFxcIikuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsQ2xhc3MpLHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLnJpZ2h0Q2xhc3MpfHxcXFwicmlnaHRcXFwiPT09dGhpcy5vcHRpb25zLmFsaWdubWVudHx8Rm91bmRhdGlvbi5ydGwoKXx8dGhpcy4kZWxlbWVudC5wYXJlbnRzKFxcXCIudG9wLWJhci1yaWdodFxcXCIpLmlzKFxcXCIqXFxcIik/KHRoaXMub3B0aW9ucy5hbGlnbm1lbnQ9XFxcInJpZ2h0XFxcIix0LmFkZENsYXNzKFxcXCJvcGVucy1sZWZ0XFxcIikpOnQuYWRkQ2xhc3MoXFxcIm9wZW5zLXJpZ2h0XFxcIiksdGhpcy5jaGFuZ2VkPSExLHRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcIl9pc1ZlcnRpY2FsXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3JldHVyblxcXCJibG9ja1xcXCI9PT10aGlzLiR0YWJzLmNzcyhcXFwiZGlzcGxheVxcXCIpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcyxpPVxcXCJvbnRvdWNoc3RhcnRcXFwiaW4gd2luZG93fHxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQsbj1cXFwiaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiLHM9ZnVuY3Rpb24gcyhfcyl7dmFyIG89dChfcy50YXJnZXQpLnBhcmVudHNVbnRpbChcXFwidWxcXFwiLFxcXCIuXFxcIituKSxhPW8uaGFzQ2xhc3Mobikscj1cXFwidHJ1ZVxcXCI9PT1vLmF0dHIoXFxcImRhdGEtaXMtY2xpY2tcXFwiKSxsPW8uY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51XFxcIik7aWYoIWEpcmV0dXJuIHZvaWQoZS5vcHRpb25zLmNsb3NlT25DbGlja0luc2lkZSYmZS5faGlkZShvKSk7aWYocil7aWYoIWUub3B0aW9ucy5jbG9zZU9uQ2xpY2t8fCFlLm9wdGlvbnMuY2xpY2tPcGVuJiYhaXx8ZS5vcHRpb25zLmZvcmNlRm9sbG93JiZpKXJldHVybjtfcy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxfcy5wcmV2ZW50RGVmYXVsdCgpLGUuX2hpZGUobyk7fWVsc2UgX3MucHJldmVudERlZmF1bHQoKSxfcy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxlLl9zaG93KGwpLG8uYWRkKG8ucGFyZW50c1VudGlsKGUuJGVsZW1lbnQsXFxcIi5cXFwiK24pKS5hdHRyKFxcXCJkYXRhLWlzLWNsaWNrXFxcIiwhMCk7fTsodGhpcy5vcHRpb25zLmNsaWNrT3Blbnx8aSkmJnRoaXMuJG1lbnVJdGVtcy5vbihcXFwiY2xpY2suemYuZHJvcGRvd25tZW51IHRvdWNoc3RhcnQuemYuZHJvcGRvd25tZW51XFxcIixzKSx0aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyfHx0aGlzLiRtZW51SXRlbXMub24oXFxcIm1vdXNlZW50ZXIuemYuZHJvcGRvd25tZW51XFxcIixmdW5jdGlvbihpKXt2YXIgcz10KHRoaXMpLG89cy5oYXNDbGFzcyhuKTtvJiYoY2xlYXJUaW1lb3V0KGUuZGVsYXkpLGUuZGVsYXk9c2V0VGltZW91dChmdW5jdGlvbigpe2UuX3Nob3cocy5jaGlsZHJlbihcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKSk7fSxlLm9wdGlvbnMuaG92ZXJEZWxheSkpO30pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLmRyb3Bkb3dubWVudVxcXCIsZnVuY3Rpb24oaSl7dmFyIHM9dCh0aGlzKSxvPXMuaGFzQ2xhc3Mobik7aWYobyYmZS5vcHRpb25zLmF1dG9jbG9zZSl7aWYoXFxcInRydWVcXFwiPT09cy5hdHRyKFxcXCJkYXRhLWlzLWNsaWNrXFxcIikmJmUub3B0aW9ucy5jbGlja09wZW4pcmV0dXJuITE7Y2xlYXJUaW1lb3V0KGUuZGVsYXkpLGUuZGVsYXk9c2V0VGltZW91dChmdW5jdGlvbigpe2UuX2hpZGUocyk7fSxlLm9wdGlvbnMuY2xvc2luZ1RpbWUpO319KSx0aGlzLiRtZW51SXRlbXMub24oXFxcImtleWRvd24uemYuZHJvcGRvd25tZW51XFxcIixmdW5jdGlvbihpKXt2YXIgbixzLG89dChpLnRhcmdldCkucGFyZW50c1VudGlsKFxcXCJ1bFxcXCIsJ1tyb2xlPVxcXCJtZW51aXRlbVxcXCJdJyksYT1lLiR0YWJzLmluZGV4KG8pPi0xLHI9YT9lLiR0YWJzOm8uc2libGluZ3MoXFxcImxpXFxcIikuYWRkKG8pO3IuZWFjaChmdW5jdGlvbihlKXtpZih0KHRoaXMpLmlzKG8pKXJldHVybiBuPXIuZXEoZS0xKSx2b2lkKHM9ci5lcShlKzEpKTt9KTt2YXIgbD1mdW5jdGlvbiBsKCl7by5pcyhcXFwiOmxhc3QtY2hpbGRcXFwiKXx8KHMuY2hpbGRyZW4oXFxcImE6Zmlyc3RcXFwiKS5mb2N1cygpLGkucHJldmVudERlZmF1bHQoKSk7fSx1PWZ1bmN0aW9uIHUoKXtuLmNoaWxkcmVuKFxcXCJhOmZpcnN0XFxcIikuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCk7fSxkPWZ1bmN0aW9uIGQoKXt2YXIgdD1vLmNoaWxkcmVuKFxcXCJ1bC5pcy1kcm9wZG93bi1zdWJtZW51XFxcIik7dC5sZW5ndGgmJihlLl9zaG93KHQpLG8uZmluZChcXFwibGkgPiBhOmZpcnN0XFxcIikuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpO30saD1mdW5jdGlvbiBoKCl7dmFyIHQ9by5wYXJlbnQoXFxcInVsXFxcIikucGFyZW50KFxcXCJsaVxcXCIpO3QuY2hpbGRyZW4oXFxcImE6Zmlyc3RcXFwiKS5mb2N1cygpLGUuX2hpZGUodCksaS5wcmV2ZW50RGVmYXVsdCgpO30sYz17b3BlbjpkLGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ZS5faGlkZShlLiRlbGVtZW50KSxlLiRtZW51SXRlbXMuZmluZChcXFwiYTpmaXJzdFxcXCIpLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7aS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTt9fTthP2UuX2lzVmVydGljYWwoKT9Gb3VuZGF0aW9uLnJ0bCgpP3QuZXh0ZW5kKGMse2Rvd246bCx1cDp1LG5leHQ6aCxwcmV2aW91czpkfSk6dC5leHRlbmQoYyx7ZG93bjpsLHVwOnUsbmV4dDpkLHByZXZpb3VzOmh9KTpGb3VuZGF0aW9uLnJ0bCgpP3QuZXh0ZW5kKGMse25leHQ6dSxwcmV2aW91czpsLGRvd246ZCx1cDpofSk6dC5leHRlbmQoYyx7bmV4dDpsLHByZXZpb3VzOnUsZG93bjpkLHVwOmh9KTpGb3VuZGF0aW9uLnJ0bCgpP3QuZXh0ZW5kKGMse25leHQ6aCxwcmV2aW91czpkLGRvd246bCx1cDp1fSk6dC5leHRlbmQoYyx7bmV4dDpkLHByZXZpb3VzOmgsZG93bjpsLHVwOnV9KSxGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJEcm9wZG93bk1lbnVcXFwiLGMpO30pO319LHtrZXk6XFxcIl9hZGRCb2R5SGFuZGxlclxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10KGRvY3VtZW50LmJvZHkpLGk9dGhpcztlLm9mZihcXFwibW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51XFxcIikub24oXFxcIm1vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudVxcXCIsZnVuY3Rpb24odCl7dmFyIG49aS4kZWxlbWVudC5maW5kKHQudGFyZ2V0KTtuLmxlbmd0aHx8KGkuX2hpZGUoKSxlLm9mZihcXFwibW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51XFxcIikpO30pO319LHtrZXk6XFxcIl9zaG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzLiR0YWJzLmluZGV4KHRoaXMuJHRhYnMuZmlsdGVyKGZ1bmN0aW9uKGksbil7cmV0dXJuIHQobikuZmluZChlKS5sZW5ndGg+MDt9KSksbj1lLnBhcmVudChcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5zaWJsaW5ncyhcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKTt0aGlzLl9oaWRlKG4saSksZS5jc3MoXFxcInZpc2liaWxpdHlcXFwiLFxcXCJoaWRkZW5cXFwiKS5hZGRDbGFzcyhcXFwianMtZHJvcGRvd24tYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMX0pLnBhcmVudChcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtZXhwYW5kZWRcXFwiOiEwfSk7dmFyIHM9Rm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdShlLG51bGwsITApO2lmKCFzKXt2YXIgbz1cXFwibGVmdFxcXCI9PT10aGlzLm9wdGlvbnMuYWxpZ25tZW50P1xcXCItcmlnaHRcXFwiOlxcXCItbGVmdFxcXCIsYT1lLnBhcmVudChcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIik7YS5yZW1vdmVDbGFzcyhcXFwib3BlbnNcXFwiK28pLmFkZENsYXNzKFxcXCJvcGVucy1cXFwiK3RoaXMub3B0aW9ucy5hbGlnbm1lbnQpLHM9Rm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdShlLG51bGwsITApLHN8fGEucmVtb3ZlQ2xhc3MoXFxcIm9wZW5zLVxcXCIrdGhpcy5vcHRpb25zLmFsaWdubWVudCkuYWRkQ2xhc3MoXFxcIm9wZW5zLWlubmVyXFxcIiksdGhpcy5jaGFuZ2VkPSEwO31lLmNzcyhcXFwidmlzaWJpbGl0eVxcXCIsXFxcIlxcXCIpLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuX2FkZEJvZHlIYW5kbGVyKCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzaG93LnpmLmRyb3Bkb3dubWVudVxcXCIsW2VdKTt9fSx7a2V5OlxcXCJfaGlkZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXt2YXIgaTtpPXQmJnQubGVuZ3RoP3Q6dm9pZCAwIT09ZT90aGlzLiR0YWJzLm5vdChmdW5jdGlvbih0LGkpe3JldHVybiB0PT09ZTt9KTp0aGlzLiRlbGVtZW50O3ZhciBuPWkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpfHxpLmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKS5sZW5ndGg+MDtpZihuKXtpZihpLmZpbmQoXFxcImxpLmlzLWFjdGl2ZVxcXCIpLmFkZChpKS5hdHRyKHtcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITEsXFxcImRhdGEtaXMtY2xpY2tcXFwiOiExfSkucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLGkuZmluZChcXFwidWwuanMtZHJvcGRvd24tYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMH0pLnJlbW92ZUNsYXNzKFxcXCJqcy1kcm9wZG93bi1hY3RpdmVcXFwiKSx0aGlzLmNoYW5nZWR8fGkuZmluZChcXFwib3BlbnMtaW5uZXJcXFwiKS5sZW5ndGgpe3ZhciBzPVxcXCJsZWZ0XFxcIj09PXRoaXMub3B0aW9ucy5hbGlnbm1lbnQ/XFxcInJpZ2h0XFxcIjpcXFwibGVmdFxcXCI7aS5maW5kKFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLmFkZChpKS5yZW1vdmVDbGFzcyhcXFwib3BlbnMtaW5uZXIgb3BlbnMtXFxcIit0aGlzLm9wdGlvbnMuYWxpZ25tZW50KS5hZGRDbGFzcyhcXFwib3BlbnMtXFxcIitzKSx0aGlzLmNoYW5nZWQ9ITE7fXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiaGlkZS56Zi5kcm9wZG93bm1lbnVcXFwiLFtpXSk7fX19LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kbWVudUl0ZW1zLm9mZihcXFwiLnpmLmRyb3Bkb3dubWVudVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtaXMtY2xpY2tcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtcmlnaHQtYXJyb3cgaXMtbGVmdC1hcnJvdyBpcy1kb3duLWFycm93IG9wZW5zLXJpZ2h0IG9wZW5zLWxlZnQgb3BlbnMtaW5uZXJcXFwiKSx0KGRvY3VtZW50LmJvZHkpLm9mZihcXFwiLnpmLmRyb3Bkb3dubWVudVxcXCIpLEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsXFxcImRyb3Bkb3duXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17ZGlzYWJsZUhvdmVyOiExLGF1dG9jbG9zZTohMCxob3ZlckRlbGF5OjUwLGNsaWNrT3BlbjohMSxjbG9zaW5nVGltZTo1MDAsYWxpZ25tZW50OlxcXCJsZWZ0XFxcIixjbG9zZU9uQ2xpY2s6ITAsY2xvc2VPbkNsaWNrSW5zaWRlOiEwLHZlcnRpY2FsQ2xhc3M6XFxcInZlcnRpY2FsXFxcIixyaWdodENsYXNzOlxcXCJhbGlnbi1yaWdodFxcXCIsZm9yY2VGb2xsb3c6ITB9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkRyb3Bkb3duTWVudVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiRXF1YWxpemVyXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLWVxdWFsaXplclxcXCIpfHxcXFwiXFxcIixpPXRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyLXdhdGNoPVxcXCInK2UrJ1xcXCJdJyk7dGhpcy4kd2F0Y2hlZD1pLmxlbmd0aD9pOnRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtZXF1YWxpemVyLXdhdGNoXVxcXCIpLHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1yZXNpemVcXFwiLGV8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwiZXFcXFwiKSksdGhpcy5oYXNOZXN0ZWQ9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1lcXVhbGl6ZXJdXFxcIikubGVuZ3RoPjAsdGhpcy5pc05lc3RlZD10aGlzLiRlbGVtZW50LnBhcmVudHNVbnRpbChkb2N1bWVudC5ib2R5LFxcXCJbZGF0YS1lcXVhbGl6ZXJdXFxcIikubGVuZ3RoPjAsdGhpcy5pc09uPSExLHRoaXMuX2JpbmRIYW5kbGVyPXtvblJlc2l6ZU1lQm91bmQ6dGhpcy5fb25SZXNpemVNZS5iaW5kKHRoaXMpLG9uUG9zdEVxdWFsaXplZEJvdW5kOnRoaXMuX29uUG9zdEVxdWFsaXplZC5iaW5kKHRoaXMpfTt2YXIgbixzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiaW1nXFxcIik7dGhpcy5vcHRpb25zLmVxdWFsaXplT24/KG49dGhpcy5fY2hlY2tNUSgpLHQod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIix0aGlzLl9jaGVja01RLmJpbmQodGhpcykpKTp0aGlzLl9ldmVudHMoKSwodm9pZCAwIT09biYmbj09PSExfHx2b2lkIDA9PT1uKSYmKHMubGVuZ3RoP0ZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQocyx0aGlzLl9yZWZsb3cuYmluZCh0aGlzKSk6dGhpcy5fcmVmbG93KCkpO319LHtrZXk6XFxcIl9wYXVzZUV2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmlzT249ITEsdGhpcy4kZWxlbWVudC5vZmYoe1xcXCIuemYuZXF1YWxpemVyXFxcIjp0aGlzLl9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZCxcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCI6dGhpcy5fYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kfSk7fX0se2tleTpcXFwiX29uUmVzaXplTWVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3RoaXMuX3JlZmxvdygpO319LHtrZXk6XFxcIl9vblBvc3RFcXVhbGl6ZWRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3QudGFyZ2V0IT09dGhpcy4kZWxlbWVudFswXSYmdGhpcy5fcmVmbG93KCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9wYXVzZUV2ZW50cygpLHRoaXMuaGFzTmVzdGVkP3RoaXMuJGVsZW1lbnQub24oXFxcInBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyXFxcIix0aGlzLl9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZCk6dGhpcy4kZWxlbWVudC5vbihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIsdGhpcy5fYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kKSx0aGlzLmlzT249ITA7fX0se2tleTpcXFwiX2NoZWNrTVFcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9IUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uKTtyZXR1cm4gdD90aGlzLmlzT24mJih0aGlzLl9wYXVzZUV2ZW50cygpLHRoaXMuJHdhdGNoZWQuY3NzKFxcXCJoZWlnaHRcXFwiLFxcXCJhdXRvXFxcIikpOnRoaXMuaXNPbnx8dGhpcy5fZXZlbnRzKCksdDt9fSx7a2V5OlxcXCJfa2lsbHN3aXRjaFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt9fSx7a2V5OlxcXCJfcmVmbG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3JldHVybiF0aGlzLm9wdGlvbnMuZXF1YWxpemVPblN0YWNrJiZ0aGlzLl9pc1N0YWNrZWQoKT8odGhpcy4kd2F0Y2hlZC5jc3MoXFxcImhlaWdodFxcXCIsXFxcImF1dG9cXFwiKSwhMSk6dm9pZCh0aGlzLm9wdGlvbnMuZXF1YWxpemVCeVJvdz90aGlzLmdldEhlaWdodHNCeVJvdyh0aGlzLmFwcGx5SGVpZ2h0QnlSb3cuYmluZCh0aGlzKSk6dGhpcy5nZXRIZWlnaHRzKHRoaXMuYXBwbHlIZWlnaHQuYmluZCh0aGlzKSkpO319LHtrZXk6XFxcIl9pc1N0YWNrZWRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7cmV0dXJuIHRoaXMuJHdhdGNoZWRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIT09dGhpcy4kd2F0Y2hlZFsxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7fX0se2tleTpcXFwiZ2V0SGVpZ2h0c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7Zm9yKHZhciBlPVtdLGk9MCxuPXRoaXMuJHdhdGNoZWQubGVuZ3RoO2k8bjtpKyspe3RoaXMuJHdhdGNoZWRbaV0uc3R5bGUuaGVpZ2h0PVxcXCJhdXRvXFxcIixlLnB1c2godGhpcy4kd2F0Y2hlZFtpXS5vZmZzZXRIZWlnaHQpO310KGUpO319LHtrZXk6XFxcImdldEhlaWdodHNCeVJvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9dGhpcy4kd2F0Y2hlZC5sZW5ndGg/dGhpcy4kd2F0Y2hlZC5maXJzdCgpLm9mZnNldCgpLnRvcDowLG49W10scz0wO25bc109W107Zm9yKHZhciBvPTAsYT10aGlzLiR3YXRjaGVkLmxlbmd0aDtvPGE7bysrKXt0aGlzLiR3YXRjaGVkW29dLnN0eWxlLmhlaWdodD1cXFwiYXV0b1xcXCI7dmFyIHI9dCh0aGlzLiR3YXRjaGVkW29dKS5vZmZzZXQoKS50b3A7ciE9aSYmKHMrKyxuW3NdPVtdLGk9ciksbltzXS5wdXNoKFt0aGlzLiR3YXRjaGVkW29dLHRoaXMuJHdhdGNoZWRbb10ub2Zmc2V0SGVpZ2h0XSk7fWZvcih2YXIgbD0wLHU9bi5sZW5ndGg7bDx1O2wrKyl7dmFyIGQ9dChuW2xdKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1sxXTt9KS5nZXQoKSxoPU1hdGgubWF4LmFwcGx5KG51bGwsZCk7bltsXS5wdXNoKGgpO31lKG4pO319LHtrZXk6XFxcImFwcGx5SGVpZ2h0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT1NYXRoLm1heC5hcHBseShudWxsLHQpO3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicHJlZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIpLHRoaXMuJHdhdGNoZWQuY3NzKFxcXCJoZWlnaHRcXFwiLGUpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiKTt9fSx7a2V5OlxcXCJhcHBseUhlaWdodEJ5Um93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInByZWVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiKTtmb3IodmFyIGk9MCxuPWUubGVuZ3RoO2k8bjtpKyspe3ZhciBzPWVbaV0ubGVuZ3RoLG89ZVtpXVtzLTFdO2lmKHM8PTIpdChlW2ldWzBdWzBdKS5jc3Moe2hlaWdodDpcXFwiYXV0b1xcXCJ9KTtlbHNle3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicHJlZXF1YWxpemVkcm93LnpmLmVxdWFsaXplclxcXCIpO2Zvcih2YXIgYT0wLHI9cy0xO2E8cjthKyspe3QoZVtpXVthXVswXSkuY3NzKHtoZWlnaHQ6b30pO310aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInBvc3RlcXVhbGl6ZWRyb3cuemYuZXF1YWxpemVyXFxcIik7fX10aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyXFxcIik7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9wYXVzZUV2ZW50cygpLHRoaXMuJHdhdGNoZWQuY3NzKFxcXCJoZWlnaHRcXFwiLFxcXCJhdXRvXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17ZXF1YWxpemVPblN0YWNrOiExLGVxdWFsaXplQnlSb3c6ITEsZXF1YWxpemVPbjpcXFwiXFxcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiRXF1YWxpemVyXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyxuKSx0aGlzLnJ1bGVzPVtdLHRoaXMuY3VycmVudFBhdGg9XFxcIlxcXCIsdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiSW50ZXJjaGFuZ2VcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9hZGRCcmVha3BvaW50cygpLHRoaXMuX2dlbmVyYXRlUnVsZXMoKSx0aGlzLl9yZWZsb3coKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3Qod2luZG93KS5vbihcXFwicmVzaXplLnpmLmludGVyY2hhbmdlXFxcIixGb3VuZGF0aW9uLnV0aWwudGhyb3R0bGUodGhpcy5fcmVmbG93LmJpbmQodGhpcyksNTApKTt9fSx7a2V5OlxcXCJfcmVmbG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0O2Zvcih2YXIgZSBpbiB0aGlzLnJ1bGVzKXtpZih0aGlzLnJ1bGVzLmhhc093blByb3BlcnR5KGUpKXt2YXIgaT10aGlzLnJ1bGVzW2VdO3dpbmRvdy5tYXRjaE1lZGlhKGkucXVlcnkpLm1hdGNoZXMmJih0PWkpO319dCYmdGhpcy5yZXBsYWNlKHQucGF0aCk7fX0se2tleTpcXFwiX2FkZEJyZWFrcG9pbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2Zvcih2YXIgdCBpbiBGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllcyl7aWYoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXMuaGFzT3duUHJvcGVydHkodCkpe3ZhciBpPUZvdW5kYXRpb24uTWVkaWFRdWVyeS5xdWVyaWVzW3RdO2UuU1BFQ0lBTF9RVUVSSUVTW2kubmFtZV09aS52YWx1ZTt9fX19LHtrZXk6XFxcIl9nZW5lcmF0ZVJ1bGVzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgaSxuPVtdO2k9dGhpcy5vcHRpb25zLnJ1bGVzP3RoaXMub3B0aW9ucy5ydWxlczp0aGlzLiRlbGVtZW50LmRhdGEoXFxcImludGVyY2hhbmdlXFxcIikubWF0Y2goL1xcXFxbLio/XFxcXF0vZyk7Zm9yKHZhciBzIGluIGkpe2lmKGkuaGFzT3duUHJvcGVydHkocykpe3ZhciBvPWlbc10uc2xpY2UoMSwtMSkuc3BsaXQoXFxcIiwgXFxcIiksYT1vLnNsaWNlKDAsLTEpLmpvaW4oXFxcIlxcXCIpLHI9b1tvLmxlbmd0aC0xXTtlLlNQRUNJQUxfUVVFUklFU1tyXSYmKHI9ZS5TUEVDSUFMX1FVRVJJRVNbcl0pLG4ucHVzaCh7cGF0aDphLHF1ZXJ5OnJ9KTt9fXRoaXMucnVsZXM9bjt9fSx7a2V5OlxcXCJyZXBsYWNlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXtpZih0aGlzLmN1cnJlbnRQYXRoIT09ZSl7dmFyIGk9dGhpcyxuPVxcXCJyZXBsYWNlZC56Zi5pbnRlcmNoYW5nZVxcXCI7XFxcIklNR1xcXCI9PT10aGlzLiRlbGVtZW50WzBdLm5vZGVOYW1lP3RoaXMuJGVsZW1lbnQuYXR0cihcXFwic3JjXFxcIixlKS5vbihcXFwibG9hZFxcXCIsZnVuY3Rpb24oKXtpLmN1cnJlbnRQYXRoPWU7fSkudHJpZ2dlcihuKTplLm1hdGNoKC9cXFxcLihnaWZ8anBnfGpwZWd8cG5nfHN2Z3x0aWZmKShbPyNdLiopPy9pKT90aGlzLiRlbGVtZW50LmNzcyh7XFxcImJhY2tncm91bmQtaW1hZ2VcXFwiOlxcXCJ1cmwoXFxcIitlK1xcXCIpXFxcIn0pLnRyaWdnZXIobik6dC5nZXQoZSxmdW5jdGlvbihzKXtpLiRlbGVtZW50Lmh0bWwocykudHJpZ2dlcihuKSx0KHMpLmZvdW5kYXRpb24oKSxpLmN1cnJlbnRQYXRoPWU7fSk7fX19LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtydWxlczpudWxsfSxlLlNQRUNJQUxfUVVFUklFUz17bGFuZHNjYXBlOlxcXCJzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKVxcXCIscG9ydHJhaXQ6XFxcInNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcXFwiLHJldGluYTpcXFwib25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMi8xKSwgb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpXFxcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiSW50ZXJjaGFuZ2VcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIk1hZ2VsbGFuXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudFswXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJtYWdlbGxhblxcXCIpO3RoaXMuJHRhcmdldHM9dChcXFwiW2RhdGEtbWFnZWxsYW4tdGFyZ2V0XVxcXCIpLHRoaXMuJGxpbmtzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiYVxcXCIpLHRoaXMuJGVsZW1lbnQuYXR0cih7XFxcImRhdGEtcmVzaXplXFxcIjplLFxcXCJkYXRhLXNjcm9sbFxcXCI6ZSxpZDplfSksdGhpcy4kYWN0aXZlPXQoKSx0aGlzLnNjcm9sbFBvcz1wYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsMTApLHRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcImNhbGNQb2ludHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcyxpPWRvY3VtZW50LmJvZHksbj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7dGhpcy5wb2ludHM9W10sdGhpcy53aW5IZWlnaHQ9TWF0aC5yb3VuZChNYXRoLm1heCh3aW5kb3cuaW5uZXJIZWlnaHQsbi5jbGllbnRIZWlnaHQpKSx0aGlzLmRvY0hlaWdodD1NYXRoLnJvdW5kKE1hdGgubWF4KGkuc2Nyb2xsSGVpZ2h0LGkub2Zmc2V0SGVpZ2h0LG4uY2xpZW50SGVpZ2h0LG4uc2Nyb2xsSGVpZ2h0LG4ub2Zmc2V0SGVpZ2h0KSksdGhpcy4kdGFyZ2V0cy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPU1hdGgucm91bmQoaS5vZmZzZXQoKS50b3AtZS5vcHRpb25zLnRocmVzaG9sZCk7aS50YXJnZXRQb2ludD1uLGUucG9pbnRzLnB1c2gobik7fSk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3QoXFxcImh0bWwsIGJvZHlcXFwiKSx7ZHVyYXRpb246ZS5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLGVhc2luZzplLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nfTt0KHdpbmRvdykub25lKFxcXCJsb2FkXFxcIixmdW5jdGlvbigpe2Uub3B0aW9ucy5kZWVwTGlua2luZyYmbG9jYXRpb24uaGFzaCYmZS5zY3JvbGxUb0xvYyhsb2NhdGlvbi5oYXNoKSxlLmNhbGNQb2ludHMoKSxlLl91cGRhdGVBY3RpdmUoKTt9KSx0aGlzLiRlbGVtZW50Lm9uKHtcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCI6dGhpcy5yZWZsb3cuYmluZCh0aGlzKSxcXFwic2Nyb2xsbWUuemYudHJpZ2dlclxcXCI6dGhpcy5fdXBkYXRlQWN0aXZlLmJpbmQodGhpcyl9KS5vbihcXFwiY2xpY2suemYubWFnZWxsYW5cXFwiLCdhW2hyZWZePVxcXCIjXFxcIl0nLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKTt2YXIgaT10aGlzLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpO2Uuc2Nyb2xsVG9Mb2MoaSk7fSk7fX0se2tleTpcXFwic2Nyb2xsVG9Mb2NcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe2lmKCF0KGUpLmxlbmd0aClyZXR1cm4hMTt2YXIgaT1NYXRoLnJvdW5kKHQoZSkub2Zmc2V0KCkudG9wLXRoaXMub3B0aW9ucy50aHJlc2hvbGQvMi10aGlzLm9wdGlvbnMuYmFyT2Zmc2V0KTt0KFxcXCJodG1sLCBib2R5XFxcIikuc3RvcCghMCkuYW5pbWF0ZSh7c2Nyb2xsVG9wOml9LHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbix0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nKTt9fSx7a2V5OlxcXCJyZWZsb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5jYWxjUG9pbnRzKCksdGhpcy5fdXBkYXRlQWN0aXZlKCk7fX0se2tleTpcXFwiX3VwZGF0ZUFjdGl2ZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdCxlPXBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwxMCk7aWYoZSt0aGlzLndpbkhlaWdodD09PXRoaXMuZG9jSGVpZ2h0KXQ9dGhpcy5wb2ludHMubGVuZ3RoLTE7ZWxzZSBpZihlPHRoaXMucG9pbnRzWzBdKXQ9MDtlbHNle3ZhciBpPXRoaXMuc2Nyb2xsUG9zPGUsbj10aGlzLHM9dGhpcy5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHQscyl7cmV0dXJuIGk/dC1uLm9wdGlvbnMuYmFyT2Zmc2V0PD1lOnQtbi5vcHRpb25zLmJhck9mZnNldC1uLm9wdGlvbnMudGhyZXNob2xkPD1lO30pO3Q9cy5sZW5ndGg/cy5sZW5ndGgtMTowO31pZih0aGlzLiRhY3RpdmUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSx0aGlzLiRhY3RpdmU9dGhpcy4kbGlua3MuZmlsdGVyKCdbaHJlZj1cXFwiIycrdGhpcy4kdGFyZ2V0cy5lcSh0KS5kYXRhKFxcXCJtYWdlbGxhbi10YXJnZXRcXFwiKSsnXFxcIl0nKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLHRoaXMub3B0aW9ucy5kZWVwTGlua2luZyl7dmFyIG89dGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpO3dpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZT93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCxudWxsLG8pOndpbmRvdy5sb2NhdGlvbi5oYXNoPW87fXRoaXMuc2Nyb2xsUG9zPWUsdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJ1cGRhdGUuemYubWFnZWxsYW5cXFwiLFt0aGlzLiRhY3RpdmVdKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKHRoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudHJpZ2dlciAuemYubWFnZWxsYW5cXFwiKS5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyksdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKXt2YXIgdD10aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIik7d2luZG93LmxvY2F0aW9uLmhhc2gucmVwbGFjZSh0LFxcXCJcXFwiKTt9Rm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17YW5pbWF0aW9uRHVyYXRpb246NTAwLGFuaW1hdGlvbkVhc2luZzpcXFwibGluZWFyXFxcIix0aHJlc2hvbGQ6NTAsYWN0aXZlQ2xhc3M6XFxcImFjdGl2ZVxcXCIsZGVlcExpbmtpbmc6ITEsYmFyT2Zmc2V0OjB9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIk1hZ2VsbGFuXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLiRsYXN0VHJpZ2dlcj10KCksdGhpcy4kdHJpZ2dlcnM9dCgpLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIk9mZkNhbnZhc1xcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIk9mZkNhbnZhc1xcXCIse0VTQ0FQRTpcXFwiY2xvc2VcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpO2lmKHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLFxcXCJ0cnVlXFxcIiksdGhpcy4kdHJpZ2dlcnM9dChkb2N1bWVudCkuZmluZCgnW2RhdGEtb3Blbj1cXFwiJytlKydcXFwiXSwgW2RhdGEtY2xvc2U9XFxcIicrZSsnXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiJytlKydcXFwiXScpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLFxcXCJmYWxzZVxcXCIpLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiLGUpLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spaWYodChcXFwiLmpzLW9mZi1jYW52YXMtZXhpdFxcXCIpLmxlbmd0aCl0aGlzLiRleGl0ZXI9dChcXFwiLmpzLW9mZi1jYW52YXMtZXhpdFxcXCIpO2Vsc2V7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7aS5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIixcXFwianMtb2ZmLWNhbnZhcy1leGl0XFxcIiksdChcXFwiW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XVxcXCIpLmFwcGVuZChpKSx0aGlzLiRleGl0ZXI9dChpKTt9dGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQ9dGhpcy5vcHRpb25zLmlzUmV2ZWFsZWR8fG5ldyBSZWdFeHAodGhpcy5vcHRpb25zLnJldmVhbENsYXNzLFxcXCJnXFxcIikudGVzdCh0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZSksdGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQmJih0aGlzLm9wdGlvbnMucmV2ZWFsT249dGhpcy5vcHRpb25zLnJldmVhbE9ufHx0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHJldmVhbC1mb3ItbWVkaXVtfHJldmVhbC1mb3ItbGFyZ2UpL2cpWzBdLnNwbGl0KFxcXCItXFxcIilbMl0sdGhpcy5fc2V0TVFDaGVja2VyKCkpLHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZXx8KHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZT0xZTMqcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KFxcXCJbZGF0YS1vZmYtY2FudmFzLXdyYXBwZXJdXFxcIilbMF0pLnRyYW5zaXRpb25EdXJhdGlvbikpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXNcXFwiKS5vbih7XFxcIm9wZW4uemYudHJpZ2dlclxcXCI6dGhpcy5vcGVuLmJpbmQodGhpcyksXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiOnRoaXMuY2xvc2UuYmluZCh0aGlzKSxcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiOnRoaXMudG9nZ2xlLmJpbmQodGhpcyksXFxcImtleWRvd24uemYub2ZmY2FudmFzXFxcIjp0aGlzLl9oYW5kbGVLZXlib2FyZC5iaW5kKHRoaXMpfSksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy4kZXhpdGVyLmxlbmd0aCYmdGhpcy4kZXhpdGVyLm9uKHtcXFwiY2xpY2suemYub2ZmY2FudmFzXFxcIjp0aGlzLmNsb3NlLmJpbmQodGhpcyl9KTt9fSx7a2V5OlxcXCJfc2V0TVFDaGVja2VyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLGZ1bmN0aW9uKCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoZS5vcHRpb25zLnJldmVhbE9uKT9lLnJldmVhbCghMCk6ZS5yZXZlYWwoITEpO30pLm9uZShcXFwibG9hZC56Zi5vZmZjYW52YXNcXFwiLGZ1bmN0aW9uKCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoZS5vcHRpb25zLnJldmVhbE9uKSYmZS5yZXZlYWwoITApO30pO319LHtrZXk6XFxcInJldmVhbFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1jbG9zZV1cXFwiKTt0Pyh0aGlzLmNsb3NlKCksdGhpcy5pc1JldmVhbGVkPSEwLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJvcGVuLnpmLnRyaWdnZXIgdG9nZ2xlLnpmLnRyaWdnZXJcXFwiKSxlLmxlbmd0aCYmZS5oaWRlKCkpOih0aGlzLmlzUmV2ZWFsZWQ9ITEsdGhpcy4kZWxlbWVudC5vbih7XFxcIm9wZW4uemYudHJpZ2dlclxcXCI6dGhpcy5vcGVuLmJpbmQodGhpcyksXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIjp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpfSksZS5sZW5ndGgmJmUuc2hvdygpKTt9fSx7a2V5OlxcXCJvcGVuXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlLGkpe2lmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikmJiF0aGlzLmlzUmV2ZWFsZWQpe3ZhciBuPXRoaXM7dChkb2N1bWVudC5ib2R5KTt0aGlzLm9wdGlvbnMuZm9yY2VUb3AmJnQoXFxcImJvZHlcXFwiKS5zY3JvbGxUb3AoMCk7dmFyIHM9dChcXFwiW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXVxcXCIpO3MuYWRkQ2xhc3MoXFxcImlzLW9mZi1jYW52YXMtb3BlbiBpcy1vcGVuLVxcXCIrbi5vcHRpb25zLnBvc2l0aW9uKSxuLiRlbGVtZW50LmFkZENsYXNzKFxcXCJpcy1vcGVuXFxcIiksdGhpcy4kdHJpZ2dlcnMuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsXFxcInRydWVcXFwiKSx0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIixcXFwiZmFsc2VcXFwiKS50cmlnZ2VyKFxcXCJvcGVuZWQuemYub2ZmY2FudmFzXFxcIiksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy4kZXhpdGVyLmFkZENsYXNzKFxcXCJpcy12aXNpYmxlXFxcIiksaSYmKHRoaXMuJGxhc3RUcmlnZ2VyPWkpLHRoaXMub3B0aW9ucy5hdXRvRm9jdXMmJnMub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZChzKSxmdW5jdGlvbigpe24uJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSYmKG4uJGVsZW1lbnQuYXR0cihcXFwidGFiaW5kZXhcXFwiLFxcXCItMVxcXCIpLG4uJGVsZW1lbnQuZm9jdXMoKSk7fSksdGhpcy5vcHRpb25zLnRyYXBGb2N1cyYmcy5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHMpLGZ1bmN0aW9uKCl7bi4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtb3BlblxcXCIpJiYobi4kZWxlbWVudC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsXFxcIi0xXFxcIiksbi50cmFwRm9jdXMoKSk7fSk7fX19LHtrZXk6XFxcIl90cmFwRm9jdXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9Rm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpLGU9dC5lcSgwKSxpPXQuZXEoLTEpO3Qub2ZmKFxcXCIuemYub2ZmY2FudmFzXFxcIikub24oXFxcImtleWRvd24uemYub2ZmY2FudmFzXFxcIixmdW5jdGlvbih0KXt2YXIgbj1Gb3VuZGF0aW9uLktleWJvYXJkLnBhcnNlS2V5KHQpO1xcXCJUQUJcXFwiPT09biYmdC50YXJnZXQ9PT1pWzBdJiYodC5wcmV2ZW50RGVmYXVsdCgpLGUuZm9jdXMoKSksXFxcIlNISUZUX1RBQlxcXCI9PT1uJiZ0LnRhcmdldD09PWVbMF0mJih0LnByZXZlbnREZWZhdWx0KCksaS5mb2N1cygpKTt9KTt9fSx7a2V5OlxcXCJjbG9zZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7aWYodGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtb3BlblxcXCIpJiYhdGhpcy5pc1JldmVhbGVkKXt2YXIgaT10aGlzO3QoXFxcIltkYXRhLW9mZi1jYW52YXMtd3JhcHBlcl1cXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtb2ZmLWNhbnZhcy1vcGVuIGlzLW9wZW4tXFxcIitpLm9wdGlvbnMucG9zaXRpb24pLGkuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSx0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIixcXFwidHJ1ZVxcXCIpLnRyaWdnZXIoXFxcImNsb3NlZC56Zi5vZmZjYW52YXNcXFwiKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiZ0aGlzLiRleGl0ZXIucmVtb3ZlQ2xhc3MoXFxcImlzLXZpc2libGVcXFwiKSx0aGlzLiR0cmlnZ2Vycy5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIixcXFwiZmFsc2VcXFwiKSx0aGlzLm9wdGlvbnMudHJhcEZvY3VzJiZ0KFxcXCJbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdXFxcIikucmVtb3ZlQXR0cihcXFwidGFiaW5kZXhcXFwiKTt9fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGUpe3RoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKT90aGlzLmNsb3NlKHQsZSk6dGhpcy5vcGVuKHQsZSk7fX0se2tleTpcXFwiX2hhbmRsZUtleWJvYXJkXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzO0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KHQsXFxcIk9mZkNhbnZhc1xcXCIse2Nsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7cmV0dXJuIGUuY2xvc2UoKSxlLiRsYXN0VHJpZ2dlci5mb2N1cygpLCEwO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7dC5zdG9wUHJvcGFnYXRpb24oKSx0LnByZXZlbnREZWZhdWx0KCk7fX0pO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5jbG9zZSgpLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudHJpZ2dlciAuemYub2ZmY2FudmFzXFxcIiksdGhpcy4kZXhpdGVyLm9mZihcXFwiLnpmLm9mZmNhbnZhc1xcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2Nsb3NlT25DbGljazohMCx0cmFuc2l0aW9uVGltZTowLHBvc2l0aW9uOlxcXCJsZWZ0XFxcIixmb3JjZVRvcDohMCxpc1JldmVhbGVkOiExLHJldmVhbE9uOm51bGwsYXV0b0ZvY3VzOiEwLHJldmVhbENsYXNzOlxcXCJyZXZlYWwtZm9yLVxcXCIsdHJhcEZvY3VzOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJPZmZDYW52YXNcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIk9yYml0XFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiT3JiaXRcXFwiLHtsdHI6e0FSUk9XX1JJR0hUOlxcXCJuZXh0XFxcIixBUlJPV19MRUZUOlxcXCJwcmV2aW91c1xcXCJ9LHJ0bDp7QVJST1dfTEVGVDpcXFwibmV4dFxcXCIsQVJST1dfUklHSFQ6XFxcInByZXZpb3VzXFxcIn19KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiR3cmFwcGVyPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKSx0aGlzLiRzbGlkZXM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk7dmFyIHQ9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJpbWdcXFwiKSxlPXRoaXMuJHNsaWRlcy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKTtlLmxlbmd0aHx8dGhpcy4kc2xpZGVzLmVxKDApLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSx0aGlzLm9wdGlvbnMudXNlTVVJfHx0aGlzLiRzbGlkZXMuYWRkQ2xhc3MoXFxcIm5vLW1vdGlvbnVpXFxcIiksdC5sZW5ndGg/Rm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCh0LHRoaXMuX3ByZXBhcmVGb3JPcmJpdC5iaW5kKHRoaXMpKTp0aGlzLl9wcmVwYXJlRm9yT3JiaXQoKSx0aGlzLm9wdGlvbnMuYnVsbGV0cyYmdGhpcy5fbG9hZEJ1bGxldHMoKSx0aGlzLl9ldmVudHMoKSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJnRoaXMuJHNsaWRlcy5sZW5ndGg+MSYmdGhpcy5nZW9TeW5jKCksdGhpcy5vcHRpb25zLmFjY2Vzc2libGUmJnRoaXMuJHdyYXBwZXIuYXR0cihcXFwidGFiaW5kZXhcXFwiLDApO319LHtrZXk6XFxcIl9sb2FkQnVsbGV0c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRidWxsZXRzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykuZmluZChcXFwiYnV0dG9uXFxcIik7fX0se2tleTpcXFwiZ2VvU3luY1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzO3RoaXMudGltZXI9bmV3IEZvdW5kYXRpb24uVGltZXIodGhpcy4kZWxlbWVudCx7ZHVyYXRpb246dGhpcy5vcHRpb25zLnRpbWVyRGVsYXksaW5maW5pdGU6ITF9LGZ1bmN0aW9uKCl7dC5jaGFuZ2VTbGlkZSghMCk7fSksdGhpcy50aW1lci5zdGFydCgpO319LHtrZXk6XFxcIl9wcmVwYXJlRm9yT3JiaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpczt0aGlzLl9zZXRXcmFwcGVySGVpZ2h0KGZ1bmN0aW9uKGUpe3QuX3NldFNsaWRlSGVpZ2h0KGUpO30pO319LHtrZXk6XFxcIl9zZXRXcmFwcGVySGVpZ2h0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaSxuPTAscz0wO3RoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCl7aT10aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCx0KHRoaXMpLmF0dHIoXFxcImRhdGEtc2xpZGVcXFwiLHMpLHMmJnQodGhpcykuY3NzKHtwb3NpdGlvbjpcXFwicmVsYXRpdmVcXFwiLGRpc3BsYXk6XFxcIm5vbmVcXFwifSksbj1pPm4/aTpuLHMrKzt9KSxzPT09dGhpcy4kc2xpZGVzLmxlbmd0aCYmKHRoaXMuJHdyYXBwZXIuY3NzKHtoZWlnaHQ6bn0pLGUobikpO319LHtrZXk6XFxcIl9zZXRTbGlkZUhlaWdodFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24oKXt0KHRoaXMpLmNzcyhcXFwibWF4LWhlaWdodFxcXCIsZSk7fSk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO2lmKHRoaXMuJHNsaWRlcy5sZW5ndGg+MSl7aWYodGhpcy5vcHRpb25zLnN3aXBlJiZ0aGlzLiRzbGlkZXMub2ZmKFxcXCJzd2lwZWxlZnQuemYub3JiaXQgc3dpcGVyaWdodC56Zi5vcmJpdFxcXCIpLm9uKFxcXCJzd2lwZWxlZnQuemYub3JiaXRcXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxlLmNoYW5nZVNsaWRlKCEwKTt9KS5vbihcXFwic3dpcGVyaWdodC56Zi5vcmJpdFxcXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLGUuY2hhbmdlU2xpZGUoITEpO30pLHRoaXMub3B0aW9ucy5hdXRvUGxheSYmKHRoaXMuJHNsaWRlcy5vbihcXFwiY2xpY2suemYub3JiaXRcXFwiLGZ1bmN0aW9uKCl7ZS4kZWxlbWVudC5kYXRhKFxcXCJjbGlja2VkT25cXFwiLCFlLiRlbGVtZW50LmRhdGEoXFxcImNsaWNrZWRPblxcXCIpKSxlLnRpbWVyW2UuJGVsZW1lbnQuZGF0YShcXFwiY2xpY2tlZE9uXFxcIik/XFxcInBhdXNlXFxcIjpcXFwic3RhcnRcXFwiXSgpO30pLHRoaXMub3B0aW9ucy5wYXVzZU9uSG92ZXImJnRoaXMuJGVsZW1lbnQub24oXFxcIm1vdXNlZW50ZXIuemYub3JiaXRcXFwiLGZ1bmN0aW9uKCl7ZS50aW1lci5wYXVzZSgpO30pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLm9yYml0XFxcIixmdW5jdGlvbigpe2UuJGVsZW1lbnQuZGF0YShcXFwiY2xpY2tlZE9uXFxcIil8fGUudGltZXIuc3RhcnQoKTt9KSksdGhpcy5vcHRpb25zLm5hdkJ1dHRvbnMpe3ZhciBpPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLm5leHRDbGFzcytcXFwiLCAuXFxcIit0aGlzLm9wdGlvbnMucHJldkNsYXNzKTtpLmF0dHIoXFxcInRhYmluZGV4XFxcIiwwKS5vbihcXFwiY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXRcXFwiLGZ1bmN0aW9uKGkpe2kucHJldmVudERlZmF1bHQoKSxlLmNoYW5nZVNsaWRlKHQodGhpcykuaGFzQ2xhc3MoZS5vcHRpb25zLm5leHRDbGFzcykpO30pO310aGlzLm9wdGlvbnMuYnVsbGV0cyYmdGhpcy4kYnVsbGV0cy5vbihcXFwiY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXRcXFwiLGZ1bmN0aW9uKCl7aWYoL2lzLWFjdGl2ZS9nLnRlc3QodGhpcy5jbGFzc05hbWUpKXJldHVybiExO3ZhciBpPXQodGhpcykuZGF0YShcXFwic2xpZGVcXFwiKSxuPWk+ZS4kc2xpZGVzLmZpbHRlcihcXFwiLmlzLWFjdGl2ZVxcXCIpLmRhdGEoXFxcInNsaWRlXFxcIikscz1lLiRzbGlkZXMuZXEoaSk7ZS5jaGFuZ2VTbGlkZShuLHMsaSk7fSksdGhpcy5vcHRpb25zLmFjY2Vzc2libGUmJnRoaXMuJHdyYXBwZXIuYWRkKHRoaXMuJGJ1bGxldHMpLm9uKFxcXCJrZXlkb3duLnpmLm9yYml0XFxcIixmdW5jdGlvbihpKXtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJPcmJpdFxcXCIse25leHQ6ZnVuY3Rpb24gbmV4dCgpe2UuY2hhbmdlU2xpZGUoITApO30scHJldmlvdXM6ZnVuY3Rpb24gcHJldmlvdXMoKXtlLmNoYW5nZVNsaWRlKCExKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe3QoaS50YXJnZXQpLmlzKGUuJGJ1bGxldHMpJiZlLiRidWxsZXRzLmZpbHRlcihcXFwiLmlzLWFjdGl2ZVxcXCIpLmZvY3VzKCk7fX0pO30pO319fSx7a2V5OlxcXCJjaGFuZ2VTbGlkZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlLGkpe3ZhciBuPXRoaXMuJHNsaWRlcy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKS5lcSgwKTtpZigvbXVpL2cudGVzdChuWzBdLmNsYXNzTmFtZSkpcmV0dXJuITE7dmFyIHMsbz10aGlzLiRzbGlkZXMuZmlyc3QoKSxhPXRoaXMuJHNsaWRlcy5sYXN0KCkscj10P1xcXCJSaWdodFxcXCI6XFxcIkxlZnRcXFwiLGw9dD9cXFwiTGVmdFxcXCI6XFxcIlJpZ2h0XFxcIix1PXRoaXM7cz1lP2U6dD90aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwP24ubmV4dChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpLmxlbmd0aD9uLm5leHQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTpvOm4ubmV4dChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOnRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXA/bi5wcmV2KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykubGVuZ3RoP24ucHJldihcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOmE6bi5wcmV2KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykscy5sZW5ndGgmJih0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImJlZm9yZXNsaWRlY2hhbmdlLnpmLm9yYml0XFxcIixbbixzXSksdGhpcy5vcHRpb25zLmJ1bGxldHMmJihpPWl8fHRoaXMuJHNsaWRlcy5pbmRleChzKSx0aGlzLl91cGRhdGVCdWxsZXRzKGkpKSx0aGlzLm9wdGlvbnMudXNlTVVJPyhGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4ocy5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuY3NzKHtwb3NpdGlvbjpcXFwiYWJzb2x1dGVcXFwiLHRvcDowfSksdGhpcy5vcHRpb25zW1xcXCJhbmltSW5Gcm9tXFxcIityXSxmdW5jdGlvbigpe3MuY3NzKHtwb3NpdGlvbjpcXFwicmVsYXRpdmVcXFwiLGRpc3BsYXk6XFxcImJsb2NrXFxcIn0pLmF0dHIoXFxcImFyaWEtbGl2ZVxcXCIsXFxcInBvbGl0ZVxcXCIpO30pLEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQobi5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksdGhpcy5vcHRpb25zW1xcXCJhbmltT3V0VG9cXFwiK2xdLGZ1bmN0aW9uKCl7bi5yZW1vdmVBdHRyKFxcXCJhcmlhLWxpdmVcXFwiKSx1Lm9wdGlvbnMuYXV0b1BsYXkmJiF1LnRpbWVyLmlzUGF1c2VkJiZ1LnRpbWVyLnJlc3RhcnQoKTt9KSk6KG4ucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1pblxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtbGl2ZVxcXCIpLmhpZGUoKSxzLmFkZENsYXNzKFxcXCJpcy1hY3RpdmUgaXMtaW5cXFwiKS5hdHRyKFxcXCJhcmlhLWxpdmVcXFwiLFxcXCJwb2xpdGVcXFwiKS5zaG93KCksdGhpcy5vcHRpb25zLmF1dG9QbGF5JiYhdGhpcy50aW1lci5pc1BhdXNlZCYmdGhpcy50aW1lci5yZXN0YXJ0KCkpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwic2xpZGVjaGFuZ2UuemYub3JiaXRcXFwiLFtzXSkpO319LHtrZXk6XFxcIl91cGRhdGVCdWxsZXRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5ib3hPZkJ1bGxldHMpLmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYmx1cigpLGk9ZS5maW5kKFxcXCJzcGFuOmxhc3RcXFwiKS5kZXRhY2goKTt0aGlzLiRidWxsZXRzLmVxKHQpLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hcHBlbmQoaSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLm9yYml0XFxcIikuZmluZChcXFwiKlxcXCIpLm9mZihcXFwiLnpmLm9yYml0XFxcIikuZW5kKCkuaGlkZSgpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2J1bGxldHM6ITAsbmF2QnV0dG9uczohMCxhbmltSW5Gcm9tUmlnaHQ6XFxcInNsaWRlLWluLXJpZ2h0XFxcIixhbmltT3V0VG9SaWdodDpcXFwic2xpZGUtb3V0LXJpZ2h0XFxcIixhbmltSW5Gcm9tTGVmdDpcXFwic2xpZGUtaW4tbGVmdFxcXCIsYW5pbU91dFRvTGVmdDpcXFwic2xpZGUtb3V0LWxlZnRcXFwiLGF1dG9QbGF5OiEwLHRpbWVyRGVsYXk6NWUzLGluZmluaXRlV3JhcDohMCxzd2lwZTohMCxwYXVzZU9uSG92ZXI6ITAsYWNjZXNzaWJsZTohMCxjb250YWluZXJDbGFzczpcXFwib3JiaXQtY29udGFpbmVyXFxcIixzbGlkZUNsYXNzOlxcXCJvcmJpdC1zbGlkZVxcXCIsYm94T2ZCdWxsZXRzOlxcXCJvcmJpdC1idWxsZXRzXFxcIixuZXh0Q2xhc3M6XFxcIm9yYml0LW5leHRcXFwiLHByZXZDbGFzczpcXFwib3JiaXQtcHJldmlvdXNcXFwiLHVzZU1VSTohMH0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiT3JiaXRcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD10KGkpLHRoaXMucnVsZXM9dGhpcy4kZWxlbWVudC5kYXRhKFxcXCJyZXNwb25zaXZlLW1lbnVcXFwiKSx0aGlzLmN1cnJlbnRNcT1udWxsLHRoaXMuY3VycmVudFBsdWdpbj1udWxsLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlJlc3BvbnNpdmVNZW51XFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYoXFxcInN0cmluZ1xcXCI9PXR5cGVvZiB0aGlzLnJ1bGVzKXtmb3IodmFyIGU9e30sbj10aGlzLnJ1bGVzLnNwbGl0KFxcXCIgXFxcIikscz0wO3M8bi5sZW5ndGg7cysrKXt2YXIgbz1uW3NdLnNwbGl0KFxcXCItXFxcIiksYT1vLmxlbmd0aD4xP29bMF06XFxcInNtYWxsXFxcIixyPW8ubGVuZ3RoPjE/b1sxXTpvWzBdO251bGwhPT1pW3JdJiYoZVthXT1pW3JdKTt9dGhpcy5ydWxlcz1lO310LmlzRW1wdHlPYmplY3QodGhpcy5ydWxlcyl8fHRoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3Qod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIixmdW5jdGlvbigpe2UuX2NoZWNrTWVkaWFRdWVyaWVzKCk7fSk7fX0se2tleTpcXFwiX2NoZWNrTWVkaWFRdWVyaWVzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlLG49dGhpczt0LmVhY2godGhpcy5ydWxlcyxmdW5jdGlvbih0KXtGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0KSYmKGU9dCk7fSksZSYmKHRoaXMuY3VycmVudFBsdWdpbiBpbnN0YW5jZW9mIHRoaXMucnVsZXNbZV0ucGx1Z2lufHwodC5lYWNoKGksZnVuY3Rpb24odCxlKXtuLiRlbGVtZW50LnJlbW92ZUNsYXNzKGUuY3NzQ2xhc3MpO30pLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5ydWxlc1tlXS5jc3NDbGFzcyksdGhpcy5jdXJyZW50UGx1Z2luJiZ0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpLHRoaXMuY3VycmVudFBsdWdpbj1uZXcgdGhpcy5ydWxlc1tlXS5wbHVnaW4odGhpcy4kZWxlbWVudCx7fSkpKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCksdCh3aW5kb3cpLm9mZihcXFwiLnpmLlJlc3BvbnNpdmVNZW51XFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17fTt2YXIgaT17ZHJvcGRvd246e2Nzc0NsYXNzOlxcXCJkcm9wZG93blxcXCIscGx1Z2luOkZvdW5kYXRpb24uX3BsdWdpbnNbXFxcImRyb3Bkb3duLW1lbnVcXFwiXXx8bnVsbH0sZHJpbGxkb3duOntjc3NDbGFzczpcXFwiZHJpbGxkb3duXFxcIixwbHVnaW46Rm91bmRhdGlvbi5fcGx1Z2lucy5kcmlsbGRvd258fG51bGx9LGFjY29yZGlvbjp7Y3NzQ2xhc3M6XFxcImFjY29yZGlvbi1tZW51XFxcIixwbHVnaW46Rm91bmRhdGlvbi5fcGx1Z2luc1tcXFwiYWNjb3JkaW9uLW1lbnVcXFwiXXx8bnVsbH19O0ZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIlJlc3BvbnNpdmVNZW51XFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9dChpKSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksdGhpcy5fZXZlbnRzKCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJSZXNwb25zaXZlVG9nZ2xlXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5kYXRhKFxcXCJyZXNwb25zaXZlLXRvZ2dsZVxcXCIpO2V8fGNvbnNvbGUuZXJyb3IoXFxcIllvdXIgdGFiIGJhciBuZWVkcyBhbiBJRCBvZiBhIE1lbnUgYXMgdGhlIHZhbHVlIG9mIGRhdGEtdGFiLWJhci5cXFwiKSx0aGlzLiR0YXJnZXRNZW51PXQoXFxcIiNcXFwiK2UpLHRoaXMuJHRvZ2dsZXI9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS10b2dnbGVdXFxcIiksdGhpcy5fdXBkYXRlKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl91cGRhdGVNcUhhbmRsZXI9dGhpcy5fdXBkYXRlLmJpbmQodGhpcyksdCh3aW5kb3cpLm9uKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLHRoaXMuX3VwZGF0ZU1xSGFuZGxlciksdGhpcy4kdG9nZ2xlci5vbihcXFwiY2xpY2suemYucmVzcG9uc2l2ZVRvZ2dsZVxcXCIsdGhpcy50b2dnbGVNZW51LmJpbmQodGhpcykpO319LHtrZXk6XFxcIl91cGRhdGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmhpZGVGb3IpPyh0aGlzLiRlbGVtZW50LmhpZGUoKSx0aGlzLiR0YXJnZXRNZW51LnNob3coKSk6KHRoaXMuJGVsZW1lbnQuc2hvdygpLHRoaXMuJHRhcmdldE1lbnUuaGlkZSgpKTt9fSx7a2V5OlxcXCJ0b2dnbGVNZW51XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKXx8KHRoaXMuJHRhcmdldE1lbnUudG9nZ2xlKDApLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwidG9nZ2xlZC56Zi5yZXNwb25zaXZlVG9nZ2xlXFxcIikpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi5yZXNwb25zaXZlVG9nZ2xlXFxcIiksdGhpcy4kdG9nZ2xlci5vZmYoXFxcIi56Zi5yZXNwb25zaXZlVG9nZ2xlXFxcIiksdCh3aW5kb3cpLm9mZihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIix0aGlzLl91cGRhdGVNcUhhbmRsZXIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2hpZGVGb3I6XFxcIm1lZGl1bVxcXCJ9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIlJlc3BvbnNpdmVUb2dnbGVcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiAvaVAoYWR8aG9uZXxvZCkuKk9TLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTt9ZnVuY3Rpb24gaSgpe3JldHVybiAvQW5kcm9pZC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7fWZ1bmN0aW9uIG4oKXtyZXR1cm4gZSgpfHxpKCk7fXZhciBzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJSZXZlYWxcXFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJSZXZlYWxcXFwiLHtFTlRFUjpcXFwib3BlblxcXCIsU1BBQ0U6XFxcIm9wZW5cXFwiLEVTQ0FQRTpcXFwiY2xvc2VcXFwiLFRBQjpcXFwidGFiX2ZvcndhcmRcXFwiLFNISUZUX1RBQjpcXFwidGFiX2JhY2t3YXJkXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuaWQ9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpLHRoaXMuaXNBY3RpdmU9ITEsdGhpcy5jYWNoZWQ9e21xOkZvdW5kYXRpb24uTWVkaWFRdWVyeS5jdXJyZW50fSx0aGlzLmlzTW9iaWxlPW4oKSx0aGlzLiRhbmNob3I9dCh0KCdbZGF0YS1vcGVuPVxcXCInK3RoaXMuaWQrJ1xcXCJdJykubGVuZ3RoPydbZGF0YS1vcGVuPVxcXCInK3RoaXMuaWQrJ1xcXCJdJzonW2RhdGEtdG9nZ2xlPVxcXCInK3RoaXMuaWQrJ1xcXCJdJyksdGhpcy4kYW5jaG9yLmF0dHIoe1xcXCJhcmlhLWNvbnRyb2xzXFxcIjp0aGlzLmlkLFxcXCJhcmlhLWhhc3BvcHVwXFxcIjohMCx0YWJpbmRleDowfSksKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVufHx0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJmdWxsXFxcIikpJiYodGhpcy5vcHRpb25zLmZ1bGxTY3JlZW49ITAsdGhpcy5vcHRpb25zLm92ZXJsYXk9ITEpLHRoaXMub3B0aW9ucy5vdmVybGF5JiYhdGhpcy4kb3ZlcmxheSYmKHRoaXMuJG92ZXJsYXk9dGhpcy5fbWFrZU92ZXJsYXkodGhpcy5pZCkpLHRoaXMuJGVsZW1lbnQuYXR0cih7cm9sZTpcXFwiZGlhbG9nXFxcIixcXFwiYXJpYS1oaWRkZW5cXFwiOiEwLFxcXCJkYXRhLXlldGktYm94XFxcIjp0aGlzLmlkLFxcXCJkYXRhLXJlc2l6ZVxcXCI6dGhpcy5pZH0pLHRoaXMuJG92ZXJsYXk/dGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyh0aGlzLiRvdmVybGF5KToodGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyh0KFxcXCJib2R5XFxcIikpLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcIndpdGhvdXQtb3ZlcmxheVxcXCIpKSx0aGlzLl9ldmVudHMoKSx0aGlzLm9wdGlvbnMuZGVlcExpbmsmJndpbmRvdy5sb2NhdGlvbi5oYXNoPT09XFxcIiNcXFwiK3RoaXMuaWQmJnQod2luZG93KS5vbmUoXFxcImxvYWQuemYucmV2ZWFsXFxcIix0aGlzLm9wZW4uYmluZCh0aGlzKSk7fX0se2tleTpcXFwiX21ha2VPdmVybGF5XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10KFxcXCI8ZGl2PjwvZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJyZXZlYWwtb3ZlcmxheVxcXCIpLmFwcGVuZFRvKFxcXCJib2R5XFxcIik7cmV0dXJuIGk7fX0se2tleTpcXFwiX3VwZGF0ZVBvc2l0aW9uXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlLGksbj10aGlzLiRlbGVtZW50Lm91dGVyV2lkdGgoKSxzPXQod2luZG93KS53aWR0aCgpLG89dGhpcy4kZWxlbWVudC5vdXRlckhlaWdodCgpLGE9dCh3aW5kb3cpLmhlaWdodCgpO2U9XFxcImF1dG9cXFwiPT09dGhpcy5vcHRpb25zLmhPZmZzZXQ/cGFyc2VJbnQoKHMtbikvMiwxMCk6cGFyc2VJbnQodGhpcy5vcHRpb25zLmhPZmZzZXQsMTApLGk9XFxcImF1dG9cXFwiPT09dGhpcy5vcHRpb25zLnZPZmZzZXQ/bz5hP3BhcnNlSW50KE1hdGgubWluKDEwMCxhLzEwKSwxMCk6cGFyc2VJbnQoKGEtbykvNCwxMCk6cGFyc2VJbnQodGhpcy5vcHRpb25zLnZPZmZzZXQsMTApLHRoaXMuJGVsZW1lbnQuY3NzKHt0b3A6aStcXFwicHhcXFwifSksdGhpcy4kb3ZlcmxheSYmXFxcImF1dG9cXFwiPT09dGhpcy5vcHRpb25zLmhPZmZzZXR8fCh0aGlzLiRlbGVtZW50LmNzcyh7bGVmdDplK1xcXCJweFxcXCJ9KSx0aGlzLiRlbGVtZW50LmNzcyh7bWFyZ2luOlxcXCIwcHhcXFwifSkpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcyxpPXRoaXM7dGhpcy4kZWxlbWVudC5vbih7XFxcIm9wZW4uemYudHJpZ2dlclxcXCI6dGhpcy5vcGVuLmJpbmQodGhpcyksXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiOmZ1bmN0aW9uIGNsb3NlWmZUcmlnZ2VyKG4scyl7aWYobi50YXJnZXQ9PT1pLiRlbGVtZW50WzBdfHx0KG4udGFyZ2V0KS5wYXJlbnRzKFxcXCJbZGF0YS1jbG9zYWJsZV1cXFwiKVswXT09PXMpcmV0dXJuIGUuY2xvc2UuYXBwbHkoZSk7fSxcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiOnRoaXMudG9nZ2xlLmJpbmQodGhpcyksXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiOmZ1bmN0aW9uIHJlc2l6ZW1lWmZUcmlnZ2VyKCl7aS5fdXBkYXRlUG9zaXRpb24oKTt9fSksdGhpcy4kYW5jaG9yLmxlbmd0aCYmdGhpcy4kYW5jaG9yLm9uKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24odCl7MTMhPT10LndoaWNoJiYzMiE9PXQud2hpY2h8fCh0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKSxpLm9wZW4oKSk7fSksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy5vcHRpb25zLm92ZXJsYXkmJnRoaXMuJG92ZXJsYXkub2ZmKFxcXCIuemYucmV2ZWFsXFxcIikub24oXFxcImNsaWNrLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24oZSl7ZS50YXJnZXQhPT1pLiRlbGVtZW50WzBdJiYhdC5jb250YWlucyhpLiRlbGVtZW50WzBdLGUudGFyZ2V0KSYmdC5jb250YWlucyhkb2N1bWVudCxlLnRhcmdldCkmJmkuY2xvc2UoKTt9KSx0aGlzLm9wdGlvbnMuZGVlcExpbmsmJnQod2luZG93KS5vbihcXFwicG9wc3RhdGUuemYucmV2ZWFsOlxcXCIrdGhpcy5pZCx0aGlzLl9oYW5kbGVTdGF0ZS5iaW5kKHRoaXMpKTt9fSx7a2V5OlxcXCJfaGFuZGxlU3RhdGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3dpbmRvdy5sb2NhdGlvbi5oYXNoIT09XFxcIiNcXFwiK3RoaXMuaWR8fHRoaXMuaXNBY3RpdmU/dGhpcy5jbG9zZSgpOnRoaXMub3BlbigpO319LHtrZXk6XFxcIm9wZW5cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcztpZih0aGlzLm9wdGlvbnMuZGVlcExpbmspe3ZhciBpPVxcXCIjXFxcIit0aGlzLmlkO3dpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZT93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCxudWxsLGkpOndpbmRvdy5sb2NhdGlvbi5oYXNoPWk7fWlmKHRoaXMuaXNBY3RpdmU9ITAsdGhpcy4kZWxlbWVudC5jc3Moe3Zpc2liaWxpdHk6XFxcImhpZGRlblxcXCJ9KS5zaG93KCkuc2Nyb2xsVG9wKDApLHRoaXMub3B0aW9ucy5vdmVybGF5JiZ0aGlzLiRvdmVybGF5LmNzcyh7dmlzaWJpbGl0eTpcXFwiaGlkZGVuXFxcIn0pLnNob3coKSx0aGlzLl91cGRhdGVQb3NpdGlvbigpLHRoaXMuJGVsZW1lbnQuaGlkZSgpLmNzcyh7dmlzaWJpbGl0eTpcXFwiXFxcIn0pLHRoaXMuJG92ZXJsYXkmJih0aGlzLiRvdmVybGF5LmNzcyh7dmlzaWJpbGl0eTpcXFwiXFxcIn0pLmhpZGUoKSx0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJmYXN0XFxcIik/dGhpcy4kb3ZlcmxheS5hZGRDbGFzcyhcXFwiZmFzdFxcXCIpOnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcInNsb3dcXFwiKSYmdGhpcy4kb3ZlcmxheS5hZGRDbGFzcyhcXFwic2xvd1xcXCIpKSx0aGlzLm9wdGlvbnMubXVsdGlwbGVPcGVuZWR8fHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VtZS56Zi5yZXZlYWxcXFwiLHRoaXMuaWQpLHRoaXMub3B0aW9ucy5hbmltYXRpb25Jbil7dmFyIG47IWZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24gdCgpe24uJGVsZW1lbnQuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMSx0YWJpbmRleDotMX0pLmZvY3VzKCk7fTtuPWUsZS5vcHRpb25zLm92ZXJsYXkmJkZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihlLiRvdmVybGF5LFxcXCJmYWRlLWluXFxcIiksRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKGUuJGVsZW1lbnQsZS5vcHRpb25zLmFuaW1hdGlvbkluLGZ1bmN0aW9uKCl7ZS5mb2N1c2FibGVFbGVtZW50cz1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUoZS4kZWxlbWVudCksdCgpO30pO30oKTt9ZWxzZSB0aGlzLm9wdGlvbnMub3ZlcmxheSYmdGhpcy4kb3ZlcmxheS5zaG93KDApLHRoaXMuJGVsZW1lbnQuc2hvdyh0aGlzLm9wdGlvbnMuc2hvd0RlbGF5KTt0aGlzLiRlbGVtZW50LmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITEsdGFiaW5kZXg6LTF9KS5mb2N1cygpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib3Blbi56Zi5yZXZlYWxcXFwiKSx0aGlzLmlzTW9iaWxlPyh0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zPXdpbmRvdy5wYWdlWU9mZnNldCx0KFxcXCJodG1sLCBib2R5XFxcIikuYWRkQ2xhc3MoXFxcImlzLXJldmVhbC1vcGVuXFxcIikpOnQoXFxcImJvZHlcXFwiKS5hZGRDbGFzcyhcXFwiaXMtcmV2ZWFsLW9wZW5cXFwiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5fZXh0cmFIYW5kbGVycygpO30sMCk7fX0se2tleTpcXFwiX2V4dHJhSGFuZGxlcnNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLmZvY3VzYWJsZUVsZW1lbnRzPUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KSx0aGlzLm9wdGlvbnMub3ZlcmxheXx8IXRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2t8fHRoaXMub3B0aW9ucy5mdWxsU2NyZWVufHx0KFxcXCJib2R5XFxcIikub24oXFxcImNsaWNrLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24oaSl7aS50YXJnZXQhPT1lLiRlbGVtZW50WzBdJiYhdC5jb250YWlucyhlLiRlbGVtZW50WzBdLGkudGFyZ2V0KSYmdC5jb250YWlucyhkb2N1bWVudCxpLnRhcmdldCkmJmUuY2xvc2UoKTt9KSx0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYyYmdCh3aW5kb3cpLm9uKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24odCl7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkodCxcXFwiUmV2ZWFsXFxcIix7Y2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtlLm9wdGlvbnMuY2xvc2VPbkVzYyYmKGUuY2xvc2UoKSxlLiRhbmNob3IuZm9jdXMoKSk7fX0pO30pLHRoaXMuJGVsZW1lbnQub24oXFxcImtleWRvd24uemYucmV2ZWFsXFxcIixmdW5jdGlvbihpKXt2YXIgbj10KHRoaXMpO0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXFxcIlJldmVhbFxcXCIse3RhYl9mb3J3YXJkOmZ1bmN0aW9uIHRhYl9mb3J3YXJkKCl7cmV0dXJuIGUuZm9jdXNhYmxlRWxlbWVudHM9Rm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKGUuJGVsZW1lbnQpLGUuJGVsZW1lbnQuZmluZChcXFwiOmZvY3VzXFxcIikuaXMoZS5mb2N1c2FibGVFbGVtZW50cy5lcSgtMSkpPyhlLmZvY3VzYWJsZUVsZW1lbnRzLmVxKDApLmZvY3VzKCksITApOjA9PT1lLmZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aHx8dm9pZCAwO30sdGFiX2JhY2t3YXJkOmZ1bmN0aW9uIHRhYl9iYWNrd2FyZCgpe3JldHVybiBlLmZvY3VzYWJsZUVsZW1lbnRzPUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZShlLiRlbGVtZW50KSxlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoMCkpfHxlLiRlbGVtZW50LmlzKFxcXCI6Zm9jdXNcXFwiKT8oZS5mb2N1c2FibGVFbGVtZW50cy5lcSgtMSkuZm9jdXMoKSwhMCk6MD09PWUuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RofHx2b2lkIDA7fSxvcGVuOmZ1bmN0aW9uIG9wZW4oKXtlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKGUuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtY2xvc2VdXFxcIikpP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtlLiRhbmNob3IuZm9jdXMoKTt9LDEpOm4uaXMoZS5mb2N1c2FibGVFbGVtZW50cykmJmUub3BlbigpO30sY2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtlLm9wdGlvbnMuY2xvc2VPbkVzYyYmKGUuY2xvc2UoKSxlLiRhbmNob3IuZm9jdXMoKSk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQodCl7dCYmaS5wcmV2ZW50RGVmYXVsdCgpO319KTt9KTt9fSx7a2V5OlxcXCJjbG9zZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtmdW5jdGlvbiBlKCl7aS5pc01vYmlsZT8odChcXFwiaHRtbCwgYm9keVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1yZXZlYWwtb3BlblxcXCIpLGkub3JpZ2luYWxTY3JvbGxQb3MmJih0KFxcXCJib2R5XFxcIikuc2Nyb2xsVG9wKGkub3JpZ2luYWxTY3JvbGxQb3MpLGkub3JpZ2luYWxTY3JvbGxQb3M9bnVsbCkpOnQoXFxcImJvZHlcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtcmV2ZWFsLW9wZW5cXFwiKSxpLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCksaS4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZWQuemYucmV2ZWFsXFxcIik7fWlmKCF0aGlzLmlzQWN0aXZlfHwhdGhpcy4kZWxlbWVudC5pcyhcXFwiOnZpc2libGVcXFwiKSlyZXR1cm4hMTt2YXIgaT10aGlzO3RoaXMub3B0aW9ucy5hbmltYXRpb25PdXQ/KHRoaXMub3B0aW9ucy5vdmVybGF5P0ZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kb3ZlcmxheSxcXFwiZmFkZS1vdXRcXFwiLGUpOmUoKSxGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsdGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCkpOih0aGlzLm9wdGlvbnMub3ZlcmxheT90aGlzLiRvdmVybGF5LmhpZGUoMCxlKTplKCksdGhpcy4kZWxlbWVudC5oaWRlKHRoaXMub3B0aW9ucy5oaWRlRGVsYXkpKSx0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYyYmdCh3aW5kb3cpLm9mZihcXFwia2V5ZG93bi56Zi5yZXZlYWxcXFwiKSwhdGhpcy5vcHRpb25zLm92ZXJsYXkmJnRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnQoXFxcImJvZHlcXFwiKS5vZmYoXFxcImNsaWNrLnpmLnJldmVhbFxcXCIpLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIpLHRoaXMub3B0aW9ucy5yZXNldE9uQ2xvc2UmJnRoaXMuJGVsZW1lbnQuaHRtbCh0aGlzLiRlbGVtZW50Lmh0bWwoKSksdGhpcy5pc0FjdGl2ZT0hMSxpLm9wdGlvbnMuZGVlcExpbmsmJih3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGU/d2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFxcXCJcXFwiLGRvY3VtZW50LnRpdGxlLHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk6d2luZG93LmxvY2F0aW9uLmhhc2g9XFxcIlxcXCIpO319LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmlzQWN0aXZlP3RoaXMuY2xvc2UoKTp0aGlzLm9wZW4oKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMub3B0aW9ucy5vdmVybGF5JiYodGhpcy4kZWxlbWVudC5hcHBlbmRUbyh0KFxcXCJib2R5XFxcIikpLHRoaXMuJG92ZXJsYXkuaGlkZSgpLm9mZigpLnJlbW92ZSgpKSx0aGlzLiRlbGVtZW50LmhpZGUoKS5vZmYoKSx0aGlzLiRhbmNob3Iub2ZmKFxcXCIuemZcXFwiKSx0KHdpbmRvdykub2ZmKFxcXCIuemYucmV2ZWFsOlxcXCIrdGhpcy5pZCksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7cy5kZWZhdWx0cz17YW5pbWF0aW9uSW46XFxcIlxcXCIsYW5pbWF0aW9uT3V0OlxcXCJcXFwiLHNob3dEZWxheTowLGhpZGVEZWxheTowLGNsb3NlT25DbGljazohMCxjbG9zZU9uRXNjOiEwLG11bHRpcGxlT3BlbmVkOiExLHZPZmZzZXQ6XFxcImF1dG9cXFwiLGhPZmZzZXQ6XFxcImF1dG9cXFwiLGZ1bGxTY3JlZW46ITEsYnRtT2Zmc2V0UGN0OjEwLG92ZXJsYXk6ITAscmVzZXRPbkNsb3NlOiExLGRlZXBMaW5rOiExfSxGb3VuZGF0aW9uLnBsdWdpbihzLFxcXCJSZXZlYWxcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUpe3JldHVybiB0L2U7fWZ1bmN0aW9uIGkodCxlLGksbil7cmV0dXJuIE1hdGguYWJzKHQucG9zaXRpb24oKVtlXSt0W25dKCkvMi1pKTt9dmFyIG49ZnVuY3Rpb24oKXtmdW5jdGlvbiBuKGUsaSl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsbiksdGhpcy4kZWxlbWVudD1lLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxuLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLGkpLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlNsaWRlclxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIlNsaWRlclxcXCIse2x0cjp7QVJST1dfUklHSFQ6XFxcImluY3JlYXNlXFxcIixBUlJPV19VUDpcXFwiaW5jcmVhc2VcXFwiLEFSUk9XX0RPV046XFxcImRlY3JlYXNlXFxcIixBUlJPV19MRUZUOlxcXCJkZWNyZWFzZVxcXCIsU0hJRlRfQVJST1dfUklHSFQ6XFxcImluY3JlYXNlX2Zhc3RcXFwiLFNISUZUX0FSUk9XX1VQOlxcXCJpbmNyZWFzZV9mYXN0XFxcIixTSElGVF9BUlJPV19ET1dOOlxcXCJkZWNyZWFzZV9mYXN0XFxcIixTSElGVF9BUlJPV19MRUZUOlxcXCJkZWNyZWFzZV9mYXN0XFxcIn0scnRsOntBUlJPV19MRUZUOlxcXCJpbmNyZWFzZVxcXCIsQVJST1dfUklHSFQ6XFxcImRlY3JlYXNlXFxcIixTSElGVF9BUlJPV19MRUZUOlxcXCJpbmNyZWFzZV9mYXN0XFxcIixTSElGVF9BUlJPV19SSUdIVDpcXFwiZGVjcmVhc2VfZmFzdFxcXCJ9fSk7fXJldHVybiBfY3JlYXRlQ2xhc3Mobixbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5pbnB1dHM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJpbnB1dFxcXCIpLHRoaXMuaGFuZGxlcz10aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXNsaWRlci1oYW5kbGVdXFxcIiksdGhpcy4kaGFuZGxlPXRoaXMuaGFuZGxlcy5lcSgwKSx0aGlzLiRpbnB1dD10aGlzLmlucHV0cy5sZW5ndGg/dGhpcy5pbnB1dHMuZXEoMCk6dChcXFwiI1xcXCIrdGhpcy4kaGFuZGxlLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiKSksdGhpcy4kZmlsbD10aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXNsaWRlci1maWxsXVxcXCIpLmNzcyh0aGlzLm9wdGlvbnMudmVydGljYWw/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIiwwKTt2YXIgZT0hMSxpPXRoaXM7KHRoaXMub3B0aW9ucy5kaXNhYmxlZHx8dGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcykpJiYodGhpcy5vcHRpb25zLmRpc2FibGVkPSEwLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSx0aGlzLmlucHV0cy5sZW5ndGh8fCh0aGlzLmlucHV0cz10KCkuYWRkKHRoaXMuJGlucHV0KSx0aGlzLm9wdGlvbnMuYmluZGluZz0hMCksdGhpcy5fc2V0SW5pdEF0dHIoMCksdGhpcy5fZXZlbnRzKHRoaXMuJGhhbmRsZSksdGhpcy5oYW5kbGVzWzFdJiYodGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkPSEwLHRoaXMuJGhhbmRsZTI9dGhpcy5oYW5kbGVzLmVxKDEpLHRoaXMuJGlucHV0Mj10aGlzLmlucHV0cy5sZW5ndGg+MT90aGlzLmlucHV0cy5lcSgxKTp0KFxcXCIjXFxcIit0aGlzLiRoYW5kbGUyLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiKSksdGhpcy5pbnB1dHNbMV18fCh0aGlzLmlucHV0cz10aGlzLmlucHV0cy5hZGQodGhpcy4kaW5wdXQyKSksZT0hMCx0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQsITAsZnVuY3Rpb24oKXtpLl9zZXRIYW5kbGVQb3MoaS4kaGFuZGxlMixpLm9wdGlvbnMuaW5pdGlhbEVuZCwhMCk7fSksdGhpcy5fc2V0SW5pdEF0dHIoMSksdGhpcy5fZXZlbnRzKHRoaXMuJGhhbmRsZTIpKSxlfHx0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQsITApO319LHtrZXk6XFxcIl9zZXRIYW5kbGVQb3NcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsaSxuLHMpe2lmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSl7aT1wYXJzZUZsb2F0KGkpLGk8dGhpcy5vcHRpb25zLnN0YXJ0P2k9dGhpcy5vcHRpb25zLnN0YXJ0Omk+dGhpcy5vcHRpb25zLmVuZCYmKGk9dGhpcy5vcHRpb25zLmVuZCk7dmFyIG89dGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkO2lmKG8paWYoMD09PXRoaXMuaGFuZGxlcy5pbmRleCh0KSl7dmFyIGE9cGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyLmF0dHIoXFxcImFyaWEtdmFsdWVub3dcXFwiKSk7aT1pPj1hP2EtdGhpcy5vcHRpb25zLnN0ZXA6aTt9ZWxzZXt2YXIgcj1wYXJzZUZsb2F0KHRoaXMuJGhhbmRsZS5hdHRyKFxcXCJhcmlhLXZhbHVlbm93XFxcIikpO2k9aTw9cj9yK3RoaXMub3B0aW9ucy5zdGVwOmk7fXRoaXMub3B0aW9ucy52ZXJ0aWNhbCYmIW4mJihpPXRoaXMub3B0aW9ucy5lbmQtaSk7dmFyIGw9dGhpcyx1PXRoaXMub3B0aW9ucy52ZXJ0aWNhbCxkPXU/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIixoPXU/XFxcInRvcFxcXCI6XFxcImxlZnRcXFwiLGM9dFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkXSxmPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZF0scD1lKGktdGhpcy5vcHRpb25zLnN0YXJ0LHRoaXMub3B0aW9ucy5lbmQtdGhpcy5vcHRpb25zLnN0YXJ0KS50b0ZpeGVkKDIpLG09KGYtYykqcCx2PSgxMDAqZShtLGYpKS50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKTtpPXBhcnNlRmxvYXQoaS50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKSk7dmFyIGc9e307aWYodGhpcy5fc2V0VmFsdWVzKHQsaSksbyl7dmFyIHcseT0wPT09dGhpcy5oYW5kbGVzLmluZGV4KHQpLGI9fn4oMTAwKmUoYyxmKSk7aWYoeSlnW2hdPXYrXFxcIiVcXFwiLHc9cGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyWzBdLnN0eWxlW2hdKS12K2IscyYmXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHMmJnMoKTtlbHNle3ZhciAkPXBhcnNlRmxvYXQodGhpcy4kaGFuZGxlWzBdLnN0eWxlW2hdKTt3PXYtKGlzTmFOKCQpP3RoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQvKCh0aGlzLm9wdGlvbnMuZW5kLXRoaXMub3B0aW9ucy5zdGFydCkvMTAwKTokKStiO31nW1xcXCJtaW4tXFxcIitkXT13K1xcXCIlXFxcIjt9dGhpcy4kZWxlbWVudC5vbmUoXFxcImZpbmlzaGVkLnpmLmFuaW1hdGVcXFwiLGZ1bmN0aW9uKCl7bC4kZWxlbWVudC50cmlnZ2VyKFxcXCJtb3ZlZC56Zi5zbGlkZXJcXFwiLFt0XSk7fSk7dmFyIEM9dGhpcy4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIpPzFlMy82MDp0aGlzLm9wdGlvbnMubW92ZVRpbWU7Rm91bmRhdGlvbi5Nb3ZlKEMsdCxmdW5jdGlvbigpe3QuY3NzKGgsditcXFwiJVxcXCIpLGwub3B0aW9ucy5kb3VibGVTaWRlZD9sLiRmaWxsLmNzcyhnKTpsLiRmaWxsLmNzcyhkLDEwMCpwK1xcXCIlXFxcIik7fSksY2xlYXJUaW1lb3V0KGwudGltZW91dCksbC50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtsLiRlbGVtZW50LnRyaWdnZXIoXFxcImNoYW5nZWQuemYuc2xpZGVyXFxcIixbdF0pO30sbC5vcHRpb25zLmNoYW5nZWREZWxheSk7fX19LHtrZXk6XFxcIl9zZXRJbml0QXR0clxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy5pbnB1dHMuZXEodCkuYXR0cihcXFwiaWRcXFwiKXx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJzbGlkZXJcXFwiKTt0aGlzLmlucHV0cy5lcSh0KS5hdHRyKHtpZDplLG1heDp0aGlzLm9wdGlvbnMuZW5kLG1pbjp0aGlzLm9wdGlvbnMuc3RhcnQsc3RlcDp0aGlzLm9wdGlvbnMuc3RlcH0pLHRoaXMuaGFuZGxlcy5lcSh0KS5hdHRyKHtyb2xlOlxcXCJzbGlkZXJcXFwiLFxcXCJhcmlhLWNvbnRyb2xzXFxcIjplLFxcXCJhcmlhLXZhbHVlbWF4XFxcIjp0aGlzLm9wdGlvbnMuZW5kLFxcXCJhcmlhLXZhbHVlbWluXFxcIjp0aGlzLm9wdGlvbnMuc3RhcnQsXFxcImFyaWEtdmFsdWVub3dcXFwiOjA9PT10P3RoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQ6dGhpcy5vcHRpb25zLmluaXRpYWxFbmQsXFxcImFyaWEtb3JpZW50YXRpb25cXFwiOnRoaXMub3B0aW9ucy52ZXJ0aWNhbD9cXFwidmVydGljYWxcXFwiOlxcXCJob3Jpem9udGFsXFxcIix0YWJpbmRleDowfSk7fX0se2tleTpcXFwiX3NldFZhbHVlc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXt2YXIgaT10aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ/dGhpcy5oYW5kbGVzLmluZGV4KHQpOjA7dGhpcy5pbnB1dHMuZXEoaSkudmFsKGUpLHQuYXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIsZSk7fX0se2tleTpcXFwiX2hhbmRsZUV2ZW50XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShuLHMsbyl7dmFyIGEscjtpZihvKWE9dGhpcy5fYWRqdXN0VmFsdWUobnVsbCxvKSxyPSEwO2Vsc2V7bi5wcmV2ZW50RGVmYXVsdCgpO3ZhciBsPXRoaXMsdT10aGlzLm9wdGlvbnMudmVydGljYWwsZD11P1xcXCJoZWlnaHRcXFwiOlxcXCJ3aWR0aFxcXCIsaD11P1xcXCJ0b3BcXFwiOlxcXCJsZWZ0XFxcIixjPXU/bi5wYWdlWTpuLnBhZ2VYLGY9KHRoaXMuJGhhbmRsZVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkXS8yLHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZF0pLHA9dT90KHdpbmRvdykuc2Nyb2xsVG9wKCk6dCh3aW5kb3cpLnNjcm9sbExlZnQoKSxtPXRoaXMuJGVsZW1lbnQub2Zmc2V0KClbaF07bi5jbGllbnRZPT09bi5wYWdlWSYmKGMrPXApO3ZhciB2LGc9Yy1tO3Y9ZzwwPzA6Zz5mP2Y6Zzt2YXIgdz1lKHYsZik7aWYoYT0odGhpcy5vcHRpb25zLmVuZC10aGlzLm9wdGlvbnMuc3RhcnQpKncrdGhpcy5vcHRpb25zLnN0YXJ0LEZvdW5kYXRpb24ucnRsKCkmJiF0aGlzLm9wdGlvbnMudmVydGljYWwmJihhPXRoaXMub3B0aW9ucy5lbmQtYSksYT1sLl9hZGp1c3RWYWx1ZShudWxsLGEpLHI9ITEsIXMpe3ZhciB5PWkodGhpcy4kaGFuZGxlLGgsdixkKSxiPWkodGhpcy4kaGFuZGxlMixoLHYsZCk7cz15PD1iP3RoaXMuJGhhbmRsZTp0aGlzLiRoYW5kbGUyO319dGhpcy5fc2V0SGFuZGxlUG9zKHMsYSxyKTt9fSx7a2V5OlxcXCJfYWRqdXN0VmFsdWVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQsZSl7dmFyIGksbixzLG8sYT10aGlzLm9wdGlvbnMuc3RlcCxyPXBhcnNlRmxvYXQoYS8yKTtyZXR1cm4gaT10P3BhcnNlRmxvYXQodC5hdHRyKFxcXCJhcmlhLXZhbHVlbm93XFxcIikpOmUsbj1pJWEscz1pLW4sbz1zK2EsMD09PW4/aTppPWk+PXMrcj9vOnM7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGksbj10aGlzO2lmKHRoaXMuaW5wdXRzLm9mZihcXFwiY2hhbmdlLnpmLnNsaWRlclxcXCIpLm9uKFxcXCJjaGFuZ2UuemYuc2xpZGVyXFxcIixmdW5jdGlvbihlKXt2YXIgaT1uLmlucHV0cy5pbmRleCh0KHRoaXMpKTtuLl9oYW5kbGVFdmVudChlLG4uaGFuZGxlcy5lcShpKSx0KHRoaXMpLnZhbCgpKTt9KSx0aGlzLm9wdGlvbnMuY2xpY2tTZWxlY3QmJnRoaXMuJGVsZW1lbnQub2ZmKFxcXCJjbGljay56Zi5zbGlkZXJcXFwiKS5vbihcXFwiY2xpY2suemYuc2xpZGVyXFxcIixmdW5jdGlvbihlKXtyZXR1cm4hbi4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIpJiZ2b2lkKHQoZS50YXJnZXQpLmlzKFxcXCJbZGF0YS1zbGlkZXItaGFuZGxlXVxcXCIpfHwobi5vcHRpb25zLmRvdWJsZVNpZGVkP24uX2hhbmRsZUV2ZW50KGUpOm4uX2hhbmRsZUV2ZW50KGUsbi4kaGFuZGxlKSkpO30pLHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpe3RoaXMuaGFuZGxlcy5hZGRUb3VjaCgpO3ZhciBzPXQoXFxcImJvZHlcXFwiKTtlLm9mZihcXFwibW91c2Vkb3duLnpmLnNsaWRlclxcXCIpLm9uKFxcXCJtb3VzZWRvd24uemYuc2xpZGVyXFxcIixmdW5jdGlvbihvKXtlLmFkZENsYXNzKFxcXCJpcy1kcmFnZ2luZ1xcXCIpLG4uJGZpbGwuYWRkQ2xhc3MoXFxcImlzLWRyYWdnaW5nXFxcIiksbi4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIsITApLGk9dChvLmN1cnJlbnRUYXJnZXQpLHMub24oXFxcIm1vdXNlbW92ZS56Zi5zbGlkZXJcXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxuLl9oYW5kbGVFdmVudCh0LGkpO30pLm9uKFxcXCJtb3VzZXVwLnpmLnNsaWRlclxcXCIsZnVuY3Rpb24odCl7bi5faGFuZGxlRXZlbnQodCxpKSxlLnJlbW92ZUNsYXNzKFxcXCJpcy1kcmFnZ2luZ1xcXCIpLG4uJGZpbGwucmVtb3ZlQ2xhc3MoXFxcImlzLWRyYWdnaW5nXFxcIiksbi4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIsITEpLHMub2ZmKFxcXCJtb3VzZW1vdmUuemYuc2xpZGVyIG1vdXNldXAuemYuc2xpZGVyXFxcIik7fSk7fSkub24oXFxcInNlbGVjdHN0YXJ0LnpmLnNsaWRlciB0b3VjaG1vdmUuemYuc2xpZGVyXFxcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCk7fSk7fWUub2ZmKFxcXCJrZXlkb3duLnpmLnNsaWRlclxcXCIpLm9uKFxcXCJrZXlkb3duLnpmLnNsaWRlclxcXCIsZnVuY3Rpb24oZSl7dmFyIGkscz10KHRoaXMpLG89bi5vcHRpb25zLmRvdWJsZVNpZGVkP24uaGFuZGxlcy5pbmRleChzKTowLGE9cGFyc2VGbG9hdChuLmlucHV0cy5lcShvKS52YWwoKSk7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSxcXFwiU2xpZGVyXFxcIix7ZGVjcmVhc2U6ZnVuY3Rpb24gZGVjcmVhc2UoKXtpPWEtbi5vcHRpb25zLnN0ZXA7fSxpbmNyZWFzZTpmdW5jdGlvbiBpbmNyZWFzZSgpe2k9YStuLm9wdGlvbnMuc3RlcDt9LGRlY3JlYXNlX2Zhc3Q6ZnVuY3Rpb24gZGVjcmVhc2VfZmFzdCgpe2k9YS0xMCpuLm9wdGlvbnMuc3RlcDt9LGluY3JlYXNlX2Zhc3Q6ZnVuY3Rpb24gaW5jcmVhc2VfZmFzdCgpe2k9YSsxMCpuLm9wdGlvbnMuc3RlcDt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe2UucHJldmVudERlZmF1bHQoKSxuLl9zZXRIYW5kbGVQb3MocyxpLCEwKTt9fSk7fSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmhhbmRsZXMub2ZmKFxcXCIuemYuc2xpZGVyXFxcIiksdGhpcy5pbnB1dHMub2ZmKFxcXCIuemYuc2xpZGVyXFxcIiksdGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi5zbGlkZXJcXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxuO30oKTtuLmRlZmF1bHRzPXtzdGFydDowLGVuZDoxMDAsc3RlcDoxLGluaXRpYWxTdGFydDowLGluaXRpYWxFbmQ6MTAwLGJpbmRpbmc6ITEsY2xpY2tTZWxlY3Q6ITAsdmVydGljYWw6ITEsZHJhZ2dhYmxlOiEwLGRpc2FibGVkOiExLGRvdWJsZVNpZGVkOiExLGRlY2ltYWw6Mixtb3ZlVGltZToyMDAsZGlzYWJsZWRDbGFzczpcXFwiZGlzYWJsZWRcXFwiLGludmVydFZlcnRpY2FsOiExLGNoYW5nZWREZWxheTo1MDB9LEZvdW5kYXRpb24ucGx1Z2luKG4sXFxcIlNsaWRlclxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3JldHVybiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5LG51bGwpLmZvbnRTaXplLDEwKSp0O312YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGkoZSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxpKSx0aGlzLiRlbGVtZW50PWUsdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGkuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiU3RpY2t5XFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoaSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5wYXJlbnQoXFxcIltkYXRhLXN0aWNreS1jb250YWluZXJdXFxcIiksaT10aGlzLiRlbGVtZW50WzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcInN0aWNreVxcXCIpLG49dGhpcztlLmxlbmd0aHx8KHRoaXMud2FzV3JhcHBlZD0hMCksdGhpcy4kY29udGFpbmVyPWUubGVuZ3RoP2U6dCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKS53cmFwSW5uZXIodGhpcy4kZWxlbWVudCksdGhpcy4kY29udGFpbmVyLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcyksdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpLmF0dHIoe1xcXCJkYXRhLXJlc2l6ZVxcXCI6aX0pLHRoaXMuc2Nyb2xsQ291bnQ9dGhpcy5vcHRpb25zLmNoZWNrRXZlcnksdGhpcy5pc1N0dWNrPSExLHQod2luZG93KS5vbmUoXFxcImxvYWQuemYuc3RpY2t5XFxcIixmdW5jdGlvbigpe24uY29udGFpbmVySGVpZ2h0PVxcXCJub25lXFxcIj09bi4kZWxlbWVudC5jc3MoXFxcImRpc3BsYXlcXFwiKT8wOm4uJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LG4uJGNvbnRhaW5lci5jc3MoXFxcImhlaWdodFxcXCIsbi5jb250YWluZXJIZWlnaHQpLG4uZWxlbUhlaWdodD1uLmNvbnRhaW5lckhlaWdodCxcXFwiXFxcIiE9PW4ub3B0aW9ucy5hbmNob3I/bi4kYW5jaG9yPXQoXFxcIiNcXFwiK24ub3B0aW9ucy5hbmNob3IpOm4uX3BhcnNlUG9pbnRzKCksbi5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtuLl9jYWxjKCExKTt9KSxuLl9ldmVudHMoaS5zcGxpdChcXFwiLVxcXCIpLnJldmVyc2UoKS5qb2luKFxcXCItXFxcIikpO30pO319LHtrZXk6XFxcIl9wYXJzZVBvaW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtmb3IodmFyIGU9XFxcIlxcXCI9PXRoaXMub3B0aW9ucy50b3BBbmNob3I/MTp0aGlzLm9wdGlvbnMudG9wQW5jaG9yLGk9XFxcIlxcXCI9PXRoaXMub3B0aW9ucy5idG1BbmNob3I/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDp0aGlzLm9wdGlvbnMuYnRtQW5jaG9yLG49W2UsaV0scz17fSxvPTAsYT1uLmxlbmd0aDtvPGEmJm5bb107bysrKXt2YXIgcjtpZihcXFwibnVtYmVyXFxcIj09dHlwZW9mIG5bb10pcj1uW29dO2Vsc2V7dmFyIGw9bltvXS5zcGxpdChcXFwiOlxcXCIpLHU9dChcXFwiI1xcXCIrbFswXSk7cj11Lm9mZnNldCgpLnRvcCxsWzFdJiZcXFwiYm90dG9tXFxcIj09PWxbMV0udG9Mb3dlckNhc2UoKSYmKHIrPXVbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTt9c1tvXT1yO310aGlzLnBvaW50cz1zO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXMsbj10aGlzLnNjcm9sbExpc3RlbmVyPVxcXCJzY3JvbGwuemYuXFxcIitlO3RoaXMuaXNPbnx8KHRoaXMuY2FuU3RpY2smJih0aGlzLmlzT249ITAsdCh3aW5kb3cpLm9mZihuKS5vbihuLGZ1bmN0aW9uKHQpezA9PT1pLnNjcm9sbENvdW50PyhpLnNjcm9sbENvdW50PWkub3B0aW9ucy5jaGVja0V2ZXJ5LGkuX3NldFNpemVzKGZ1bmN0aW9uKCl7aS5fY2FsYyghMSx3aW5kb3cucGFnZVlPZmZzZXQpO30pKTooaS5zY3JvbGxDb3VudC0tLGkuX2NhbGMoITEsd2luZG93LnBhZ2VZT2Zmc2V0KSk7fSkpLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIikub24oXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiLGZ1bmN0aW9uKHQscyl7aS5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtpLl9jYWxjKCExKSxpLmNhblN0aWNrP2kuaXNPbnx8aS5fZXZlbnRzKGUpOmkuaXNPbiYmaS5fcGF1c2VMaXN0ZW5lcnMobik7fSk7fSkpO319LHtrZXk6XFxcIl9wYXVzZUxpc3RlbmVyc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dGhpcy5pc09uPSExLHQod2luZG93KS5vZmYoZSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwYXVzZS56Zi5zdGlja3lcXFwiKTt9fSx7a2V5OlxcXCJfY2FsY1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXtyZXR1cm4gdCYmdGhpcy5fc2V0U2l6ZXMoKSx0aGlzLmNhblN0aWNrPyhlfHwoZT13aW5kb3cucGFnZVlPZmZzZXQpLHZvaWQoZT49dGhpcy50b3BQb2ludD9lPD10aGlzLmJvdHRvbVBvaW50P3RoaXMuaXNTdHVja3x8dGhpcy5fc2V0U3RpY2t5KCk6dGhpcy5pc1N0dWNrJiZ0aGlzLl9yZW1vdmVTdGlja3koITEpOnRoaXMuaXNTdHVjayYmdGhpcy5fcmVtb3ZlU3RpY2t5KCEwKSkpOih0aGlzLmlzU3R1Y2smJnRoaXMuX3JlbW92ZVN0aWNreSghMCksITEpO319LHtrZXk6XFxcIl9zZXRTdGlja3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpcyxlPXRoaXMub3B0aW9ucy5zdGlja1RvLGk9XFxcInRvcFxcXCI9PT1lP1xcXCJtYXJnaW5Ub3BcXFwiOlxcXCJtYXJnaW5Cb3R0b21cXFwiLG49XFxcInRvcFxcXCI9PT1lP1xcXCJib3R0b21cXFwiOlxcXCJ0b3BcXFwiLHM9e307c1tpXT10aGlzLm9wdGlvbnNbaV0rXFxcImVtXFxcIixzW2VdPTAsc1tuXT1cXFwiYXV0b1xcXCIscy5sZWZ0PXRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0K3BhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSlbXFxcInBhZGRpbmctbGVmdFxcXCJdLDEwKSx0aGlzLmlzU3R1Y2s9ITAsdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtYW5jaG9yZWQgaXMtYXQtXFxcIituKS5hZGRDbGFzcyhcXFwiaXMtc3R1Y2sgaXMtYXQtXFxcIitlKS5jc3MocykudHJpZ2dlcihcXFwic3RpY2t5LnpmLnN0dWNrdG86XFxcIitlKSx0aGlzLiRlbGVtZW50Lm9uKFxcXCJ0cmFuc2l0aW9uZW5kIHdlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQgTVNUcmFuc2l0aW9uRW5kXFxcIixmdW5jdGlvbigpe3QuX3NldFNpemVzKCk7fSk7fX0se2tleTpcXFwiX3JlbW92ZVN0aWNreVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy5vcHRpb25zLnN0aWNrVG8saT1cXFwidG9wXFxcIj09PWUsbj17fSxzPSh0aGlzLnBvaW50cz90aGlzLnBvaW50c1sxXS10aGlzLnBvaW50c1swXTp0aGlzLmFuY2hvckhlaWdodCktdGhpcy5lbGVtSGVpZ2h0LG89aT9cXFwibWFyZ2luVG9wXFxcIjpcXFwibWFyZ2luQm90dG9tXFxcIixhPXQ/XFxcInRvcFxcXCI6XFxcImJvdHRvbVxcXCI7bltvXT0wLG4uYm90dG9tPVxcXCJhdXRvXFxcIix0P24udG9wPTA6bi50b3A9cyxuLmxlZnQ9XFxcIlxcXCIsdGhpcy5pc1N0dWNrPSExLHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcImlzLXN0dWNrIGlzLWF0LVxcXCIrZSkuYWRkQ2xhc3MoXFxcImlzLWFuY2hvcmVkIGlzLWF0LVxcXCIrYSkuY3NzKG4pLnRyaWdnZXIoXFxcInN0aWNreS56Zi51bnN0dWNrZnJvbTpcXFwiK2EpO319LHtrZXk6XFxcIl9zZXRTaXplc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dGhpcy5jYW5TdGljaz1Gb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc3RpY2t5T24pLHRoaXMuY2FuU3RpY2t8fHQmJlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB0JiZ0KCk7dmFyIGU9dGhpcy4kY29udGFpbmVyWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoLGk9d2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kY29udGFpbmVyWzBdKSxuPXBhcnNlSW50KGlbXFxcInBhZGRpbmctcmlnaHRcXFwiXSwxMCk7dGhpcy4kYW5jaG9yJiZ0aGlzLiRhbmNob3IubGVuZ3RoP3RoaXMuYW5jaG9ySGVpZ2h0PXRoaXMuJGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ6dGhpcy5fcGFyc2VQb2ludHMoKSx0aGlzLiRlbGVtZW50LmNzcyh7XFxcIm1heC13aWR0aFxcXCI6ZS1uK1xcXCJweFxcXCJ9KTt2YXIgcz10aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodHx8dGhpcy5jb250YWluZXJIZWlnaHQ7aWYoXFxcIm5vbmVcXFwiPT10aGlzLiRlbGVtZW50LmNzcyhcXFwiZGlzcGxheVxcXCIpJiYocz0wKSx0aGlzLmNvbnRhaW5lckhlaWdodD1zLHRoaXMuJGNvbnRhaW5lci5jc3Moe2hlaWdodDpzfSksdGhpcy5lbGVtSGVpZ2h0PXMsdGhpcy5pc1N0dWNrKXRoaXMuJGVsZW1lbnQuY3NzKHtsZWZ0OnRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0K3BhcnNlSW50KGlbXFxcInBhZGRpbmctbGVmdFxcXCJdLDEwKX0pO2Vsc2UgaWYodGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtYXQtYm90dG9tXFxcIikpe3ZhciBvPSh0aGlzLnBvaW50cz90aGlzLnBvaW50c1sxXS10aGlzLiRjb250YWluZXIub2Zmc2V0KCkudG9wOnRoaXMuYW5jaG9ySGVpZ2h0KS10aGlzLmVsZW1IZWlnaHQ7dGhpcy4kZWxlbWVudC5jc3MoXFxcInRvcFxcXCIsbyk7fXRoaXMuX3NldEJyZWFrUG9pbnRzKHMsZnVuY3Rpb24oKXt0JiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgdCYmdCgpO30pO319LHtrZXk6XFxcIl9zZXRCcmVha1BvaW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxpKXtpZighdGhpcy5jYW5TdGljayl7aWYoIWl8fFxcXCJmdW5jdGlvblxcXCIhPXR5cGVvZiBpKXJldHVybiExO2koKTt9dmFyIG49ZSh0aGlzLm9wdGlvbnMubWFyZ2luVG9wKSxzPWUodGhpcy5vcHRpb25zLm1hcmdpbkJvdHRvbSksbz10aGlzLnBvaW50cz90aGlzLnBvaW50c1swXTp0aGlzLiRhbmNob3Iub2Zmc2V0KCkudG9wLGE9dGhpcy5wb2ludHM/dGhpcy5wb2ludHNbMV06byt0aGlzLmFuY2hvckhlaWdodCxyPXdpbmRvdy5pbm5lckhlaWdodDtcXFwidG9wXFxcIj09PXRoaXMub3B0aW9ucy5zdGlja1RvPyhvLT1uLGEtPXQrbik6XFxcImJvdHRvbVxcXCI9PT10aGlzLm9wdGlvbnMuc3RpY2tUbyYmKG8tPXItKHQrcyksYS09ci1zKSx0aGlzLnRvcFBvaW50PW8sdGhpcy5ib3R0b21Qb2ludD1hLGkmJlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBpJiZpKCk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9yZW1vdmVTdGlja3koITApLHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzK1xcXCIgaXMtYW5jaG9yZWQgaXMtYXQtdG9wXFxcIikuY3NzKHtoZWlnaHQ6XFxcIlxcXCIsdG9wOlxcXCJcXFwiLGJvdHRvbTpcXFwiXFxcIixcXFwibWF4LXdpZHRoXFxcIjpcXFwiXFxcIn0pLm9mZihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIpLHRoaXMuJGFuY2hvciYmdGhpcy4kYW5jaG9yLmxlbmd0aCYmdGhpcy4kYW5jaG9yLm9mZihcXFwiY2hhbmdlLnpmLnN0aWNreVxcXCIpLHQod2luZG93KS5vZmYodGhpcy5zY3JvbGxMaXN0ZW5lciksdGhpcy53YXNXcmFwcGVkP3RoaXMuJGVsZW1lbnQudW53cmFwKCk6dGhpcy4kY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcykuY3NzKHtoZWlnaHQ6XFxcIlxcXCJ9KSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxpO30oKTtpLmRlZmF1bHRzPXtjb250YWluZXI6XFxcIjxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyPjwvZGl2PlxcXCIsc3RpY2tUbzpcXFwidG9wXFxcIixhbmNob3I6XFxcIlxcXCIsdG9wQW5jaG9yOlxcXCJcXFwiLGJ0bUFuY2hvcjpcXFwiXFxcIixtYXJnaW5Ub3A6MSxtYXJnaW5Cb3R0b206MSxzdGlja3lPbjpcXFwibWVkaXVtXFxcIixzdGlja3lDbGFzczpcXFwic3RpY2t5XFxcIixjb250YWluZXJDbGFzczpcXFwic3RpY2t5LWNvbnRhaW5lclxcXCIsY2hlY2tFdmVyeTotMX0sRm91bmRhdGlvbi5wbHVnaW4oaSxcXFwiU3RpY2t5XFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJUYWJzXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiVGFic1xcXCIse0VOVEVSOlxcXCJvcGVuXFxcIixTUEFDRTpcXFwib3BlblxcXCIsQVJST1dfUklHSFQ6XFxcIm5leHRcXFwiLEFSUk9XX1VQOlxcXCJwcmV2aW91c1xcXCIsQVJST1dfRE9XTjpcXFwibmV4dFxcXCIsQVJST1dfTEVGVDpcXFwicHJldmlvdXNcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcztpZih0aGlzLiR0YWJUaXRsZXM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMubGlua0NsYXNzKSx0aGlzLiR0YWJDb250ZW50PXQoJ1tkYXRhLXRhYnMtY29udGVudD1cXFwiJyt0aGlzLiRlbGVtZW50WzBdLmlkKydcXFwiXScpLHRoaXMuJHRhYlRpdGxlcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkuZmluZChcXFwiYVxcXCIpLHM9aS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksbz1uWzBdLmhhc2guc2xpY2UoMSksYT1uWzBdLmlkP25bMF0uaWQ6bytcXFwiLWxhYmVsXFxcIixyPXQoXFxcIiNcXFwiK28pO2kuYXR0cih7cm9sZTpcXFwicHJlc2VudGF0aW9uXFxcIn0pLG4uYXR0cih7cm9sZTpcXFwidGFiXFxcIixcXFwiYXJpYS1jb250cm9sc1xcXCI6byxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6cyxpZDphfSksci5hdHRyKHtyb2xlOlxcXCJ0YWJwYW5lbFxcXCIsXFxcImFyaWEtaGlkZGVuXFxcIjohcyxcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjphfSkscyYmZS5vcHRpb25zLmF1dG9Gb2N1cyYmbi5mb2N1cygpO30pLHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCl7dmFyIGk9dGhpcy4kdGFiQ29udGVudC5maW5kKFxcXCJpbWdcXFwiKTtpLmxlbmd0aD9Gb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKGksdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpOnRoaXMuX3NldEhlaWdodCgpO310aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX2FkZEtleUhhbmRsZXIoKSx0aGlzLl9hZGRDbGlja0hhbmRsZXIoKSx0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXI9bnVsbCx0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQmJih0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXI9dGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcyksdCh3aW5kb3cpLm9uKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcikpO319LHtrZXk6XFxcIl9hZGRDbGlja0hhbmRsZXJcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50Lm9mZihcXFwiY2xpY2suemYudGFic1xcXCIpLm9uKFxcXCJjbGljay56Zi50YWJzXFxcIixcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcyxmdW5jdGlvbihpKXtpLnByZXZlbnREZWZhdWx0KCksaS5zdG9wUHJvcGFnYXRpb24oKSx0KHRoaXMpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKXx8ZS5faGFuZGxlVGFiQ2hhbmdlKHQodGhpcykpO30pO319LHtrZXk6XFxcIl9hZGRLZXlIYW5kbGVyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7ZS4kZWxlbWVudC5maW5kKFxcXCJsaTpmaXJzdC1vZi10eXBlXFxcIiksZS4kZWxlbWVudC5maW5kKFxcXCJsaTpsYXN0LW9mLXR5cGVcXFwiKTt0aGlzLiR0YWJUaXRsZXMub2ZmKFxcXCJrZXlkb3duLnpmLnRhYnNcXFwiKS5vbihcXFwia2V5ZG93bi56Zi50YWJzXFxcIixmdW5jdGlvbihpKXtpZig5IT09aS53aGljaCl7dmFyIG4scyxvPXQodGhpcyksYT1vLnBhcmVudChcXFwidWxcXFwiKS5jaGlsZHJlbihcXFwibGlcXFwiKTthLmVhY2goZnVuY3Rpb24oaSl7aWYodCh0aGlzKS5pcyhvKSlyZXR1cm4gdm9pZChlLm9wdGlvbnMud3JhcE9uS2V5cz8obj0wPT09aT9hLmxhc3QoKTphLmVxKGktMSkscz1pPT09YS5sZW5ndGgtMT9hLmZpcnN0KCk6YS5lcShpKzEpKToobj1hLmVxKE1hdGgubWF4KDAsaS0xKSkscz1hLmVxKE1hdGgubWluKGkrMSxhLmxlbmd0aC0xKSkpKTt9KSxGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJUYWJzXFxcIix7b3BlbjpmdW5jdGlvbiBvcGVuKCl7by5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpLGUuX2hhbmRsZVRhYkNoYW5nZShvKTt9LHByZXZpb3VzOmZ1bmN0aW9uIHByZXZpb3VzKCl7bi5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpLGUuX2hhbmRsZVRhYkNoYW5nZShuKTt9LG5leHQ6ZnVuY3Rpb24gbmV4dCgpe3MuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuZm9jdXMoKSxlLl9oYW5kbGVUYWJDaGFuZ2Uocyk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQoKXtpLnN0b3BQcm9wYWdhdGlvbigpLGkucHJldmVudERlZmF1bHQoKTt9fSk7fX0pO319LHtrZXk6XFxcIl9oYW5kbGVUYWJDaGFuZ2VcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPWUuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJyksbj1pWzBdLmhhc2gscz10aGlzLiR0YWJDb250ZW50LmZpbmQobiksbz10aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5saW5rQ2xhc3MrXFxcIi5pcy1hY3RpdmVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuYXR0cih7XFxcImFyaWEtc2VsZWN0ZWRcXFwiOlxcXCJmYWxzZVxcXCJ9KTt0KFxcXCIjXFxcIitvLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiKSkucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6XFxcInRydWVcXFwifSksZS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksaS5hdHRyKHtcXFwiYXJpYS1zZWxlY3RlZFxcXCI6XFxcInRydWVcXFwifSkscy5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjpcXFwiZmFsc2VcXFwifSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJjaGFuZ2UuemYudGFic1xcXCIsW2VdKTt9fSx7a2V5OlxcXCJzZWxlY3RUYWJcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlO2U9XFxcIm9iamVjdFxcXCI9PSh0eXBlb2YgdD09PVxcXCJ1bmRlZmluZWRcXFwiP1xcXCJ1bmRlZmluZWRcXFwiOl90eXBlb2YodCkpP3RbMF0uaWQ6dCxlLmluZGV4T2YoXFxcIiNcXFwiKTwwJiYoZT1cXFwiI1xcXCIrZSk7dmFyIGk9dGhpcy4kdGFiVGl0bGVzLmZpbmQoJ1tocmVmPVxcXCInK2UrJ1xcXCJdJykucGFyZW50KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMubGlua0NsYXNzKTt0aGlzLl9oYW5kbGVUYWJDaGFuZ2UoaSk7fX0se2tleTpcXFwiX3NldEhlaWdodFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT0wO3RoaXMuJHRhYkNvbnRlbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnBhbmVsQ2xhc3MpLmNzcyhcXFwiaGVpZ2h0XFxcIixcXFwiXFxcIikuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKTtufHxpLmNzcyh7dmlzaWJpbGl0eTpcXFwiaGlkZGVuXFxcIixkaXNwbGF5OlxcXCJibG9ja1xcXCJ9KTt2YXIgcz10aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtufHxpLmNzcyh7dmlzaWJpbGl0eTpcXFwiXFxcIixkaXNwbGF5OlxcXCJcXFwifSksZT1zPmU/czplO30pLmNzcyhcXFwiaGVpZ2h0XFxcIixlK1xcXCJweFxcXCIpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMubGlua0NsYXNzKS5vZmYoXFxcIi56Zi50YWJzXFxcIikuaGlkZSgpLmVuZCgpLmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5wYW5lbENsYXNzKS5oaWRlKCksdGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0JiZudWxsIT10aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXImJnQod2luZG93KS5vZmYoXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXthdXRvRm9jdXM6ITEsd3JhcE9uS2V5czohMCxtYXRjaEhlaWdodDohMSxsaW5rQ2xhc3M6XFxcInRhYnMtdGl0bGVcXFwiLHBhbmVsQ2xhc3M6XFxcInRhYnMtcGFuZWxcXFwifSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJUYWJzXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyxpLmRhdGEoKSxuKSx0aGlzLmNsYXNzTmFtZT1cXFwiXFxcIix0aGlzLl9pbml0KCksdGhpcy5fZXZlbnRzKCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJUb2dnbGVyXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU7dGhpcy5vcHRpb25zLmFuaW1hdGU/KGU9dGhpcy5vcHRpb25zLmFuaW1hdGUuc3BsaXQoXFxcIiBcXFwiKSx0aGlzLmFuaW1hdGlvbkluPWVbMF0sdGhpcy5hbmltYXRpb25PdXQ9ZVsxXXx8bnVsbCk6KGU9dGhpcy4kZWxlbWVudC5kYXRhKFxcXCJ0b2dnbGVyXFxcIiksdGhpcy5jbGFzc05hbWU9XFxcIi5cXFwiPT09ZVswXT9lLnNsaWNlKDEpOmUpO3ZhciBpPXRoaXMuJGVsZW1lbnRbMF0uaWQ7dCgnW2RhdGEtb3Blbj1cXFwiJytpKydcXFwiXSwgW2RhdGEtY2xvc2U9XFxcIicraSsnXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiJytpKydcXFwiXScpLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiLGkpLHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsIXRoaXMuJGVsZW1lbnQuaXMoXFxcIjpoaWRkZW5cXFwiKSk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50Lm9mZihcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiKS5vbihcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiLHRoaXMudG9nZ2xlLmJpbmQodGhpcykpO319LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzW3RoaXMub3B0aW9ucy5hbmltYXRlP1xcXCJfdG9nZ2xlQW5pbWF0ZVxcXCI6XFxcIl90b2dnbGVDbGFzc1xcXCJdKCk7fX0se2tleTpcXFwiX3RvZ2dsZUNsYXNzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5jbGFzc05hbWUpO3ZhciB0PXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5jbGFzc05hbWUpO3Q/dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJvbi56Zi50b2dnbGVyXFxcIik6dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJvZmYuemYudG9nZ2xlclxcXCIpLHRoaXMuX3VwZGF0ZUFSSUEodCk7fX0se2tleTpcXFwiX3RvZ2dsZUFuaW1hdGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpczt0aGlzLiRlbGVtZW50LmlzKFxcXCI6aGlkZGVuXFxcIik/Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsdGhpcy5hbmltYXRpb25JbixmdW5jdGlvbigpe3QuX3VwZGF0ZUFSSUEoITApLHRoaXMudHJpZ2dlcihcXFwib24uemYudG9nZ2xlclxcXCIpO30pOkZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kZWxlbWVudCx0aGlzLmFuaW1hdGlvbk91dCxmdW5jdGlvbigpe3QuX3VwZGF0ZUFSSUEoITEpLHRoaXMudHJpZ2dlcihcXFwib2ZmLnpmLnRvZ2dsZXJcXFwiKTt9KTt9fSx7a2V5OlxcXCJfdXBkYXRlQVJJQVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhIXQpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50b2dnbGVyXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17YW5pbWF0ZTohMX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiVG9nZ2xlclxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5pc0FjdGl2ZT0hMSx0aGlzLmlzQ2xpY2s9ITEsdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiVG9vbHRpcFxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1kZXNjcmliZWRieVxcXCIpfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcInRvb2x0aXBcXFwiKTt0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcz10aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzc3x8dGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLiRlbGVtZW50KSx0aGlzLm9wdGlvbnMudGlwVGV4dD10aGlzLm9wdGlvbnMudGlwVGV4dHx8dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJ0aXRsZVxcXCIpLHRoaXMudGVtcGxhdGU9dGhpcy5vcHRpb25zLnRlbXBsYXRlP3QodGhpcy5vcHRpb25zLnRlbXBsYXRlKTp0aGlzLl9idWlsZFRlbXBsYXRlKGUpLHRoaXMudGVtcGxhdGUuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSkudGV4dCh0aGlzLm9wdGlvbnMudGlwVGV4dCkuaGlkZSgpLHRoaXMuJGVsZW1lbnQuYXR0cih7dGl0bGU6XFxcIlxcXCIsXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiOmUsXFxcImRhdGEteWV0aS1ib3hcXFwiOmUsXFxcImRhdGEtdG9nZ2xlXFxcIjplLFxcXCJkYXRhLXJlc2l6ZVxcXCI6ZX0pLmFkZENsYXNzKHRoaXMub3B0aW9ucy50cmlnZ2VyQ2xhc3MpLHRoaXMudXNlZFBvc2l0aW9ucz1bXSx0aGlzLmNvdW50ZXI9NCx0aGlzLmNsYXNzQ2hhbmdlZD0hMSx0aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJfZ2V0UG9zaXRpb25DbGFzc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7aWYoIXQpcmV0dXJuXFxcIlxcXCI7dmFyIGU9dFswXS5jbGFzc05hbWUubWF0Y2goL1xcXFxiKHRvcHxsZWZ0fHJpZ2h0KVxcXFxiL2cpO3JldHVybiBlPWU/ZVswXTpcXFwiXFxcIjt9fSx7a2V5OlxcXCJfYnVpbGRUZW1wbGF0ZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9KHRoaXMub3B0aW9ucy50b29sdGlwQ2xhc3MrXFxcIiBcXFwiK3RoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzK1xcXCIgXFxcIit0aGlzLm9wdGlvbnMudGVtcGxhdGVDbGFzc2VzKS50cmltKCksbj10KFxcXCI8ZGl2PjwvZGl2PlxcXCIpLmFkZENsYXNzKGkpLmF0dHIoe3JvbGU6XFxcInRvb2x0aXBcXFwiLFxcXCJhcmlhLWhpZGRlblxcXCI6ITAsXFxcImRhdGEtaXMtYWN0aXZlXFxcIjohMSxcXFwiZGF0YS1pcy1mb2N1c1xcXCI6ITEsaWQ6ZX0pO3JldHVybiBuO319LHtrZXk6XFxcIl9yZXBvc2l0aW9uXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0aGlzLnVzZWRQb3NpdGlvbnMucHVzaCh0P3Q6XFxcImJvdHRvbVxcXCIpLCF0JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwidG9wXFxcIik8MD90aGlzLnRlbXBsYXRlLmFkZENsYXNzKFxcXCJ0b3BcXFwiKTpcXFwidG9wXFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCk6XFxcImxlZnRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInJpZ2h0XFxcIik8MD90aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJyaWdodFxcXCIpOlxcXCJyaWdodFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcXFwibGVmdFxcXCIpOiF0JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwidG9wXFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLnRlbXBsYXRlLmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6XFxcInRvcFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6XFxcImxlZnRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInJpZ2h0XFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCk6XFxcInJpZ2h0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCk6dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KSx0aGlzLmNsYXNzQ2hhbmdlZD0hMCx0aGlzLmNvdW50ZXItLTt9fSx7a2V5OlxcXCJfc2V0UG9zaXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLnRlbXBsYXRlKSxlPUZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy50ZW1wbGF0ZSksaT1Gb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGVsZW1lbnQpLG49XFxcImxlZnRcXFwiPT09dD9cXFwibGVmdFxcXCI6XFxcInJpZ2h0XFxcIj09PXQ/XFxcImxlZnRcXFwiOlxcXCJ0b3BcXFwiLHM9XFxcInRvcFxcXCI9PT1uP1xcXCJoZWlnaHRcXFwiOlxcXCJ3aWR0aFxcXCI7XFxcImhlaWdodFxcXCI9PT1zP3RoaXMub3B0aW9ucy52T2Zmc2V0OnRoaXMub3B0aW9ucy5oT2Zmc2V0O2lmKGUud2lkdGg+PWUud2luZG93RGltcy53aWR0aHx8IXRoaXMuY291bnRlciYmIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkpcmV0dXJuIHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSx0aGlzLiRlbGVtZW50LFxcXCJjZW50ZXIgYm90dG9tXFxcIix0aGlzLm9wdGlvbnMudk9mZnNldCx0aGlzLm9wdGlvbnMuaE9mZnNldCwhMCkpLmNzcyh7d2lkdGg6aS53aW5kb3dEaW1zLndpZHRoLTIqdGhpcy5vcHRpb25zLmhPZmZzZXQsaGVpZ2h0OlxcXCJhdXRvXFxcIn0pLCExO2Zvcih0aGlzLnRlbXBsYXRlLm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsdGhpcy4kZWxlbWVudCxcXFwiY2VudGVyIFxcXCIrKHR8fFxcXCJib3R0b21cXFwiKSx0aGlzLm9wdGlvbnMudk9mZnNldCx0aGlzLm9wdGlvbnMuaE9mZnNldCkpOyFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMudGVtcGxhdGUpJiZ0aGlzLmNvdW50ZXI7KXt0aGlzLl9yZXBvc2l0aW9uKHQpLHRoaXMuX3NldFBvc2l0aW9uKCk7fX19LHtrZXk6XFxcInNob3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYoXFxcImFsbFxcXCIhPT10aGlzLm9wdGlvbnMuc2hvd09uJiYhRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLnNob3dPbikpcmV0dXJuITE7dmFyIHQ9dGhpczt0aGlzLnRlbXBsYXRlLmNzcyhcXFwidmlzaWJpbGl0eVxcXCIsXFxcImhpZGRlblxcXCIpLnNob3coKSx0aGlzLl9zZXRQb3NpdGlvbigpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VtZS56Zi50b29sdGlwXFxcIix0aGlzLnRlbXBsYXRlLmF0dHIoXFxcImlkXFxcIikpLHRoaXMudGVtcGxhdGUuYXR0cih7XFxcImRhdGEtaXMtYWN0aXZlXFxcIjohMCxcXFwiYXJpYS1oaWRkZW5cXFwiOiExfSksdC5pc0FjdGl2ZT0hMCx0aGlzLnRlbXBsYXRlLnN0b3AoKS5oaWRlKCkuY3NzKFxcXCJ2aXNpYmlsaXR5XFxcIixcXFwiXFxcIikuZmFkZUluKHRoaXMub3B0aW9ucy5mYWRlSW5EdXJhdGlvbixmdW5jdGlvbigpe30pLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwic2hvdy56Zi50b29sdGlwXFxcIik7fX0se2tleTpcXFwiaGlkZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzO3RoaXMudGVtcGxhdGUuc3RvcCgpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITAsXFxcImRhdGEtaXMtYWN0aXZlXFxcIjohMX0pLmZhZGVPdXQodGhpcy5vcHRpb25zLmZhZGVPdXREdXJhdGlvbixmdW5jdGlvbigpe3QuaXNBY3RpdmU9ITEsdC5pc0NsaWNrPSExLHQuY2xhc3NDaGFuZ2VkJiYodC50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0Ll9nZXRQb3NpdGlvbkNsYXNzKHQudGVtcGxhdGUpKS5hZGRDbGFzcyh0Lm9wdGlvbnMucG9zaXRpb25DbGFzcyksdC51c2VkUG9zaXRpb25zPVtdLHQuY291bnRlcj00LHQuY2xhc3NDaGFuZ2VkPSExKTt9KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImhpZGUuemYudG9vbHRpcFxcXCIpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpcyxlPSh0aGlzLnRlbXBsYXRlLCExKTt0aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyfHx0aGlzLiRlbGVtZW50Lm9uKFxcXCJtb3VzZWVudGVyLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGUpe3QuaXNBY3RpdmV8fCh0LnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe3Quc2hvdygpO30sdC5vcHRpb25zLmhvdmVyRGVsYXkpKTt9KS5vbihcXFwibW91c2VsZWF2ZS56Zi50b29sdGlwXFxcIixmdW5jdGlvbihpKXtjbGVhclRpbWVvdXQodC50aW1lb3V0KSwoIWV8fHQuaXNDbGljayYmIXQub3B0aW9ucy5jbGlja09wZW4pJiZ0LmhpZGUoKTt9KSx0aGlzLm9wdGlvbnMuY2xpY2tPcGVuP3RoaXMuJGVsZW1lbnQub24oXFxcIm1vdXNlZG93bi56Zi50b29sdGlwXFxcIixmdW5jdGlvbihlKXtlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLHQuaXNDbGlja3x8KHQuaXNDbGljaz0hMCwhdC5vcHRpb25zLmRpc2FibGVIb3ZlciYmdC4kZWxlbWVudC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIpfHx0LmlzQWN0aXZlfHx0LnNob3coKSk7fSk6dGhpcy4kZWxlbWVudC5vbihcXFwibW91c2Vkb3duLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGUpe2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdC5pc0NsaWNrPSEwO30pLHRoaXMub3B0aW9ucy5kaXNhYmxlRm9yVG91Y2h8fHRoaXMuJGVsZW1lbnQub24oXFxcInRhcC56Zi50b29sdGlwIHRvdWNoZW5kLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGUpe3QuaXNBY3RpdmU/dC5oaWRlKCk6dC5zaG93KCk7fSksdGhpcy4kZWxlbWVudC5vbih7XFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiOnRoaXMuaGlkZS5iaW5kKHRoaXMpfSksdGhpcy4kZWxlbWVudC5vbihcXFwiZm9jdXMuemYudG9vbHRpcFxcXCIsZnVuY3Rpb24oaSl7cmV0dXJuIGU9ITAsdC5pc0NsaWNrPyh0Lm9wdGlvbnMuY2xpY2tPcGVufHwoZT0hMSksITEpOnZvaWQgdC5zaG93KCk7fSkub24oXFxcImZvY3Vzb3V0LnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGkpe2U9ITEsdC5pc0NsaWNrPSExLHQuaGlkZSgpO30pLm9uKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIixmdW5jdGlvbigpe3QuaXNBY3RpdmUmJnQuX3NldFBvc2l0aW9uKCk7fSk7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuaXNBY3RpdmU/dGhpcy5oaWRlKCk6dGhpcy5zaG93KCk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIix0aGlzLnRlbXBsYXRlLnRleHQoKSkub2ZmKFxcXCIuemYudHJpZ2dlciAuemYudG9vdGlwXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1kZXNjcmliZWRieVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEteWV0aS1ib3hcXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLXRvZ2dsZVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtcmVzaXplXFxcIiksdGhpcy50ZW1wbGF0ZS5yZW1vdmUoKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtkaXNhYmxlRm9yVG91Y2g6ITEsaG92ZXJEZWxheToyMDAsZmFkZUluRHVyYXRpb246MTUwLGZhZGVPdXREdXJhdGlvbjoxNTAsZGlzYWJsZUhvdmVyOiExLHRlbXBsYXRlQ2xhc3NlczpcXFwiXFxcIix0b29sdGlwQ2xhc3M6XFxcInRvb2x0aXBcXFwiLHRyaWdnZXJDbGFzczpcXFwiaGFzLXRpcFxcXCIsc2hvd09uOlxcXCJzbWFsbFxcXCIsdGVtcGxhdGU6XFxcIlxcXCIsdGlwVGV4dDpcXFwiXFxcIix0b3VjaENsb3NlVGV4dDpcXFwiVGFwIHRvIGNsb3NlLlxcXCIsY2xpY2tPcGVuOiEwLHBvc2l0aW9uQ2xhc3M6XFxcIlxcXCIsdk9mZnNldDoxMCxoT2Zmc2V0OjEyfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJUb29sdGlwXFxcIik7fShqUXVlcnkpO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2JhYmVsLWxvYWRlci9saWI/e1wicHJlc2V0c1wiOltcInJlYWN0XCIsXCJlczIwMTVcIl19IS4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XHJcbmltcG9ydCB7IFJvdXRlLCBSb3V0ZXIsIEluZGV4Um91dGUsIGhhc2hIaXN0b3J5IH0gZnJvbSAncmVhY3Qtcm91dGVyJztcclxuXHJcbmltcG9ydCBNYWluIGZyb20gJy4vY29tcG9uZW50cy9NYWluJztcclxuaW1wb3J0IFRpbWVyIGZyb20gJy4vY29tcG9uZW50cy9UaW1lcic7XHJcbmltcG9ydCBDb3VudGRvd24gZnJvbSAnLi9jb21wb25lbnRzL0NvdW50ZG93bic7XHJcblxyXG4vLyBMb2FkIEZvdW5kYXRpb25cclxucmVxdWlyZSgnc3R5bGUhY3NzIWZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5jc3MnKTtcclxuJChkb2N1bWVudCkuZm91bmRhdGlvbigpO1xyXG5cclxuLy8gQXBwIHN0eWxlc1xyXG5yZXF1aXJlKCdzdHlsZSFjc3Mhc2FzcyFhcHBsaWNhdGlvblN0eWxlcycpO1xyXG5cclxuUmVhY3RET00ucmVuZGVyKFxyXG4gICAgPFJvdXRlciBoaXN0b3J5PXtoYXNoSGlzdG9yeX0+XHJcbiAgICAgICAgPFJvdXRlIHBhdGg9XCIvXCIgY29tcG9uZW50PXtNYWlufT5cclxuICAgICAgICAgICAgPFJvdXRlIHBhdGg9XCJjb3VudGRvd25cIiBjb21wb25lbnQ9e0NvdW50ZG93bn0gLz5cclxuICAgICAgICAgICAgPEluZGV4Um91dGUgY29tcG9uZW50PXtUaW1lcn0gLz5cclxuICAgICAgICA8L1JvdXRlPlxyXG4gICAgPC9Sb3V0ZXI+LFxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpXHJcbik7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL2FwcC9hcHAuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGpRdWVyeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImpRdWVyeVwiXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9yZWFjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0UHVyZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RQdXJlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZhY3RvcmllcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoJy4vb25seUNoaWxkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG4gIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudDtcbiAgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xuICBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY2xvbmVFbGVtZW50O1xufVxuXG52YXIgX19zcHJlYWQgPSBfYXNzaWduO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5lZCwgJ1JlYWN0Ll9fc3ByZWFkIGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZC4gVXNlICcgKyAnT2JqZWN0LmFzc2lnbiBkaXJlY3RseSBvciBhbm90aGVyIGhlbHBlciBmdW5jdGlvbiB3aXRoIHNpbWlsYXIgJyArICdzZW1hbnRpY3MuIFlvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8geW91ciBjb21waWxlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcHJlYWQtZGVwcmVjYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcbiAgICB3YXJuZWQgPSB0cnVlO1xuICAgIHJldHVybiBfYXNzaWduLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBSZWFjdCA9IHtcblxuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBSZWFjdFB1cmVDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgLy8gQ3VycmVudGx5IGEgbm9vcC4gV2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0cmFjZSBtaXhpbnMuXG4gICAgcmV0dXJuIG1peGluO1xuICB9LFxuXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cbiAgRE9NOiBSZWFjdERPTUZhY3RvcmllcyxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLy8gRGVwcmVjYXRlZCBob29rIGZvciBKU1ggc3ByZWFkLCBkb24ndCB1c2UgdGhpcyBmb3IgYW55dGhpbmcuXG4gIF9fc3ByZWFkOiBfX3NwcmVhZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9SZWFjdC5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyO1xudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcjtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZ1bmMgPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbkZvckVhY2hCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZvckVhY2hCb29rS2VlcGluZywgdHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBGb3JFYWNoQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgRm9yRWFjaEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIG1hcHBpbmcuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgTWFwQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7ISp9IG1hcFJlc3VsdCBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBtYXBGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IG1hcENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqL1xuZnVuY3Rpb24gTWFwQm9va0tlZXBpbmcobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIHRoaXMucmVzdWx0ID0gbWFwUmVzdWx0O1xuICB0aGlzLmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgdGhpcy5mdW5jID0gbWFwRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuTWFwQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVzdWx0ID0gbnVsbDtcbiAgdGhpcy5rZXlQcmVmaXggPSBudWxsO1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oTWFwQm9va0tlZXBpbmcsIGZvdXJBcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxuICAgICAga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4LFxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gTWFwQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZER1bW15KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlYWN0Q2hpbGRyZW4gPSB7XG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbDogbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCxcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogU3RhdGljIHBvb2xlcnMuIFNldmVyYWwgY3VzdG9tIHZlcnNpb25zIGZvciBlYWNoIHBvdGVudGlhbCBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cy4gQSBjb21wbGV0ZWx5IGdlbmVyaWMgcG9vbGVyIGlzIGVhc3kgdG8gaW1wbGVtZW50LCBidXQgd291bGRcbiAqIHJlcXVpcmUgYWNjZXNzaW5nIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIEluIGVhY2ggb2YgdGhlc2UsIGB0aGlzYCByZWZlcnMgdG9cbiAqIHRoZSBDbGFzcyBpdHNlbGYsIG5vdCBhbiBpbnN0YW5jZS4gSWYgYW55IG90aGVycyBhcmUgbmVlZGVkLCBzaW1wbHkgYWRkIHRoZW1cbiAqIGhlcmUsIG9yIGluIHRoZWlyIG93biBmaWxlcy5cbiAqL1xudmFyIG9uZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIpO1xuICB9XG59O1xuXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMpO1xuICB9XG59O1xuXG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCk7XG4gIH1cbn07XG5cbnZhciBmaXZlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogX3Byb2RJbnZhcmlhbnQoJzI1JykgOiB2b2lkIDA7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIC8vIENhc3RpbmcgYXMgYW55IHNvIHRoYXQgZmxvdyBpZ25vcmVzIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gYW5kIHRydXN0c1xuICAvLyBpdCB0byBtYXRjaCB0aGUgdHlwZSB3ZSBkZWNsYXJlZFxuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG5mdW5jdGlvbiByZWFjdFByb2RJbnZhcmlhbnQoY29kZSkge1xuICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICB2YXIgbWVzc2FnZSA9ICdNaW5pZmllZCBSZWFjdCBlcnJvciAjJyArIGNvZGUgKyAnOyB2aXNpdCAnICsgJ2h0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ0NvdW50OyBhcmdJZHgrKykge1xuICAgIG1lc3NhZ2UgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYXJnSWR4ICsgMV0pO1xuICB9XG5cbiAgbWVzc2FnZSArPSAnIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCcgKyAnIGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLic7XG5cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVhY3RQcm9kSW52YXJpYW50J3Mgb3duIGZyYW1lXG5cbiAgdGhyb3cgZXJyb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3RQcm9kSW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZmFjdG9yeVxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIHZhciBmYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgLy8gRXhwb3NlIHRoZSB0eXBlIG9uIHRoZSBmYWN0b3J5IGFuZCB0aGUgcHJvdG90eXBlIHNvIHRoYXQgaXQgY2FuIGJlXG4gIC8vIGVhc2lseSBhY2Nlc3NlZCBvbiBlbGVtZW50cy4gRS5nLiBgPEZvbyAvPi50eXBlID09PSBGb29gLlxuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgYGNvbnN0cnVjdG9yYCBzaW5jZSB0aGlzIG1heSBub3QgYmUgdGhlIGZ1bmN0aW9uXG4gIC8vIHRoYXQgY3JlYXRlZCB0aGUgZWxlbWVudCwgYW5kIGl0IG1heSBub3QgZXZlbiBiZSBhIGNvbnN0cnVjdG9yLlxuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5ID0gZnVuY3Rpb24gKG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jbG9uZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5pc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvd2FybmluZy5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbm1vZHVsZS5leHBvcnRzID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRoaXMgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudCBzaW5jZSB0aGlzIGZpbGUgaXMgc2hhcmVkIGJldHdlZW5cbiAqIGlzb21vcnBoaWMgYW5kIHJlbmRlcmVycy4gV2UgY291bGQgZXh0cmFjdCB0aGlzIHRvIGFcbiAqXG4gKi9cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXG4gIC8vIHNvbWUgY2hlY2tzLiBSZWFjdCBGaWJlciBhbHNvIGlubGluZXMgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBwdXJwb3Nlcy5cbiAgdHlwZSA9PT0gJ29iamVjdCcgJiYgY2hpbGRyZW4uJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcnO1xuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBTeW1ib2wgKi9cblxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFVuZXNjYXBlIGFuZCB1bndyYXAga2V5IGZvciBodW1hbi1yZWFkYWJsZSBkaXNwbGF5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHVuZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGtleSkge1xuICB2YXIgdW5lc2NhcGVSZWdleCA9IC8oPTB8PTIpL2c7XG4gIHZhciB1bmVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0wJzogJz0nLFxuICAgICc9Mic6ICc6J1xuICB9O1xuICB2YXIga2V5U3Vic3RyaW5nID0ga2V5WzBdID09PSAnLicgJiYga2V5WzFdID09PSAnJCcgPyBrZXkuc3Vic3RyaW5nKDIpIDoga2V5LnN1YnN0cmluZygxKTtcblxuICByZXR1cm4gKCcnICsga2V5U3Vic3RyaW5nKS5yZXBsYWNlKHVuZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiB1bmVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbn1cblxudmFyIEtleUVzY2FwZVV0aWxzID0ge1xuICBlc2NhcGU6IGVzY2FwZSxcbiAgdW5lc2NhcGU6IHVuZXNjYXBlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUVzY2FwZVV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL0tleUVzY2FwZVV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IF9wcm9kSW52YXJpYW50KCc4NScpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBSZWFjdENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWFjdFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24oUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlKTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHVyZUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9SZWFjdFB1cmVDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBNSVhJTlNfS0VZID0gJ21peGlucyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBhbGxvdyB0aGUgY3JlYXRpb24gb2YgYW5vbnltb3VzIGZ1bmN0aW9ucyB3aGljaCBkbyBub3Rcbi8vIGhhdmUgLm5hbWUgc2V0IHRvIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBiZWluZyBhc3NpZ25lZCB0by5cbmZ1bmN0aW9uIGlkZW50aXR5KGZuKSB7XG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICovXG5cblxudmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbi8qKlxuICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAqIG9yIGhvc3QgY29tcG9uZW50cy5cbiAqXG4gKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7YXJyYXl9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgbWl4aW5zOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHN0YXRpY3M6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgcHJvcFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjaGlsZENvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgKlxuICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4ge1xuICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRJbml0aWFsU3RhdGU6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0OiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAvKipcbiAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgKiBAcmVxdWlyZWRcbiAgICovXG4gIHJlbmRlcjogJ0RFRklORV9PTkNFJyxcblxuICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbE1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgKlxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICogdXBkYXRlLlxuICAgKlxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogJ0RFRklORV9PTkNFJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGU6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6ICdPVkVSUklERV9CQVNFJ1xuXG59O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbHRob3VnaCB0aGVzZSBhcmUgZGVjbGFyZWQgbGlrZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGluIHRoZSBzcGVjaWZpY2F0aW9uXG4gKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICogYmVpbmcgc3RhdGljLCB0aGV5IG11c3QgYmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBcInN0YXRpY3NcIiBrZXkgdW5kZXJcbiAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAqL1xudmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9LFxuICBtaXhpbnM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgaWYgKG1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCAnY2hpbGRDb250ZXh0Jyk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgfSxcbiAgY29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgJ2NvbnRleHQnKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzLCBjb250ZXh0VHlwZXMpO1xuICB9LFxuICAvKipcbiAgICogU3BlY2lhbCBjYXNlIGdldERlZmF1bHRQcm9wcyB3aGljaCBzaG91bGQgbW92ZSBpbnRvIHN0YXRpY3MgYnV0IHJlcXVpcmVzXG4gICAqIGF1dG9tYXRpYyBtZXJnaW5nLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcywgZ2V0RGVmYXVsdFByb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgIH1cbiAgfSxcbiAgcHJvcFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHByb3BUeXBlcywgJ3Byb3AnKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IucHJvcFR5cGVzID0gX2Fzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICB9LFxuICBzdGF0aWNzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gIH0sXG4gIGF1dG9iaW5kOiBmdW5jdGlvbiAoKSB7fSB9O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIC8vIHVzZSBhIHdhcm5pbmcgaW5zdGVhZCBvZiBhbiBpbnZhcmlhbnQgc28gY29tcG9uZW50c1xuICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBvbmx5IGluIF9fREVWX19cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKSB7XG4gIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV0gOiBudWxsO1xuXG4gIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChSZWFjdENsYXNzTWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09ICdPVkVSUklERV9CQVNFJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlIGAlc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzIGRvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3MycsIG5hbWUpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gRGlzYWxsb3cgZGVmaW5pbmcgbWV0aG9kcyBtb3JlIHRoYW4gb25jZSB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJyB8fCBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NCcsIG5hbWUpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogTWl4aW4gaGVscGVyIHdoaWNoIGhhbmRsZXMgcG9saWN5IHZhbGlkYXRpb24gYW5kIHJlc2VydmVkXG4gKiBzcGVjaWZpY2F0aW9uIGtleXMgd2hlbiBidWlsZGluZyBSZWFjdCBjbGFzc2VzLlxuICovXG5mdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICBpZiAoIXNwZWMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHR5cGVvZlNwZWMgPSB0eXBlb2Ygc3BlYztcbiAgICAgIHZhciBpc01peGluVmFsaWQgPSB0eXBlb2ZTcGVjID09PSAnb2JqZWN0JyAmJiBzcGVjICE9PSBudWxsO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpc01peGluVmFsaWQsICclczogWW91XFwncmUgYXR0ZW1wdGluZyB0byBpbmNsdWRlIGEgbWl4aW4gdGhhdCBpcyBlaXRoZXIgbnVsbCAnICsgJ29yIG5vdCBhbiBvYmplY3QuIENoZWNrIHRoZSBtaXhpbnMgaW5jbHVkZWQgYnkgdGhlIGNvbXBvbmVudCwgJyArICdhcyB3ZWxsIGFzIGFueSBtaXhpbnMgdGhleSBpbmNsdWRlIHRoZW1zZWx2ZXMuICcgKyAnRXhwZWN0ZWQgb2JqZWN0IGJ1dCBnb3QgJXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBzcGVjID09PSBudWxsID8gbnVsbCA6IHR5cGVvZlNwZWMpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gICEodHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gdXNlIGEgY29tcG9uZW50IGNsYXNzIG9yIGZ1bmN0aW9uIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBfcHJvZEludmFyaWFudCgnNzUnKSA6IHZvaWQgMDtcbiAgISFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3BlYykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IF9wcm9kSW52YXJpYW50KCc3NicpIDogdm9pZCAwO1xuXG4gIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIGF1dG9CaW5kUGFpcnMgPSBwcm90by5fX3JlYWN0QXV0b0JpbmRQYWlycztcblxuICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgfVxuXG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpO1xuXG4gICAgaWYgKFJFU0VSVkVEX1NQRUNfS0VZUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgUkVTRVJWRURfU1BFQ19LRVlTW25hbWVdKENvbnN0cnVjdG9yLCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldHVwIG1ldGhvZHMgb24gcHJvdG90eXBlOlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBtZW1iZXIgbWV0aG9kcyBzaG91bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgYm91bmQ6XG4gICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgIHZhciBpc1JlYWN0Q2xhc3NNZXRob2QgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQgJiYgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICBhdXRvQmluZFBhaXJzLnB1c2gobmFtZSwgcHJvcGVydHkpO1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAhKGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcgfHwgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyB3aGVuIG1peGluZyBpbiBjb21wb25lbnQgc3BlY3MuJywgc3BlY1BvbGljeSwgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzcnLCBzcGVjUG9saWN5LCBuYW1lKSA6IHZvaWQgMDtcblxuICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgIC8vIG1ldGhvZHMgYmVmb3JlIGNhbGxpbmcgdGhlIG5ldyBwcm9wZXJ0eSwgbWVyZ2luZyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXG4gICAgICAgICAgICAvLyBhdCBwcm9maWxpbmcgdG9vbHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgaWYgKCFzdGF0aWNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTO1xuICAgICEhaXNSZXNlcnZlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgcHJvcGVydHksIGAlc2AsIHRoYXQgc2hvdWxkblxcJ3QgYmUgb24gdGhlIFwic3RhdGljc1wiIGtleS4gRGVmaW5lIGl0IGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IGluc3RlYWQ7IGl0IHdpbGwgc3RpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IuJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzgnLCBuYW1lKSA6IHZvaWQgMDtcblxuICAgIHZhciBpc0luaGVyaXRlZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG4gICAgISFpc0luaGVyaXRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc5JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgIShvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nKSA6IF9wcm9kSW52YXJpYW50KCc4MCcpIDogdm9pZCAwO1xuXG4gIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICEob25lW2tleV0gPT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyB3aXRoIGNsYXNoaW5nIGtleXMuJywga2V5KSA6IF9wcm9kSW52YXJpYW50KCc4MScsIGtleSkgOiB2b2lkIDA7XG4gICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb25lO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgdmFyIGMgPSB7fTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYik7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgdmFyIF9iaW5kID0gYm91bmRNZXRob2QuYmluZDtcbiAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24gKG5ld1RoaXMpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgKyAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgKyAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICB9O1xuICB9XG4gIHJldHVybiBib3VuZE1ldGhvZDtcbn1cblxuLyoqXG4gKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgdmFyIHBhaXJzID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG4gICAgdmFyIG1ldGhvZCA9IHBhaXJzW2kgKyAxXTtcbiAgICBjb21wb25lbnRbYXV0b0JpbmRLZXldID0gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cbiAqL1xudmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcblxuICAvKipcbiAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICovXG4gIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVyLmlzTW91bnRlZCh0aGlzKTtcbiAgfVxufTtcblxudmFyIFJlYWN0Q2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7fTtcbl9hc3NpZ24oUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDbGFzc01peGluKTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxuICpcbiAqIEBjbGFzcyBSZWFjdENsYXNzXG4gKi9cbnZhciBSZWFjdENsYXNzID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbiAoc3BlYykge1xuICAgIC8vIFRvIGtlZXAgb3VyIHdhcm5pbmdzIG1vcmUgdW5kZXJzdGFuZGFibGUsIHdlJ2xsIHVzZSBhIGxpdHRsZSBoYWNrIGhlcmUgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCBDb25zdHJ1Y3Rvci5uYW1lICE9PSAnQ29uc3RydWN0b3InLiBUaGlzIG1ha2VzIHN1cmUgd2UgZG9uJ3RcbiAgICAvLyB1bm5lY2Vzc2FyaWx5IGlkZW50aWZ5IGEgY2xhc3Mgd2l0aG91dCBkaXNwbGF5TmFtZSBhcyAnQ29uc3RydWN0b3InLlxuICAgIHZhciBDb25zdHJ1Y3RvciA9IGlkZW50aXR5KGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBnZXRzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgKyAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQgJiYgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnODInLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB9KTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fX3JlYWN0QXV0b0JpbmRQYWlycyA9IFtdO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nKSA6IF9wcm9kSW52YXJpYW50KCc4MycpIDogdm9pZCAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/Jywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdE1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2xhc3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXBwaW5nIGZyb20gc3VwcG9ydGVkIEhUTUwgdGFncyB0byBgUmVhY3RET01Db21wb25lbnRgIGNsYXNzZXMuXG4gKiBUaGlzIGlzIGFsc28gYWNjZXNzaWJsZSB2aWEgYFJlYWN0LkRPTWAuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSB7XG4gIGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2EnKSxcbiAgYWJicjogY3JlYXRlRE9NRmFjdG9yeSgnYWJicicpLFxuICBhZGRyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdhZGRyZXNzJyksXG4gIGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ2FyZWEnKSxcbiAgYXJ0aWNsZTogY3JlYXRlRE9NRmFjdG9yeSgnYXJ0aWNsZScpLFxuICBhc2lkZTogY3JlYXRlRE9NRmFjdG9yeSgnYXNpZGUnKSxcbiAgYXVkaW86IGNyZWF0ZURPTUZhY3RvcnkoJ2F1ZGlvJyksXG4gIGI6IGNyZWF0ZURPTUZhY3RvcnkoJ2InKSxcbiAgYmFzZTogY3JlYXRlRE9NRmFjdG9yeSgnYmFzZScpLFxuICBiZGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JkaScpLFxuICBiZG86IGNyZWF0ZURPTUZhY3RvcnkoJ2JkbycpLFxuICBiaWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2JpZycpLFxuICBibG9ja3F1b3RlOiBjcmVhdGVET01GYWN0b3J5KCdibG9ja3F1b3RlJyksXG4gIGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JvZHknKSxcbiAgYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2JyJyksXG4gIGJ1dHRvbjogY3JlYXRlRE9NRmFjdG9yeSgnYnV0dG9uJyksXG4gIGNhbnZhczogY3JlYXRlRE9NRmFjdG9yeSgnY2FudmFzJyksXG4gIGNhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2NhcHRpb24nKSxcbiAgY2l0ZTogY3JlYXRlRE9NRmFjdG9yeSgnY2l0ZScpLFxuICBjb2RlOiBjcmVhdGVET01GYWN0b3J5KCdjb2RlJyksXG4gIGNvbDogY3JlYXRlRE9NRmFjdG9yeSgnY29sJyksXG4gIGNvbGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdjb2xncm91cCcpLFxuICBkYXRhOiBjcmVhdGVET01GYWN0b3J5KCdkYXRhJyksXG4gIGRhdGFsaXN0OiBjcmVhdGVET01GYWN0b3J5KCdkYXRhbGlzdCcpLFxuICBkZDogY3JlYXRlRE9NRmFjdG9yeSgnZGQnKSxcbiAgZGVsOiBjcmVhdGVET01GYWN0b3J5KCdkZWwnKSxcbiAgZGV0YWlsczogY3JlYXRlRE9NRmFjdG9yeSgnZGV0YWlscycpLFxuICBkZm46IGNyZWF0ZURPTUZhY3RvcnkoJ2RmbicpLFxuICBkaWFsb2c6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpYWxvZycpLFxuICBkaXY6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpdicpLFxuICBkbDogY3JlYXRlRE9NRmFjdG9yeSgnZGwnKSxcbiAgZHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2R0JyksXG4gIGVtOiBjcmVhdGVET01GYWN0b3J5KCdlbScpLFxuICBlbWJlZDogY3JlYXRlRE9NRmFjdG9yeSgnZW1iZWQnKSxcbiAgZmllbGRzZXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZWxkc2V0JyksXG4gIGZpZ2NhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ2NhcHRpb24nKSxcbiAgZmlndXJlOiBjcmVhdGVET01GYWN0b3J5KCdmaWd1cmUnKSxcbiAgZm9vdGVyOiBjcmVhdGVET01GYWN0b3J5KCdmb290ZXInKSxcbiAgZm9ybTogY3JlYXRlRE9NRmFjdG9yeSgnZm9ybScpLFxuICBoMTogY3JlYXRlRE9NRmFjdG9yeSgnaDEnKSxcbiAgaDI6IGNyZWF0ZURPTUZhY3RvcnkoJ2gyJyksXG4gIGgzOiBjcmVhdGVET01GYWN0b3J5KCdoMycpLFxuICBoNDogY3JlYXRlRE9NRmFjdG9yeSgnaDQnKSxcbiAgaDU6IGNyZWF0ZURPTUZhY3RvcnkoJ2g1JyksXG4gIGg2OiBjcmVhdGVET01GYWN0b3J5KCdoNicpLFxuICBoZWFkOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkJyksXG4gIGhlYWRlcjogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZGVyJyksXG4gIGhncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnaGdyb3VwJyksXG4gIGhyOiBjcmVhdGVET01GYWN0b3J5KCdocicpLFxuICBodG1sOiBjcmVhdGVET01GYWN0b3J5KCdodG1sJyksXG4gIGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2knKSxcbiAgaWZyYW1lOiBjcmVhdGVET01GYWN0b3J5KCdpZnJhbWUnKSxcbiAgaW1nOiBjcmVhdGVET01GYWN0b3J5KCdpbWcnKSxcbiAgaW5wdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucHV0JyksXG4gIGluczogY3JlYXRlRE9NRmFjdG9yeSgnaW5zJyksXG4gIGtiZDogY3JlYXRlRE9NRmFjdG9yeSgna2JkJyksXG4gIGtleWdlbjogY3JlYXRlRE9NRmFjdG9yeSgna2V5Z2VuJyksXG4gIGxhYmVsOiBjcmVhdGVET01GYWN0b3J5KCdsYWJlbCcpLFxuICBsZWdlbmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xlZ2VuZCcpLFxuICBsaTogY3JlYXRlRE9NRmFjdG9yeSgnbGknKSxcbiAgbGluazogY3JlYXRlRE9NRmFjdG9yeSgnbGluaycpLFxuICBtYWluOiBjcmVhdGVET01GYWN0b3J5KCdtYWluJyksXG4gIG1hcDogY3JlYXRlRE9NRmFjdG9yeSgnbWFwJyksXG4gIG1hcms6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcmsnKSxcbiAgbWVudTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudScpLFxuICBtZW51aXRlbTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudWl0ZW0nKSxcbiAgbWV0YTogY3JlYXRlRE9NRmFjdG9yeSgnbWV0YScpLFxuICBtZXRlcjogY3JlYXRlRE9NRmFjdG9yeSgnbWV0ZXInKSxcbiAgbmF2OiBjcmVhdGVET01GYWN0b3J5KCduYXYnKSxcbiAgbm9zY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ25vc2NyaXB0JyksXG4gIG9iamVjdDogY3JlYXRlRE9NRmFjdG9yeSgnb2JqZWN0JyksXG4gIG9sOiBjcmVhdGVET01GYWN0b3J5KCdvbCcpLFxuICBvcHRncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnb3B0Z3JvdXAnKSxcbiAgb3B0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdvcHRpb24nKSxcbiAgb3V0cHV0OiBjcmVhdGVET01GYWN0b3J5KCdvdXRwdXQnKSxcbiAgcDogY3JlYXRlRE9NRmFjdG9yeSgncCcpLFxuICBwYXJhbTogY3JlYXRlRE9NRmFjdG9yeSgncGFyYW0nKSxcbiAgcGljdHVyZTogY3JlYXRlRE9NRmFjdG9yeSgncGljdHVyZScpLFxuICBwcmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3ByZScpLFxuICBwcm9ncmVzczogY3JlYXRlRE9NRmFjdG9yeSgncHJvZ3Jlc3MnKSxcbiAgcTogY3JlYXRlRE9NRmFjdG9yeSgncScpLFxuICBycDogY3JlYXRlRE9NRmFjdG9yeSgncnAnKSxcbiAgcnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3J0JyksXG4gIHJ1Ynk6IGNyZWF0ZURPTUZhY3RvcnkoJ3J1YnknKSxcbiAgczogY3JlYXRlRE9NRmFjdG9yeSgncycpLFxuICBzYW1wOiBjcmVhdGVET01GYWN0b3J5KCdzYW1wJyksXG4gIHNjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnc2NyaXB0JyksXG4gIHNlY3Rpb246IGNyZWF0ZURPTUZhY3RvcnkoJ3NlY3Rpb24nKSxcbiAgc2VsZWN0OiBjcmVhdGVET01GYWN0b3J5KCdzZWxlY3QnKSxcbiAgc21hbGw6IGNyZWF0ZURPTUZhY3RvcnkoJ3NtYWxsJyksXG4gIHNvdXJjZTogY3JlYXRlRE9NRmFjdG9yeSgnc291cmNlJyksXG4gIHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3NwYW4nKSxcbiAgc3Ryb25nOiBjcmVhdGVET01GYWN0b3J5KCdzdHJvbmcnKSxcbiAgc3R5bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0eWxlJyksXG4gIHN1YjogY3JlYXRlRE9NRmFjdG9yeSgnc3ViJyksXG4gIHN1bW1hcnk6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1bW1hcnknKSxcbiAgc3VwOiBjcmVhdGVET01GYWN0b3J5KCdzdXAnKSxcbiAgdGFibGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RhYmxlJyksXG4gIHRib2R5OiBjcmVhdGVET01GYWN0b3J5KCd0Ym9keScpLFxuICB0ZDogY3JlYXRlRE9NRmFjdG9yeSgndGQnKSxcbiAgdGV4dGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHRhcmVhJyksXG4gIHRmb290OiBjcmVhdGVET01GYWN0b3J5KCd0Zm9vdCcpLFxuICB0aDogY3JlYXRlRE9NRmFjdG9yeSgndGgnKSxcbiAgdGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoZWFkJyksXG4gIHRpbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpbWUnKSxcbiAgdGl0bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpdGxlJyksXG4gIHRyOiBjcmVhdGVET01GYWN0b3J5KCd0cicpLFxuICB0cmFjazogY3JlYXRlRE9NRmFjdG9yeSgndHJhY2snKSxcbiAgdTogY3JlYXRlRE9NRmFjdG9yeSgndScpLFxuICB1bDogY3JlYXRlRE9NRmFjdG9yeSgndWwnKSxcbiAgJ3Zhcic6IGNyZWF0ZURPTUZhY3RvcnkoJ3ZhcicpLFxuICB2aWRlbzogY3JlYXRlRE9NRmFjdG9yeSgndmlkZW8nKSxcbiAgd2JyOiBjcmVhdGVET01GYWN0b3J5KCd3YnInKSxcblxuICAvLyBTVkdcbiAgY2lyY2xlOiBjcmVhdGVET01GYWN0b3J5KCdjaXJjbGUnKSxcbiAgY2xpcFBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ2NsaXBQYXRoJyksXG4gIGRlZnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlZnMnKSxcbiAgZWxsaXBzZTogY3JlYXRlRE9NRmFjdG9yeSgnZWxsaXBzZScpLFxuICBnOiBjcmVhdGVET01GYWN0b3J5KCdnJyksXG4gIGltYWdlOiBjcmVhdGVET01GYWN0b3J5KCdpbWFnZScpLFxuICBsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdsaW5lJyksXG4gIGxpbmVhckdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdsaW5lYXJHcmFkaWVudCcpLFxuICBtYXNrOiBjcmVhdGVET01GYWN0b3J5KCdtYXNrJyksXG4gIHBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdGgnKSxcbiAgcGF0dGVybjogY3JlYXRlRE9NRmFjdG9yeSgncGF0dGVybicpLFxuICBwb2x5Z29uOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5Z29uJyksXG4gIHBvbHlsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5bGluZScpLFxuICByYWRpYWxHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgncmFkaWFsR3JhZGllbnQnKSxcbiAgcmVjdDogY3JlYXRlRE9NRmFjdG9yeSgncmVjdCcpLFxuICBzdG9wOiBjcmVhdGVET01GYWN0b3J5KCdzdG9wJyksXG4gIHN2ZzogY3JlYXRlRE9NRmFjdG9yeSgnc3ZnJyksXG4gIHRleHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHQnKSxcbiAgdHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3RzcGFuJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GYWN0b3JpZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJyBDaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgfHwgKG93bmVySGFzS2V5VXNlV2FybmluZy51bmlxdWVLZXkgPSB7fSk7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAobWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbWVtb2l6ZXJbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBlbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLic7XG4gIH1cblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpKSA6IHZvaWQgMDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAvLyBFbnRyeSBpdGVyYXRvcnMgcHJvdmlkZSBpbXBsaWNpdCBrZXlzLlxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1JlYWN0VHlwZVNwZWMoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQsIG51bGwpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSB7XG5cbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgc2hvdWxkIG5vdCBiZSBudWxsLCB1bmRlZmluZWQsIGJvb2xlYW4sIG9yICcgKyAnbnVtYmVyLiBJdCBzaG91bGQgYmUgYSBzdHJpbmcgKGZvciBET00gZWxlbWVudHMpIG9yIGEgUmVhY3RDbGFzcyAnICsgJyhmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgY3JlYXRlRmFjdG9yeTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gICAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gICAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gIH0sXG5cbiAgY2xvbmVFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3I7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBpc05hdGl2ZShmbikge1xuICAvLyBCYXNlZCBvbiBpc05hdGl2ZSgpIGZyb20gTG9kYXNoXG4gIHZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArIGZ1bmNUb1N0cmluZ1xuICAvLyBUYWtlIGFuIGV4YW1wbGUgbmF0aXZlIGZ1bmN0aW9uIHNvdXJjZSBmb3IgY29tcGFyaXNvblxuICAuY2FsbChoYXNPd25Qcm9wZXJ0eSlcbiAgLy8gU3RyaXAgcmVnZXggY2hhcmFjdGVycyBzbyB3ZSBjYW4gdXNlIGl0IGZvciByZWdleFxuICAucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAvLyBSZW1vdmUgaGFzT3duUHJvcGVydHkgZnJvbSB0aGUgdGVtcGxhdGUgdG8gbWFrZSBpdCBnZW5lcmljXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJyk7XG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9IGZ1bmNUb1N0cmluZy5jYWxsKGZuKTtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KHNvdXJjZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG52YXIgY2FuVXNlQ29sbGVjdGlvbnMgPVxuLy8gQXJyYXkuZnJvbVxudHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicgJiZcbi8vIE1hcFxudHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXApICYmXG4vLyBNYXAucHJvdG90eXBlLmtleXNcbk1hcC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcC5wcm90b3R5cGUua2V5cykgJiZcbi8vIFNldFxudHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQpICYmXG4vLyBTZXQucHJvdG90eXBlLmtleXNcblNldC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldC5wcm90b3R5cGUua2V5cyk7XG5cbnZhciBzZXRJdGVtO1xudmFyIGdldEl0ZW07XG52YXIgcmVtb3ZlSXRlbTtcbnZhciBnZXRJdGVtSURzO1xudmFyIGFkZFJvb3Q7XG52YXIgcmVtb3ZlUm9vdDtcbnZhciBnZXRSb290SURzO1xuXG5pZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgdmFyIGl0ZW1NYXAgPSBuZXcgTWFwKCk7XG4gIHZhciByb290SURTZXQgPSBuZXcgU2V0KCk7XG5cbiAgc2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgaXRlbSkge1xuICAgIGl0ZW1NYXAuc2V0KGlkLCBpdGVtKTtcbiAgfTtcbiAgZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBpdGVtTWFwLmdldChpZCk7XG4gIH07XG4gIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpdGVtTWFwWydkZWxldGUnXShpZCk7XG4gIH07XG4gIGdldEl0ZW1JRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oaXRlbU1hcC5rZXlzKCkpO1xuICB9O1xuXG4gIGFkZFJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByb290SURTZXQuYWRkKGlkKTtcbiAgfTtcbiAgcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJvb3RJRFNldFsnZGVsZXRlJ10oaWQpO1xuICB9O1xuICBnZXRSb290SURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHJvb3RJRFNldC5rZXlzKCkpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGl0ZW1CeUtleSA9IHt9O1xuICB2YXIgcm9vdEJ5S2V5ID0ge307XG5cbiAgLy8gVXNlIG5vbi1udW1lcmljIGtleXMgdG8gcHJldmVudCBWOCBwZXJmb3JtYW5jZSBpc3N1ZXM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgdmFyIGdldEtleUZyb21JRCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiAnLicgKyBpZDtcbiAgfTtcbiAgdmFyIGdldElERnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoa2V5LnN1YnN0cigxKSwgMTApO1xuICB9O1xuXG4gIHNldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBpdGVtQnlLZXlba2V5XSA9IGl0ZW07XG4gIH07XG4gIGdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByZXR1cm4gaXRlbUJ5S2V5W2tleV07XG4gIH07XG4gIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgaXRlbUJ5S2V5W2tleV07XG4gIH07XG4gIGdldEl0ZW1JRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGl0ZW1CeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH07XG5cbiAgYWRkUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJvb3RCeUtleVtrZXldID0gdHJ1ZTtcbiAgfTtcbiAgcmVtb3ZlUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSByb290QnlLZXlba2V5XTtcbiAgfTtcbiAgZ2V0Um9vdElEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocm9vdEJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfTtcbn1cblxudmFyIHVubW91bnRlZElEcyA9IFtdO1xuXG5mdW5jdGlvbiBwdXJnZURlZXAoaWQpIHtcbiAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgaWYgKGl0ZW0pIHtcbiAgICB2YXIgY2hpbGRJRHMgPSBpdGVtLmNoaWxkSURzO1xuXG4gICAgcmVtb3ZlSXRlbShpZCk7XG4gICAgY2hpbGRJRHMuZm9yRWFjaChwdXJnZURlZXApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcjZW1wdHknO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gJyN0ZXh0JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVJRChpZCkge1xuICB2YXIgbmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoaWQpO1xuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgdmFyIG93bmVyTmFtZTtcbiAgaWYgKG93bmVySUQpIHtcbiAgICBvd25lck5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKG93bmVySUQpO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQsICdSZWFjdENvbXBvbmVudFRyZWVIb29rOiBNaXNzaW5nIFJlYWN0IGVsZW1lbnQgZm9yIGRlYnVnSUQgJXMgd2hlbiAnICsgJ2J1aWxkaW5nIHN0YWNrJywgaWQpIDogdm9pZCAwO1xuICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBlbGVtZW50ICYmIGVsZW1lbnQuX3NvdXJjZSwgb3duZXJOYW1lKTtcbn1cblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSB7XG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChpZCwgbmV4dENoaWxkSURzKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICAhaXRlbSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJdGVtIG11c3QgaGF2ZSBiZWVuIHNldCcpIDogX3Byb2RJbnZhcmlhbnQoJzE0NCcpIDogdm9pZCAwO1xuICAgIGl0ZW0uY2hpbGRJRHMgPSBuZXh0Q2hpbGRJRHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRDaGlsZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHRDaGlsZElEID0gbmV4dENoaWxkSURzW2ldO1xuICAgICAgdmFyIG5leHRDaGlsZCA9IGdldEl0ZW0obmV4dENoaWxkSUQpO1xuICAgICAgIW5leHRDaGlsZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob29rIGV2ZW50cyB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MCcpIDogdm9pZCAwO1xuICAgICAgIShuZXh0Q2hpbGQuY2hpbGRJRHMgIT0gbnVsbCB8fCB0eXBlb2YgbmV4dENoaWxkLmVsZW1lbnQgIT09ICdvYmplY3QnIHx8IG5leHRDaGlsZC5lbGVtZW50ID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uU2V0Q2hpbGRyZW4oKSB0byBmaXJlIGZvciBhIGNvbnRhaW5lciBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQxJykgOiB2b2lkIDA7XG4gICAgICAhbmV4dENoaWxkLmlzTW91bnRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbk1vdW50Q29tcG9uZW50KCkgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCc3MScpIDogdm9pZCAwO1xuICAgICAgaWYgKG5leHRDaGlsZC5wYXJlbnRJRCA9PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZC5wYXJlbnRJRCA9IGlkO1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZG4ndCBiZSBuZWNlc3NhcnkgYnV0IG1vdW50aW5nIGEgbmV3IHJvb3QgZHVyaW5nIGluXG4gICAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBjdXJyZW50bHkgY2F1c2VzIG5vdC15ZXQtbW91bnRlZCBjb21wb25lbnRzIHRvXG4gICAgICAgIC8vIGJlIHB1cmdlZCBmcm9tIG91ciB0cmVlIGRhdGEgc28gdGhlaXIgcGFyZW50IGlkIGlzIG1pc3NpbmcuXG4gICAgICB9XG4gICAgICAhKG5leHRDaGlsZC5wYXJlbnRJRCA9PT0gaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uQmVmb3JlTW91bnRDb21wb25lbnQoKSBwYXJlbnQgYW5kIG9uU2V0Q2hpbGRyZW4oKSB0byBiZSBjb25zaXN0ZW50ICglcyBoYXMgcGFyZW50cyAlcyBhbmQgJXMpLicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IF9wcm9kSW52YXJpYW50KCcxNDInLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiB2b2lkIDA7XG4gICAgfVxuICB9LFxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQsIHBhcmVudElEKSB7XG4gICAgdmFyIGl0ZW0gPSB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgICAgdGV4dDogbnVsbCxcbiAgICAgIGNoaWxkSURzOiBbXSxcbiAgICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgICB1cGRhdGVDb3VudDogMFxuICAgIH07XG4gICAgc2V0SXRlbShpZCwgaXRlbSk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGVsZW1lbnQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS5lbGVtZW50ID0gZWxlbWVudDtcbiAgfSxcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICAhaXRlbSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJdGVtIG11c3QgaGF2ZSBiZWVuIHNldCcpIDogX3Byb2RJbnZhcmlhbnQoJzE0NCcpIDogdm9pZCAwO1xuICAgIGl0ZW0uaXNNb3VudGVkID0gdHJ1ZTtcbiAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICBpZiAoaXNSb290KSB7XG4gICAgICBhZGRSb290KGlkKTtcbiAgICB9XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS51cGRhdGVDb3VudCsrO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgaXQgZXhpc3RzLlxuICAgICAgLy8gYGl0ZW1gIG1pZ2h0IG5vdCBleGlzdCBpZiBpdCBpcyBpbnNpZGUgYW4gZXJyb3IgYm91bmRhcnksIGFuZCBhIHNpYmxpbmdcbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5IGNoaWxkIHRocmV3IHdoaWxlIG1vdW50aW5nLiBUaGVuIHRoaXMgaW5zdGFuY2UgbmV2ZXJcbiAgICAgIC8vIGdvdCBhIGNoYW5jZSB0byBtb3VudCwgYnV0IGl0IHN0aWxsIGdldHMgYW4gdW5tb3VudGluZyBldmVudCBkdXJpbmdcbiAgICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBjbGVhbnVwLlxuICAgICAgaXRlbS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICByZW1vdmVSb290KGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudGVkSURzLnB1c2goaWQpO1xuICB9LFxuICBwdXJnZVVubW91bnRlZENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RDb21wb25lbnRUcmVlSG9vay5fcHJldmVudFB1cmdpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bm1vdW50ZWRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHVubW91bnRlZElEc1tpXTtcbiAgICAgIHB1cmdlRGVlcChpZCk7XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5sZW5ndGggPSAwO1xuICB9LFxuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlzTW91bnRlZCA6IGZhbHNlO1xuICB9LFxuICBnZXRDdXJyZW50U3RhY2tBZGRlbmR1bTogZnVuY3Rpb24gKHRvcEVsZW1lbnQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0b3BFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKHRvcEVsZW1lbnQpO1xuICAgICAgdmFyIG93bmVyID0gdG9wRWxlbWVudC5fb3duZXI7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgdG9wRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50T3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIHZhciBpZCA9IGN1cnJlbnRPd25lciAmJiBjdXJyZW50T3duZXIuX2RlYnVnSUQ7XG5cbiAgICBpbmZvICs9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoaWQpO1xuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRTdGFja0FkZGVuZHVtQnlJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB3aGlsZSAoaWQpIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVJRChpZCk7XG4gICAgICBpZCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UGFyZW50SUQoaWQpO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0Q2hpbGRJRHM6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmNoaWxkSURzIDogW107XG4gIH0sXG4gIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpO1xuICB9LFxuICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgfSxcbiAgZ2V0T3duZXJJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5fb3duZXIuX2RlYnVnSUQ7XG4gIH0sXG4gIGdldFBhcmVudElEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5wYXJlbnRJRCA6IG51bGw7XG4gIH0sXG4gIGdldFNvdXJjZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICB2YXIgZWxlbWVudCA9IGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50ICE9IG51bGwgPyBlbGVtZW50Ll9zb3VyY2UgOiBudWxsO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH0sXG4gIGdldFRleHQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcnICsgZWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LFxuICBnZXRVcGRhdGVDb3VudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0udXBkYXRlQ291bnQgOiAwO1xuICB9LFxuXG5cbiAgZ2V0Um9vdElEczogZ2V0Um9vdElEcyxcbiAgZ2V0UmVnaXN0ZXJlZElEczogZ2V0SXRlbUlEc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P29iamVjdH0gZWxlbWVudCBUaGUgUmVhY3QgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHs/bnVtYmVyfSBkZWJ1Z0lEIFRoZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQsIGRlYnVnSUQpIHtcbiAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICEodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIFJlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc4NCcsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogdm9pZCAwO1xuICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKSA6IHZvaWQgMDtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBjb21wb25lbnRTdGFja0luZm8gPSAnJztcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVidWdJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHByb3BUeXBlczoge1xuICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAqXG4gKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gKlxuICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICogICB9KTtcbiAqXG4gKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gKlxuICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAqXG4gKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKlxuICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAqICAgICAgICAgICk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICB9LFxuICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gKiAgfSk7XG4gKlxuICogQGludGVybmFsXG4gKi9cblxudmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG59O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cbi8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4vKipcbiAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIgd2UgZG9uJ3QgdXNlIHJlYWxcbiAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSAnJztcbn1cbi8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cblByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0ICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgIGlmICghbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICsgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICsgJ2FuZCB3aWxsIG5vdCB3b3JrIGluIHByb2R1Y3Rpb24gd2l0aCB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiAnICsgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLCBwcm9wRnVsbE5hbWUsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyhudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgIH1cbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgfVxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gIC8vIE5hdGl2ZSBTeW1ib2wuXG4gIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gJ29iamVjdCc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdzeW1ib2wnO1xuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgfVxuICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcxNS40LjEnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MycpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdERPTScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyogZ2xvYmFscyBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSByZXF1aXJlKCcuL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET00gPSB7XG4gIGZpbmRET01Ob2RlOiBmaW5kRE9NTm9kZSxcbiAgcmVuZGVyOiBSZWFjdE1vdW50LnJlbmRlcixcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMsXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxufTtcblxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxuaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3Qoe1xuICAgIENvbXBvbmVudFRyZWU6IHtcbiAgICAgIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gICAgICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICAvLyBpbnN0IGlzIGFuIGludGVybmFsIGluc3RhbmNlIChidXQgY291bGQgYmUgYSBjb21wb3NpdGUpXG4gICAgICAgIGlmIChpbnN0Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgICAgIGluc3QgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdCkge1xuICAgICAgICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgTW91bnQ6IFJlYWN0TW91bnQsXG4gICAgUmVjb25jaWxlcjogUmVhY3RSZWNvbmNpbGVyXG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiBkZXZ0b29scyBpcyBub3QgaW5zdGFsbGVkXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCBoYXZlIHRoZSBpc3N1ZSB3aXRoIGRldnRvb2xzIGxvYWRlZCBvdmVyIGZpbGU6Ly9cbiAgICAgICAgdmFyIHNob3dGaWxlVXJsTWVzc2FnZSA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgPT09IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAoc2hvd0ZpbGVVcmxNZXNzYWdlID8gJ2FuZCB1c2UgYW4gSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgYSBmaWxlOiBVUkwpICcgOiAnJykgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXN0RnVuYyA9IGZ1bmN0aW9uIHRlc3RGbigpIHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCh0ZXN0RnVuYy5uYW1lIHx8IHRlc3RGdW5jLnRvU3RyaW5nKCkpLmluZGV4T2YoJ3Rlc3RGbicpICE9PSAtMSwgJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYSBtaW5pZmllZCBjb3B5IG9mIHRoZSBkZXZlbG9wbWVudCBidWlsZCAnICsgJ29mIFJlYWN0LiBXaGVuIGRlcGxveWluZyBSZWFjdCBhcHBzIHRvIHByb2R1Y3Rpb24sIG1ha2Ugc3VyZSB0byB1c2UgJyArICd0aGUgcHJvZHVjdGlvbiBidWlsZCB3aGljaCBza2lwcyBkZXZlbG9wbWVudCB3YXJuaW5ncyBhbmQgaXMgZmFzdGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LW1pbmlmaWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xuXG4gICAgLy8gSWYgd2UncmUgaW4gSUU4LCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGluIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgcHJvdmlkZVxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHByZXZlbnRpbmcgY29tcGF0aWJpbGl0eSBtb2RlXG4gICAgdmFyIGllQ29tcGF0aWJpbGl0eU1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgODtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpZUNvbXBhdGliaWxpdHlNb2RlLCAnSW50ZXJuZXQgRXhwbG9yZXIgaXMgcnVubmluZyBpbiBjb21wYXRpYmlsaXR5IG1vZGU7IHBsZWFzZSBhZGQgdGhlICcgKyAnZm9sbG93aW5nIHRhZyB0byB5b3VyIEhUTUwgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nOiAnICsgJzxtZXRhIGh0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIiBjb250ZW50PVwiSUU9ZWRnZVwiIC8+JykgOiB2b2lkIDA7XG5cbiAgICB2YXIgZXhwZWN0ZWRGZWF0dXJlcyA9IFtcbiAgICAvLyBzaGltc1xuICAgIEFycmF5LmlzQXJyYXksIEFycmF5LnByb3RvdHlwZS5ldmVyeSwgQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLCBBcnJheS5wcm90b3R5cGUubWFwLCBEYXRlLm5vdywgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIE9iamVjdC5rZXlzLCBTdHJpbmcucHJvdG90eXBlLnRyaW1dO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZEZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWV4cGVjdGVkRmVhdHVyZXNbaV0pIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmUgb3IgbW9yZSBFUzUgc2hpbXMgZXhwZWN0ZWQgYnkgUmVhY3QgYXJlIG5vdCBhdmFpbGFibGU6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLXBvbHlmaWxscycpIDogdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuICB2YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2snKTtcbiAgdmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rJyk7XG4gIHZhciBSZWFjdERPTUludmFsaWRBUklBSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnZhbGlkQVJJQUhvb2snKTtcblxuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2spO1xuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2spO1xuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTUludmFsaWRBUklBSG9vayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgRmxhZ3MgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xuXG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbi8qKlxuICogRHJpbGwgZG93biAodGhyb3VnaCBjb21wb3NpdGVzIGFuZCBlbXB0eSBjb21wb25lbnRzKSB1bnRpbCB3ZSBnZXQgYSBob3N0IG9yXG4gKiBob3N0IHRleHQgY29tcG9uZW50LlxuICpcbiAqIFRoaXMgaXMgcHJldHR5IHBvbHltb3JwaGljIGJ1dCB1bmF2b2lkYWJsZSB3aXRoIHRoZSBjdXJyZW50IHN0cnVjdHVyZSB3ZSBoYXZlXG4gKiBmb3IgYF9yZW5kZXJlZENoaWxkcmVuYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgdmFyIHJlbmRlcmVkO1xuICB3aGlsZSAocmVuZGVyZWQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50ID0gcmVuZGVyZWQ7XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSBgX2hvc3ROb2RlYCBvbiB0aGUgcmVuZGVyZWQgaG9zdC90ZXh0IGNvbXBvbmVudCB3aXRoIHRoZSBnaXZlblxuICogRE9NIG5vZGUuIFRoZSBwYXNzZWQgYGluc3RgIGNhbiBiZSBhIGNvbXBvc2l0ZS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVOb2RlKGluc3QsIG5vZGUpIHtcbiAgdmFyIGhvc3RJbnN0ID0gZ2V0UmVuZGVyZWRIb3N0T3JUZXh0RnJvbUNvbXBvbmVudChpbnN0KTtcbiAgaG9zdEluc3QuX2hvc3ROb2RlID0gbm9kZTtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuXG5mdW5jdGlvbiB1bmNhY2hlTm9kZShpbnN0KSB7XG4gIHZhciBub2RlID0gaW5zdC5faG9zdE5vZGU7XG4gIGlmIChub2RlKSB7XG4gICAgZGVsZXRlIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gICAgaW5zdC5faG9zdE5vZGUgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gZWFjaCBjaGlsZCBvZiBgaW5zdGAsIGFzc3VtaW5nIHRoYXQgdGhlIGNoaWxkcmVuXG4gKiBtYXRjaCB1cCB3aXRoIHRoZSBET00gKGVsZW1lbnQpIGNoaWxkcmVuIG9mIGBub2RlYC5cbiAqXG4gKiBXZSBjYWNoZSBlbnRpcmUgbGV2ZWxzIGF0IG9uY2UgdG8gYXZvaWQgYW4gbl4yIHByb2JsZW0gd2hlcmUgd2UgYWNjZXNzIHRoZVxuICogY2hpbGRyZW4gb2YgYSBub2RlIHNlcXVlbnRpYWxseSBhbmQgaGF2ZSB0byB3YWxrIGZyb20gdGhlIHN0YXJ0IHRvIG91ciB0YXJnZXRcbiAqIG5vZGUgZXZlcnkgdGltZS5cbiAqXG4gKiBTaW5jZSB3ZSB1cGRhdGUgYF9yZW5kZXJlZENoaWxkcmVuYCBhbmQgdGhlIGFjdHVhbCBET00gYXQgKHNsaWdodGx5KVxuICogZGlmZmVyZW50IHRpbWVzLCB3ZSBjb3VsZCByYWNlIGhlcmUgYW5kIHNlZSBhIG5ld2VyIGBfcmVuZGVyZWRDaGlsZHJlbmAgdGhhblxuICogdGhlIERPTSBub2RlcyB3ZSBzZWUuIFRvIGF2b2lkIHRoaXMsIFJlYWN0TXVsdGlDaGlsZCBjYWxsc1xuICogYHByZXBhcmVUb01hbmFnZUNoaWxkcmVuYCBiZWZvcmUgd2UgY2hhbmdlIGBfcmVuZGVyZWRDaGlsZHJlbmAsIGF0IHdoaWNoXG4gKiB0aW1lIHRoZSBjb250YWluZXIncyBjaGlsZCBub2RlcyBhcmUgYWx3YXlzIGNhY2hlZCAodW50aWwgaXQgdW5tb3VudHMpLlxuICovXG5mdW5jdGlvbiBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgbm9kZSkge1xuICBpZiAoaW5zdC5fZmxhZ3MgJiBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjaGlsZHJlbiA9IGluc3QuX3JlbmRlcmVkQ2hpbGRyZW47XG4gIHZhciBjaGlsZE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIG91dGVyOiBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgaWYgKCFjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3QgPSBjaGlsZHJlbltuYW1lXTtcbiAgICB2YXIgY2hpbGRJRCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY2hpbGRJbnN0KS5fZG9tSUQ7XG4gICAgaWYgKGNoaWxkSUQgPT09IDApIHtcbiAgICAgIC8vIFdlJ3JlIGN1cnJlbnRseSB1bm1vdW50aW5nIHRoaXMgY2hpbGQgaW4gUmVhY3RNdWx0aUNoaWxkOyBza2lwIGl0LlxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIFdlIGFzc3VtZSB0aGUgY2hpbGQgbm9kZXMgYXJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBjaGlsZCBpbnN0YW5jZXMuXG4gICAgZm9yICg7IGNoaWxkTm9kZSAhPT0gbnVsbDsgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxICYmIGNoaWxkTm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSA9PT0gU3RyaW5nKGNoaWxkSUQpIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBjaGlsZE5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LXRleHQ6ICcgKyBjaGlsZElEICsgJyAnIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBjaGlsZE5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LWVtcHR5OiAnICsgY2hpbGRJRCArICcgJykge1xuICAgICAgICBwcmVjYWNoZU5vZGUoY2hpbGRJbnN0LCBjaGlsZE5vZGUpO1xuICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBET00gY2hpbGRyZW4gd2l0aG91dCBmaW5kaW5nIGFuIElEIG1hdGNoLlxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBlbGVtZW50IHdpdGggSUQgJXMuJywgY2hpbGRJRCkgOiBfcHJvZEludmFyaWFudCgnMzInLCBjaGlsZElEKSA6IHZvaWQgMDtcbiAgfVxuICBpbnN0Ll9mbGFncyB8PSBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBSZWFjdERPTUNvbXBvbmVudCBvclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgaW5zdGFuY2Ugd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3Agb2YgdGhlIHRyZWUuIFRoaXMgbm9kZSBtdXN0IG5vdCBiZSBwYXJ0IG9mIGEgUmVhY3QgdHJlZSAob3IgaXNcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsb3Nlc3Q7XG4gIHZhciBpbnN0O1xuICBmb3IgKDsgbm9kZSAmJiAoaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pOyBub2RlID0gcGFyZW50cy5wb3AoKSkge1xuICAgIGNsb3Nlc3QgPSBpbnN0O1xuICAgIGlmIChwYXJlbnRzLmxlbmd0aCkge1xuICAgICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgaW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAoaW5zdCAhPSBudWxsICYmIGluc3QuX2hvc3ROb2RlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgIShpbnN0Ll9ob3N0Tm9kZSAhPT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzMzJykgOiB2b2lkIDA7XG5cbiAgaWYgKGluc3QuX2hvc3ROb2RlKSB7XG4gICAgcmV0dXJuIGluc3QuX2hvc3ROb2RlO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIERPTSBub2RlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIWluc3QuX2hvc3ROb2RlKSB7XG4gICAgcGFyZW50cy5wdXNoKGluc3QpO1xuICAgICFpbnN0Ll9ob3N0UGFyZW50ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0IERPTSB0cmVlIHJvb3Qgc2hvdWxkIGFsd2F5cyBoYXZlIGEgbm9kZSByZWZlcmVuY2UuJykgOiBfcHJvZEludmFyaWFudCgnMzQnKSA6IHZvaWQgMDtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuXG4gIC8vIE5vdyBwYXJlbnRzIGNvbnRhaW5zIGVhY2ggYW5jZXN0b3IgdGhhdCBkb2VzICpub3QqIGhhdmUgYSBjYWNoZWQgbmF0aXZlXG4gIC8vIG5vZGUsIGFuZCBgaW5zdGAgaXMgdGhlIGRlZXBlc3QgYW5jZXN0b3IgdGhhdCBkb2VzLlxuICBmb3IgKDsgcGFyZW50cy5sZW5ndGg7IGluc3QgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIGluc3QuX2hvc3ROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHtcbiAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBnZXRJbnN0YW5jZUZyb21Ob2RlLFxuICBnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlLFxuICBwcmVjYWNoZUNoaWxkTm9kZXM6IHByZWNhY2hlQ2hpbGROb2RlcyxcbiAgcHJlY2FjaGVOb2RlOiBwcmVjYWNoZU5vZGUsXG4gIHVuY2FjaGVOb2RlOiB1bmNhY2hlTm9kZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudFRyZWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50VHJlZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuZnVuY3Rpb24gcmVhY3RQcm9kSW52YXJpYW50KGNvZGUpIHtcbiAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIG1lc3NhZ2UgPSAnTWluaWZpZWQgUmVhY3QgZXJyb3IgIycgKyBjb2RlICsgJzsgdmlzaXQgJyArICdodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBhcmdJZHggPSAwOyBhcmdJZHggPCBhcmdDb3VudDsgYXJnSWR4KyspIHtcbiAgICBtZXNzYWdlICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2FyZ0lkeCArIDFdKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQnICsgJyBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nO1xuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHJlYWN0UHJvZEludmFyaWFudCdzIG93biBmcmFtZVxuXG4gIHRocm93IGVycm9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0UHJvZEludmFyaWFudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9QUk9QRVJUWTogMHgxLFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg0LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHg4LFxuICBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTogMHgxMCB8IDB4OCxcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHgyMCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gdGhhdCBnaXZlbiBhbiBhdHRyaWJ1dGUgbmFtZSB3aWxsIHJldHVybiB0cnVlXG4gICAqIGlmIGl0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00gdmVyYmF0aW0uIFVzZWZ1bCBmb3IgZGF0YS0qIG9yIGFyaWEtKlxuICAgKiBhdHRyaWJ1dGVzIHdoZXJlIGl0J3MgaW1wb3NzaWJsZSB0byBlbnVtZXJhdGUgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgKiBhdHRyaWJ1dGUgbmFtZXMsXG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lc3BhY2UgVVJMLiAoQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIG5vIG5hbWVzcGFjZS4pXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgSW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG4gICAgdmFyIFByb3BlcnRpZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lc3BhY2VzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNwYWNlcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NUHJvcGVydHlOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTVByb3BlcnR5TmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGlmIChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSkge1xuICAgICAgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLnB1c2goZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgXFwnJXNcXCcgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLCBwcm9wTmFtZSkgOiBfcHJvZEludmFyaWFudCgnNDgnLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc1MCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZF0gPSBwcm9wTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2F0dHJpYnV0ZU5hbWVdID0gcHJvcE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBET01BdHRyaWJ1dGVOYW1lc3BhY2VzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTVByb3BlcnR5TmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWUgPSBET01Qcm9wZXJ0eU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTU11dGF0aW9uTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kID0gRE9NTXV0YXRpb25NZXRob2RzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wTmFtZV0gPSBwcm9wZXJ0eUluZm87XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9ICc6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEJztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcbiAqXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnaWQnXVxuICogICB0cnVlXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cbiAqICAgdW5kZWZpbmVkXG4gKlxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcbiAqL1xudmFyIERPTVByb3BlcnR5ID0ge1xuXG4gIElEX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdGlkJyxcbiAgUk9PVF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3Ryb290JyxcblxuICBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSOiBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSLFxuICBBVFRSSUJVVEVfTkFNRV9DSEFSOiBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ1xcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwJyxcblxuICAvKipcbiAgICogTWFwIGZyb20gcHJvcGVydHkgXCJzdGFuZGFyZCBuYW1lXCIgdG8gYW4gb2JqZWN0IHdpdGggaW5mbyBhYm91dCBob3cgdG8gc2V0XG4gICAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAgICpcbiAgICogYXR0cmlidXRlTmFtZTpcbiAgICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICAgKiBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgICogcHJvcGVydHlOYW1lOlxuICAgKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICAgKiAgIGV4dGVybmFsIGZhY3RvcnMuKVxuICAgKiBtdXRhdGlvbk1ldGhvZDpcbiAgICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gICAqICAgaW5pdGlhbCByZW5kZXIuXG4gICAqIG11c3RVc2VQcm9wZXJ0eTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAgICogaGFzQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNOdW1lcmljVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYyBhbmQgc2hvdWxkIGJlXG4gICAqICAgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmVcbiAgICogICBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4gICAqICAgUmVtb3ZlZCB3aGVuIHN0cmljdGx5IGVxdWFsIHRvIGZhbHNlOyBwcmVzZW50IHdpdGhvdXQgYSB2YWx1ZSB3aGVuXG4gICAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICAgKi9cbiAgcHJvcGVydGllczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcHJvcGVydHkgbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sIHVzZWRcbiAgICogdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIHByb3BlcnRpZXMuIEF2YWlsYWJsZSBvbmx5IGluIF9fREVWX18uXG4gICAqXG4gICAqIGF1dG9mb2N1cyBpcyBwcmVkZWZpbmVkLCBiZWNhdXNlIGFkZGluZyBpdCB0byB0aGUgcHJvcGVydHkgd2hpdGVsaXN0XG4gICAqIGNhdXNlcyB1bmludGVuZGVkIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8geyBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnIH0gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGlzQ3VzdG9tQXR0cmlidXRlKCkgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkLlxuICAgKi9cbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBpbmplY3Rpb246IERPTVByb3BlcnR5SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0ge1xuICBoYXNDYWNoZWRDaGlsZE5vZGVzOiAxIDw8IDBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBUklBRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0FSSUFET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQ2hhbmdlRXZlbnRQbHVnaW4nKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vSFRNTERPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01UcmVlVHJhdmVyc2FsID0gcmVxdWlyZSgnLi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwnKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRMaXN0ZW5lcicpO1xudmFyIFJlYWN0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluamVjdGlvbicpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2VsZWN0RXZlbnRQbHVnaW4nKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0VHJlZVRyYXZlcnNhbChSZWFjdERPTVRyZWVUcmF2ZXJzYWwpO1xuXG4gIC8qKlxuICAgKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAgICogdGhlbSkuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICAgIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gICAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICAgIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkhvc3RDb21wb25lbnQuaW5qZWN0VGV4dENvbXBvbmVudENsYXNzKFJlYWN0RE9NVGV4dENvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoQVJJQURPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeShmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgICByZXR1cm4gbmV3IFJlYWN0RE9NRW1wdHlDb21wb25lbnQoaW5zdGFudGlhdGUpO1xuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluamVjdDogaW5qZWN0XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQVJJQURPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7XG4gICAgLy8gR2xvYmFsIFN0YXRlcyBhbmQgUHJvcGVydGllc1xuICAgICdhcmlhLWN1cnJlbnQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWRldGFpbHMnOiAwLFxuICAgICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgICAnYXJpYS1oaWRkZW4nOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICAgJ2FyaWEtbGFiZWwnOiAwLFxuICAgICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gICAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAgICdhcmlhLWNoZWNrZWQnOiAwLFxuICAgICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAgICdhcmlhLW1vZGFsJzogMCxcbiAgICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAgICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAgICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAgICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgICAnYXJpYS1zb3J0JzogMCxcbiAgICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAgICdhcmlhLXZhbHVlbm93JzogMCxcbiAgICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAgIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgICAnYXJpYS1hdG9taWMnOiAwLFxuICAgICdhcmlhLWJ1c3knOiAwLFxuICAgICdhcmlhLWxpdmUnOiAwLFxuICAgICdhcmlhLXJlbGV2YW50JzogMCxcbiAgICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAgICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAgICdhcmlhLWNvbGNvdW50JzogMCxcbiAgICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAgICdhcmlhLWZsb3d0byc6IDAsXG4gICAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICAgJ2FyaWEtb3ducyc6IDAsXG4gICAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAgICdhcmlhLXJvd2NvdW50JzogMCxcbiAgICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICAgJ2FyaWEtc2V0c2l6ZSc6IDBcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHt9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBUklBRE9NUHJvcGVydHlDb25maWc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0FSSUFET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZSgnLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUnKTtcbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljSW5wdXRFdmVudCcpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQmVmb3JlSW5wdXQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkJlZm9yZUlucHV0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlQcmVzcycsICd0b3BUZXh0SW5wdXQnLCAndG9wUGFzdGUnXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25TdGFydCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblVwZGF0ZScsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25TdGFydCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5nZXRQb29sZWQobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RvcFRleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENvbXBvc2l0aW9uRW5kJyB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gRXZlbnRQbHVnaW5VdGlscy5nZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xuICovXG52YXIgbGlzdGVuZXJCYW5rID0ge307XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbnZhciBnZXREaWN0aW9uYXJ5S2V5ID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIEV2ZW50UGx1Z2luSHViID0ge1xuXG4gIC8qKlxuICAgKiBNZXRob2RzIGZvciBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgaW5qZWN0aW9uOiB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuXG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBgbGlzdGVuZXJgIGF0IGBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XWAuIElzIGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIHN0b3JlLlxuICAgKi9cbiAgcHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IF9wcm9kSW52YXJpYW50KCc5NCcsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG5cbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldID0gbGlzdGVuZXI7XG5cbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcbiAgICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QuX2N1cnJlbnRFbGVtZW50LnR5cGUsIGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIHJldHVybiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSAmJiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbmV2ZXIgYmUgbnVsbCAtLSB3aGVuIGlzIGl0P1xuICAgIGlmIChiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIERPTSBlbGVtZW50IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKi9cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyQmFuay5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICAgKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIHBsdWdpbnMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nIGFuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiBfcHJvZEludmFyaWFudCgnOTUnKSA6IHZvaWQgMDtcbiAgICAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbiAgICBSZWFjdEVycm9yVXRpbHMucmV0aHJvd0NhdWdodEVycm9yKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSBuZWVkZWQgZm9yIHRlc3RzIG9ubHkuIERvIG5vdCB1c2UhXG4gICAqL1xuICBfX3B1cmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgbGlzdGVuZXJCYW5rID0ge307XG4gIH0sXG5cbiAgX19nZXRMaXN0ZW5lckJhbms6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbGlzdGVuZXJCYW5rO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5IdWI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luSHViLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk2JywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAhcGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5NycsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBGYWlsZWQgdG8gcHVibGlzaCBldmVudCBgJXNgIGZvciBwbHVnaW4gYCVzYC4nLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk4JywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5OScsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzIGFuZFxuICogY2FuIGJlIHVzZWQgd2l0aCBgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXJgIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTAwJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gPSByZWdpc3RyYXRpb25OYW1lO1xuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJykge1xuICAgICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHtcblxuICAvKipcbiAgICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gICAqL1xuICBwbHVnaW5zOiBbXSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gICAqL1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICAgKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gICAqIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7fSA6IG51bGwsXG4gIC8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiBfX0RFVl9fXG5cbiAgLyoqXG4gICAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcbiAgICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gICAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogZnVuY3Rpb24gKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAgICEhZXZlbnRQbHVnaW5PcmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzEwMScpIDogdm9pZCAwO1xuICAgIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAgICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAgICpcbiAgICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogZnVuY3Rpb24gKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTAyJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICAgICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9va3MgdXAgdGhlIHBsdWdpbiBmb3IgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQSBzeW50aGV0aWMgZXZlbnQuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IFRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gZXZlbnQuZGlzcGF0Y2hDb25maWc7XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWVdIHx8IG51bGw7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBwdWxsaW5nIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIG91dCBvZiBkaXNwYXRjaENvbmZpZyBoZWxwcyBGbG93IHNlZVxuICAgICAgLy8gdGhhdCBpdCBpcyBub3QgdW5kZWZpbmVkLlxuICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG5cbiAgICAgIGZvciAodmFyIHBoYXNlIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICAgIGlmICghcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VdXTtcbiAgICAgICAgaWYgKHBsdWdpbk1vZHVsZSkge1xuICAgICAgICAgIHJldHVybiBwbHVnaW5Nb2R1bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAgIGlmIChldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcztcbiAgICAgIGZvciAodmFyIGxvd2VyQ2FzZWROYW1lIGluIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICAgICAgZGVsZXRlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBDb21wb25lbnRUcmVlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGluc3RhbmNlc1xuICogICBhbmQgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIENvbXBvbmVudFRyZWU7XG52YXIgVHJlZVRyYXZlcnNhbDtcbnZhciBpbmplY3Rpb24gPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIENvbXBvbmVudFRyZWUgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIGluamVjdFRyZWVUcmF2ZXJzYWw6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIFRyZWVUcmF2ZXJzYWwgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuaXNBbmNlc3RvciAmJiBJbmplY3RlZC5nZXRMb3dlc3RDb21tb25BbmNlc3RvciwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdFRyZWVUcmF2ZXJzYWwoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBpc0FuY2VzdG9yIG9yIGdldExvd2VzdENvbW1vbkFuY2VzdG9yLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaEVuZCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hDYW5jZWwnO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU1vdmUnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoTW92ZSc7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VEb3duJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaFN0YXJ0Jztcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDMnKSA6IHZvaWQgMDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGRpc3BhdGNoTGlzdGVuZXIgPyBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoZGlzcGF0Y2hJbnN0YW5jZSkgOiBudWxsO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIH0sXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcbiAgfSxcbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5pc0FuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRMb3dlc3RDb21tb25BbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCk7XG4gIH0sXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXQsIGZuLCBhcmcpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKHRhcmdldCwgZm4sIGFyZyk7XG4gIH0sXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbyk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGEgRmlyc3QgYXJndW1lbnRcbiAqIEBwYXJhbSB7Kn0gYiBTZWNvbmQgYXJndW1lbnRcbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGEpIHtcbiAgdHJ5IHtcbiAgICBmdW5jKGEpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgaWYgKGNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICBjYXVnaHRFcnJvciA9IHg7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJ5IFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHNvIHRoYXQgYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIGV2ZW50XG4gICAqIGhhbmRsZXIgYXJlIHN1cmUgdG8gYmUgcmV0aHJvd24gYnkgcmV0aHJvd0NhdWdodEVycm9yLlxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKipcbiAgICogVG8gaGVscCBkZXZlbG9wbWVudCB3ZSBjYW4gZ2V0IGJldHRlciBkZXZ0b29scyBpbnRlZ3JhdGlvbiBieSBzaW11bGF0aW5nIGFcbiAgICogcmVhbCBicm93c2VyIGV2ZW50LlxuICAgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBhKSB7XG4gICAgICB2YXIgYm91bmRGdW5jID0gZnVuYy5iaW5kKG51bGwsIGEpO1xuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIG5hbWU7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjMzNlxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IF9wcm9kSW52YXJpYW50KCczMCcpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG5cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBjbGFzcyBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XG4gKi9cbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9zdGFydFRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuX2Fzc2lnbihGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB0aGlzLl9zdGFydFRleHQgPSBudWxsO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHRleHQgb2YgaW5wdXQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ3ZhbHVlJyBpbiB0aGlzLl9yb290KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcm9vdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBkaWZmZXJpbmcgc3Vic3RyaW5nIGJldHdlZW4gdGhlIGluaXRpYWxseSBzdG9yZWRcbiAgICogdGV4dCBjb250ZW50IGFuZCB0aGUgY3VycmVudCBjb250ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2ZhbGxiYWNrVGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIHN0YXJ0VmFsdWUgPSB0aGlzLl9zdGFydFRleHQ7XG4gICAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gICAgdmFyIGVuZDtcbiAgICB2YXIgZW5kVmFsdWUgPSB0aGlzLmdldFRleHQoKTtcbiAgICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gICAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICAgIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gICAgcmV0dXJuIHRoaXMuX2ZhbGxiYWNrVGV4dDtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogU3RhdGljIHBvb2xlcnMuIFNldmVyYWwgY3VzdG9tIHZlcnNpb25zIGZvciBlYWNoIHBvdGVudGlhbCBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cy4gQSBjb21wbGV0ZWx5IGdlbmVyaWMgcG9vbGVyIGlzIGVhc3kgdG8gaW1wbGVtZW50LCBidXQgd291bGRcbiAqIHJlcXVpcmUgYWNjZXNzaW5nIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIEluIGVhY2ggb2YgdGhlc2UsIGB0aGlzYCByZWZlcnMgdG9cbiAqIHRoZSBDbGFzcyBpdHNlbGYsIG5vdCBhbiBpbnN0YW5jZS4gSWYgYW55IG90aGVycyBhcmUgbmVlZGVkLCBzaW1wbHkgYWRkIHRoZW1cbiAqIGhlcmUsIG9yIGluIHRoZWlyIG93biBmaWxlcy5cbiAqL1xudmFyIG9uZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIpO1xuICB9XG59O1xuXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMpO1xuICB9XG59O1xuXG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCk7XG4gIH1cbn07XG5cbnZhciBmaXZlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgfVxufTtcblxudmFyIHN0YW5kYXJkUmVsZWFzZXIgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgIShpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogX3Byb2RJbnZhcmlhbnQoJzI1JykgOiB2b2lkIDA7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIC8vIENhc3RpbmcgYXMgYW55IHNvIHRoYXQgZmxvdyBpZ25vcmVzIHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gYW5kIHRydXN0c1xuICAvLyBpdCB0byBtYXRjaCB0aGUgdHlwZSB3ZSBkZWNsYXJlZFxuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9Qb29sZWRDbGFzcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRleHRDb250ZW50QWNjZXNzb3I7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LCBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIHRoZXNlIGhhdmUgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIGRlbGV0ZSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGRlbGV0ZSB0aGlzLnByZXZlbnREZWZhdWx0O1xuICAgIGRlbGV0ZSB0aGlzLnN0b3BQcm9wYWdhdGlvbjtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHZhbGlkLXR5cGVvZlxuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllc1tpXV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdG9wUHJvcGFnYXRpb24nLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gJyArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcblxuICBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2xhc3MsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG59O1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oU3ludGhldGljRXZlbnQsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICAqXG4gICogQHBhcmFtIHtvYmplY3R9IFN5bnRoZXRpY0V2ZW50XG4gICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAgKi9cbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBnZXRWYWwgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xuICAgIHdhcm4oYWN0aW9uLCAnVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wJyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyAnVGhpcyBpcyBhIG5vLW9wIGZ1bmN0aW9uJyA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIHZhciB3YXJuaW5nQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgc2VlaW5nIHRoaXMsICcgKyAneW91XFwncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiAnICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpIDogdm9pZCAwO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljSW5wdXRFdmVudCwgSW5wdXRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljSW5wdXRFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljSW5wdXRFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2hhbmdlJykge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICAvLyBJRTEwKyBmaXJlIGlucHV0IGV2ZW50cyB0byBvZnRlbiwgc3VjaCB3aGVuIGEgcGxhY2Vob2xkZXJcbiAgLy8gY2hhbmdlcyBvciB3aGVuIGFuIGlucHV0IHdpdGggYSBwbGFjZWhvbGRlciBpcyBmb2N1c2VkLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDExKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xuICogc2V0IG9uIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAqL1xudmFyIG5ld1ZhbHVlUHJvcCA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgc28gd2UgY2FuIGRvIGVxdWFsaXR5IGNoZWNrcy5cbiAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSAnJyArIHZhbDtcbiAgICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLnNldC5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbn07XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlLCAndmFsdWUnKTtcblxuICAvLyBOb3QgZ3VhcmRlZCBpbiBhIGNhbkRlZmluZVByb3BlcnR5IGNoZWNrOiBJRTggc3VwcG9ydHMgZGVmaW5lUHJvcGVydHkgb25seVxuICAvLyBvbiBET00gZWxlbWVudHNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XG4gIGlmIChhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuXG4gIGlmIChhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XG5cbiAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG59XG5cbi8qKlxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0Jykge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOS0xMSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcFNlbGVjdGlvbkNoYW5nZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5VXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJbnN0O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDbGljaycpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUU7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RGZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcbnZhciB1cGRhdGVCYXRjaE51bWJlciA9IDA7XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTIzJykgOiB2b2lkIDA7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIHVzZUNyZWF0ZUVsZW1lbnQgKi90cnVlKTtcbn1cblxuX2Fzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgcmV0dXJuIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpO1xufVxuXG4vKipcbiAqIEFycmF5IGNvbXBhcmF0b3IgZm9yIFJlYWN0Q29tcG9uZW50cyBieSBtb3VudCBvcmRlcmluZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzIgc2Vjb25kIGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cbiAqL1xuZnVuY3Rpb24gbW91bnRPcmRlckNvbXBhcmF0b3IoYzEsIGMyKSB7XG4gIHJldHVybiBjMS5fbW91bnRPcmRlciAtIGMyLl9tb3VudE9yZGVyO1xufVxuXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xuICAhKGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgZmx1c2ggdHJhbnNhY3Rpb25cXCdzIHN0b3JlZCBkaXJ0eS1jb21wb25lbnRzIGxlbmd0aCAoJXMpIHRvIG1hdGNoIGRpcnR5LWNvbXBvbmVudHMgYXJyYXkgbGVuZ3RoICglcykuJywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IF9wcm9kSW52YXJpYW50KCcxMjQnLCBsZW4sIGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIDogdm9pZCAwO1xuXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxuICAvLyBhbHdheXMgLS0gc2VlIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpKSB3aWxsIHJlY29uY2lsZSBjaGlsZHJlbiwgcmVjb25jaWxlXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudE9yZGVyQ29tcGFyYXRvcik7XG5cbiAgLy8gQW55IHVwZGF0ZXMgZW5xdWV1ZWQgd2hpbGUgcmVjb25jaWxpbmcgbXVzdCBiZSBwZXJmb3JtZWQgYWZ0ZXIgdGhpcyBlbnRpcmVcbiAgLy8gYmF0Y2guIE90aGVyd2lzZSwgaWYgZGlydHlDb21wb25lbnRzIGlzIFtBLCBCXSB3aGVyZSBBIGhhcyBjaGlsZHJlbiBCIGFuZFxuICAvLyBDLCBCIGNvdWxkIHVwZGF0ZSB0d2ljZSBpbiBhIHNpbmdsZSBiYXRjaCBpZiBDJ3MgcmVuZGVyIGVucXVldWVzIGFuIHVwZGF0ZVxuICAvLyB0byBCIChzaW5jZSBCIHdvdWxkIGhhdmUgYWxyZWFkeSB1cGRhdGVkLCB3ZSBzaG91bGQgc2tpcCBpdCwgYW5kIHRoZSBvbmx5XG4gIC8vIHdheSB3ZSBjYW4ga25vdyB0byBkbyBzbyBpcyBieSBjaGVja2luZyB0aGUgYmF0Y2ggY291bnRlcikuXG4gIHVwZGF0ZUJhdGNoTnVtYmVyKys7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgcGVuZGluZyBjaGFuZ2VzIGFwcGx5LCBpdCB3aWxsIHN0aWxsXG4gICAgLy8gYmUgaGVyZSwgYnV0IHdlIGFzc3VtZSB0aGF0IGl0IGhhcyBjbGVhcmVkIGl0cyBfcGVuZGluZ0NhbGxiYWNrcyBhbmRcbiAgICAvLyB0aGF0IHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBpcyBhIG5vb3AuXG4gICAgdmFyIGNvbXBvbmVudCA9IGRpcnR5Q29tcG9uZW50c1tpXTtcblxuICAgIC8vIElmIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBoYXBwZW5zIHRvIGVucXVldWUgYW55IG5ldyB1cGRhdGVzLCB3ZVxuICAgIC8vIHNob3VsZG4ndCBleGVjdXRlIHRoZSBjYWxsYmFja3MgdW50aWwgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMsIHNvXG4gICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgIHZhciBjYWxsYmFja3MgPSBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3M7XG4gICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIHZhciBtYXJrZXJOYW1lO1xuICAgIGlmIChSZWFjdEZlYXR1cmVGbGFncy5sb2dUb3BMZXZlbFJlbmRlcnMpIHtcbiAgICAgIHZhciBuYW1lZENvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgIC8vIER1Y2sgdHlwZSBUb3BMZXZlbFdyYXBwZXIuIFRoaXMgaXMgcHJvYmFibHkgYWx3YXlzIHRydWUuXG4gICAgICBpZiAoY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC50eXBlLmlzUmVhY3RUb3BMZXZlbFdyYXBwZXIpIHtcbiAgICAgICAgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgICAgfVxuICAgICAgbWFya2VyTmFtZSA9ICdSZWFjdCB1cGRhdGU6ICcgKyBuYW1lZENvbXBvbmVudC5nZXROYW1lKCk7XG4gICAgICBjb25zb2xlLnRpbWUobWFya2VyTmFtZSk7XG4gICAgfVxuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShjb21wb25lbnQsIHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcik7XG5cbiAgICBpZiAobWFya2VyTmFtZSkge1xuICAgICAgY29uc29sZS50aW1lRW5kKG1hcmtlck5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFja3Nbal0sIGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xuICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYXNhcEVucXVldWVkKSB7XG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xuICAgICAgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcbiAqIGxpc3Qgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSB0aGUgcmVyZW5kZXIgb2NjdXJzLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFN0YXRlLCBmb3JjZVVwZGF0ZSwgZXRjLjsgY3JlYXRpb24gYW5kXG4gIC8vIGRlc3RydWN0aW9uIG9mIHRvcC1sZXZlbCBjb21wb25lbnRzIGlzIGd1YXJkZWQgaW4gUmVhY3RNb3VudC4pXG5cbiAgaWYgKCFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhlbnF1ZXVlVXBkYXRlLCBjb21wb25lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRpcnR5Q29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIGlmIChjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID09IG51bGwpIHtcbiAgICBjb21wb25lbnQuX3VwZGF0ZUJhdGNoTnVtYmVyID0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxO1xuICB9XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRvIGJlIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJhdGNoaW5nIGN5Y2xlLiBUaHJvd3NcbiAqIGlmIG5vIHVwZGF0ZXMgYXJlIGN1cnJlbnRseSBiZWluZyBwZXJmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzLmFzYXA6IENhblxcJ3QgZW5xdWV1ZSBhbiBhc2FwIGNhbGxiYWNrIGluIGEgY29udGV4dCB3aGVyZXVwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzEyNScpIDogdm9pZCAwO1xuICBhc2FwQ2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgYXNhcEVucXVldWVkID0gdHJ1ZTtcbn1cblxudmFyIFJlYWN0VXBkYXRlc0luamVjdGlvbiA9IHtcbiAgaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIChSZWNvbmNpbGVUcmFuc2FjdGlvbikge1xuICAgICFSZWNvbmNpbGVUcmFuc2FjdGlvbiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcycpIDogX3Byb2RJbnZhcmlhbnQoJzEyNicpIDogdm9pZCAwO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVjb25jaWxlVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgaW5qZWN0QmF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24gKF9iYXRjaGluZ1N0cmF0ZWd5KSB7XG4gICAgIV9iYXRjaGluZ1N0cmF0ZWd5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IF9wcm9kSW52YXJpYW50KCcxMjcnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBfcHJvZEludmFyaWFudCgnMTI4JykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPT09ICdib29sZWFuJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYW4gaXNCYXRjaGluZ1VwZGF0ZXMgYm9vbGVhbiBhdHRyaWJ1dGUnKSA6IF9wcm9kSW52YXJpYW50KCcxMjknKSA6IHZvaWQgMDtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5ID0gX2JhdGNoaW5nU3RyYXRlZ3k7XG4gIH1cbn07XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSB7XG4gIC8qKlxuICAgKiBSZWFjdCByZWZlcmVuY2VzIGBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uYCB1c2luZyB0aGlzIHByb3BlcnR5IGluIG9yZGVyXG4gICAqIHRvIGFsbG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IG51bGwsXG5cbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICBlbnF1ZXVlVXBkYXRlOiBlbnF1ZXVlVXBkYXRlLFxuICBmbHVzaEJhdGNoZWRVcGRhdGVzOiBmbHVzaEJhdGNoZWRVcGRhdGVzLFxuICBpbmplY3Rpb246IFJlYWN0VXBkYXRlc0luamVjdGlvbixcbiAgYXNhcDogYXNhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cblxudmFyIENhbGxiYWNrUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhbGxiYWNrUXVldWUoYXJnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbGxiYWNrUXVldWUpO1xuXG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgdGhpcy5fYXJnID0gYXJnO1xuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgQ29udGV4dCB0byBjYWxsIGBjYWxsYmFja2Agd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfTtcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLm5vdGlmeUFsbCA9IGZ1bmN0aW9uIG5vdGlmeUFsbCgpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzO1xuICAgIHZhciBhcmcgPSB0aGlzLl9hcmc7XG4gICAgaWYgKGNhbGxiYWNrcyAmJiBjb250ZXh0cykge1xuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogX3Byb2RJbnZhcmlhbnQoJzI0JykgOiB2b2lkIDA7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0sIGFyZyk7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9O1xuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLmNoZWNrcG9pbnQgPSBmdW5jdGlvbiBjaGVja3BvaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jYWxsYmFja3MgPyB0aGlzLl9jYWxsYmFja3MubGVuZ3RoIDogMDtcbiAgfTtcblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5yb2xsYmFjayA9IGZ1bmN0aW9uIHJvbGxiYWNrKGxlbikge1xuICAgIGlmICh0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY29udGV4dHMpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPSBsZW47XG4gICAgICB0aGlzLl9jb250ZXh0cy5sZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGludGVybmFsIHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLlxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfTtcblxuICByZXR1cm4gQ2FsbGJhY2tRdWV1ZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2FsbGJhY2tRdWV1ZSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0NhbGxiYWNrUXVldWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxuICAvLyByZW5kZXIgKGJvdGggaW5pdGlhbCByZW5kZXJzIGFuZCB1cGRhdGVzKS4gVXNlZnVsIHdoZW4gbG9va2luZyBhdCBwcm9kLW1vZGVcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFncztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RGZWF0dXJlRmxhZ3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWYgPSByZXF1aXJlKCcuL1JlYWN0UmVmJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHRoZSBjb250YWluaW5nIGhvc3QgY29tcG9uZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZU1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xuICAgKiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cC5cbiAgICovXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlLmdldEhvc3ROb2RlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBzYWZlbHkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KHNhZmVseSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBjb21wb25lbnQgdXNpbmcgYSBuZXcgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gcHJldkVsZW1lbnQgJiYgY29udGV4dCA9PT0gaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkge1xuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGFuIGVsZW1lbnQgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuXG4gICAgICAvLyBUT0RPOiBCYWlsaW5nIG91dCBlYXJseSBpcyBqdXN0IGEgcGVyZiBvcHRpbWl6YXRpb24gcmlnaHQ/XG4gICAgICAvLyBUT0RPOiBSZW1vdmluZyB0aGUgcmV0dXJuIHN0YXRlbWVudCBzaG91bGQgYWZmZWN0IGNvcnJlY3RuZXNzP1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgbmV4dEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWZzQ2hhbmdlZCA9IFJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCkge1xuICAgICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBwcmV2RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgIT09IHVwZGF0ZUJhdGNoTnVtYmVyKSB7XG4gICAgICAvLyBUaGUgY29tcG9uZW50J3MgZW5xdWV1ZWQgYmF0Y2ggbnVtYmVyIHNob3VsZCBhbHdheXMgYmUgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGJhdGNoIG9yIHRoZSBmb2xsb3dpbmcgb25lLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCB8fCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PT0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxLCAncGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBVbmV4cGVjdGVkIGJhdGNoIG51bWJlciAoY3VycmVudCAlcywgJyArICdwZW5kaW5nICVzKScsIHVwZGF0ZUJhdGNoTnVtYmVyLCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlcikgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlcm5hbEluc3RhbmNlLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0T3duZXInKTtcblxudmFyIFJlYWN0UmVmID0ge307XG5cbmZ1bmN0aW9uIGF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYoY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLmFkZENvbXBvbmVudEFzUmVmVG8oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKG51bGwpO1xuICB9IGVsc2Uge1xuICAgIC8vIExlZ2FjeSByZWZcbiAgICBSZWFjdE93bmVyLnJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbShjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cblJlYWN0UmVmLmF0dGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxuUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGVsZW1lbnQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxuXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgdmFyIHByZXZSZWYgPSBudWxsO1xuICB2YXIgcHJldk93bmVyID0gbnVsbDtcbiAgaWYgKHByZXZFbGVtZW50ICE9PSBudWxsICYmIHR5cGVvZiBwcmV2RWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICBwcmV2UmVmID0gcHJldkVsZW1lbnQucmVmO1xuICAgIHByZXZPd25lciA9IHByZXZFbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciBuZXh0UmVmID0gbnVsbDtcbiAgdmFyIG5leHRPd25lciA9IG51bGw7XG4gIGlmIChuZXh0RWxlbWVudCAhPT0gbnVsbCAmJiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgbmV4dFJlZiA9IG5leHRFbGVtZW50LnJlZjtcbiAgICBuZXh0T3duZXIgPSBuZXh0RWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gcHJldlJlZiAhPT0gbmV4dFJlZiB8fFxuICAvLyBJZiBvd25lciBjaGFuZ2VzIGJ1dCB3ZSBoYXZlIGFuIHVuY2hhbmdlZCBmdW5jdGlvbiByZWYsIGRvbid0IHVwZGF0ZSByZWZzXG4gIHR5cGVvZiBuZXh0UmVmID09PSAnc3RyaW5nJyAmJiBuZXh0T3duZXIgIT09IHByZXZPd25lcjtcbn07XG5cblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgZGV0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlZjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWYuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICogQGZpbmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRPd25lcihvYmplY3QpIHtcbiAgcmV0dXJuICEhKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0LmF0dGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqZWN0LmRldGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogUmVhY3RPd25lcnMgYXJlIGNhcGFibGUgb2Ygc3RvcmluZyByZWZlcmVuY2VzIHRvIG93bmVkIGNvbXBvbmVudHMuXG4gKlxuICogQWxsIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9iZWluZy8vIHJlZmVyZW5jZWQgYnkgb3duZXIgY29tcG9uZW50cywgYnV0XG4gKiBvbmx5IFJlYWN0T3duZXIgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL3JlZmVyZW5jaW5nLy8gb3duZWQgY29tcG9uZW50cy5cbiAqIFRoZSBuYW1lZCByZWZlcmVuY2UgaXMga25vd24gYXMgYSBcInJlZlwiLlxuICpcbiAqIFJlZnMgYXJlIGF2YWlsYWJsZSB3aGVuIG1vdW50ZWQgYW5kIHVwZGF0ZWQgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gKFxuICogICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9PlxuICogICAgICAgICAgIDxDdXN0b21Db21wb25lbnQgcmVmPVwiY3VzdG9tXCIgLz5cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICApO1xuICogICAgIH0sXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5oYW5kbGVDbGljaygpO1xuICogICAgIH0sXG4gKiAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5pbml0aWFsaXplKCk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBSZWZzIHNob3VsZCByYXJlbHkgYmUgdXNlZC4gV2hlbiByZWZzIGFyZSB1c2VkLCB0aGV5IHNob3VsZCBvbmx5IGJlIGRvbmUgdG9cbiAqIGNvbnRyb2wgZGF0YSB0aGF0IGlzIG5vdCBoYW5kbGVkIGJ5IFJlYWN0J3MgZGF0YSBmbG93LlxuICpcbiAqIEBjbGFzcyBSZWFjdE93bmVyXG4gKi9cbnZhciBSZWFjdE93bmVyID0ge1xuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCBieSByZWYgdG8gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIGJ5IHdoaWNoIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRvIHJlY29yZCB0aGUgcmVmLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRDb21wb25lbnRBc1JlZlRvOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIWlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWRkQ29tcG9uZW50QXNSZWZUbyguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTknKSA6IHZvaWQgMDtcbiAgICBvd25lci5hdHRhY2hSZWYocmVmLCBjb21wb25lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGJ5IHJlZiBmcm9tIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBkZXJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIG9mIHRoZSByZWYgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0aGUgcmVmIGlzIHJlY29yZGVkLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZW1vdmVDb21wb25lbnRBc1JlZkZyb206IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kLCBvciB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjAnKSA6IHZvaWQgMDtcbiAgICB2YXIgb3duZXJQdWJsaWNJbnN0YW5jZSA9IG93bmVyLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgLy8gQ2hlY2sgdGhhdCBgY29tcG9uZW50YCdzIG93bmVyIGlzIHN0aWxsIGFsaXZlIGFuZCB0aGF0IGBjb21wb25lbnRgIGlzIHN0aWxsIHRoZSBjdXJyZW50IHJlZlxuICAgIC8vIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG8gZGV0YWNoIHRoZSByZWYgaWYgYW5vdGhlciBjb21wb25lbnQgc3RvbGUgaXQuXG4gICAgaWYgKG93bmVyUHVibGljSW5zdGFuY2UgJiYgb3duZXJQdWJsaWNJbnN0YW5jZS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdE93bmVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIFJlYWN0SW5zdHJ1bWVudGF0aW9uIHdpdGggYSBfX0RFVl9fIGNoZWNrXG5cbnZhciBkZWJ1Z1Rvb2wgPSBudWxsO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3REZWJ1Z1Rvb2wgPSByZXF1aXJlKCcuL1JlYWN0RGVidWdUb29sJyk7XG4gIGRlYnVnVG9vbCA9IFJlYWN0RGVidWdUb29sO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0cnVtZW50YXRpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rID0gcmVxdWlyZSgnLi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rJyk7XG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3cgPSByZXF1aXJlKCdmYmpzL2xpYi9wZXJmb3JtYW5jZU5vdycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBob29rcyA9IFtdO1xudmFyIGRpZEhvb2tUaHJvd0ZvckV2ZW50ID0ge307XG5cbmZ1bmN0aW9uIGNhbGxIb29rKGV2ZW50LCBmbiwgY29udGV4dCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuICB0cnkge1xuICAgIGZuLmNhbGwoY29udGV4dCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRIb29rVGhyb3dGb3JFdmVudFtldmVudF0sICdFeGNlcHRpb24gdGhyb3duIGJ5IGhvb2sgd2hpbGUgaGFuZGxpbmcgJXM6ICVzJywgZXZlbnQsIGUgKyAnXFxuJyArIGUuc3RhY2spIDogdm9pZCAwO1xuICAgIGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEV2ZW50KGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaG9vayA9IGhvb2tzW2ldO1xuICAgIHZhciBmbiA9IGhvb2tbZXZlbnRdO1xuICAgIGlmIChmbikge1xuICAgICAgY2FsbEhvb2soZXZlbnQsIGZuLCBob29rLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGlzUHJvZmlsaW5nID0gZmFsc2U7XG52YXIgZmx1c2hIaXN0b3J5ID0gW107XG52YXIgbGlmZUN5Y2xlVGltZXJTdGFjayA9IFtdO1xudmFyIGN1cnJlbnRGbHVzaE5lc3RpbmcgPSAwO1xudmFyIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xudmFyIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IDA7XG52YXIgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG52YXIgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbnZhciBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbnZhciBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcblxudmFyIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNsZWFySGlzdG9yeSgpIHtcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vay5wdXJnZVVubW91bnRlZENvbXBvbmVudHMoKTtcbiAgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suY2xlYXJIaXN0b3J5KCk7XG59XG5cbmZ1bmN0aW9uIGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKSB7XG4gIHJldHVybiByZWdpc3RlcmVkSURzLnJlZHVjZShmdW5jdGlvbiAodHJlZSwgaWQpIHtcbiAgICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gICAgdmFyIHBhcmVudElEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgdHJlZVtpZF0gPSB7XG4gICAgICBkaXNwbGF5TmFtZTogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCksXG4gICAgICB0ZXh0OiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFRleHQoaWQpLFxuICAgICAgdXBkYXRlQ291bnQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VXBkYXRlQ291bnQoaWQpLFxuICAgICAgY2hpbGRJRHM6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q2hpbGRJRHMoaWQpLFxuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIG93bmVycyBidXQgdGhpcyBpcyBjbG9zZSBlbm91Z2guXG4gICAgICBvd25lcklEOiBvd25lcklEIHx8IHBhcmVudElEICYmIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChwYXJlbnRJRCkgfHwgMCxcbiAgICAgIHBhcmVudElEOiBwYXJlbnRJRFxuICAgIH07XG4gICAgcmV0dXJuIHRyZWU7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRNZWFzdXJlbWVudHMoKSB7XG4gIHZhciBwcmV2aW91c1N0YXJ0VGltZSA9IGN1cnJlbnRGbHVzaFN0YXJ0VGltZTtcbiAgdmFyIHByZXZpb3VzTWVhc3VyZW1lbnRzID0gY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzO1xuICB2YXIgcHJldmlvdXNPcGVyYXRpb25zID0gUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suZ2V0SGlzdG9yeSgpO1xuXG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gMDtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcbiAgICBjbGVhckhpc3RvcnkoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJldmlvdXNNZWFzdXJlbWVudHMubGVuZ3RoIHx8IHByZXZpb3VzT3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICB2YXIgcmVnaXN0ZXJlZElEcyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UmVnaXN0ZXJlZElEcygpO1xuICAgIGZsdXNoSGlzdG9yeS5wdXNoKHtcbiAgICAgIGR1cmF0aW9uOiBwZXJmb3JtYW5jZU5vdygpIC0gcHJldmlvdXNTdGFydFRpbWUsXG4gICAgICBtZWFzdXJlbWVudHM6IHByZXZpb3VzTWVhc3VyZW1lbnRzIHx8IFtdLFxuICAgICAgb3BlcmF0aW9uczogcHJldmlvdXNPcGVyYXRpb25zIHx8IFtdLFxuICAgICAgdHJlZVNuYXBzaG90OiBnZXRUcmVlU25hcHNob3QocmVnaXN0ZXJlZElEcylcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFySGlzdG9yeSgpO1xuICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMgPSBbXTtcbn1cblxuZnVuY3Rpb24gY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpIHtcbiAgdmFyIGFsbG93Um9vdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgaWYgKGFsbG93Um9vdCAmJiBkZWJ1Z0lEID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZGVidWdJRCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3REZWJ1Z1Rvb2w6IGRlYnVnSUQgbWF5IG5vdCBiZSBlbXB0eS4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBiZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICBpZiAoY3VycmVudEZsdXNoTmVzdGluZyA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoY3VycmVudFRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ0RpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0YXJ0IHdoaWxlICVzIHRpbWVyIGlzIHN0aWxsIGluICcgKyAncHJvZ3Jlc3MgZm9yICVzIGluc3RhbmNlLicsIHRpbWVyVHlwZSwgY3VycmVudFRpbWVyVHlwZSB8fCAnbm8nLCBkZWJ1Z0lEID09PSBjdXJyZW50VGltZXJEZWJ1Z0lEID8gJ3RoZSBzYW1lJyA6ICdhbm90aGVyJykgOiB2b2lkIDA7XG4gICAgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSB0cnVlO1xuICB9XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbn1cblxuZnVuY3Rpb24gZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICE9PSB0aW1lclR5cGUgJiYgIWxpZmVDeWNsZVRpbWVySGFzV2FybmVkKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGVyZSBpcyBhbiBpbnRlcm5hbCBlcnJvciBpbiB0aGUgUmVhY3QgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnQgY29kZS4gJyArICdXZSBkaWQgbm90IGV4cGVjdCAlcyB0aW1lciB0byBzdG9wIHdoaWxlICVzIHRpbWVyIGlzIHN0aWxsIGluICcgKyAncHJvZ3Jlc3MgZm9yICVzIGluc3RhbmNlLiBQbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWcgaW4gUmVhY3QuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzLnB1c2goe1xuICAgICAgdGltZXJUeXBlOiB0aW1lclR5cGUsXG4gICAgICBpbnN0YW5jZUlEOiBkZWJ1Z0lELFxuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBjdXJyZW50VGltZXJTdGFydFRpbWUgLSBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uXG4gICAgfSk7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIoKSB7XG4gIHZhciBjdXJyZW50VGltZXIgPSB7XG4gICAgc3RhcnRUaW1lOiBjdXJyZW50VGltZXJTdGFydFRpbWUsXG4gICAgbmVzdGVkRmx1c2hTdGFydFRpbWU6IHBlcmZvcm1hbmNlTm93KCksXG4gICAgZGVidWdJRDogY3VycmVudFRpbWVyRGVidWdJRCxcbiAgICB0aW1lclR5cGU6IGN1cnJlbnRUaW1lclR5cGVcbiAgfTtcbiAgbGlmZUN5Y2xlVGltZXJTdGFjay5wdXNoKGN1cnJlbnRUaW1lcik7XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IDA7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIF9saWZlQ3ljbGVUaW1lclN0YWNrJCA9IGxpZmVDeWNsZVRpbWVyU3RhY2sucG9wKCksXG4gICAgICBzdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuc3RhcnRUaW1lLFxuICAgICAgbmVzdGVkRmx1c2hTdGFydFRpbWUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQubmVzdGVkRmx1c2hTdGFydFRpbWUsXG4gICAgICBkZWJ1Z0lEID0gX2xpZmVDeWNsZVRpbWVyU3RhY2skLmRlYnVnSUQsXG4gICAgICB0aW1lclR5cGUgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQudGltZXJUeXBlO1xuXG4gIHZhciBuZXN0ZWRGbHVzaER1cmF0aW9uID0gcGVyZm9ybWFuY2VOb3coKSAtIG5lc3RlZEZsdXNoU3RhcnRUaW1lO1xuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gKz0gbmVzdGVkRmx1c2hEdXJhdGlvbjtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IGRlYnVnSUQ7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSB0aW1lclR5cGU7XG59XG5cbnZhciBsYXN0TWFya1RpbWVTdGFtcCA9IDA7XG52YXIgY2FuVXNlUGVyZm9ybWFuY2VNZWFzdXJlID1cbi8vICRGbG93Rml4TWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzIzNDVcbnR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIHNob3VsZE1hcmsoZGVidWdJRCkge1xuICBpZiAoIWlzUHJvZmlsaW5nIHx8ICFjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoZGVidWdJRCk7XG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpc0hvc3RFbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZyc7XG4gIGlmIChpc0hvc3RFbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXJrQmVnaW4oZGVidWdJRCwgbWFya1R5cGUpIHtcbiAgaWYgKCFzaG91bGRNYXJrKGRlYnVnSUQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1hcmtOYW1lID0gZGVidWdJRCArICc6OicgKyBtYXJrVHlwZTtcbiAgbGFzdE1hcmtUaW1lU3RhbXAgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBwZXJmb3JtYW5jZS5tYXJrKG1hcmtOYW1lKTtcbn1cblxuZnVuY3Rpb24gbWFya0VuZChkZWJ1Z0lELCBtYXJrVHlwZSkge1xuICBpZiAoIXNob3VsZE1hcmsoZGVidWdJRCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWFya05hbWUgPSBkZWJ1Z0lEICsgJzo6JyArIG1hcmtUeXBlO1xuICB2YXIgZGlzcGxheU5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGRlYnVnSUQpIHx8ICdVbmtub3duJztcblxuICAvLyBDaHJvbWUgaGFzIGFuIGlzc3VlIG9mIGRyb3BwaW5nIG1hcmtlcnMgcmVjb3JkZWQgdG9vIGZhc3Q6XG4gIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTY0MDY1MlxuICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSB3aWxsIG5vdCByZXBvcnQgdmVyeSBzbWFsbCBtZWFzdXJlbWVudHMuXG4gIC8vIEkgZGV0ZXJtaW5lZCB0aGUgbWFnaWMgbnVtYmVyIGJ5IHR3ZWFraW5nIGl0IGJhY2sgYW5kIGZvcnRoLlxuICAvLyAwLjA1bXMgd2FzIGVub3VnaCB0byBwcmV2ZW50IHRoZSBpc3N1ZSwgYnV0IEkgc2V0IGl0IHRvIDAuMW1zIHRvIGJlIHNhZmUuXG4gIC8vIFdoZW4gdGhlIGJ1ZyBpcyBmaXhlZCwgd2UgY2FuIGBtZWFzdXJlKClgIHVuY29uZGl0aW9uYWxseSBpZiB3ZSB3YW50IHRvLlxuICB2YXIgdGltZVN0YW1wID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgaWYgKHRpbWVTdGFtcCAtIGxhc3RNYXJrVGltZVN0YW1wID4gMC4xKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50TmFtZSA9IGRpc3BsYXlOYW1lICsgJyBbJyArIG1hcmtUeXBlICsgJ10nO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUobWVhc3VyZW1lbnROYW1lLCBtYXJrTmFtZSk7XG4gIH1cblxuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKG1hcmtOYW1lKTtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlbWVudE5hbWUpO1xufVxuXG52YXIgUmVhY3REZWJ1Z1Rvb2wgPSB7XG4gIGFkZEhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9va3MucHVzaChob29rKTtcbiAgfSxcbiAgcmVtb3ZlSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaG9va3NbaV0gPT09IGhvb2spIHtcbiAgICAgICAgaG9va3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpc1Byb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc1Byb2ZpbGluZztcbiAgfSxcbiAgYmVnaW5Qcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc1Byb2ZpbGluZyA9IHRydWU7XG4gICAgZmx1c2hIaXN0b3J5Lmxlbmd0aCA9IDA7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBSZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rKTtcbiAgfSxcbiAgZW5kUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rKTtcbiAgfSxcbiAgZ2V0Rmx1c2hIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZsdXNoSGlzdG9yeTtcbiAgfSxcbiAgb25CZWdpbkZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudEZsdXNoTmVzdGluZysrO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgcGF1c2VDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5GbHVzaCcpO1xuICB9LFxuICBvbkVuZEZsdXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nLS07XG4gICAgcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XG4gICAgZW1pdEV2ZW50KCdvbkVuZEZsdXNoJyk7XG4gIH0sXG4gIG9uQmVnaW5MaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5MaWZlQ3ljbGVUaW1lcicsIGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgbWFya0JlZ2luKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgYmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkVuZExpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgbWFya0VuZChkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIGVtaXRFdmVudCgnb25FbmRMaWZlQ3ljbGVUaW1lcicsIGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH0sXG4gIG9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xuICB9LFxuICBvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCcpO1xuICB9LFxuICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICBjaGVja0RlYnVnSUQob3BlcmF0aW9uLmluc3RhbmNlSUQpO1xuICAgIGVtaXRFdmVudCgnb25Ib3N0T3BlcmF0aW9uJywgb3BlcmF0aW9uKTtcbiAgfSxcbiAgb25TZXRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25TZXRTdGF0ZScpO1xuICB9LFxuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoZGVidWdJRCwgY2hpbGREZWJ1Z0lEcykge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBjaGlsZERlYnVnSURzLmZvckVhY2goY2hlY2tEZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uU2V0Q2hpbGRyZW4nLCBkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgY2hlY2tEZWJ1Z0lEKHBhcmVudERlYnVnSUQsIHRydWUpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVNb3VudENvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAnbW91bnQnKTtcbiAgfSxcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgbWFya0VuZChkZWJ1Z0lELCAnbW91bnQnKTtcbiAgICBlbWl0RXZlbnQoJ29uTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVVcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50KTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgJ3VwZGF0ZScpO1xuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgbWFya0VuZChkZWJ1Z0lELCAndXBkYXRlJyk7XG4gICAgZW1pdEV2ZW50KCdvblVwZGF0ZUNvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvbkJlZm9yZVVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWZvcmVVbm1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICd1bm1vdW50Jyk7XG4gIH0sXG4gIG9uVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgbWFya0VuZChkZWJ1Z0lELCAndW5tb3VudCcpO1xuICAgIGVtaXRFdmVudCgnb25Vbm1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uVGVzdEV2ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvblRlc3RFdmVudCcpO1xuICB9XG59O1xuXG4vLyBUT0RPIHJlbW92ZSB0aGVzZSB3aGVuIFJOL3d3dyBnZXRzIHVwZGF0ZWRcblJlYWN0RGVidWdUb29sLmFkZERldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5hZGRIb29rO1xuUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlRGV2dG9vbCA9IFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2s7XG5cblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayk7XG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0Q29tcG9uZW50VHJlZUhvb2spO1xudmFyIHVybCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnJztcbmlmICgvWz8mXXJlYWN0X3BlcmZcXGIvLnRlc3QodXJsKSkge1xuICBSZWFjdERlYnVnVG9vbC5iZWdpblByb2ZpbGluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVidWdUb29sO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5JbnZhbGlkU2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIXByb2Nlc3NpbmdDaGlsZENvbnRleHQsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayA9IHtcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgd2FybkludmFsaWRTZXRTdGF0ZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2suanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoaXN0b3J5ID0gW107XG5cbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHtcbiAgb25Ib3N0T3BlcmF0aW9uOiBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgaGlzdG9yeS5wdXNoKG9wZXJhdGlvbik7XG4gIH0sXG4gIGNsZWFySGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5fcHJldmVudENsZWFyaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0cy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoaXN0b3J5ID0gW107XG4gIH0sXG4gIGdldEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93O1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2U7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgd2luZG93Lm1zUGVyZm9ybWFuY2UgfHwgd2luZG93LndlYmtpdFBlcmZvcm1hbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlIHx8IHt9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIE9CU0VSVkVEX0VSUk9SID0ge307XG5cbi8qKlxuICogYFRyYW5zYWN0aW9uYCBjcmVhdGVzIGEgYmxhY2sgYm94IHRoYXQgaXMgYWJsZSB0byB3cmFwIGFueSBtZXRob2Qgc3VjaCB0aGF0XG4gKiBjZXJ0YWluIGludmFyaWFudHMgYXJlIG1haW50YWluZWQgYmVmb3JlIGFuZCBhZnRlciB0aGUgbWV0aG9kIGlzIGludm9rZWRcbiAqIChFdmVuIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgaW52b2tpbmcgdGhlIHdyYXBwZWQgbWV0aG9kKS4gV2hvZXZlclxuICogaW5zdGFudGlhdGVzIGEgdHJhbnNhY3Rpb24gY2FuIHByb3ZpZGUgZW5mb3JjZXJzIG9mIHRoZSBpbnZhcmlhbnRzIGF0XG4gKiBjcmVhdGlvbiB0aW1lLiBUaGUgYFRyYW5zYWN0aW9uYCBjbGFzcyBpdHNlbGYgd2lsbCBzdXBwbHkgb25lIGFkZGl0aW9uYWxcbiAqIGF1dG9tYXRpYyBpbnZhcmlhbnQgZm9yIHlvdSAtIHRoZSBpbnZhcmlhbnQgdGhhdCBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2VcbiAqIHNob3VsZCBub3QgYmUgcnVuIHdoaWxlIGl0IGlzIGFscmVhZHkgYmVpbmcgcnVuLiBZb3Ugd291bGQgdHlwaWNhbGx5IGNyZWF0ZSBhXG4gKiBzaW5nbGUgaW5zdGFuY2Ugb2YgYSBgVHJhbnNhY3Rpb25gIGZvciByZXVzZSBtdWx0aXBsZSB0aW1lcywgdGhhdCBwb3RlbnRpYWxseVxuICogaXMgdXNlZCB0byB3cmFwIHNldmVyYWwgZGlmZmVyZW50IG1ldGhvZHMuIFdyYXBwZXJzIGFyZSBleHRyZW1lbHkgc2ltcGxlIC1cbiAqIHRoZXkgb25seSByZXF1aXJlIGltcGxlbWVudGluZyB0d28gbWV0aG9kcy5cbiAqXG4gKiA8cHJlPlxuICogICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJzIChpbmplY3RlZCBhdCBjcmVhdGlvbiB0aW1lKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgICAgICAgICtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHYgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICstLXwgICAgd3JhcHBlcjEgICB8LS0tfC0tLS0rICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICArLS0tLS0tLS0tLS0tLS0tKyAgIHYgICAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICstLS0tfCAgIHdyYXBwZXIyICB8LS0tLS0tLS0rICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICB2ICAgICB2ICAgfCB3cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfCBpbnZhcmlhbnRzXG4gKiBwZXJmb3JtKGFueU1ldGhvZCkgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfCBtYWludGFpbmVkXG4gKiArLS0tLS0tLS0tLS0tLS0tLS0+fC18LS0tfC18LS0tfC0tPnxhbnlNZXRob2R8LS0tfC0tLXwtfC0tLXwtfC0tLS0tLS0tPlxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICBpbml0aWFsaXplICAgICAgICAgICAgICAgICAgICBjbG9zZSAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogPC9wcmU+XG4gKlxuICogVXNlIGNhc2VzOlxuICogLSBQcmVzZXJ2aW5nIHRoZSBpbnB1dCBzZWxlY3Rpb24gcmFuZ2VzIGJlZm9yZS9hZnRlciByZWNvbmNpbGlhdGlvbi5cbiAqICAgUmVzdG9yaW5nIHNlbGVjdGlvbiBldmVuIGluIHRoZSBldmVudCBvZiBhbiB1bmV4cGVjdGVkIGVycm9yLlxuICogLSBEZWFjdGl2YXRpbmcgZXZlbnRzIHdoaWxlIHJlYXJyYW5naW5nIHRoZSBET00sIHByZXZlbnRpbmcgYmx1cnMvZm9jdXNlcyxcbiAqICAgd2hpbGUgZ3VhcmFudGVlaW5nIHRoYXQgYWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHN5c3RlbSBpcyByZWFjdGl2YXRlZC5cbiAqIC0gRmx1c2hpbmcgYSBxdWV1ZSBvZiBjb2xsZWN0ZWQgRE9NIG11dGF0aW9ucyB0byB0aGUgbWFpbiBVSSB0aHJlYWQgYWZ0ZXIgYVxuICogICByZWNvbmNpbGlhdGlvbiB0YWtlcyBwbGFjZSBpbiBhIHdvcmtlciB0aHJlYWQuXG4gKiAtIEludm9raW5nIGFueSBjb2xsZWN0ZWQgYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGFmdGVyIHJlbmRlcmluZyBuZXdcbiAqICAgY29udGVudC5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IFdyYXBwaW5nIHBhcnRpY3VsYXIgZmx1c2hlcyBvZiB0aGUgYFJlYWN0V29ya2VyYCBxdWV1ZVxuICogICB0byBwcmVzZXJ2ZSB0aGUgYHNjcm9sbFRvcGAgKGFuIGF1dG9tYXRpYyBzY3JvbGwgYXdhcmUgRE9NKS5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IExheW91dCBjYWxjdWxhdGlvbnMgYmVmb3JlIGFuZCBhZnRlciBET00gdXBkYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIFRyYW5zYWN0aW9uSW1wbCA9IHtcbiAgLyoqXG4gICAqIFNldHMgdXAgdGhpcyBpbnN0YW5jZSBzbyB0aGF0IGl0IGlzIHByZXBhcmVkIGZvciBjb2xsZWN0aW5nIG1ldHJpY3MuIERvZXNcbiAgICogc28gc3VjaCB0aGF0IHRoaXMgc2V0dXAgbWV0aG9kIG1heSBiZSB1c2VkIG9uIGFuIGluc3RhbmNlIHRoYXQgaXMgYWxyZWFkeVxuICAgKiBpbml0aWFsaXplZCwgaW4gYSB3YXkgdGhhdCBkb2VzIG5vdCBjb25zdW1lIGFkZGl0aW9uYWwgbWVtb3J5IHVwb24gcmV1c2UuXG4gICAqIFRoYXQgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgZGVjaWRlIHRvIG1ha2UgeW91ciBzdWJjbGFzcyBvZiB0aGlzIG1peGluIGFcbiAgICogXCJQb29sZWRDbGFzc1wiLlxuICAgKi9cbiAgcmVpbml0aWFsaXplVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLmdldFRyYW5zYWN0aW9uV3JhcHBlcnMoKTtcbiAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGEpIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhID0gW107XG4gICAgfVxuICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICB9LFxuXG4gIF9pc0luVHJhbnNhY3Rpb246IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPn0gQXJyYXkgb2YgdHJhbnNhY3Rpb24gd3JhcHBlcnMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBudWxsLFxuXG4gIGlzSW5UcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2lzSW5UcmFuc2FjdGlvbjtcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIHdpdGhpbiBhIHNhZmV0eSB3aW5kb3cuIFVzZSB0aGlzIGZvciB0aGUgdG9wIGxldmVsXG4gICAqIG1ldGhvZHMgdGhhdCByZXN1bHQgaW4gbGFyZ2UgYW1vdW50cyBvZiBjb21wdXRhdGlvbi9tdXRhdGlvbnMgdGhhdCB3b3VsZFxuICAgKiBuZWVkIHRvIGJlIHNhZmV0eSBjaGVja2VkLiBUaGUgb3B0aW9uYWwgYXJndW1lbnRzIGhlbHBzIHByZXZlbnQgdGhlIG5lZWRcbiAgICogdG8gYmluZCBpbiBtYW55IGNhc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWVtYmVyIG9mIHNjb3BlIHRvIGNhbGwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBTY29wZSB0byBpbnZva2UgZnJvbS5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGIgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBjIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZCBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGUgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBmIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICpcbiAgICogQHJldHVybiB7Kn0gUmV0dXJuIHZhbHVlIGZyb20gYG1ldGhvZGAuXG4gICAqL1xuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICEhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5wZXJmb3JtKC4uLik6IENhbm5vdCBpbml0aWFsaXplIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSBpcyBhbHJlYWR5IGFuIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzI3JykgOiB2b2lkIDA7XG4gICAgdmFyIGVycm9yVGhyb3duO1xuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxuICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGluaXRpYWxpemVBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoIHRoZVxuICAgICAgICAvLyBPQlNFUlZFRF9FUlJPUiBzdGF0ZSBiZWZvcmUgb3ZlcndyaXRpbmcgaXQgd2l0aCB0aGUgcmVhbCByZXR1cm4gdmFsdWVcbiAgICAgICAgLy8gb2YgaW5pdGlhbGl6ZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byBPQlNFUlZFRF9FUlJPUiBpbiB0aGUgZmluYWxseVxuICAgICAgICAvLyBibG9jaywgaXQgbWVhbnMgd3JhcHBlci5pbml0aWFsaXplIHRocmV3LlxuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IE9CU0VSVkVEX0VSUk9SO1xuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IHdyYXBwZXIuaW5pdGlhbGl6ZSA/IHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9PT0gT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXG4gICAqIChgY2xvc2VgcnMgdGhhdCBjb3JyZXNwb25kIHRvIGluaXRpYWxpemVycyB0aGF0IGZhaWxlZCB3aWxsIG5vdCBiZVxuICAgKiBpbnZva2VkKS5cbiAgICovXG4gIGNsb3NlQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLmNsb3NlQWxsKCk6IENhbm5vdCBjbG9zZSB0cmFuc2FjdGlvbiB3aGVuIG5vbmUgYXJlIG9wZW4uJykgOiBfcHJvZEludmFyaWFudCgnMjgnKSA6IHZvaWQgMDtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xuICAgICAgdmFyIGVycm9yVGhyb3duO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXG4gICAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBPQlNFUlZFRF9FUlJPUiAmJiB3cmFwcGVyLmNsb3NlKSB7XG4gICAgICAgICAgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb25JbXBsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9UcmFuc2FjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1pbnB1dC1lbGVtZW50Lmh0bWwjaW5wdXQtdHlwZS1hdHRyLXN1bW1hcnlcbiAqL1xuXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgJ2NvbG9yJzogdHJ1ZSxcbiAgJ2RhdGUnOiB0cnVlLFxuICAnZGF0ZXRpbWUnOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICAnZW1haWwnOiB0cnVlLFxuICAnbW9udGgnOiB0cnVlLFxuICAnbnVtYmVyJzogdHJ1ZSxcbiAgJ3Bhc3N3b3JkJzogdHJ1ZSxcbiAgJ3JhbmdlJzogdHJ1ZSxcbiAgJ3NlYXJjaCc6IHRydWUsXG4gICd0ZWwnOiB0cnVlLFxuICAndGV4dCc6IHRydWUsXG4gICd0aW1lJzogdHJ1ZSxcbiAgJ3VybCc6IHRydWUsXG4gICd3ZWVrJzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gISFzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV07XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHRJbnB1dEVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2lzVGV4dElucHV0RWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cblxudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuXG4gICAgdmFyIGxlYXZlID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbnRlckxlYXZlRXZlbnRQbHVnaW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBXZWJraXQsIEZpcmVmb3gsIElFOStcbiAgICAvLyB3aGljaDogIDEgMiAzXG4gICAgLy8gYnV0dG9uOiAwIDEgMiAoc3RhbmRhcmQpXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICBpZiAoJ3doaWNoJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLy8gSUU8OVxuICAgIC8vIHdoaWNoOiAgdW5kZWZpbmVkXG4gICAgLy8gYnV0dG9uOiAwIDAgMFxuICAgIC8vIGJ1dHRvbjogMSA0IDIgKG9ubW91c2V1cClcbiAgICByZXR1cm4gYnV0dG9uID09PSAyID8gMiA6IGJ1dHRvbiA9PT0gNCA/IDEgOiAwO1xuICB9LFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH0sXG4gIC8vIFwiUHJvcHJpZXRhcnlcIiBJbnRlcmZhY2UuXG4gIHBhZ2VYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VYJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQuY2xpZW50WCArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdDtcbiAgfSxcbiAgcGFnZVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVknIGluIGV2ZW50ID8gZXZlbnQucGFnZVkgOiBldmVudC5jbGllbnRZICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3A7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFVJRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgVUlFdmVudEludGVyZmFjZSA9IHtcbiAgdmlldzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnZpZXcpIHtcbiAgICAgIHJldHVybiBldmVudC52aWV3O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgaWYgKHRhcmdldC53aW5kb3cgPT09IHRhcmdldCkge1xuICAgICAgLy8gdGFyZ2V0IGlzIGEgd2luZG93IG9iamVjdFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgIGlmIChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gIH0sXG4gIGRldGFpbDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVUlFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNVSUV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9WaWV3cG9ydE1ldHJpY3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgJ0FsdCc6ICdhbHRLZXknLFxuICAnQ29udHJvbCc6ICdjdHJsS2V5JyxcbiAgJ01ldGEnOiAnbWV0YUtleScsXG4gICdTaGlmdCc6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRNb2RpZmllclN0YXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChuZXcgUmVnRXhwKCdeKGRhdGF8YXJpYSktWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpKSxcbiAgUHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhY2NlcHQ6IDAsXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBhY2Nlc3NLZXk6IDAsXG4gICAgYWN0aW9uOiAwLFxuICAgIGFsbG93RnVsbFNjcmVlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IDAsXG4gICAgYWx0OiAwLFxuICAgIC8vIHNwZWNpZmllcyB0YXJnZXQgY29udGV4dCBmb3IgbGlua3Mgd2l0aCBgcHJlbG9hZGAgdHlwZVxuICAgIGFzOiAwLFxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvQ29tcGxldGU6IDAsXG4gICAgLy8gYXV0b0ZvY3VzIGlzIHBvbHlmaWxsZWQvbm9ybWFsaXplZCBieSBBdXRvRm9jdXNVdGlsc1xuICAgIC8vIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNlbGxQYWRkaW5nOiAwLFxuICAgIGNlbGxTcGFjaW5nOiAwLFxuICAgIGNoYXJTZXQ6IDAsXG4gICAgY2hhbGxlbmdlOiAwLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2l0ZTogMCxcbiAgICBjbGFzc0lEOiAwLFxuICAgIGNsYXNzTmFtZTogMCxcbiAgICBjb2xzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIGNvbnRlbnQ6IDAsXG4gICAgY29udGVudEVkaXRhYmxlOiAwLFxuICAgIGNvbnRleHRNZW51OiAwLFxuICAgIGNvbnRyb2xzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IDAsXG4gICAgY3Jvc3NPcmlnaW46IDAsXG4gICAgZGF0YTogMCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiAwLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpcjogMCxcbiAgICBkaXNhYmxlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiAwLFxuICAgIGVuY1R5cGU6IDAsXG4gICAgZm9ybTogMCxcbiAgICBmb3JtQWN0aW9uOiAwLFxuICAgIGZvcm1FbmNUeXBlOiAwLFxuICAgIGZvcm1NZXRob2Q6IDAsXG4gICAgZm9ybU5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGZvcm1UYXJnZXQ6IDAsXG4gICAgZnJhbWVCb3JkZXI6IDAsXG4gICAgaGVhZGVyczogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBoaWdoOiAwLFxuICAgIGhyZWY6IDAsXG4gICAgaHJlZkxhbmc6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgaWNvbjogMCxcbiAgICBpZDogMCxcbiAgICBpbnB1dE1vZGU6IDAsXG4gICAgaW50ZWdyaXR5OiAwLFxuICAgIGlzOiAwLFxuICAgIGtleVBhcmFtczogMCxcbiAgICBrZXlUeXBlOiAwLFxuICAgIGtpbmQ6IDAsXG4gICAgbGFiZWw6IDAsXG4gICAgbGFuZzogMCxcbiAgICBsaXN0OiAwLFxuICAgIGxvb3A6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvdzogMCxcbiAgICBtYW5pZmVzdDogMCxcbiAgICBtYXJnaW5IZWlnaHQ6IDAsXG4gICAgbWFyZ2luV2lkdGg6IDAsXG4gICAgbWF4OiAwLFxuICAgIG1heExlbmd0aDogMCxcbiAgICBtZWRpYTogMCxcbiAgICBtZWRpYUdyb3VwOiAwLFxuICAgIG1ldGhvZDogMCxcbiAgICBtaW46IDAsXG4gICAgbWluTGVuZ3RoOiAwLFxuICAgIC8vIENhdXRpb247IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4gICAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC5cbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiAwLFxuICAgIG5vbmNlOiAwLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wdGltdW06IDAsXG4gICAgcGF0dGVybjogMCxcbiAgICBwbGFjZWhvbGRlcjogMCxcbiAgICBwbGF5c0lubGluZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcG9zdGVyOiAwLFxuICAgIHByZWxvYWQ6IDAsXG4gICAgcHJvZmlsZTogMCxcbiAgICByYWRpb0dyb3VwOiAwLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZWZlcnJlclBvbGljeTogMCxcbiAgICByZWw6IDAsXG4gICAgcmVxdWlyZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJldmVyc2VkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByb2xlOiAwLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNhbmRib3g6IDAsXG4gICAgc2NvcGU6IDAsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzY3JvbGxpbmc6IDAsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNoYXBlOiAwLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNpemVzOiAwLFxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IDAsXG4gICAgc3JjOiAwLFxuICAgIHNyY0RvYzogMCxcbiAgICBzcmNMYW5nOiAwLFxuICAgIHNyY1NldDogMCxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc3RlcDogMCxcbiAgICBzdHlsZTogMCxcbiAgICBzdW1tYXJ5OiAwLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIHRhcmdldDogMCxcbiAgICB0aXRsZTogMCxcbiAgICAvLyBTZXR0aW5nIC50eXBlIHRocm93cyBvbiBub24tPGlucHV0PiB0YWdzXG4gICAgdHlwZTogMCxcbiAgICB1c2VNYXA6IDAsXG4gICAgdmFsdWU6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgd21vZGU6IDAsXG4gICAgd3JhcDogMCxcblxuICAgIC8qKlxuICAgICAqIFJERmEgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFib3V0OiAwLFxuICAgIGRhdGF0eXBlOiAwLFxuICAgIGlubGlzdDogMCxcbiAgICBwcmVmaXg6IDAsXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXG4gICAgcHJvcGVydHk6IDAsXG4gICAgcmVzb3VyY2U6IDAsXG4gICAgJ3R5cGVvZic6IDAsXG4gICAgdm9jYWI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIC8vIGF1dG9DYXBpdGFsaXplIGFuZCBhdXRvQ29ycmVjdCBhcmUgc3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yXG4gICAgLy8ga2V5Ym9hcmQgaGludHMuXG4gICAgYXV0b0NhcGl0YWxpemU6IDAsXG4gICAgYXV0b0NvcnJlY3Q6IDAsXG4gICAgLy8gYXV0b1NhdmUgYWxsb3dzIFdlYktpdC9CbGluayB0byBwZXJzaXN0IHZhbHVlcyBvZiBpbnB1dCBmaWVsZHMgb24gcGFnZSByZWxvYWRzXG4gICAgYXV0b1NhdmU6IDAsXG4gICAgLy8gY29sb3IgaXMgZm9yIFNhZmFyaSBtYXNrLWljb24gbGlua1xuICAgIGNvbG9yOiAwLFxuICAgIC8vIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlIGFyZSBmb3JcbiAgICAvLyBNaWNyb2RhdGEgc3VwcG9ydC4gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1Qcm9wOiAwLFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaXRlbVR5cGU6IDAsXG4gICAgLy8gaXRlbUlEIGFuZCBpdGVtUmVmIGFyZSBmb3IgTWljcm9kYXRhIHN1cHBvcnQgYXMgd2VsbCBidXRcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgV0hBVFdHIHNwZWMgZG9jdW1lbnQuIFNlZVxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL21pY3JvZGF0YS5odG1sI21pY3JvZGF0YS1kb20tYXBpXG4gICAgaXRlbUlEOiAwLFxuICAgIGl0ZW1SZWY6IDAsXG4gICAgLy8gcmVzdWx0cyBzaG93IGxvb2tpbmcgZ2xhc3MgaWNvbiBhbmQgcmVjZW50IHNlYXJjaGVzIG9uIGlucHV0XG4gICAgLy8gc2VhcmNoIGZpZWxkcyBpbiBXZWJLaXQvQmxpbmtcbiAgICByZXN1bHRzOiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiBhbiBpZnJhbWVcbiAgICAvLyBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgc2FuZGJveCBhdHRyaWJ1dGUgb24gSUU8MTBcbiAgICBzZWN1cml0eTogMCxcbiAgICAvLyBJRS1vbmx5IGF0dHJpYnV0ZSB0aGF0IGNvbnRyb2xzIGZvY3VzIGJlaGF2aW9yXG4gICAgdW5zZWxlY3RhYmxlOiAwXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTERPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgcmVjb25jaWxlciB0aGF0IHJlcXVpcmVzIGtub3dsZWRnZSBvZlxuICogdGhlIGJyb3dzZXIgY29udGV4dC4gVE9ETzogVGhlc2UgY2FsbGVycyBzaG91bGQgYmUgcmVmYWN0b3JlZCB0byBhdm9pZCB0aGVcbiAqIG5lZWQgZm9yIHRoaXMgaW5qZWN0aW9uLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogUmVhY3RET01JRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzLFxuXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cDogRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERhbmdlciA9IHJlcXVpcmUoJy4vRGFuZ2VyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG5mdW5jdGlvbiBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgbm9kZSkge1xuICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRleHQgY29tcG9uZW50cywgd2hpY2ggcmV0dXJuIFtvcGVuLCBjbG9zZV0gY29tbWVudHNcbiAgLy8gZnJvbSBnZXRIb3N0Tm9kZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZVsxXTtcbiAgfVxuICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dFNpYmxpbmcgOiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHBhcmVudE5vZGUgUGFyZW50IG5vZGUgaW4gd2hpY2ggdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgaW5zZXJ0Q2hpbGRBdCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBXZSByZWx5IGV4Y2x1c2l2ZWx5IG9uIGBpbnNlcnRCZWZvcmUobm9kZSwgbnVsbClgIGluc3RlYWQgb2YgYWxzbyB1c2luZ1xuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiAoVXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsIGJyb3dzZXJzIHNvXG4gIC8vIHdlIGFyZSBjYXJlZnVsIHRvIHVzZSBgbnVsbGAuKVxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xufSk7XG5cbmZ1bmN0aW9uIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBjaGlsZE5vZGVbMF0sIGNoaWxkTm9kZVsxXSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGUpKSB7XG4gICAgdmFyIGNsb3NpbmdDb21tZW50ID0gY2hpbGROb2RlWzFdO1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZVswXTtcbiAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvc2luZ0NvbW1lbnQpO1xuICB9XG4gIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcbn1cblxuZnVuY3Rpb24gbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgb3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCByZWZlcmVuY2VOb2RlKSB7XG4gIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIG5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIHN0YXJ0Tm9kZSwgY2xvc2luZ0NvbW1lbnQpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZS5uZXh0U2libGluZztcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIC8vIFRoZSBjbG9zaW5nIGNvbW1lbnQgaXMgcmVtb3ZlZCBieSBSZWFjdE11bHRpQ2hpbGQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZURlbGltaXRlZFRleHQob3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCBzdHJpbmdUZXh0KSB7XG4gIHZhciBwYXJlbnROb2RlID0gb3BlbmluZ0NvbW1lbnQucGFyZW50Tm9kZTtcbiAgdmFyIG5vZGVBZnRlckNvbW1lbnQgPSBvcGVuaW5nQ29tbWVudC5uZXh0U2libGluZztcbiAgaWYgKG5vZGVBZnRlckNvbW1lbnQgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgLy8gVGhlcmUgYXJlIG5vIHRleHQgbm9kZXMgYmV0d2VlbiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBjb21tZW50czsgaW5zZXJ0XG4gICAgLy8gYSBuZXcgb25lIGlmIHN0cmluZ1RleHQgaXNuJ3QgZW1wdHkuXG4gICAgaWYgKHN0cmluZ1RleHQpIHtcbiAgICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nVGV4dCksIG5vZGVBZnRlckNvbW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGZpcnN0IG5vZGUgYWZ0ZXIgdGhlIG9wZW5pbmcgY29tbWVudCwgYW5kXG4gICAgICAvLyByZW1vdmUgYWxsIGZvbGxvd2luZyBub2RlcyB1cCB1bnRpbCB0aGUgY2xvc2luZyBjb21tZW50LlxuICAgICAgc2V0VGV4dENvbnRlbnQobm9kZUFmdGVyQ29tbWVudCwgc3RyaW5nVGV4dCk7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG5vZGVBZnRlckNvbW1lbnQsIGNsb3NpbmdDb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvcGVuaW5nQ29tbWVudCkuX2RlYnVnSUQsXG4gICAgICB0eXBlOiAncmVwbGFjZSB0ZXh0JyxcbiAgICAgIHBheWxvYWQ6IHN0cmluZ1RleHRcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgaWYgKHByZXZJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IHByZXZJbnN0YW5jZS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlcGxhY2Ugd2l0aCcsXG4gICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG1hcmt1cC5ub2RlKTtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgaW5zdGFuY2VJRDogbmV4dEluc3RhbmNlLl9kZWJ1Z0lELFxuICAgICAgICAgIHR5cGU6ICdtb3VudCcsXG4gICAgICAgICAgcGF5bG9hZDogbWFya3VwLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCxcblxuICByZXBsYWNlRGVsaW1pdGVkVGV4dDogcmVwbGFjZURlbGltaXRlZFRleHQsXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuIFRoZVxuICAgKiB1cGRhdGUgY29uZmlndXJhdGlvbnMgYXJlIGVhY2ggZXhwZWN0ZWQgdG8gaGF2ZSBhIGBwYXJlbnROb2RlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NVcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50Tm9kZSwgdXBkYXRlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50Tm9kZURlYnVnSUQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShwYXJlbnROb2RlKS5fZGVidWdJRDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHVwZGF0ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlICdJTlNFUlRfTUFSS1VQJzpcbiAgICAgICAgICBpbnNlcnRMYXp5VHJlZUNoaWxkQXQocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ2luc2VydCBjaGlsZCcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHsgdG9JbmRleDogdXBkYXRlLnRvSW5kZXgsIGNvbnRlbnQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKCkgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNT1ZFX0VYSVNUSU5HJzpcbiAgICAgICAgICBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlLCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdtb3ZlIGNoaWxkJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXgsIHRvSW5kZXg6IHVwZGF0ZS50b0luZGV4IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU0VUX01BUktVUCc6XG4gICAgICAgICAgc2V0SW5uZXJIVE1MKHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVwbGFjZSBjaGlsZHJlbicsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVEVYVF9DT05URU5UJzpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ3JlcGxhY2UgdGV4dCcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5jb250ZW50LnRvU3RyaW5nKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUkVNT1ZFX05PREUnOlxuICAgICAgICAgIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIHVwZGF0ZS5mcm9tTm9kZSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ3JlbW92ZSBjaGlsZCcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHsgZnJvbUluZGV4OiB1cGRhdGUuZnJvbUluZGV4IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqXG4gKiBJbiBJRSAoOC0xMSkgYW5kIEVkZ2UsIGFwcGVuZGluZyBub2RlcyB3aXRoIG5vIGNoaWxkcmVuIGlzIGRyYW1hdGljYWxseVxuICogZmFzdGVyIHRoYW4gYXBwZW5kaW5nIGEgZnVsbCBzdWJ0cmVlLCBzbyB3ZSBlc3NlbnRpYWxseSBxdWV1ZSB1cCB0aGVcbiAqIC5hcHBlbmRDaGlsZCBjYWxscyBoZXJlIGFuZCBhcHBseSB0aGVtIHNvIGVhY2ggbm9kZSBpcyBhZGRlZCB0byBpdHMgcGFyZW50XG4gKiBiZWZvcmUgYW55IGNoaWxkcmVuIGFyZSBhZGRlZC5cbiAqXG4gKiBJbiBvdGhlciBicm93c2VycywgZG9pbmcgc28gaXMgc2xvd2VyIG9yIG5ldXRyYWwgY29tcGFyZWQgdG8gdGhlIG90aGVyIG9yZGVyXG4gKiAoaW4gRmlyZWZveCwgdHdpY2UgYXMgc2xvdykgc28gd2Ugb25seSBkbyB0aGlzIGludmVyc2lvbiBpbiBJRS5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NwaWN5ai9pbm5lcmh0bWwtdnMtY3JlYXRlZWxlbWVudC12cy1jbG9uZW5vZGUuXG4gKi9cbnZhciBlbmFibGVMYXp5ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZycgJiYgL1xcYkVkZ2VcXC9cXGQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmZ1bmN0aW9uIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKSB7XG4gIGlmICghZW5hYmxlTGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbm9kZSA9IHRyZWUubm9kZTtcbiAgdmFyIGNoaWxkcmVuID0gdHJlZS5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluc2VydFRyZWVCZWZvcmUobm9kZSwgY2hpbGRyZW5baV0sIG51bGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0cmVlLmh0bWwgIT0gbnVsbCkge1xuICAgIHNldElubmVySFRNTChub2RlLCB0cmVlLmh0bWwpO1xuICB9IGVsc2UgaWYgKHRyZWUudGV4dCAhPSBudWxsKSB7XG4gICAgc2V0VGV4dENvbnRlbnQobm9kZSwgdHJlZS50ZXh0KTtcbiAgfVxufVxuXG52YXIgaW5zZXJ0VHJlZUJlZm9yZSA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIHRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlbid0IGFjdHVhbGx5IHBhcnQgb2YgdGhlIERPTSBhZnRlciBpbnNlcnRpb24gc29cbiAgLy8gYXBwZW5kaW5nIGNoaWxkcmVuIHdvbid0IHVwZGF0ZSB0aGUgRE9NLiBXZSBuZWVkIHRvIGVuc3VyZSB0aGUgZnJhZ21lbnRcbiAgLy8gaXMgcHJvcGVybHkgcG9wdWxhdGVkIGZpcnN0LCBicmVha2luZyBvdXQgb2Ygb3VyIGxhenkgYXBwcm9hY2ggZm9yIGp1c3RcbiAgLy8gdGhpcyBsZXZlbC4gQWxzbywgc29tZSA8b2JqZWN0PiBwbHVnaW5zIChsaWtlIEZsYXNoIFBsYXllcikgd2lsbCByZWFkXG4gIC8vIDxwYXJhbT4gbm9kZXMgaW1tZWRpYXRlbHkgdXBvbiBpbnNlcnRpb24gaW50byB0aGUgRE9NLCBzbyA8b2JqZWN0PlxuICAvLyBtdXN0IGFsc28gYmUgcG9wdWxhdGVkIHByaW9yIHRvIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gIGlmICh0cmVlLm5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSB8fCB0cmVlLm5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFICYmIHRyZWUubm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0JyAmJiAodHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PSBudWxsIHx8IHRyZWUubm9kZS5uYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkpIHtcbiAgICBpbnNlcnRUcmVlQ2hpbGRyZW4odHJlZSk7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodHJlZS5ub2RlLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZE5vZGUsIG5ld1RyZWUpIHtcbiAgb2xkTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdUcmVlLm5vZGUsIG9sZE5vZGUpO1xuICBpbnNlcnRUcmVlQ2hpbGRyZW4obmV3VHJlZSk7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlQ2hpbGQocGFyZW50VHJlZSwgY2hpbGRUcmVlKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgcGFyZW50VHJlZS5jaGlsZHJlbi5wdXNoKGNoaWxkVHJlZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50VHJlZS5ub2RlLmFwcGVuZENoaWxkKGNoaWxkVHJlZS5ub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZUhUTUwodHJlZSwgaHRtbCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUuaHRtbCA9IGh0bWw7XG4gIH0gZWxzZSB7XG4gICAgc2V0SW5uZXJIVE1MKHRyZWUubm9kZSwgaHRtbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVldWVUZXh0KHRyZWUsIHRleHQpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICB0cmVlLnRleHQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIHNldFRleHRDb250ZW50KHRyZWUubm9kZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLm5vZGUubm9kZU5hbWU7XG59XG5cbmZ1bmN0aW9uIERPTUxhenlUcmVlKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBub2RlLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBodG1sOiBudWxsLFxuICAgIHRleHQ6IG51bGwsXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gIH07XG59XG5cbkRPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUgPSBpbnNlcnRUcmVlQmVmb3JlO1xuRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUgPSByZXBsYWNlQ2hpbGRXaXRoVHJlZTtcbkRPTUxhenlUcmVlLnF1ZXVlQ2hpbGQgPSBxdWV1ZUNoaWxkO1xuRE9NTGF6eVRyZWUucXVldWVIVE1MID0gcXVldWVIVE1MO1xuRE9NTGF6eVRyZWUucXVldWVUZXh0ID0gcXVldWVUZXh0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUxhenlUcmVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9ET01MYXp5VHJlZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01OYW1lc3BhY2VzID0ge1xuICBodG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsXG4gIG1hdGhtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnLFxuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zydcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NTmFtZXNwYWNlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvRE9NTmFtZXNwYWNlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xuXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15bIFxcclxcblxcdFxcZl0vO1xudmFyIE5PTlZJU0lCTEVfVEVTVCA9IC88KCEtLXxsaW5rfG5vc2NyaXB0fG1ldGF8c2NyaXB0fHN0eWxlKVsgXFxyXFxuXFx0XFxmXFwvPl0vO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgLy8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgLy8gdGhlIHRhcmdldCBub2RlXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKHN2Z05vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0ZXN0RWxlbWVudCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0SW5uZXJIVE1MO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9zZXRJbm5lckhUTUwuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRleHRDb250ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9zZXRUZXh0Q29udGVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEJhc2VkIG9uIHRoZSBlc2NhcGUtaHRtbCBsaWJyYXJ5LCB3aGljaCBpcyB1c2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBiZWxvdzpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0IChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAqIENvcHlyaWdodCAoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAqIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgPSByZXF1aXJlKCdmYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgRGFuZ2VyID0ge1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIG5vZGUgd2l0aCBhIHN0cmluZyBvZiBtYXJrdXAgYXQgaXRzIGN1cnJlbnQgcG9zaXRpb24gd2l0aGluIGl0c1xuICAgKiBwYXJlbnQuIFRoZSBtYXJrdXAgbXVzdCByZW5kZXIgaW50byBhIHNpbmdsZSByb290IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb2xkQ2hpbGQgQ2hpbGQgbm9kZSB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byByZW5kZXIgaW4gcGxhY2Ugb2YgdGhlIGNoaWxkIG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwKSB7XG4gICAgIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhIHdvcmtlciB0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlIGdsb2JhbGx5IGJlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBfcHJvZEludmFyaWFudCgnNTYnKSA6IHZvaWQgMDtcbiAgICAhbWFya3VwID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLicpIDogX3Byb2RJbnZhcmlhbnQoJzU3JykgOiB2b2lkIDA7XG4gICAgIShvbGRDaGlsZC5ub2RlTmFtZSAhPT0gJ0hUTUwnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVwbGFjZSBtYXJrdXAgb2YgdGhlIDxodG1sPiBub2RlLiBUaGlzIGlzIGJlY2F1c2UgYnJvd3NlciBxdWlya3MgbWFrZSB0aGlzIHVucmVsaWFibGUgYW5kL29yIHNsb3cuIElmIHlvdSB3YW50IHRvIHJlbmRlciB0byB0aGUgcm9vdCB5b3UgbXVzdCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkuJykgOiBfcHJvZEludmFyaWFudCgnNTgnKSA6IHZvaWQgMDtcblxuICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIG5ld0NoaWxkID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgZW1wdHlGdW5jdGlvbilbMF07XG4gICAgICBvbGRDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZShvbGRDaGlsZCwgbWFya3VwKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYW5nZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0Rhbmdlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJy4vY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZSgnLi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byByZW5kZXIgYWxsIG1hcmt1cC5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBQYXR0ZXJuIHVzZWQgYnkgYGdldE5vZGVOYW1lYC5cbiAqL1xudmFyIG5vZGVOYW1lUGF0dGVybiA9IC9eXFxzKjwoXFx3KykvO1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBgbm9kZU5hbWVgIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHZhciBub2RlTmFtZU1hdGNoID0gbWFya3VwLm1hdGNoKG5vZGVOYW1lUGF0dGVybik7XG4gIHJldHVybiBub2RlTmFtZU1hdGNoICYmIG5vZGVOYW1lTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5vZGVzIHJlbmRlcmVkIGZyb20gdGhlIHN1cHBsaWVkIG1hcmt1cC4gVGhlXG4gKiBvcHRpb25hbGx5IHN1cHBsaWVkIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBvbmNlIGZvciBlYWNoXG4gKiA8c2NyaXB0PiBlbGVtZW50IHRoYXQgaXMgcmVuZGVyZWQuIElmIG5vIGBoYW5kbGVTY3JpcHRgIGZ1bmN0aW9uIGlzIHN1cHBsaWVkLFxuICogYW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiBhbnkgPHNjcmlwdD4gZWxlbWVudHMgYXJlIHJlbmRlcmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgQSBzdHJpbmcgb2YgdmFsaWQgSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gaGFuZGxlU2NyaXB0IEludm9rZWQgb25jZSBmb3IgZWFjaCByZW5kZXJlZCA8c2NyaXB0Pi5cbiAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnR8RE9NVGV4dE5vZGU+fSBBbiBhcnJheSBvZiByZW5kZXJlZCBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgaGFuZGxlU2NyaXB0KSB7XG4gIHZhciBub2RlID0gZHVtbXlOb2RlO1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwIGR1bW15IG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAhaGFuZGxlU2NyaXB0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGNyZWF0ZUFycmF5RnJvbU1peGVkKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKTtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gYXJyYXlzLlxuICpcbiAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGNhbGxlciBrbm93cyB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgdHlwZS4gRm9yIGxlc3NcbiAqIHdlbGwgZGVmaW5lZCBpbnB1dHMgdXNlIGNyZWF0ZUFycmF5RnJvbU1peGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufGZpbGVsaXN0fSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICAvLyBTb21lIGJyb3dzZXJzIGJ1aWx0aW4gb2JqZWN0cyBjYW4gcmVwb3J0IHR5cGVvZiAnZnVuY3Rpb24nIChlLmcuIE5vZGVMaXN0XG4gIC8vIGluIG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkpLlxuICAhKCFBcnJheS5pc0FycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgbmVlZHMgYSBsZW5ndGggcHJvcGVydHknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgIShsZW5ndGggPT09IDAgfHwgbGVuZ3RoIC0gMSBpbiBvYmopID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBzaG91bGQgaGF2ZSBrZXlzIGZvciBpbmRpY2VzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEodHlwZW9mIG9iai5jYWxsZWUgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBjYW5cXCd0IGJlIGBhcmd1bWVudHNgLiBVc2UgcmVzdCBwYXJhbXMgJyArICcoZnVuY3Rpb24oLi4uYXJncykge30pIG9yIEFycmF5LmZyb20oKSBpbnN0ZWFkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAvLyBPbGQgSUUgZG9lc24ndCBnaXZlIGNvbGxlY3Rpb25zIGFjY2VzcyB0byBoYXNPd25Qcm9wZXJ0eS4gQXNzdW1lIGlucHV0c1xuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcbiAgLy8gZmFsbGJhY2suXG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIGtleSBieSBrZXkuIFRoaXMgYXNzdW1lcyBhbGwga2V5cyBoYXZlIGEgdmFsdWUsXG4gIC8vIHNvIHdpbGwgbm90IHByZXNlcnZlIHNwYXJzZWx5IHBvcHVsYXRlZCBpbnB1dHMuXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKSB7XG4gICAgcmV0W2lpXSA9IG9ialtpaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGEgaGV1cmlzdGljIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBcImFycmF5LWxpa2VcIi5cbiAqXG4gKiAgIEEgbW9uayBhc2tlZCBKb3NodSwgYSBaZW4gbWFzdGVyLCBcIkhhcyBhIGRvZyBCdWRkaGEgbmF0dXJlP1wiXG4gKiAgIEpvc2h1IHJlcGxpZWQ6IFwiTXUuXCJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaXRzIGFyZ3VtZW50IGhhcyBcImFycmF5IG5hdHVyZVwiOiBpdCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhY3R1YWwgYXJyYXksIGFuIGBhcmd1bWVudHMnIG9iamVjdCwgb3IgYW5cbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxuICpcbiAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBvdGhlciBhcnJheS1saWtlIG9iamVjdHMgbGlrZSBGaWxlbGlzdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzQXJyYXlOYXR1cmUob2JqKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbm90IG51bGwvZmFsc2VcbiAgICAhIW9iaiAmJiAoXG4gICAgLy8gYXJyYXlzIGFyZSBvYmplY3RzLCBOb2RlTGlzdHMgYXJlIGZ1bmN0aW9ucyBpbiBTYWZhcmlcbiAgICB0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAvLyBxdWFja3MgbGlrZSBhbiBhcnJheVxuICAgICdsZW5ndGgnIGluIG9iaiAmJlxuICAgIC8vIG5vdCB3aW5kb3dcbiAgICAhKCdzZXRJbnRlcnZhbCcgaW4gb2JqKSAmJlxuICAgIC8vIG5vIERPTSBub2RlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFuIGFycmF5LWxpa2VcbiAgICAvLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcbiAgICB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9ICdudW1iZXInICYmIChcbiAgICAvLyBhIHJlYWwgYXJyYXlcbiAgICBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAvLyBhcmd1bWVudHNcbiAgICAnY2FsbGVlJyBpbiBvYmogfHxcbiAgICAvLyBIVE1MQ29sbGVjdGlvbi9Ob2RlTGlzdFxuICAgICdpdGVtJyBpbiBvYmopXG4gICk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBhbHJlYWR5IGFuIGFycmF5LlxuICpcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxuICpcbiAqICAgdmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIHRha2VzT25lT3JNb3JlVGhpbmdzKHRoaW5ncykge1xuICogICAgIHRoaW5ncyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKHRoaW5ncyk7XG4gKiAgICAgLi4uXG4gKiAgIH1cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QsIGxpa2UgYGFyZ3VtZW50c2AsIGludG8gYW4gYXJyYXlcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NaXhlZChvYmopIHtcbiAgaWYgKCFoYXNBcnJheU5hdHVyZShvYmopKSB7XG4gICAgcmV0dXJuIFtvYmpdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9BcnJheShvYmopO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCAqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIGRldGVjdCB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5LlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFNvbWUgYnJvd3NlcnMgY2Fubm90IHVzZSBgaW5uZXJIVE1MYCB0byByZW5kZXIgY2VydGFpbiBlbGVtZW50cyBzdGFuZGFsb25lLFxuICogc28gd2Ugd3JhcCB0aGVtLCByZW5kZXIgdGhlIHdyYXBwZWQgbm9kZXMsIHRoZW4gZXh0cmFjdCB0aGUgZGVzaXJlZCBub2RlLlxuICpcbiAqIEluIElFOCwgY2VydGFpbiBlbGVtZW50cyBjYW5ub3QgcmVuZGVyIGFsb25lLCBzbyB3cmFwIGFsbCBlbGVtZW50cyAoJyonKS5cbiAqL1xuXG52YXIgc2hvdWxkV3JhcCA9IHt9O1xuXG52YXIgc2VsZWN0V3JhcCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cInRydWVcIj4nLCAnPC9zZWxlY3Q+J107XG52YXIgdGFibGVXcmFwID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbnZhciBzdmdXcmFwID0gWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nLCAnPC9zdmc+J107XG5cbnZhciBtYXJrdXBXcmFwID0ge1xuICAnKic6IFsxLCAnPzxkaXY+JywgJzwvZGl2PiddLFxuXG4gICdhcmVhJzogWzEsICc8bWFwPicsICc8L21hcD4nXSxcbiAgJ2NvbCc6IFsyLCAnPHRhYmxlPjx0Ym9keT48L3Rib2R5Pjxjb2xncm91cD4nLCAnPC9jb2xncm91cD48L3RhYmxlPiddLFxuICAnbGVnZW5kJzogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gICdwYXJhbSc6IFsxLCAnPG9iamVjdD4nLCAnPC9vYmplY3Q+J10sXG4gICd0cic6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxuXG4gICdvcHRncm91cCc6IHNlbGVjdFdyYXAsXG4gICdvcHRpb24nOiBzZWxlY3RXcmFwLFxuXG4gICdjYXB0aW9uJzogdGFibGVXcmFwLFxuICAnY29sZ3JvdXAnOiB0YWJsZVdyYXAsXG4gICd0Ym9keSc6IHRhYmxlV3JhcCxcbiAgJ3Rmb290JzogdGFibGVXcmFwLFxuICAndGhlYWQnOiB0YWJsZVdyYXAsXG5cbiAgJ3RkJzogdHJXcmFwLFxuICAndGgnOiB0cldyYXBcbn07XG5cbi8vIEluaXRpYWxpemUgdGhlIFNWRyBlbGVtZW50cyBzaW5jZSB3ZSBrbm93IHRoZXknbGwgYWx3YXlzIG5lZWQgdG8gYmUgd3JhcHBlZFxuLy8gY29uc2lzdGVudGx5LiBJZiB0aGV5IGFyZSBjcmVhdGVkIGluc2lkZSBhIDxkaXY+IHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpblxuLy8gdGhlIHdyb25nIG5hbWVzcGFjZSAoYW5kIHdpbGwgbm90IGRpc3BsYXkpLlxudmFyIHN2Z0VsZW1lbnRzID0gWydjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2cnLCAnaW1hZ2UnLCAnbGluZScsICdsaW5lYXJHcmFkaWVudCcsICdtYXNrJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICd0ZXh0JywgJ3RzcGFuJ107XG5zdmdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlTmFtZSkge1xuICBtYXJrdXBXcmFwW25vZGVOYW1lXSA9IHN2Z1dyYXA7XG4gIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gdHJ1ZTtcbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxuICpcbiAqIE5PVEU6IFRoaXMgbGF6aWx5IGRldGVjdHMgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgTG93ZXJjYXNlIGBub2RlTmFtZWAuXG4gKiBAcmV0dXJuIHs/YXJyYXl9IE1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24sIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpIHtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01hcmt1cCB3cmFwcGluZyBub2RlIG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgaWYgKCFtYXJrdXBXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIG5vZGVOYW1lID0gJyonO1xuICB9XG4gIGlmICghc2hvdWxkV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICcqJykge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8bGluayAvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPCcgKyBub2RlTmFtZSArICc+PC8nICsgbm9kZU5hbWUgKyAnPic7XG4gICAgfVxuICAgIHNob3VsZFdyYXBbbm9kZU5hbWVdID0gIWR1bW15Tm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBzaG91bGRXcmFwW25vZGVOYW1lXSA/IG1hcmt1cFdyYXBbbm9kZU5hbWVdIDogbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdXBXcmFwO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbi8qKlxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuXG4gKi9cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudEluc3QsIHVwZGF0ZXMpIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHBhcmVudEluc3QpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyhub2RlLCB1cGRhdGVzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlET3BlcmF0aW9ucztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHJlcXVpcmUoJy4vQXV0b0ZvY3VzVXRpbHMnKTtcbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NSW5wdXQgPSByZXF1aXJlKCcuL1JlYWN0RE9NSW5wdXQnKTtcbnZhciBSZWFjdERPTU9wdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01PcHRpb24nKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3QnKTtcbnZhciBSZWFjdERPTVRleHRhcmVhID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRhcmVhJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcbnZhciBkZWxldGVMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGdldE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZTtcbnZhciBsaXN0ZW5UbyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5saXN0ZW5UbztcbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG5cbi8vIEZvciBxdWlja2x5IG1hdGNoaW5nIGNoaWxkcmVuIHR5cGUsIHRvIHRlc3QgaWYgY2FuIGJlIHRyZWF0ZWQgYXMgY29udGVudC5cbnZhciBDT05URU5UX1RZUEVTID0geyAnc3RyaW5nJzogdHJ1ZSwgJ251bWJlcic6IHRydWUgfTtcblxudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MID0gJ19faHRtbCc7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogbnVsbCxcbiAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiBudWxsXG59O1xuXG4vLyBOb2RlIHR5cGUgZm9yIGRvY3VtZW50IGZyYWdtZW50cyAoTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKS5cbnZhciBET0NfRlJBR01FTlRfVFlQRSA9IDExO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oaW50ZXJuYWxJbnN0YW5jZSkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHZhciBvd25lciA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lciB8fCBudWxsO1xuICAgIGlmIChvd25lcikge1xuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJyBUaGlzIERPTSBub2RlIHdhcyByZW5kZXJlZCBieSBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGZyaWVuZGx5U3RyaW5naWZ5KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gJ1snICsgb2JqLm1hcChmcmllbmRseVN0cmluZ2lmeSkuam9pbignLCAnKSArICddJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGtleUVzY2FwZWQgPSAvXlthLXokX11bXFx3JF9dKiQvaS50ZXN0KGtleSkgPyBrZXkgOiBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgICAgICAgIHBhaXJzLnB1c2goa2V5RXNjYXBlZCArICc6ICcgKyBmcmllbmRseVN0cmluZ2lmeShvYmpba2V5XSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3snICsgcGFpcnMuam9pbignLCAnKSArICd9JztcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICdbZnVuY3Rpb24gb2JqZWN0XSc7XG4gIH1cbiAgLy8gRGlmZmVycyBmcm9tIEpTT04uc3RyaW5naWZ5IGluIHRoYXQgdW5kZWZpbmVkIGJlY2F1c2UgdW5kZWZpbmVkIGFuZCB0aGF0XG4gIC8vIGluZiBhbmQgbmFuIGRvbid0IGJlY29tZSBudWxsXG4gIHJldHVybiBTdHJpbmcob2JqKTtcbn1cblxudmFyIHN0eWxlTXV0YXRpb25XYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZShzdHlsZTEsIHN0eWxlMiwgY29tcG9uZW50KSB7XG4gIGlmIChzdHlsZTEgPT0gbnVsbCB8fCBzdHlsZTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hhbGxvd0VxdWFsKHN0eWxlMSwgc3R5bGUyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50Ll90YWc7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXIpIHtcbiAgICBvd25lck5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gIH1cblxuICB2YXIgaGFzaCA9IG93bmVyTmFtZSArICd8JyArIGNvbXBvbmVudE5hbWU7XG5cbiAgaWYgKHN0eWxlTXV0YXRpb25XYXJuaW5nLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3R5bGVNdXRhdGlvbldhcm5pbmdbaGFzaF0gPSB0cnVlO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYCVzYCB3YXMgcGFzc2VkIGEgc3R5bGUgb2JqZWN0IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBtdXRhdGVkLiAnICsgJ011dGF0aW5nIGBzdHlsZWAgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgY2xvbmluZyBpdCBiZWZvcmVoYW5kLiBDaGVjayAnICsgJ3RoZSBgcmVuZGVyYCAlcy4gUHJldmlvdXMgc3R5bGU6ICVzLiBNdXRhdGVkIHN0eWxlOiAlcy4nLCBjb21wb25lbnROYW1lLCBvd25lciA/ICdvZiBgJyArIG93bmVyTmFtZSArICdgJyA6ICd1c2luZyA8JyArIGNvbXBvbmVudE5hbWUgKyAnPicsIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMSksIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMikpIDogdm9pZCAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1tjb21wb25lbnQuX3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IF9wcm9kSW52YXJpYW50KCcxMzcnLCBjb21wb25lbnQuX3RhZywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgPyAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICcgKyBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLicgOiAnJykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogX3Byb2RJbnZhcmlhbnQoJzYwJykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IF9wcm9kSW52YXJpYW50KCc2MScpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuaW5uZXJIVE1MID09IG51bGwsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5vbkZvY3VzSW4gPT0gbnVsbCAmJiBwcm9wcy5vbkZvY3VzT3V0ID09IG51bGwsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpIDogdm9pZCAwO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogX3Byb2RJbnZhcmlhbnQoJzYyJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlUHV0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIsIHRyYW5zYWN0aW9uKSB7XG4gIGlmICh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJRTggaGFzIG5vIEFQSSBmb3IgZXZlbnQgY2FwdHVyaW5nIGFuZCB0aGUgYG9uU2Nyb2xsYCBldmVudCBkb2Vzbid0XG4gICAgLy8gYnViYmxlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHJlZ2lzdHJhdGlvbk5hbWUgIT09ICdvblNjcm9sbCcgfHwgaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSksICdUaGlzIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgdGhlIGBvblNjcm9sbGAgZXZlbnQnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgY29udGFpbmVySW5mbyA9IGluc3QuX2hvc3RDb250YWluZXJJbmZvO1xuICB2YXIgaXNEb2N1bWVudEZyYWdtZW50ID0gY29udGFpbmVySW5mby5fbm9kZSAmJiBjb250YWluZXJJbmZvLl9ub2RlLm5vZGVUeXBlID09PSBET0NfRlJBR01FTlRfVFlQRTtcbiAgdmFyIGRvYyA9IGlzRG9jdW1lbnRGcmFnbWVudCA/IGNvbnRhaW5lckluZm8uX25vZGUgOiBjb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xuICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHB1dExpc3RlbmVyLCB7XG4gICAgaW5zdDogaW5zdCxcbiAgICByZWdpc3RyYXRpb25OYW1lOiByZWdpc3RyYXRpb25OYW1lLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9KTtcbn1cblxuZnVuY3Rpb24gcHV0TGlzdGVuZXIoKSB7XG4gIHZhciBsaXN0ZW5lclRvUHV0ID0gdGhpcztcbiAgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIobGlzdGVuZXJUb1B1dC5pbnN0LCBsaXN0ZW5lclRvUHV0LnJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyVG9QdXQubGlzdGVuZXIpO1xufVxuXG5mdW5jdGlvbiBpbnB1dFBvc3RNb3VudCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICBSZWFjdERPTUlucHV0LnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIHRleHRhcmVhUG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NVGV4dGFyZWEucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxuZnVuY3Rpb24gb3B0aW9uUG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NT3B0aW9uLnBvc3RNb3VudFdyYXBwZXIoaW5zdCk7XG59XG5cbnZhciBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldiA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgdmFyIGhhc0V4aXN0aW5nQ29udGVudCA9IHRoaXMuX2NvbnRlbnREZWJ1Z0lEICE9IG51bGw7XG4gICAgdmFyIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIC8vIFRoaXMgSUQgcmVwcmVzZW50cyB0aGUgaW5saW5lZCBjaGlsZCB0aGF0IGhhcyBubyBiYWNraW5nIGluc3RhbmNlOlxuICAgIHZhciBjb250ZW50RGVidWdJRCA9IC1kZWJ1Z0lEO1xuXG4gICAgaWYgKGNvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgaWYgKGhhc0V4aXN0aW5nQ29udGVudCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29tcG9uZW50KHRoaXMuX2NvbnRlbnREZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnRlbnREZWJ1Z0lEID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgU3RyaW5nKGNvbnRlbnQpLCB0aGlzLCB0aGlzLl9hbmNlc3RvckluZm8pO1xuICAgIHRoaXMuX2NvbnRlbnREZWJ1Z0lEID0gY29udGVudERlYnVnSUQ7XG4gICAgaWYgKGhhc0V4aXN0aW5nQ29udGVudCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVXBkYXRlQ29tcG9uZW50KGNvbnRlbnREZWJ1Z0lELCBjb250ZW50KTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChjb250ZW50RGVidWdJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZU1vdW50Q29tcG9uZW50KGNvbnRlbnREZWJ1Z0lELCBjb250ZW50LCBkZWJ1Z0lEKTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIFtjb250ZW50RGVidWdJRF0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnRzTG9jYWwoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgLy8gSWYgYSBjb21wb25lbnQgcmVuZGVycyB0byBudWxsIG9yIGlmIGFub3RoZXIgY29tcG9uZW50IGZhdGFscyBhbmQgY2F1c2VzXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZSB0byBiZSBjb3JydXB0ZWQsIGBub2RlYCBoZXJlIGNhbiBiZSBudWxsLlxuICAhaW5zdC5fcm9vdE5vZGVJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG1vdW50ZWQgdG8gdHJhcCBldmVudHMnKSA6IF9wcm9kSW52YXJpYW50KCc2MycpIDogdm9pZCAwO1xuICB2YXIgbm9kZSA9IGdldE5vZGUoaW5zdCk7XG4gICFub2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXBCdWJibGVkRXZlbnQoLi4uKTogUmVxdWlyZXMgbm9kZSB0byBiZSByZW5kZXJlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc2NCcpIDogdm9pZCAwO1xuXG4gIHN3aXRjaCAoaW5zdC5fdGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcblxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycy5wdXNoKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgbm9kZSksIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFJlc2V0JywgJ3Jlc2V0Jywgbm9kZSksIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BTdWJtaXQnLCAnc3VibWl0Jywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIoKSB7XG4gIFJlYWN0RE9NU2VsZWN0LnBvc3RVcGRhdGVXcmFwcGVyKHRoaXMpO1xufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgJ2FyZWEnOiB0cnVlLFxuICAnYmFzZSc6IHRydWUsXG4gICdicic6IHRydWUsXG4gICdjb2wnOiB0cnVlLFxuICAnZW1iZWQnOiB0cnVlLFxuICAnaHInOiB0cnVlLFxuICAnaW1nJzogdHJ1ZSxcbiAgJ2lucHV0JzogdHJ1ZSxcbiAgJ2tleWdlbic6IHRydWUsXG4gICdsaW5rJzogdHJ1ZSxcbiAgJ21ldGEnOiB0cnVlLFxuICAncGFyYW0nOiB0cnVlLFxuICAnc291cmNlJzogdHJ1ZSxcbiAgJ3RyYWNrJzogdHJ1ZSxcbiAgJ3dicic6IHRydWVcbn07XG5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gICdtZW51aXRlbSc6IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRUYWdDYWNoZSwgdGFnKSkge1xuICAgICFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdGFnOiAlcycsIHRhZykgOiBfcHJvZEludmFyaWFudCgnNjUnLCB0YWcpIDogdm9pZCAwO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIHJldHVybiB0YWdOYW1lLmluZGV4T2YoJy0nKSA+PSAwIHx8IHByb3BzLmlzICE9IG51bGw7XG59XG5cbnZhciBnbG9iYWxJZENvdW50ZXIgPSAxO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KGVsZW1lbnQpIHtcbiAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZTtcbiAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcbiAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcbiAgdGhpcy5fZmxhZ3MgPSAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IG51bGw7XG4gICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBudWxsKTtcbiAgfVxufVxuXG5SZWFjdERPTUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdSZWFjdERPTUNvbXBvbmVudCc7XG5cblJlYWN0RE9NQ29tcG9uZW50Lk1peGluID0ge1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P1JlYWN0RE9NQ29tcG9uZW50fSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IGluZm8gYWJvdXQgdGhlIGhvc3QgY29udGFpbmVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IGdsb2JhbElkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnbGluayc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgdGhpcy5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgICAgIGxpc3RlbmVyczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBSZWFjdERPTU9wdGlvbi5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgUmVhY3RET01TZWxlY3QubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBob3N0UGFyZW50KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBwcm9wcyk7XG5cbiAgICAvLyBXZSBjcmVhdGUgdGFncyBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZWlyIHBhcmVudCBjb250YWluZXIsIGV4Y2VwdCBIVE1MXG4gICAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuICAgIHZhciBuYW1lc3BhY2VVUkk7XG4gICAgdmFyIHBhcmVudFRhZztcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBob3N0UGFyZW50Ll9uYW1lc3BhY2VVUkk7XG4gICAgICBwYXJlbnRUYWcgPSBob3N0UGFyZW50Ll90YWc7XG4gICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mby5fdGFnKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBob3N0Q29udGFpbmVySW5mby5fbmFtZXNwYWNlVVJJO1xuICAgICAgcGFyZW50VGFnID0gaG9zdENvbnRhaW5lckluZm8uX3RhZztcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PSBudWxsIHx8IG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5zdmcgJiYgcGFyZW50VGFnID09PSAnZm9yZWlnbm9iamVjdCcpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuaHRtbDtcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICBpZiAodGhpcy5fdGFnID09PSAnc3ZnJykge1xuICAgICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLnN2ZztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fdGFnID09PSAnbWF0aCcpIHtcbiAgICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5tYXRobWw7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX25hbWVzcGFjZVVSSSA9IG5hbWVzcGFjZVVSSTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50SW5mbztcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RhZykge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxuICAgICAgICAvLyBjb21wb25lbnQgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyh0aGlzLl90YWcsIG51bGwsIHRoaXMsIHBhcmVudEluZm8pO1xuICAgICAgfVxuICAgICAgdGhpcy5fYW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SW5mbywgdGhpcy5fdGFnLCB0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgbW91bnRJbWFnZTtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBlbDtcbiAgICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5fdGFnID09PSAnc2NyaXB0Jykge1xuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gJzwnICsgdHlwZSArICc+PC8nICsgdHlwZSArICc+JztcbiAgICAgICAgICBlbCA9IGRpdi5yZW1vdmVDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHMuaXMpIHtcbiAgICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlLCBwcm9wcy5pcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2VwYXJhdGUgZWxzZSBicmFuY2ggaW5zdGVhZCBvZiB1c2luZyBgcHJvcHMuaXMgfHwgdW5kZWZpbmVkYCBhYm92ZSBiZWN1YXNlIG9mIGEgRmlyZWZveCBidWcuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgfVxuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBlbCk7XG4gICAgICB0aGlzLl9mbGFncyB8PSBGbGFncy5oYXNDYWNoZWRDaGlsZE5vZGVzO1xuICAgICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JSb290KGVsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobnVsbCwgcHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKGVsKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUluaXRpYWxDaGlsZHJlbih0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGxhenlUcmVlKTtcbiAgICAgIG1vdW50SW1hZ2UgPSBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZ09wZW4gPSB0aGlzLl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBwcm9wcyk7XG4gICAgICB2YXIgdGFnQ29udGVudCA9IHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGFnQ29udGVudCAmJiBvbWl0dGVkQ2xvc2VUYWdzW3RoaXMuX3RhZ10pIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnLz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnPicgKyB0YWdDb250ZW50ICsgJzwvJyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgKyAnPic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnB1dFBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0ZXh0YXJlYVBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUob3B0aW9uUG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50SW1hZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBJdGVyYXRpbmcgb3ZlciBvYmplY3QgcHJvcGVydGllcyBpcyBmYXN0ZXIgdGhhbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMuXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzKSB7XG4gICAgdmFyIHJldCA9ICc8JyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcywgcHJvcEtleSwgcHJvcFZhbHVlLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIFNlZSBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBzdHlsZSBibG9ja1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBfYXNzaWduKHt9LCBwcm9wcy5zdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3BWYWx1ZSA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya3VwID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyAhPSBudWxsICYmIGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgcHJvcHMpKSB7XG4gICAgICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBzdGF0aWMgcGFnZXMsIG5vIG5lZWQgdG8gcHV0IFJlYWN0IElEIGFuZCBjaGVja3N1bS4gU2F2ZXMgbG90cyBvZlxuICAgIC8vIGJ5dGVzLlxuICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2hvc3RQYXJlbnQpIHtcbiAgICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUm9vdCgpO1xuICAgIH1cbiAgICByZXQgKz0gJyAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHRoaXMuX2RvbUlEKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgdGFncy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnRlbnQgbWFya3VwLlxuICAgKi9cbiAgX2NyZWF0ZUNvbnRlbnRNYXJrdXA6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG5cbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHJldCA9IGlubmVySFRNTC5fX2h0bWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHJldCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcihjb250ZW50VG9Vc2UpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgcmV0ID0gbW91bnRJbWFnZXMuam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdsaW5lRWF0aW5nVGFnc1t0aGlzLl90YWddICYmIHJldC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgcmV0dXJuICdcXG4nICsgcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSkge1xuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVIVE1MKGxhenlUcmVlLCBpbm5lckhUTUwuX19odG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVUZXh0KGxhenlUcmVlLCBjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIG1vdW50SW1hZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIGNvbXBvbmVudCBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFsbG9jYXRlZCBhbmRcbiAgICogYXR0YWNoZWQgdG8gdGhlIERPTS4gUmVjb25jaWxlcyB0aGUgcm9vdCBET00gbm9kZSwgdGhlbiByZWN1cnNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldkVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdFByb3BzID0gcHJldkVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLl91cGRhdGVET01DaGlsZHJlbihsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgICAgLy8gaGFwcGVuIGFmdGVyIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgcHJvcGVydGllcyBieSBkZXRlY3RpbmcgZGlmZmVyZW5jZXMgaW4gcHJvcGVydHkgdmFsdWVzIGFuZFxuICAgKiB1cGRhdGluZyB0aGUgRE9NIGFzIG5lY2Vzc2FyeS4gVGhpcyBmdW5jdGlvbiBpcyBwcm9iYWJseSB0aGUgc2luZ2xlIG1vc3RcbiAgICogY3JpdGljYWwgcGF0aCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgKlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgd2hldGhlciBjaGVja2luZyBmb3IgY2hhbmdlZCB2YWx1ZXMgaW4gbWVtb3J5IGFjdHVhbGx5XG4gICAqICAgICAgIGltcHJvdmVzIHBlcmZvcm1hbmNlIChlc3BlY2lhbGx5IHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cykuXG4gICAqIFRPRE86IEJlbmNobWFyayB0aGUgZWZmZWN0cyBvZiBwdXR0aW5nIHRoaXMgYXQgdGhlIHRvcCBzaW5jZSA5OSUgb2YgcHJvcHNcbiAgICogICAgICAgZG8gbm90IGNoYW5nZSBmb3IgYSBnaXZlbiByZWNvbmNpbGlhdGlvbi5cbiAgICogVE9ETzogQmVuY2htYXJrIGFyZWFzIHRoYXQgY2FuIGJlIGltcHJvdmVkIHdpdGggY2FjaGluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIF91cGRhdGVET01Qcm9wZXJ0aWVzOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzO1xuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICB2YXIgbGFzdFN0eWxlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHk7XG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobGFzdFByb3BzW3Byb3BLZXldKSB7XG4gICAgICAgICAgLy8gT25seSBjYWxsIGRlbGV0ZUxpc3RlbmVyIGlmIHRoZXJlIHdhcyBhIGxpc3RlbmVyIHByZXZpb3VzbHkgb3JcbiAgICAgICAgICAvLyBlbHNlIHdpbGxEZWxldGVMaXN0ZW5lciBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIHdhc24ndCBhY3R1YWxseSBhXG4gICAgICAgICAgLy8gbGlzdGVuZXIgKGUuZy4sIG9uQ2xpY2s9e251bGx9KVxuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbGFzdFByb3BzKSkge1xuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGdldE5vZGUodGhpcyksIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbmV4dFByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBfYXNzaWduKHt9LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcywgcHJvcEtleSwgbmV4dFByb3AsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHRoaXMuX3RhZywgbmV4dFByb3BzKSkge1xuICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKGdldE5vZGUodGhpcyksIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIHZhciBub2RlID0gZ2V0Tm9kZSh0aGlzKTtcbiAgICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICAgQ1NTUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yU3R5bGVzKGdldE5vZGUodGhpcyksIHN0eWxlVXBkYXRlcywgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGNoaWxkcmVuIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBfdXBkYXRlRE9NQ2hpbGRyZW46IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICB2YXIgbmV4dENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBuZXh0UHJvcHMuY2hpbGRyZW5dID8gbmV4dFByb3BzLmNoaWxkcmVuIDogbnVsbDtcblxuICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuXG4gICAgLy8gTm90ZSB0aGUgdXNlIG9mIGAhPWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICB2YXIgbGFzdENoaWxkcmVuID0gbGFzdENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBsYXN0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDb250ZW50ICE9IG51bGwgPyBudWxsIDogbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gY2hpbGRyZW4gdG8gY29udGVudC9odG1sIG9yIHZpY2UgdmVyc2EsIHJlbW92ZVxuICAgIC8vIHRoZSBvbGQgY29udGVudFxuICAgIHZhciBsYXN0SGFzQ29udGVudE9ySHRtbCA9IGxhc3RDb250ZW50ICE9IG51bGwgfHwgbGFzdEh0bWwgIT0gbnVsbDtcbiAgICB2YXIgbmV4dEhhc0NvbnRlbnRPckh0bWwgPSBuZXh0Q29udGVudCAhPSBudWxsIHx8IG5leHRIdG1sICE9IG51bGw7XG4gICAgaWYgKGxhc3RDaGlsZHJlbiAhPSBudWxsICYmIG5leHRDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG51bGwsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGxhc3RIYXNDb250ZW50T3JIdG1sICYmICFuZXh0SGFzQ29udGVudE9ySHRtbCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbih0aGlzLl9kZWJ1Z0lELCBbXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5leHRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0Q29udGVudCAhPT0gbmV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyArIG5leHRDb250ZW50KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG5leHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1hcmt1cCgnJyArIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdsaW5rJzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fd3JhcHBlclN0YXRlLmxpc3RlbmVycztcbiAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgaW1wb3NzaWJsZSB0byB1bm1vdW50IHNvbWUgdG9wLWxldmVsIGNvbXBvbmVudHMgKGVnIDxodG1sPiwgPGhlYWQ+LCBhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgZWxlbWVudHMuJywgdGhpcy5fdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NicsIHRoaXMuX3RhZykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKHNhZmVseSk7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICAgIEV2ZW50UGx1Z2luSHViLmRlbGV0ZUFsbExpc3RlbmVycyh0aGlzKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9kb21JRCA9IDA7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9XG5cbn07XG5cbl9hc3NpZ24oUmVhY3RET01Db21wb25lbnQucHJvdG90eXBlLCBSZWFjdERPTUNvbXBvbmVudC5NaXhpbiwgUmVhY3RNdWx0aUNoaWxkLk1peGluKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSB7XG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9jdXNOb2RlKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvQXV0b0ZvY3VzVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgnLi9kYW5nZXJvdXNTdHlsZVZhbHVlJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKCdmYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG59KTtcblxudmFyIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gZmFsc2U7XG52YXIgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ2Nzc0Zsb2F0JztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRlbXBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICB0cnkge1xuICAgIC8vIElFOCB0aHJvd3MgXCJJbnZhbGlkIGFyZ3VtZW50LlwiIGlmIHJlc2V0dGluZyBzaG9ydGhhbmQgc3R5bGUgcHJvcGVydGllcy5cbiAgICB0ZW1wU3R5bGUuZm9udCA9ICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSB0cnVlO1xuICB9XG4gIC8vIElFOCBvbmx5IHN1cHBvcnRzIGFjY2Vzc2luZyBjc3NGbG9hdCAoc3RhbmRhcmQpIGFzIHN0eWxlRmxvYXRcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ3N0eWxlRmxvYXQnO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiVzICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgY2hlY2tSZW5kZXJNZXNzYWdlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gICAgdmFyIG93bmVyO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgfVxuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyBmb3IgdXNlIGFzIGlubGluZSBzdHlsZXM6XG4gICAqXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxuICAgKiAgIFwid2lkdGg6MjAwcHg7aGVpZ2h0OjA7XCJcbiAgICpcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cbiAgICogVGhlIHJlc3VsdCBzaG91bGQgYmUgSFRNTC1lc2NhcGVkIGJlZm9yZSBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yU3R5bGVzOiBmdW5jdGlvbiAoc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgY29tcG9uZW50KSArICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcywgY29tcG9uZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBjb21wb25lbnQuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICd1cGRhdGUgc3R5bGVzJyxcbiAgICAgICAgcGF5bG9hZDogc3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnIHx8IHN0eWxlTmFtZSA9PT0gJ2Nzc0Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXG4gIH0sXG4gIGJhY2tncm91bmRQb3NpdGlvbjoge1xuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXG4gICAgb3V0bGluZVN0eWxlOiB0cnVlLFxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9DU1NQcm9wZXJ0eS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX2h5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vZmJqcy9saWIvY2FtZWxpemUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xudmFyIHN0eWxlV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBjb21wb25lbnQpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpc05vbk51bWVyaWMgPSBpc05hTih2YWx1ZSk7XG4gIGlmIChpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBBbGxvdyAnMCcgdG8gcGFzcyB0aHJvdWdoIHdpdGhvdXQgd2FybmluZy4gMCBpcyBhbHJlYWR5IHNwZWNpYWwgYW5kXG4gICAgICAvLyBkb2Vzbid0IHJlcXVpcmUgdW5pdHMsIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FybiBhYm91dCBpdC5cbiAgICAgIGlmIChjb21wb25lbnQgJiYgdmFsdWUgIT09ICcwJykge1xuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gb3duZXIuZ2V0TmFtZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG93bmVyTmFtZSAmJiAhc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdKSB7XG4gICAgICAgICAgc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdO1xuICAgICAgICAgIHdhcm5lZCA9IHdhcm5pbmdzW25hbWVdO1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdhIGAlc2AgdGFnIChvd25lcjogYCVzYCkgd2FzIHBhc3NlZCBhIG51bWVyaWMgc3RyaW5nIHZhbHVlICcgKyAnZm9yIENTUyBwcm9wZXJ0eSBgJXNgICh2YWx1ZTogYCVzYCkgd2hpY2ggd2lsbCBiZSB0cmVhdGVkICcgKyAnYXMgYSB1bml0bGVzcyBudW1iZXIgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdC4nLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUsIG93bmVyTmFtZSB8fCAndW5rbm93bicsIG5hbWUsIHZhbHVlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBET01Qcm9wZXJ0eS5BVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB2b2lkIDA7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgY3JlYXRlTWFya3VwRm9yUm9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JSb290OiBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUUsICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0VmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgcGF5bG9hZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUgYXR0cmlidXRlJyxcbiAgICAgICAgcGF5bG9hZDogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xuXG4vKipcbiAqIEVzY2FwZXMgYXR0cmlidXRlIHZhbHVlIHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUgPSByZXF1aXJlKCcuL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lJyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGhhc0V2ZW50UGFnZVhZO1xudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BBbmltYXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSB8fCAnYW5pbWF0aW9uZW5kJyxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSB8fCAnYW5pbWF0aW9uc3RhcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpIHx8ICd0cmFuc2l0aW9uZW5kJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBfYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BXaGVlbCcpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1c2luJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEJsdXInLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BCbHVyID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJvdGVjdCBhZ2FpbnN0IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkgcmV0dXJuaW5nIG51bGxcbiAgICogU29tZSBwb3B1cCBibG9ja2VyIGV4dGVuc2lvbnMgYXBwZWFyIHRvIGRvIHRoaXM6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjg4N1xuICAgKi9cbiAgc3VwcG9ydHNFdmVudFBhZ2VYWTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICByZXR1cm4gZXYgIT0gbnVsbCAmJiAncGFnZVgnIGluIGV2O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cbiAgICogcGFnZVgvcGFnZVkgaXNuJ3Qgc3VwcG9ydGVkIChsZWdhY3kgYnJvd3NlcnMpLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc3VwcG9ydHNFdmVudFBhZ2VYWSgpO1xuICAgIH1cbiAgICBpZiAoIWhhc0V2ZW50UGFnZVhZICYmICFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICovXG4gIGhhbmRsZVRvcExldmVsOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZChwcm9wcyk7XG5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcbiAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcbiAgICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxuICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICBtYXg6IHVuZGVmaW5lZFxuICAgIH0sIHByb3BzLCB7XG4gICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG5cbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWRMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BjaGVja2VkTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmICghaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFNob3VsZG4ndCB0aGlzIGJlIGdldENoZWNrZWQocHJvcHMpP1xuICAgIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSwgJ2NoZWNrZWQnLCBjaGVja2VkIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gICAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgICAvLyBhcmUgbm90IHJlc2V0YWJsZSBub2RlcyBzbyB0aGlzIG9wZXJhdGlvbiBkb2Vzbid0IG1hdHRlciBhbmQgYWN0dWFsbHlcbiAgICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgICAvLyBwcm92aWRlZC5cblxuICAgIHN3aXRjaCAocHJvcHMudHlwZSkge1xuICAgICAgY2FzZSAnc3VibWl0JzpcbiAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb2xvcic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzIzM1xuICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAgIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAgIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSAnJztcbiAgICB9XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0sIGxldCdzIGp1c3QgdXNlIHRoZSBnbG9iYWxcbiAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MCcpIDogdm9pZCAwO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW5wdXQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAnYnV0dG9uJzogdHJ1ZSxcbiAgJ2NoZWNrYm94JzogdHJ1ZSxcbiAgJ2ltYWdlJzogdHJ1ZSxcbiAgJ2hpZGRlbic6IHRydWUsXG4gICdyYWRpbyc6IHRydWUsXG4gICdyZXNldCc6IHRydWUsXG4gICdzdWJtaXQnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKSB7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0UHJvcHMudmFsdWVMaW5rID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgdmFsdWVMaW5rLiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZExpbmssIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluayBhbmQgdmljZSB2ZXJzYS4nKSA6IF9wcm9kSW52YXJpYW50KCc4NycpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMudmFsdWUgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgdmFsdWVMaW5rIGFuZCBhIHZhbHVlIG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgdmFsdWUgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluay4nKSA6IF9wcm9kSW52YXJpYW50KCc4OCcpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgY2hlY2tlZCBwcm9wZXJ0eSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWQgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIGNoZWNrZWRMaW5rJykgOiBfcHJvZEludmFyaWFudCgnODknKSA6IHZvaWQgMDtcbn1cblxudmFyIHByb3BUeXBlcyA9IHtcbiAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICovXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgb3duZXIpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCAncHJvcCcsIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcik7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIGZvcm0gcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxuICAgKiAgICAgICAgICAgICBvciBsaW5rLlxuICAgKi9cbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gICAqL1xuICBleGVjdXRlT25DaGFuZ2U6IGZ1bmN0aW9uIChpbnB1dFByb3BzLCBldmVudCkge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLm9uQ2hhbmdlLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFZhbHVlVXRpbHM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL0xpbmtlZFZhbHVlVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbikge1xuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGhvc3RQYXJlbnQpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnXG4gICAgdmFyIHNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICB2YXIgc2VsZWN0UGFyZW50ID0gaG9zdFBhcmVudDtcblxuICAgICAgaWYgKHNlbGVjdFBhcmVudC5fdGFnID09PSAnb3B0Z3JvdXAnKSB7XG4gICAgICAgIHNlbGVjdFBhcmVudCA9IHNlbGVjdFBhcmVudC5faG9zdFBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdFBhcmVudCAhPSBudWxsICYmIHNlbGVjdFBhcmVudC5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICBzZWxlY3RWYWx1ZSA9IFJlYWN0RE9NU2VsZWN0LmdldFNlbGVjdFZhbHVlQ29udGV4dChzZWxlY3RQYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBudWxsIChlLmcuLCBubyBzcGVjaWZpZWQgdmFsdWUgb3IgYWZ0ZXIgaW5pdGlhbCBtb3VudClcbiAgICAvLyBvciBtaXNzaW5nIChlLmcuLCBmb3IgPGRhdGFsaXN0PiksIHdlIGRvbid0IGNoYW5nZSBwcm9wcy5zZWxlY3RlZFxuICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgKyAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBob3N0UHJvcHMuc2VsZWN0ZWQgPSBpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIGhvc3RQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NT3B0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCAmJiB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpIHtcbiAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgb3duZXIpO1xuXG4gIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgc2VsZWN0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGluc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbGVcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhpbnN0LCBtdWx0aXBsZSwgcHJvcFZhbHVlKSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpO1xuICB2YXIgb3B0aW9ucyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVbJycgKyBwcm9wVmFsdWVbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHJldHVybiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZSxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgcGVuZGluZ1VwZGF0ZTogZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdCksXG4gICAgICB3YXNNdWx0aXBsZTogQm9vbGVhbihwcm9wcy5tdWx0aXBsZSlcbiAgICB9O1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U2VsZWN0VmFsdWVDb250ZXh0OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFJlYWN0RE9NT3B0aW9uIGxvb2tzIGF0IHRoaXMgaW5pdGlhbCB2YWx1ZSBzbyB0aGUgaW5pdGlhbCBnZW5lcmF0ZWRcbiAgICAvLyBtYXJrdXAgaGFzIGNvcnJlY3QgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgcmV0dXJuIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gIH0sXG5cbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGlzIHZhbHVlIGRvd25cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdhc011bHRpcGxlID0gaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpO1xuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSkpIHtcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MScpIDogdm9pZCAwO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAgIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitCZW4gc2VlbWVkIHRvIGxpa2UgdGhpcyBzb2x1dGlvbi5cbiAgICAvLyBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGNoaWxkcmVuOiAnJyArIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGB0ZXh0YXJlYWAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gdmFsdWU7XG5cbiAgICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MicpIDogdm9pZCAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnOTMnKSA6IHZvaWQgMDtcbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgaW5pdGlhbFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gV2FybmluZzogbm9kZS52YWx1ZSBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyBhdCB0aGlzIHBvaW50IChJRTExKSBpZiBwbGFjZWhvbGRlciBpcyBzZXQuXG4gICAgbm9kZS52YWx1ZSA9IG5vZGUudGV4dENvbnRlbnQ7IC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlSW5zZXJ0TWFya3VwKG1hcmt1cCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnSU5TRVJUX01BUktVUCcsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFX0VYSVNUSU5HJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShjaGlsZCksXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1JFTU9WRV9OT0RFJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IG5vZGUsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3Igc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVNldE1hcmt1cChtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdTRVRfTUFSS1VQJyxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZXh0Q29udGVudCh0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RFWFRfQ09OVEVOVCcsXG4gICAgY29udGVudDogdGV4dENvbnRlbnQsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogUHVzaCBhbiB1cGRhdGUsIGlmIGFueSwgb250byB0aGUgcXVldWUuIENyZWF0ZXMgYSBuZXcgcXVldWUgaWYgbm9uZSBpc1xuICogcGFzc2VkIGFuZCBhbHdheXMgcmV0dXJucyB0aGUgcXVldWUuIE11dGF0aXZlLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgaWYgKHVwZGF0ZSkge1xuICAgIHF1ZXVlID0gcXVldWUgfHwgW107XG4gICAgcXVldWUucHVzaCh1cGRhdGUpO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKGluc3QsIHVwZGF0ZVF1ZXVlKSB7XG4gIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyhpbnN0LCB1cGRhdGVRdWV1ZSk7XG59XG5cbnZhciBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZ2V0RGVidWdJRCA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgaWYgKCFpbnN0Ll9kZWJ1Z0lEKSB7XG4gICAgICAvLyBDaGVjayBmb3IgQVJULWxpa2UgaW5zdGFuY2VzLiBUT0RPOiBUaGlzIGlzIHNpbGx5L2dyb3NzLlxuICAgICAgdmFyIGludGVybmFsO1xuICAgICAgaWYgKGludGVybmFsID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdCkpIHtcbiAgICAgICAgaW5zdCA9IGludGVybmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdC5fZGVidWdJRDtcbiAgfTtcbiAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgZGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgLy8gVE9ETzogUmVhY3QgTmF0aXZlIGVtcHR5IGNvbXBvbmVudHMgYXJlIGFsc28gbXVsdGljaGlsZC5cbiAgICAvLyBUaGlzIG1lYW5zIHRoZXkgc3RpbGwgZ2V0IGludG8gdGhpcyBtZXRob2QgYnV0IGRvbid0IGhhdmUgX2RlYnVnSUQuXG4gICAgaWYgKGRlYnVnSUQgIT09IDApIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkcmVuID8gT2JqZWN0LmtleXMoY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltrZXldLl9kZWJ1Z0lEO1xuICAgICAgfSkgOiBbXSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcblxuICAvKipcbiAgICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudHMgdGhhdCBtdXN0IHJlY29uY2lsZSBtdWx0aXBsZVxuICAgKiBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIGJ5IGBSZWFjdERPTUNvbXBvbmVudGAgdG8gbW91bnQsIHVwZGF0ZSwgYW5kXG4gICAqIHVubW91bnQgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE11bHRpQ2hpbGQucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIF9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW47XG4gICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgc2VsZkRlYnVnSUQpO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAgICogQHJldHVybiB7YXJyYXl9IEFuIGFycmF5IG9mIG1vdW50ZWQgcmVwcmVzZW50YXRpb25zLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbmFtZV07XG4gICAgICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleCsrO1xuICAgICAgICAgIG1vdW50SW1hZ2VzLnB1c2gobW91bnRJbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb3VudEltYWdlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRDb250ZW50IFN0cmluZyBvZiBjb250ZW50LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRDb250ZW50OiBmdW5jdGlvbiAobmV4dENvbnRlbnQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBuZXcgdGV4dCBjb250ZW50LlxuICAgICAgdmFyIHVwZGF0ZXMgPSBbbWFrZVRleHRDb250ZW50KG5leHRDb250ZW50KV07XG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbWFya3VwIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0TWFya3VwIFN0cmluZyBvZiBtYXJrdXAuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlTWFya3VwOiBmdW5jdGlvbiAobmV4dE1hcmt1cCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVUZXh0Q29udGVudCBjYWxsZWQgb24gbm9uLWVtcHR5IGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTgnKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZXMgPSBbbWFrZVNldE1hcmt1cChuZXh0TWFya3VwKV07XG4gICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggbmV3IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgLy8gSG9vayB1c2VkIGJ5IFJlYWN0IEFSVFxuICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIHZhciByZW1vdmVkTm9kZXMgPSB7fTtcbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gbnVsbDtcbiAgICAgIHZhciBuYW1lO1xuICAgICAgLy8gYG5leHRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggY2hpbGQgaW4gYG5leHRDaGlsZHJlbmAsIGJ1dFxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxuICAgICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgIC8vIGBuZXh0TW91bnRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggbmV3bHkgbW91bnRlZCBjaGlsZC5cbiAgICAgIHZhciBuZXh0TW91bnRJbmRleCA9IDA7XG4gICAgICB2YXIgbGFzdFBsYWNlZE5vZGUgPSBudWxsO1xuICAgICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgICBpZiAocHJldkNoaWxkID09PSBuZXh0Q2hpbGQpIHtcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLm1vdmVDaGlsZChwcmV2Q2hpbGQsIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIGxhc3RJbmRleCkpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBwcmV2Q2hpbGQuX21vdW50SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBgX21vdW50SW5kZXhgIGdldHMgdW5zZXQgYnkgdW5tb3VudGluZy5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIC8vIFRoZSBgcmVtb3ZlZE5vZGVzYCBsb29wIGJlbG93IHdpbGwgYWN0dWFsbHkgcmVtb3ZlIHRoZSBjaGlsZC5cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5fbW91bnRDaGlsZEF0SW5kZXgobmV4dENoaWxkLCBtb3VudEltYWdlc1tuZXh0TW91bnRJbmRleF0sIGxhc3RQbGFjZWROb2RlLCBuZXh0SW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSk7XG4gICAgICAgICAgbmV4dE1vdW50SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgICAgbGFzdFBsYWNlZE5vZGUgPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUobmV4dENoaWxkKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICAgIGZvciAobmFtZSBpbiByZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgaWYgKHJlbW92ZWROb2Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGRyZW5bbmFtZV0sIHJlbW92ZWROb2Rlc1tuYW1lXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlcykge1xuICAgICAgICBwcm9jZXNzUXVldWUodGhpcywgdXBkYXRlcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbmV4dENoaWxkcmVuO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIG5leHRDaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLiBJdCBkb2VzIG5vdCBhY3R1YWxseSBwZXJmb3JtIGFueVxuICAgICAqIGJhY2tlbmQgb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhlIHN1cHBsaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RJbmRleCBMYXN0IGluZGV4IHZpc2l0ZWQgb2YgdGhlIHNpYmxpbmdzIG9mIGBjaGlsZGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgsIGxhc3RJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIGBjaGlsZGAgaXMgbGVzcyB0aGFuIGBsYXN0SW5kZXhgLCB0aGVuIGl0IG5lZWRzIHRvXG4gICAgICAvLyBiZSBtb3ZlZC4gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIGl0IGJlY2F1c2UgYSBjaGlsZCB3aWxsIGJlXG4gICAgICAvLyBpbnNlcnRlZCBvciBtb3ZlZCBiZWZvcmUgYGNoaWxkYC5cbiAgICAgIGlmIChjaGlsZC5fbW91bnRJbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgICByZXR1cm4gbWFrZU1vdmUoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3VudEltYWdlIE1hcmt1cCB0byBpbnNlcnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSkge1xuICAgICAgcmV0dXJuIG1ha2VJbnNlcnRNYXJrdXAobW91bnRJbWFnZSwgYWZ0ZXJOb2RlLCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDaGlsZCB0byByZW1vdmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG5vZGUpIHtcbiAgICAgIHJldHVybiBtYWtlUmVtb3ZlKGNoaWxkLCBub2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIGEgY2hpbGQgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW91bnRDaGlsZEF0SW5kZXg6IGZ1bmN0aW9uIChjaGlsZCwgbW91bnRJbWFnZSwgYWZ0ZXJOb2RlLCBpbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXg7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVDaGlsZChjaGlsZCwgYWZ0ZXJOb2RlLCBtb3VudEltYWdlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYSByZW5kZXJlZCBjaGlsZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byB1bm1vdW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VubW91bnRDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XG4gICAgICB2YXIgdXBkYXRlID0gdGhpcy5yZW1vdmVDaGlsZChjaGlsZCwgbm9kZSk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlO1xuICAgIH1cblxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGluamVjdGVkID0gZmFsc2U7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0ge1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3Igc3dhcHBpbmcgb3V0IG1vdW50IGltYWdlcyBpbiB0aGUgbWlkZGxlIG9mXG4gICAqIHRoZSB0cmVlLlxuICAgKi9cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlIG9mIGNoaWxkIHVwZGF0ZXMuIFdpbGxcbiAgICogbGF0ZXIgbW92ZSBpbnRvIE11bHRpQ2hpbGRDb21wb25lbnRzLlxuICAgKi9cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RFbnZpcm9ubWVudDogZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG4gICAgICAhIWluamVjdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50OiBpbmplY3RFbnZpcm9ubWVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzEwNCcpIDogdm9pZCAwO1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBlbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXA7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMgPSBlbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzO1xuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciBrZXlVbmlxdWUgPSBjaGlsZEluc3RhbmNlc1tuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgfVxuICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKG5lc3RlZENoaWxkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3RhbmNlcyA9IHt9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XG4gICAgICB9LCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgaW5zdGFudGlhdGVDaGlsZCwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRJbnN0YW5jZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENoaWxkcmVuIEZsYXQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIHdheSB0byB0cmFjayBtb3ZlcyBoZXJlIGJ1dCBpZiB3ZSB1c2UgaXRlcmF0b3JzXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcbiAgICAvLyBtb3ZlZC5cbiAgICAvLyBUT0RPOiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIHByZXZDaGlsZHJlbiBvYmplY3Qgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lO1xuICAgIHZhciBwcmV2Q2hpbGQ7XG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IG5leHRDaGlsZEluc3RhbmNlO1xuICAgICAgICAvLyBDcmVhdGluZyBtb3VudCBpbWFnZSBub3cgZW5zdXJlcyByZWZzIGFyZSByZXNvbHZlZCBpbiByaWdodCBvcmRlclxuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxMDEgZm9yIGV4cGxhbmF0aW9uKS5cbiAgICAgICAgdmFyIG5leHRDaGlsZE1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQobmV4dENoaWxkSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICBtb3VudEltYWdlcy5wdXNoKG5leHRDaGlsZE1vdW50SW1hZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbm1vdW50IGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSByZW5kZXJlZENoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgaWYgKHJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChyZW5kZXJlZENoaWxkLCBzYWZlbHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xuXG52YXIgZ2V0TmV4dERlYnVnSUQgPSByZXF1aXJlKCcuL2dldE5leHREZWJ1Z0lEJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHRoaXMuY29uc3RydWN0KGVsZW1lbnQpO1xufTtcbl9hc3NpZ24oUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnQsIHtcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbn0pO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdHlwZSByZWZlcmVuY2UgaXMgYSBrbm93biBpbnRlcm5hbCB0eXBlLiBJLmUuIG5vdCBhIHVzZXJcbiAqIHByb3ZpZGVkIGNvbXBvc2l0ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgaW50ZXJuYWwgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlcm5hbENvbXBvbmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdE5vZGUsIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRIYXZlRGVidWdJRFxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5vZGUsIHNob3VsZEhhdmVEZWJ1Z0lEKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gUmVhY3RFbXB0eUNvbXBvbmVudC5jcmVhdGUoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCBlbGVtZW50LnR5cGUgPT0gbnVsbCA/IGVsZW1lbnQudHlwZSA6IHR5cGVvZiBlbGVtZW50LnR5cGUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShlbGVtZW50Ll9vd25lcikpIDogX3Byb2RJbnZhcmlhbnQoJzEzMCcsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiB2b2lkIDA7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2Ugc3RyaW5nIHZhbHVlc1xuICAgIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuXG4gICAgICAvLyBXZSByZW5hbWVkIHRoaXMuIEFsbG93IHRoZSBvbGQgbmFtZSBmb3IgY29tcGF0LiA6KFxuICAgICAgaWYgKCFpbnN0YW5jZS5nZXRIb3N0Tm9kZSkge1xuICAgICAgICBpbnN0YW5jZS5nZXRIb3N0Tm9kZSA9IGluc3RhbmNlLmdldE5hdGl2ZU5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlcihlbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3RIb3N0Q29tcG9uZW50LmNyZWF0ZUluc3RhbmNlRm9yVGV4dChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRW5jb3VudGVyZWQgaW52YWxpZCBSZWFjdCBub2RlIG9mIHR5cGUgJXMnLCB0eXBlb2Ygbm9kZSkgOiBfcHJvZEludmFyaWFudCgnMTMxJywgdHlwZW9mIG5vZGUpIDogdm9pZCAwO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdGFuY2UubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldEhvc3ROb2RlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdm9pZCAwO1xuICB9XG5cbiAgLy8gVGhlc2UgdHdvIGZpZWxkcyBhcmUgdXNlZCBieSB0aGUgRE9NIGFuZCBBUlQgZGlmZmluZyBhbGdvcml0aG1zXG4gIC8vIHJlc3BlY3RpdmVseS4gSW5zdGVhZCBvZiB1c2luZyBleHBhbmRvcyBvbiBjb21wb25lbnRzLCB3ZSBzaG91bGQgYmVcbiAgLy8gc3RvcmluZyB0aGUgc3RhdGUgbmVlZGVkIGJ5IHRoZSBkaWZmaW5nIGFsZ29yaXRobXMgZWxzZXdoZXJlLlxuICBpbnN0YW5jZS5fbW91bnRJbmRleCA9IDA7XG4gIGluc3RhbmNlLl9tb3VudEltYWdlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluc3RhbmNlLl9kZWJ1Z0lEID0gc2hvdWxkSGF2ZURlYnVnSUQgPyBnZXROZXh0RGVidWdJRCgpIDogMDtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3ROb2RlVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0Tm9kZVR5cGVzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG59XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIENvbXBvc2l0ZVR5cGVzID0ge1xuICBJbXB1cmVDbGFzczogMCxcbiAgUHVyZUNsYXNzOiAxLFxuICBTdGF0ZWxlc3NGdW5jdGlvbmFsOiAyXG59O1xuXG5mdW5jdGlvbiBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KSB7fVxuU3RhdGVsZXNzQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBDb21wb25lbnQgPSBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgdmFyIGVsZW1lbnQgPSBDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnVwZGF0ZXIpO1xuICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbmZ1bmN0aW9uIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgZWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCksICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBTZXBhcmF0ZWQgaW50byBhIGZ1bmN0aW9uIHRvIGNvbnRhaW4gZGVvcHRpbWl6YXRpb25zIGNhdXNlZCBieSB0cnkvZmluYWxseS5cbmZ1bmN0aW9uIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZuLCBkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGRlYnVnSUQgPT09IDApIHtcbiAgICAvLyBUb3AtbGV2ZWwgd3JhcHBlcnMgKHNlZSBSZWFjdE1vdW50KSBhbmQgZW1wdHkgY29tcG9uZW50cyAoc2VlXG4gICAgLy8gUmVhY3RET01FbXB0eUNvbXBvbmVudCkgYXJlIGludmlzaWJsZSB0byBob29rcyBhbmQgZGV2dG9vbHMuXG4gICAgLy8gQm90aCBhcmUgaW1wbGVtZW50YXRpb24gZGV0YWlscyB0aGF0IHNob3VsZCBnbyBhd2F5IGluIHRoZSBmdXR1cmUuXG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLSBUaGUgTGlmZS1DeWNsZSBvZiBhIENvbXBvc2l0ZSBDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogLSBjb25zdHJ1Y3RvcjogSW5pdGlhbGl6YXRpb24gb2Ygc3RhdGUuIFRoZSBpbnN0YW5jZSBpcyBub3cgcmV0YWluZWQuXG4gKiAgIC0gY29tcG9uZW50V2lsbE1vdW50XG4gKiAgIC0gcmVuZGVyXG4gKiAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXJdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnREaWRNb3VudF1cbiAqICAgICAtIGNvbXBvbmVudERpZE1vdW50XG4gKlxuICogICAgICAgVXBkYXRlIFBoYXNlczpcbiAqICAgICAgIC0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAob25seSBjYWxsZWQgaWYgcGFyZW50IHVwZGF0ZWQpXG4gKiAgICAgICAtIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICogICAgICAgICAtIGNvbXBvbmVudFdpbGxVcGRhdGVcbiAqICAgICAgICAgICAtIHJlbmRlclxuICogICAgICAgICAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzIG9yIHJlY2VpdmUgcHJvcHMgcGhhc2VzXVxuICogICAgICAgICAtIGNvbXBvbmVudERpZFVwZGF0ZVxuICpcbiAqICAgICAtIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsVW5tb3VudF1cbiAqICAgLSBbY2hpbGRyZW4gZGVzdHJveWVkXVxuICogLSAoZGVzdHJveWVkKTogVGhlIGluc3RhbmNlIGlzIG5vdyBibGFuaywgcmVsZWFzZWQgYnkgUmVhY3QgYW5kIHJlYWR5IGZvciBHQy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQW4gaW5jcmVtZW50aW5nIElEIGFzc2lnbmVkIHRvIGVhY2ggY29tcG9uZW50IHdoZW4gaXQgaXMgbW91bnRlZC4gVGhpcyBpc1xuICogdXNlZCB0byBlbmZvcmNlIHRoZSBvcmRlciBpbiB3aGljaCBgUmVhY3RVcGRhdGVzYCB1cGRhdGVzIGRpcnR5IGNvbXBvbmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG5leHRNb3VudElEID0gMTtcblxuLyoqXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlUXVldWVcbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICAvLyBDb21wb25lbnRXaWxsVW5tb3VudCBzaGFsbCBvbmx5IGJlIGNhbGxlZCBvbmNlXG4gICAgdGhpcy5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQgPSBmYWxzZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aGlzLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0UGFyZW50XG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdENvbnRhaW5lckluZm9cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KGNvbnRleHQpO1xuXG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICB2YXIgdXBkYXRlUXVldWUgPSB0cmFuc2FjdGlvbi5nZXRVcGRhdGVRdWV1ZSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGRvQ29uc3RydWN0ID0gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCk7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnQoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIC8vIFN1cHBvcnQgZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gICAgaWYgKCFkb0NvbnN0cnVjdCAmJiAoaW5zdCA9PSBudWxsIHx8IGluc3QucmVuZGVyID09IG51bGwpKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0O1xuICAgICAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCByZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgIShpbnN0ID09PSBudWxsIHx8IGluc3QgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KGluc3QpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDUnLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaW5zdCA9IG5ldyBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KTtcbiAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5JbXB1cmVDbGFzcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGxhdGVyIGluIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQsIGJ1dCBhZGQgYW4gZWFybHlcbiAgICAgIC8vIHdhcm5pbmcgbm93IHRvIGhlbHAgZGVidWdnaW5nXG4gICAgICBpZiAoaW5zdC5yZW5kZXIgPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wc011dGF0ZWQgPSBpbnN0LnByb3BzICE9PSBwdWJsaWNQcm9wcztcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LnByb3BzID09PSB1bmRlZmluZWQgfHwgIXByb3BzTXV0YXRlZCwgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyAndXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudFxcJ3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSBzaG91bGQgYmUgc2V0IHVwIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGFzIGEgY29udmVuaWVuY2UgZm9yXG4gICAgLy8gc2ltcGxlciBjbGFzcyBhYnN0cmFjdGlvbnMsIHdlIHNldCB0aGVtIHVwIGFmdGVyIHRoZSBmYWN0LlxuICAgIGluc3QucHJvcHMgPSBwdWJsaWNQcm9wcztcbiAgICBpbnN0LmNvbnRleHQgPSBwdWJsaWNDb250ZXh0O1xuICAgIGluc3QucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIGluc3QudXBkYXRlciA9IHVwZGF0ZVF1ZXVlO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3QuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5wcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgJyArICdzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIG1hcmt1cDtcbiAgICBpZiAoaW5zdC51bnN0YWJsZV9oYW5kbGVFcnJvcikge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmcocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudERpZE1vdW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0sIF90aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkTW91bnQsIGluc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgX2NvbnN0cnVjdENvbXBvbmVudDogZnVuY3Rpb24gKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXIoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9jb25zdHJ1Y3RDb21wb25lbnRXaXRob3V0T3duZXI6IGZ1bmN0aW9uIChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBpZiAoZG9Db25zdHJ1Y3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2N0b3InKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBjYW4gc3RpbGwgYmUgYW4gaW5zdGFuY2UgaW4gY2FzZSBvZiBmYWN0b3J5IGNvbXBvbmVudHNcbiAgICAvLyBidXQgd2UnbGwgY291bnQgdGhpcyBhcyB0aW1lIHNwZW50IHJlbmRlcmluZyBhcyB0aGUgbW9yZSBjb21tb24gY2FzZS5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgfVxuICB9LFxuXG4gIHBlcmZvcm1Jbml0aWFsTW91bnRXaXRoRXJyb3JIYW5kbGluZzogZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIG1hcmt1cDtcbiAgICB2YXIgY2hlY2twb2ludCA9IHRyYW5zYWN0aW9uLmNoZWNrcG9pbnQoKTtcbiAgICB0cnkge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBSb2xsIGJhY2sgdG8gY2hlY2twb2ludCwgaGFuZGxlIGVycm9yICh3aGljaCBtYXkgYWRkIGl0ZW1zIHRvIHRoZSB0cmFuc2FjdGlvbiksIGFuZCB0YWtlIGEgbmV3IGNoZWNrcG9pbnRcbiAgICAgIHRyYW5zYWN0aW9uLnJvbGxiYWNrKGNoZWNrcG9pbnQpO1xuICAgICAgdGhpcy5faW5zdGFuY2UudW5zdGFibGVfaGFuZGxlRXJyb3IoZSk7XG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uuc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKHRoaXMuX2luc3RhbmNlLnByb3BzLCB0aGlzLl9pbnN0YW5jZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LnVubW91bnRDb21wb25lbnQodHJ1ZSk7XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcblxuICAgICAgLy8gVHJ5IGFnYWluIC0gd2UndmUgaW5mb3JtZWQgdGhlIGNvbXBvbmVudCBhYm91dCB0aGUgZXJyb3IsIHNvIHRoZXkgY2FuIHJlbmRlciBhbiBlcnJvciBtZXNzYWdlIHRoaXMgdGltZS5cbiAgICAgIC8vIElmIHRoaXMgdGhyb3dzIGFnYWluLCB0aGUgZXJyb3Igd2lsbCBidWJibGUgdXAgKGFuZCBjYW4gYmUgY2F1Z2h0IGJ5IGEgaGlnaGVyIGVycm9yIGJvdW5kYXJ5KS5cbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgcGVyZm9ybUluaXRpYWxNb3VudDogZnVuY3Rpb24gKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBkZWJ1Z0lEID0gMDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbE1vdW50KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH0sIGRlYnVnSUQsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG4gICAgICAvLyBXaGVuIG1vdW50aW5nLCBjYWxscyB0byBgc2V0U3RhdGVgIGJ5IGBjb21wb25lbnRXaWxsTW91bnRgIHdpbGwgc2V0XG4gICAgICAvLyBgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWVgIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICBpbnN0LnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShpbnN0LnByb3BzLCBpbnN0LmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdCBhIHN0YXRlbGVzcyBjb21wb25lbnQsIHdlIG5vdyByZW5kZXJcbiAgICBpZiAocmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIH1cblxuICAgIHZhciBub2RlVHlwZSA9IFJlYWN0Tm9kZVR5cGVzLmdldFR5cGUocmVuZGVyZWRFbGVtZW50KTtcbiAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbm9kZVR5cGU7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChyZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xuICAgICk7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBjaGlsZDtcblxuICAgIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgZGVidWdJRCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGRlYnVnSUQgIT09IDApIHtcbiAgICAgICAgdmFyIGNoaWxkRGVidWdJRHMgPSBjaGlsZC5fZGVidWdJRCAhPT0gMCA/IFtjaGlsZC5fZGVidWdJRF0gOiBbXTtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgaWYgKCF0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCAmJiAhaW5zdC5fY2FsbGVkQ29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgIGluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKHNhZmVseSkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpICsgJy5jb21wb25lbnRXaWxsVW5tb3VudCgpJztcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQoaW5zdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVW5tb3VudCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHNhZmVseSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBwZW5kaW5nIGZpZWxkc1xuICAgIC8vIEV2ZW4gaWYgdGhpcyBjb21wb25lbnQgaXMgc2NoZWR1bGVkIGZvciBhbm90aGVyIHVwZGF0ZSBpbiBSZWFjdFVwZGF0ZXMsXG4gICAgLy8gaXQgd291bGQgc3RpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXNlIGZpZWxkcyBhcmUgcmVzZXQuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxuICAgIC8vIGxlYWtzIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMgaW5zdGFuY2UuXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XG5cbiAgICAvLyBTb21lIGV4aXN0aW5nIGNvbXBvbmVudHMgcmVseSBvbiBpbnN0LnByb3BzIGV2ZW4gYWZ0ZXIgdGhleSd2ZSBiZWVuXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5zdGF0ZSA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFza0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jb250ZXh0VHlwZXM7XG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2AsIGFuZCBhc3NlcnRzIHRoYXQgdGhleSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB0aGlzLl9tYXNrQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja0NvbnRleHRUeXBlcyhDb21wb25lbnQuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCAnY29udGV4dCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRDb250ZXh0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBjaGlsZENvbnRleHQ7XG5cbiAgICBpZiAoaW5zdC5nZXRDaGlsZENvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICEodHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb250ZXh0VHlwZXMoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZENvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICEobmFtZSBpbiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwOCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9hc3NpZ24oe30sIGN1cnJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IHRoZSBjb250ZXh0IHR5cGVzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBjb250ZXh0IGZpZWxkIHRvIGEgUmVhY3RQcm9wVHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAodHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIHRoaXMuZ2V0TmFtZSgpLCBudWxsLCB0aGlzLl9kZWJ1Z0lEKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgIT09IG51bGwgfHwgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQXR0ZW1wdGVkIHRvIHVwZGF0ZSBjb21wb25lbnQgYCVzYCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkIChvciBmYWlsZWQgdG8gbW91bnQpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEzNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdmFyIHdpbGxSZWNlaXZlID0gZmFsc2U7XG4gICAgdmFyIG5leHRDb250ZXh0O1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkIG9yIG5vdFxuICAgIGlmICh0aGlzLl9jb250ZXh0ID09PSBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlByb3BzID0gcHJldlBhcmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gTm90IGEgc2ltcGxlIHN0YXRlIHVwZGF0ZSBidXQgYSBwcm9wcyB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgIT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgIC8vIF9wZW5kaW5nU3RhdGVRdWV1ZSB3aGljaCB3aWxsIGVuc3VyZSB0aGF0IGFueSBzdGF0ZSB1cGRhdGVzIGdldHNcbiAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG4gICAgaWYgKHdpbGxSZWNlaXZlICYmIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUobmV4dFByb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgaWYgKGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5QdXJlQ2xhc3MpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSAhc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSB8fCAhc2hhbGxvd0VxdWFsKGluc3Quc3RhdGUsIG5leHRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgICAvLyBXaWxsIHNldCBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAuXG4gICAgICB0aGlzLl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlKG5leHRQYXJlbnRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCBuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBkZXRlcm1pbmVkIHRoYXQgYSBjb21wb25lbnQgc2hvdWxkIG5vdCB1cGRhdGUsIHdlIHN0aWxsIHdhbnRcbiAgICAgIC8vIHRvIHNldCBwcm9wcyBhbmQgc3RhdGUgYnV0IHdlIHNob3J0Y3V0IHRoZSByZXN0IG9mIHRoZSB1cGRhdGUuXG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRQYXJlbnRFbGVtZW50O1xuICAgICAgdGhpcy5fY29udGV4dCA9IG5leHRVbm1hc2tlZENvbnRleHQ7XG4gICAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIH1cbiAgfSxcblxuICBfcHJvY2Vzc1BlbmRpbmdTdGF0ZTogZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZTtcbiAgICB2YXIgcmVwbGFjZSA9IHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGU7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgIGlmICghcXVldWUpIHtcbiAgICAgIHJldHVybiBpbnN0LnN0YXRlO1xuICAgIH1cblxuICAgIGlmIChyZXBsYWNlICYmIHF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHF1ZXVlWzBdO1xuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSBfYXNzaWduKHt9LCByZXBsYWNlID8gcXVldWVbMF0gOiBpbnN0LnN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gcmVwbGFjZSA/IDEgOiAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XG4gICAgICBfYXNzaWduKG5leHRTdGF0ZSwgdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgY29udGV4dCkgOiBwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHVubWFza2VkQ29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xuICAgIHZhciBwcmV2UHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQ7XG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgICBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBfdGhpczIuX2RlYnVnSUQsICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkVXBkYXRlLmJpbmQoaW5zdCwgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgaW5zdCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjb21wb25lbnQncyBgcmVuZGVyYCBtZXRob2QgYW5kIHVwZGF0ZSB0aGUgRE9NIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgdmFyIHByZXZSZW5kZXJlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBuZXh0UmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG5cbiAgICB2YXIgZGVidWdJRCA9IDA7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRIb3N0Tm9kZSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBmYWxzZSk7XG5cbiAgICAgIHZhciBub2RlVHlwZSA9IFJlYWN0Tm9kZVR5cGVzLmdldFR5cGUobmV4dFJlbmRlcmVkRWxlbWVudCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZE5vZGVUeXBlID0gbm9kZVR5cGU7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQsIG5vZGVUeXBlICE9PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSAvKiBzaG91bGRIYXZlRGVidWdJRCAqL1xuICAgICAgKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICAgIHZhciBuZXh0TWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgdGhpcy5faG9zdFBhcmVudCwgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCksIGRlYnVnSUQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGVidWdJRCAhPT0gMCkge1xuICAgICAgICAgIHZhciBjaGlsZERlYnVnSURzID0gY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW107XG4gICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogT3ZlcnJpZGRlbiBpbiBzaGFsbG93IHJlbmRlcmluZy5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnN0LnJlbmRlcigpO1xuICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ3JlbmRlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSBpbnN0LnJlbmRlcigpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgcmVuZGVyZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgfHwgdGhpcy5fY29tcG9zaXRlVHlwZSAhPT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCkge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICB9XG4gICAgIShcbiAgICAvLyBUT0RPOiBBbiBgaXNWYWxpZE5vZGVgIGZ1bmN0aW9uIHdvdWxkIHByb2JhYmx5IGJlIG1vcmUgYXBwcm9wcmlhdGVcbiAgICByZW5kZXJlZEVsZW1lbnQgPT09IG51bGwgfHwgcmVuZGVyZWRFbGVtZW50ID09PSBmYWxzZSB8fCBSZWFjdC5pc1ZhbGlkRWxlbWVudChyZW5kZXJlZEVsZW1lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwOScsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIHJlbmRlcmVkRWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6aWx5IGFsbG9jYXRlcyB0aGUgcmVmcyBvYmplY3QgYW5kIHN0b3JlcyBgY29tcG9uZW50YCBhcyBgcmVmYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtjb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gc3RvcmUgYXMgYHJlZmAuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTAnKSA6IHZvaWQgMDtcbiAgICB2YXIgcHVibGljQ29tcG9uZW50SW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQgJiYgY29tcG9uZW50LmdldE5hbWUgPyBjb21wb25lbnQuZ2V0TmFtZSgpIDogJ2EgY29tcG9uZW50JztcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHB1YmxpY0NvbXBvbmVudEluc3RhbmNlICE9IG51bGwgfHwgY29tcG9uZW50Ll9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMgJyArICcoU2VlIHJlZiBcIiVzXCIgaW4gJXMgY3JlYXRlZCBieSAlcykuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4nLCByZWYsIGNvbXBvbmVudE5hbWUsIHRoaXMuZ2V0TmFtZSgpKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgcmVmc1tyZWZdID0gcHVibGljQ29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgcmVmZXJlbmNlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRhY2hSZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgcmVmcyA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzO1xuICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0XG4gICAqIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9yIG51bGwuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IubmFtZSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQgLSBpLmUuIHdoYXRcbiAgICogaXMgZXhwb3NlZCBieSByZWZzIGFuZCByZXR1cm5lZCBieSByZW5kZXIuIENhbiBiZSBudWxsIGZvciBzdGF0ZWxlc3NcbiAgICogY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHRoZSBwdWJsaWMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAodGhpcy5fY29tcG9zaXRlVHlwZSA9PT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8vIFN0dWJcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHtcbiAgSE9TVDogMCxcbiAgQ09NUE9TSVRFOiAxLFxuICBFTVBUWTogMixcblxuICBnZXRUeXBlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuRU1QVFk7XG4gICAgfSBlbHNlIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgaWYgKHR5cGVvZiBub2RlLnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkNPTVBPU0lURTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5IT1NUO1xuICAgICAgfVxuICAgIH1cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBub2RlOiAlcycsIG5vZGUpIDogX3Byb2RJbnZhcmlhbnQoJzI2Jywgbm9kZSkgOiB2b2lkIDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROb2RlVHlwZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0Tm9kZVR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P29iamVjdH0gZWxlbWVudCBUaGUgUmVhY3QgZWxlbWVudCB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHs/bnVtYmVyfSBkZWJ1Z0lEIFRoZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUmVhY3RUeXBlU3BlYyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQsIGRlYnVnSUQpIHtcbiAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICEodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIFJlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc4NCcsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogdm9pZCAwO1xuICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKSA6IHZvaWQgMDtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBjb21wb25lbnRTdGFja0luZm8gPSAnJztcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWJ1Z0lEICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIGNvbXBvbmVudFN0YWNrSW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tSZWFjdFR5cGVTcGVjO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYSBgcHJldkVsZW1lbnRgIGFuZCBgbmV4dEVsZW1lbnRgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcbiAqIGluc3RhbmNlLiBCb3RoIGFyZ3VtZW50cyBhcmUgZWxlbWVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoaXMgbG9naWMgY2FuXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJldkVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dEVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxuICogQHByb3RlY3RlZFxuICovXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuICBpZiAocHJldkVtcHR5IHx8IG5leHRFbXB0eSkge1xuICAgIHJldHVybiBwcmV2RW1wdHkgPT09IG5leHRFbXB0eTtcbiAgfVxuXG4gIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcbiAgdmFyIG5leHRUeXBlID0gdHlwZW9mIG5leHRFbGVtZW50O1xuICBpZiAocHJldlR5cGUgPT09ICdzdHJpbmcnIHx8IHByZXZUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgcHJldkVsZW1lbnQudHlwZSA9PT0gbmV4dEVsZW1lbnQudHlwZSAmJiBwcmV2RWxlbWVudC5rZXkgPT09IG5leHRFbGVtZW50LmtleTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUNvbXBvbmVudEZhY3Rvcnk7XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RFbXB0eUNvbXBvbmVudEZhY3Rvcnk6IGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgZW1wdHlDb21wb25lbnRGYWN0b3J5ID0gZmFjdG9yeTtcbiAgfVxufTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gICAgcmV0dXJuIGVtcHR5Q29tcG9uZW50RmFjdG9yeShpbnN0YW50aWF0ZSk7XG4gIH1cbn07XG5cblJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uID0gUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB3cmFwcGVyIGNsYXNzZXMgYXJvdW5kIGhvc3QgdGFncy5cbnZhciB0YWdUb0NvbXBvbmVudENsYXNzID0ge307XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgLy8gVGhpcyBhY2NlcHRzIGEgY2xhc3MgdGhhdCByZWNlaXZlcyB0aGUgdGFnIHN0cmluZy4gVGhpcyBpcyBhIGNhdGNoIGFsbFxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxuICAvLyByZW5kZXJlZCBhcyBwcm9wcy5cbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEga2V5ZWQgb2JqZWN0IHdpdGggY2xhc3NlcyBhcyB2YWx1ZXMuIEVhY2gga2V5IHJlcHJlc2VudHMgYVxuICAvLyB0YWcuIFRoYXQgcGFydGljdWxhciB0YWcgd2lsbCB1c2UgdGhpcyBjbGFzcyBpbnN0ZWFkIG9mIHRoZSBnZW5lcmljIG9uZS5cbiAgaW5qZWN0Q29tcG9uZW50Q2xhc3NlczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzZXMpIHtcbiAgICBfYXNzaWduKHRhZ1RvQ29tcG9uZW50Q2xhc3MsIGNvbXBvbmVudENsYXNzZXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGhvc3QgaW50ZXJuYWwgY29tcG9uZW50IGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjcmVhdGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGludGVybmFsIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KSB7XG4gICFnZW5lcmljQ29tcG9uZW50Q2xhc3MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgaXMgbm8gcmVnaXN0ZXJlZCBjb21wb25lbnQgZm9yIHRoZSB0YWcgJXMnLCBlbGVtZW50LnR5cGUpIDogX3Byb2RJbnZhcmlhbnQoJzExMScsIGVsZW1lbnQudHlwZSkgOiB2b2lkIDA7XG4gIHJldHVybiBuZXcgZ2VuZXJpY0NvbXBvbmVudENsYXNzKGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VGb3JUZXh0KHRleHQpIHtcbiAgcmV0dXJuIG5ldyB0ZXh0Q29tcG9uZW50Q2xhc3ModGV4dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1RleHRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQgaW5zdGFuY2VvZiB0ZXh0Q29tcG9uZW50Q2xhc3M7XG59XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSB7XG4gIGNyZWF0ZUludGVybmFsQ29tcG9uZW50OiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudCxcbiAgY3JlYXRlSW5zdGFuY2VGb3JUZXh0OiBjcmVhdGVJbnN0YW5jZUZvclRleHQsXG4gIGlzVGV4dENvbXBvbmVudDogaXNUZXh0Q29tcG9uZW50LFxuICBpbmplY3Rpb246IFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5leHREZWJ1Z0lEID0gMTtcblxuZnVuY3Rpb24gZ2V0TmV4dERlYnVnSUQoKSB7XG4gIHJldHVybiBuZXh0RGVidWdJRCsrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5leHREZWJ1Z0lEO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9nZXROZXh0RGVidWdJRC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvS2V5RXNjYXBlVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFN5bWJvbCcpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRoaXMgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudCBzaW5jZSB0aGlzIGZpbGUgaXMgc2hhcmVkIGJldHdlZW5cbiAqIGlzb21vcnBoaWMgYW5kIHJlbmRlcmVycy4gV2UgY291bGQgZXh0cmFjdCB0aGlzIHRvIGFcbiAqXG4gKi9cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXG4gIC8vIHNvbWUgY2hlY2tzLiBSZWFjdCBGaWJlciBhbHNvIGlubGluZXMgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBwdXJwb3Nlcy5cbiAgdHlwZSA9PT0gJ29iamVjdCcgJiYgY2hpbGRyZW4uJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcnO1xuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbm1vZHVsZS5leHBvcnRzID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBTeW1ib2wgKi9cblxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2VsZkRlYnVnSUQgT3B0aW9uYWwgZGVidWdJRCBvZiB0aGUgY3VycmVudCBpbnRlcm5hbCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIGlmICh0cmF2ZXJzZUNvbnRleHQgJiYgdHlwZW9mIHRyYXZlcnNlQ29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhdmVyc2VDb250ZXh0O1xuICAgIHZhciBrZXlVbmlxdWUgPSByZXN1bHRbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgfVxuICAgICAgaWYgKCFrZXlVbmlxdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4lcycsIEtleUVzY2FwZVV0aWxzLnVuZXNjYXBlKG5hbWUpLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKHNlbGZEZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0W25hbWVdID0gY2hpbGQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJuIHshb2JqZWN0fSBmbGF0dGVuZWQgY2hpbGRyZW4ga2V5ZWQgYnkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuLCBzZWxmRGVidWdJRCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAgICAgcmV0dXJuIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICB9LCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0LCByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkNoaWxkcmVuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyVXBkYXRlUXVldWUnKTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG52YXIgbm9vcENhbGxiYWNrUXVldWUgPSB7XG4gIGVucXVldWU6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IGZhbHNlO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbmV3IFJlYWN0U2VydmVyVXBkYXRlUXVldWUodGhpcyk7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbm9vcENhbGxiYWNrUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge30sXG5cbiAgY2hlY2twb2ludDogZnVuY3Rpb24gKCkge30sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG5fYXNzaWduKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB1cGRhdGUgcXVldWUgdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqIEl0IGRlbGVnYXRlcyB0byBSZWFjdFVwZGF0ZVF1ZXVlIHdoaWxlIHNlcnZlciByZW5kZXJpbmcgaXMgaW4gcHJvZ3Jlc3MgYW5kXG4gKiBzd2l0Y2hlcyB0byBSZWFjdE5vb3BVcGRhdGVRdWV1ZSBhZnRlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cbiAqIEBjbGFzcyBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICovXG5cbnZhciBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKHRyYW5zYWN0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlYWN0U2VydmVyVXBkYXRlUXVldWUpO1xuXG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5pc01vdW50ZWQgPSBmdW5jdGlvbiBpc01vdW50ZWQocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlQ2FsbGJhY2sgPSBmdW5jdGlvbiBlbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlRm9yY2VVcGRhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlRm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRm9yY2VVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVSZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVJlcGxhY2VTdGF0ZShwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVTZXRTdGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVTZXRTdGF0ZShwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyVXBkYXRlUXVldWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0U2VydmVyVXBkYXRlUXVldWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGFyZykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHZhciBkaXNwbGF5TmFtZSA9IGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY29uc3RydWN0b3IubmFtZSB8fCB0eXBlO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDAgJiYga2V5cy5sZW5ndGggPCAyMCkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZSArICcgKGtleXM6ICcgKyBrZXlzLmpvaW4oJywgJykgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gT25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIGNhbGxlck5hbWUuIE90aGVyd2lzZSB3ZSBzaG91bGQgYmUgc2lsZW50LlxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNhbGxlck5hbWUsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY3RvciAmJiAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICclcyguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50XFwncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzICcgKyAnc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yICcgKyAnc2lkZS1lZmZlY3RzIGFyZSBhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gJyArICdgY29tcG9uZW50V2lsbE1vdW50YC4nLCBjYWxsZXJOYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXG4gKi9cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIC8vIER1cmluZyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlciB0aGlzIHdpbGwgc3RpbGwgYmUgbnVsbCBidXQgYWZ0ZXJcbiAgICAgIC8vIHRoYXQgd2lsbCBhbHdheXMgcmVuZGVyIHRvIHNvbWV0aGluZy4gQXQgbGVhc3QgZm9yIG5vdy4gU28gd2UgY2FuIHVzZVxuICAgICAgLy8gdGhpcyBoYWNrLlxuICAgICAgcmV0dXJuICEhaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FsbGVyTmFtZSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgY2FsbGVyTmFtZSk7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0U3RhdGUoKTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xuICAgIHF1ZXVlLnB1c2gocGFydGlhbFN0YXRlKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgLy8gVE9ETzogaW50cm9kdWNlIF9wZW5kaW5nQ29udGV4dCBpbnN0ZWFkIG9mIHNldHRpbmcgaXQgZGlyZWN0bHkuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgdmFsaWRhdGVDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgISghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogX3Byb2RJbnZhcmlhbnQoJzEyMicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogdm9pZCAwO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVRdWV1ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVRdWV1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcblxuICAgICAgY2FzZSAnaHInOlxuXG4gICAgICBjYXNlICd4bXAnOlxuXG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgZG8ge1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGNoaWxkSW5zdGFuY2UsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJykgOiB2b2lkIDA7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcbiAgICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gcHJvYmxlbWF0aWMuaW5zdGFuY2U7XG5cbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lciA9IGFuY2VzdG9ySW5zdGFuY2UgJiYgYW5jZXN0b3JJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcblxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5TdGFja0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xuICAgICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyTmFtZXMgPSBhbmNlc3Rvck93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3duZXJJbmZvID0gW10uY29uY2F0KFxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxuICAgICAgZGVlcGVzdENvbW1vbiAhPT0gLTEgPyBjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXS5nZXROYW1lKCkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xuXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgICB2YXIgd2hpdGVzcGFjZUluZm8gPSAnJztcbiAgICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9ICcgTWFrZSBzdXJlIHlvdSBkb25cXCd0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uICcgKyAnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICAgIH1cblxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzICcgKyAnU2VlICVzLiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgb3duZXJJbmZvLCBpbmZvKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4gU2VlICVzLicsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgb3duZXJJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGluc3RhbnRpYXRlKSB7XG4gIC8vIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IHVzZXMgdGhpczpcbiAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAvLyBSZWFjdERPTUNvbXBvbmVudFRyZWUgdXNlcyB0aGVzZTpcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuICB0aGlzLl9kb21JRCA9IDA7XG59O1xuX2Fzc2lnbihSZWFjdERPTUVtcHR5Q29tcG9uZW50LnByb3RvdHlwZSwge1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgbm9kZVZhbHVlID0gJyByZWFjdC1lbXB0eTogJyArIHRoaXMuX2RvbUlEICsgJyAnO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIG5vZGUgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQobm9kZVZhbHVlKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgbm9kZSk7XG4gICAgICByZXR1cm4gRE9NTGF6eVRyZWUobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIGluc2VydCBhIGNvbW1lbnQgbm9kZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb25cbiAgICAgICAgLy8gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVyblxuICAgICAgICAvLyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJzwhLS0nICsgbm9kZVZhbHVlICsgJy0tPic7XG4gICAgfVxuICB9LFxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRW1wdHlDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSB0ZW1wQS5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSB0ZW1wQi5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0Qikge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG5cbiAgd2hpbGUgKGluc3RCKSB7XG4gICAgaWYgKGluc3RCID09PSBpbnN0QSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRQYXJlbnRJbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBpbnN0Ll9ob3N0UGFyZW50O1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGZyb20uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodG8gJiYgdG8gIT09IGNvbW1vbikge1xuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IHRvLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKGkgPSBwYXRoVG8ubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tpXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiB0cmF2ZXJzZUVudGVyTGVhdmVcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVHJlZVRyYXZlcnNhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxuLyoqXG4gKiBUZXh0IG5vZGVzIHZpb2xhdGUgYSBjb3VwbGUgYXNzdW1wdGlvbnMgdGhhdCBSZWFjdCBtYWtlcyBhYm91dCBjb21wb25lbnRzOlxuICpcbiAqICAtIFdoZW4gbW91bnRpbmcgdGV4dCBpbnRvIHRoZSBET00sIGFkamFjZW50IHRleHQgbm9kZXMgYXJlIG1lcmdlZC5cbiAqICAtIFRleHQgbm9kZXMgY2Fubm90IGJlIGFzc2lnbmVkIGEgUmVhY3Qgcm9vdCBJRC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIHdyYXAgc3RyaW5ncyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgc28gdGhhdCB0aGV5XG4gKiBjYW4gdW5kZXJnbyB0aGUgc2FtZSByZWNvbmNpbGlhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gZWxlbWVudHMuXG4gKlxuICogVE9ETzogSW52ZXN0aWdhdGUgcmVwcmVzZW50aW5nIFJlYWN0IGNvbXBvbmVudHMgaW4gdGhlIERPTSB3aXRoIHRleHQgbm9kZXMuXG4gKlxuICogQGNsYXNzIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgLy8gVE9ETzogVGhpcyBpcyByZWFsbHkgYSBSZWFjdFRleHQgKFJlYWN0Tm9kZSksIG5vdCBhIFJlYWN0RWxlbWVudFxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IHRleHQ7XG4gIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuXG4gIC8vIFByb3BlcnRpZXNcbiAgdGhpcy5fZG9tSUQgPSAwO1xuICB0aGlzLl9tb3VudEluZGV4ID0gMDtcbiAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xufTtcblxuX2Fzc2lnbihSZWFjdERPTVRleHRDb21wb25lbnQucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50SW5mbztcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8gIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxuICAgICAgICAvLyBjb21wb25lbnQgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCB0aGlzLl9zdHJpbmdUZXh0LCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdmFyIG9wZW5pbmdWYWx1ZSA9ICcgcmVhY3QtdGV4dDogJyArIGRvbUlEICsgJyAnO1xuICAgIHZhciBjbG9zaW5nVmFsdWUgPSAnIC9yZWFjdC10ZXh0ICc7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBvcGVuaW5nQ29tbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChvcGVuaW5nVmFsdWUpO1xuICAgICAgdmFyIGNsb3NpbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KGNsb3NpbmdWYWx1ZSk7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvcGVuaW5nQ29tbWVudCkpO1xuICAgICAgaWYgKHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLl9zdHJpbmdUZXh0KSkpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUoY2xvc2luZ0NvbW1lbnQpKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgb3BlbmluZ0NvbW1lbnQpO1xuICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBjbG9zaW5nQ29tbWVudDtcbiAgICAgIHJldHVybiBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRoaXMuX3N0cmluZ1RleHQpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgYmV0d2VlbiBjb21tZW50IG5vZGVzIGZvciB0aGUgcmVhc29ucyBzdGF0ZWRcbiAgICAgICAgLy8gYWJvdmUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlclxuICAgICAgICAvLyAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8IS0tJyArIG9wZW5pbmdWYWx1ZSArICctLT4nICsgZXNjYXBlZFRleHQgKyAnPCEtLScgKyBjbG9zaW5nVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0VGV4dCAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRTdHJpbmdUZXh0ICE9PSB0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcbiAgICAgICAgLy8gb3RoZXIgY29tcG9uZW50IHR5cGVzP1xuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XG4gICAgICAgIHZhciBjb21tZW50Tm9kZXMgPSB0aGlzLmdldEhvc3ROb2RlKCk7XG4gICAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5yZXBsYWNlRGVsaW1pdGVkVGV4dChjb21tZW50Tm9kZXNbMF0sIGNvbW1lbnROb2Rlc1sxXSwgbmV4dFN0cmluZ1RleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3N0Tm9kZSA9IHRoaXMuX2NvbW1lbnROb2RlcztcbiAgICBpZiAoaG9zdE5vZGUpIHtcbiAgICAgIHJldHVybiBob3N0Tm9kZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jbG9zaW5nQ29tbWVudCkge1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgICB2YXIgbm9kZSA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgIShub2RlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgY2xvc2luZyBjb21tZW50IGZvciB0ZXh0IGNvbXBvbmVudCAlcycsIHRoaXMuX2RvbUlEKSA6IF9wcm9kSW52YXJpYW50KCc2NycsIHRoaXMuX2RvbUlEKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgL3JlYWN0LXRleHQgJykge1xuICAgICAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgaG9zdE5vZGUgPSBbdGhpcy5faG9zdE5vZGUsIHRoaXMuX2Nsb3NpbmdDb21tZW50XTtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBob3N0Tm9kZTtcbiAgICByZXR1cm4gaG9zdE5vZGU7XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbnZhciBSRVNFVF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxuX2Fzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9XG59KTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIsIGMsIGQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24nKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50KGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3QuX2hvc3RQYXJlbnQpIHtcbiAgICBpbnN0ID0gaW5zdC5faG9zdFBhcmVudDtcbiAgfVxuICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgdmFyIGNvbnRhaW5lciA9IHJvb3ROb2RlLnBhcmVudE5vZGU7XG4gIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuX2Fzc2lnbihUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucHJvdG90eXBlLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRvcExldmVsVHlwZSA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgfVxufSk7XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLCBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdGFyZ2V0SW5zdDtcbiAgZG8ge1xuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGFuY2VzdG9yICYmIGZpbmRQYXJlbnQoYW5jZXN0b3IpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxWYWx1ZU1vbml0b3IoY2IpIHtcbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcbiAgY2Ioc2Nyb2xsUG9zaXRpb24pO1xufVxuXG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0ge1xuICBfZW5hYmxlZDogdHJ1ZSxcbiAgX2hhbmRsZVRvcExldmVsOiBudWxsLFxuXG4gIFdJTkRPV19IQU5ETEU6IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHdpbmRvdyA6IG51bGwsXG5cbiAgc2V0SGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uIChoYW5kbGVUb3BMZXZlbCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5faGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbiAgfSxcblxuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSxcblxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5jYXB0dXJlKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbiAgfSxcblxuICBtb25pdG9yU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uIChyZWZyZXNoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gc2Nyb2xsVmFsdWVNb25pdG9yLmJpbmQobnVsbCwgcmVmcmVzaCk7XG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAnc2Nyb2xsJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCFSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYm9va0tlZXBpbmcgPSBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcuZ2V0UG9vbGVkKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucmVsZWFzZShib29rS2VlcGluZyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIFJlYWN0SW5qZWN0aW9uID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuaW5qZWN0aW9uLFxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxuICBFbXB0eUNvbXBvbmVudDogUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luVXRpbHM6IEV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLFxuICBFdmVudEVtaXR0ZXI6IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pbmplY3Rpb24sXG4gIEhvc3RDb21wb25lbnQ6IFJlYWN0SG9zdENvbXBvbmVudC5pbmplY3Rpb24sXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0SW5qZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VycmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24odXNlQ3JlYXRlRWxlbWVudCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbmAgaW5zdGVhZC4gVGhpcyBvcHRpb24gaXMgaGVyZSBzbyB0aGF0IGl0J3NcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxuICAvLyBgUmVhY3RET01UZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmYWxzZTtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gdXNlQ3JlYXRlRWxlbWVudDtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cbiAgICovXG4gIGdldFVwZGF0ZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0VXBkYXRlUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmUgY3VycmVudCB0cmFuc2FjdGlvbiBzdGF0ZSAtLSBpZiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhpcyBtZXRob2QgaXNcbiAgICogcGFzc2VkIHRvIGByb2xsYmFja2AsIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJlc2V0IHRvIHRoYXQgc3RhdGUuXG4gICAqL1xuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVhY3RNb3VudFJlYWR5IGlzIHRoZSBvdXIgb25seSBzdGF0ZWZ1bCB3cmFwcGVyXG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5LmNoZWNrcG9pbnQoKTtcbiAgfSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5fYXNzaWduKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3Rpb24nKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0ge1xuXG4gIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAndGV4dCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gIH0sXG5cbiAgZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICAgIHNlbGVjdGlvblJhbmdlOiBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gICAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICAgKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAgICovXG4gIHJlc3RvcmVTZWxlY3Rpb246IGZ1bmN0aW9uIChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gICAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgaWYgKFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICAgIFJlYWN0SW5wdXRTZWxlY3Rpb24uc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgfVxuICAgICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gICAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICAgKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICAgKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAgICovXG4gIGdldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgdmFyIHNlbGVjdGlvbjtcblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgIC8vIElFOCBpbnB1dC5cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIHNlbGVjdGlvbiBwZXIgZG9jdW1lbnQgaW4gSUUsIHNvIGl0IG11c3RcbiAgICAgIC8vIGJlIGluIG91ciBlbGVtZW50LlxuICAgICAgaWYgKHJhbmdlLnBhcmVudEVsZW1lbnQoKSA9PT0gaW5wdXQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICAgIHN0YXJ0OiAtcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICBlbmQ6IC1yYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IFJlYWN0RE9NU2VsZWN0aW9uLmdldE9mZnNldHMoaW5wdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICAgKiB0aGUgaW5wdXQuXG4gICAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAgICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQsIG9mZnNldHMpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbi5zZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Jyk7XG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSW4gRmlyZWZveCwgcmFuZ2Uuc3RhcnRDb250YWluZXIgYW5kIHJhbmdlLmVuZENvbnRhaW5lciBjYW4gYmUgXCJhbm9ueW1vdXNcbiAgLy8gZGl2c1wiLCBlLmcuIHRoZSB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91c1xuICAvLyBkaXZzIGRvIG5vdCBzZWVtIHRvIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZFxuICAvLyBlcnJvclwiIGlmIGFueSBvZiBpdHMgcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZVxuICAvLyB3YXkgdG8gYXZvaWQgZXJyb3JpbmcgaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yXG4gIC8vIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmQgY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICBjdXJyZW50UmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGFuZCBvZmZzZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSwgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQuXG4gIC8vIGBTZWxlY3Rpb24uaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgYnV0IElFIHNvbWV0aW1lcyBnZXRzXG4gIC8vIHRoaXMgdmFsdWUgd3JvbmcuXG4gIHZhciBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQodGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLCB0ZW1wUmFuZ2Uuc3RhcnRPZmZzZXQsIHRlbXBSYW5nZS5lbmRDb250YWluZXIsIHRlbXBSYW5nZS5lbmRPZmZzZXQpO1xuXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgcmFuZ2VMZW5ndGg7XG5cbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cbiAgdmFyIGRldGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB2YXIgaXNCYWNrd2FyZCA9IGRldGVjdGlvblJhbmdlLmNvbGxhcHNlZDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpc0JhY2t3YXJkID8gZW5kIDogc3RhcnQsXG4gICAgZW5kOiBpc0JhY2t3YXJkID8gc3RhcnQgOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldElFT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpO1xuICB2YXIgc3RhcnQsIGVuZDtcblxuICBpZiAob2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBzdGFydDtcbiAgfSBlbHNlIGlmIChvZmZzZXRzLnN0YXJ0ID4gb2Zmc2V0cy5lbmQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuZW5kO1xuICAgIGVuZCA9IG9mZnNldHMuc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuICB9XG5cbiAgcmFuZ2UubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlKTtcbiAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICByYW5nZS5zZWxlY3QoKTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE1vZGVybk9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdXNlSUVPZmZzZXRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdzZWxlY3Rpb24nIGluIGRvY3VtZW50ICYmICEoJ2dldFNlbGVjdGlvbicgaW4gd2luZG93KTtcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBnZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBnZXRJRU9mZnNldHMgOiBnZXRNb2Rlcm5PZmZzZXRzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAgICovXG4gIHNldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IHNldElFT2Zmc2V0cyA6IHNldE1vZGVybk9mZnNldHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Rpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIE5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBOb2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9pc05vZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIC8qP0RPTUVsZW1lbnQqL3tcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG4vLyBXZSB1c2UgYXR0cmlidXRlcyBmb3IgZXZlcnl0aGluZyBTVkcgc28gbGV0J3MgYXZvaWQgc29tZSBkdXBsaWNhdGlvbiBhbmQgcnVuXG4vLyBjb2RlIGluc3RlYWQuXG4vLyBUaGUgZm9sbG93aW5nIGFyZSBhbGwgc3BlY2lmaWVkIGluIHRoZSBIVE1MIGNvbmZpZyBhbHJlYWR5IHNvIHdlIGV4Y2x1ZGUgaGVyZS5cbi8vIC0gY2xhc3MgKGFzIGNsYXNzTmFtZSlcbi8vIC0gY29sb3Jcbi8vIC0gaGVpZ2h0XG4vLyAtIGlkXG4vLyAtIGxhbmdcbi8vIC0gbWF4XG4vLyAtIG1lZGlhXG4vLyAtIG1ldGhvZFxuLy8gLSBtaW5cbi8vIC0gbmFtZVxuLy8gLSBzdHlsZVxuLy8gLSB0YXJnZXRcbi8vIC0gdHlwZVxuLy8gLSB3aWR0aFxudmFyIEFUVFJTID0ge1xuICBhY2NlbnRIZWlnaHQ6ICdhY2NlbnQtaGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogMCxcbiAgYWRkaXRpdmU6IDAsXG4gIGFsaWdubWVudEJhc2VsaW5lOiAnYWxpZ25tZW50LWJhc2VsaW5lJyxcbiAgYWxsb3dSZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogMCxcbiAgYW1wbGl0dWRlOiAwLFxuICBhcmFiaWNGb3JtOiAnYXJhYmljLWZvcm0nLFxuICBhc2NlbnQ6IDAsXG4gIGF0dHJpYnV0ZU5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRlVHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogMCxcbiAgYmFzZUZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlUHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmFzZWxpbmVTaGlmdDogJ2Jhc2VsaW5lLXNoaWZ0JyxcbiAgYmJveDogMCxcbiAgYmVnaW46IDAsXG4gIGJpYXM6IDAsXG4gIGJ5OiAwLFxuICBjYWxjTW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwSGVpZ2h0OiAnY2FwLWhlaWdodCcsXG4gIGNsaXA6IDAsXG4gIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgY2xpcFJ1bGU6ICdjbGlwLXJ1bGUnLFxuICBjbGlwUGF0aFVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNvbG9ySW50ZXJwb2xhdGlvbjogJ2NvbG9yLWludGVycG9sYXRpb24nLFxuICBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJyxcbiAgY29sb3JQcm9maWxlOiAnY29sb3ItcHJvZmlsZScsXG4gIGNvbG9yUmVuZGVyaW5nOiAnY29sb3ItcmVuZGVyaW5nJyxcbiAgY29udGVudFNjcmlwdFR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRTdHlsZVR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAwLFxuICBjeDogMCxcbiAgY3k6IDAsXG4gIGQ6IDAsXG4gIGRlY2VsZXJhdGU6IDAsXG4gIGRlc2NlbnQ6IDAsXG4gIGRpZmZ1c2VDb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogMCxcbiAgZGlzcGxheTogMCxcbiAgZGl2aXNvcjogMCxcbiAgZG9taW5hbnRCYXNlbGluZTogJ2RvbWluYW50LWJhc2VsaW5lJyxcbiAgZHVyOiAwLFxuICBkeDogMCxcbiAgZHk6IDAsXG4gIGVkZ2VNb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246IDAsXG4gIGVuYWJsZUJhY2tncm91bmQ6ICdlbmFibGUtYmFja2dyb3VuZCcsXG4gIGVuZDogMCxcbiAgZXhwb25lbnQ6IDAsXG4gIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogMCxcbiAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICBmaWxsUnVsZTogJ2ZpbGwtcnVsZScsXG4gIGZpbHRlcjogMCxcbiAgZmlsdGVyUmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVyVW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kQ29sb3I6ICdmbG9vZC1jb2xvcicsXG4gIGZsb29kT3BhY2l0eTogJ2Zsb29kLW9wYWNpdHknLFxuICBmb2N1c2FibGU6IDAsXG4gIGZvbnRGYW1pbHk6ICdmb250LWZhbWlseScsXG4gIGZvbnRTaXplOiAnZm9udC1zaXplJyxcbiAgZm9udFNpemVBZGp1c3Q6ICdmb250LXNpemUtYWRqdXN0JyxcbiAgZm9udFN0cmV0Y2g6ICdmb250LXN0cmV0Y2gnLFxuICBmb250U3R5bGU6ICdmb250LXN0eWxlJyxcbiAgZm9udFZhcmlhbnQ6ICdmb250LXZhcmlhbnQnLFxuICBmb250V2VpZ2h0OiAnZm9udC13ZWlnaHQnLFxuICBmb3JtYXQ6IDAsXG4gIGZyb206IDAsXG4gIGZ4OiAwLFxuICBmeTogMCxcbiAgZzE6IDAsXG4gIGcyOiAwLFxuICBnbHlwaE5hbWU6ICdnbHlwaC1uYW1lJyxcbiAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6ICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJyxcbiAgZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsOiAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLFxuICBnbHlwaFJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50VW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogMCxcbiAgaG9yaXpBZHZYOiAnaG9yaXotYWR2LXgnLFxuICBob3Jpek9yaWdpblg6ICdob3Jpei1vcmlnaW4teCcsXG4gIGlkZW9ncmFwaGljOiAwLFxuICBpbWFnZVJlbmRlcmluZzogJ2ltYWdlLXJlbmRlcmluZycsXG4gICdpbic6IDAsXG4gIGluMjogMCxcbiAgaW50ZXJjZXB0OiAwLFxuICBrOiAwLFxuICBrMTogMCxcbiAgazI6IDAsXG4gIGszOiAwLFxuICBrNDogMCxcbiAga2VybmVsTWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsVW5pdExlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAwLFxuICBrZXlQb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlTcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleVRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhBZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJTcGFjaW5nOiAnbGV0dGVyLXNwYWNpbmcnLFxuICBsaWdodGluZ0NvbG9yOiAnbGlnaHRpbmctY29sb3InLFxuICBsaW1pdGluZ0NvbmVBbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6IDAsXG4gIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgbWFya2VyU3RhcnQ6ICdtYXJrZXItc3RhcnQnLFxuICBtYXJrZXJIZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJVbml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2VyV2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6IDAsXG4gIG1hc2tDb250ZW50VW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza1VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAwLFxuICBtb2RlOiAwLFxuICBudW1PY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogMCxcbiAgb3BhY2l0eTogMCxcbiAgb3BlcmF0b3I6IDAsXG4gIG9yZGVyOiAwLFxuICBvcmllbnQ6IDAsXG4gIG9yaWVudGF0aW9uOiAwLFxuICBvcmlnaW46IDAsXG4gIG92ZXJmbG93OiAwLFxuICBvdmVybGluZVBvc2l0aW9uOiAnb3ZlcmxpbmUtcG9zaXRpb24nLFxuICBvdmVybGluZVRoaWNrbmVzczogJ292ZXJsaW5lLXRoaWNrbmVzcycsXG4gIHBhaW50T3JkZXI6ICdwYWludC1vcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UtMScsXG4gIHBhdGhMZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJuVHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJFdmVudHM6ICdwb2ludGVyLWV2ZW50cycsXG4gIHBvaW50czogMCxcbiAgcG9pbnRzQXRYOiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzQXRZOiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzQXRaOiAncG9pbnRzQXRaJyxcbiAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZVVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICByOiAwLFxuICByYWRpdXM6IDAsXG4gIHJlZlg6ICdyZWZYJyxcbiAgcmVmWTogJ3JlZlknLFxuICByZW5kZXJpbmdJbnRlbnQ6ICdyZW5kZXJpbmctaW50ZW50JyxcbiAgcmVwZWF0Q291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdER1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkRXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkRmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzdGFydDogMCxcbiAgcmVzdWx0OiAwLFxuICByb3RhdGU6IDAsXG4gIHJ4OiAwLFxuICByeTogMCxcbiAgc2NhbGU6IDAsXG4gIHNlZWQ6IDAsXG4gIHNoYXBlUmVuZGVyaW5nOiAnc2hhcGUtcmVuZGVyaW5nJyxcbiAgc2xvcGU6IDAsXG4gIHNwYWNpbmc6IDAsXG4gIHNwZWN1bGFyQ29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJFeHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogMCxcbiAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRPZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZERldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAwLFxuICBzdGVtdjogMCxcbiAgc3RpdGNoVGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3BDb2xvcjogJ3N0b3AtY29sb3InLFxuICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hQb3NpdGlvbjogJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdoVGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLFxuICBzdHJpbmc6IDAsXG4gIHN0cm9rZTogMCxcbiAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gIHN0cm9rZURhc2hvZmZzZXQ6ICdzdHJva2UtZGFzaG9mZnNldCcsXG4gIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gIHN0cm9rZUxpbmVqb2luOiAnc3Ryb2tlLWxpbmVqb2luJyxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgc3Ryb2tlV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxuICBzdXJmYWNlU2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1MYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGVWYWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldFg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0WTogJ3RhcmdldFknLFxuICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICB0ZXh0RGVjb3JhdGlvbjogJ3RleHQtZGVjb3JhdGlvbicsXG4gIHRleHRSZW5kZXJpbmc6ICd0ZXh0LXJlbmRlcmluZycsXG4gIHRleHRMZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdG86IDAsXG4gIHRyYW5zZm9ybTogMCxcbiAgdTE6IDAsXG4gIHUyOiAwLFxuICB1bmRlcmxpbmVQb3NpdGlvbjogJ3VuZGVybGluZS1wb3NpdGlvbicsXG4gIHVuZGVybGluZVRoaWNrbmVzczogJ3VuZGVybGluZS10aGlja25lc3MnLFxuICB1bmljb2RlOiAwLFxuICB1bmljb2RlQmlkaTogJ3VuaWNvZGUtYmlkaScsXG4gIHVuaWNvZGVSYW5nZTogJ3VuaWNvZGUtcmFuZ2UnLFxuICB1bml0c1BlckVtOiAndW5pdHMtcGVyLWVtJyxcbiAgdkFscGhhYmV0aWM6ICd2LWFscGhhYmV0aWMnLFxuICB2SGFuZ2luZzogJ3YtaGFuZ2luZycsXG4gIHZJZGVvZ3JhcGhpYzogJ3YtaWRlb2dyYXBoaWMnLFxuICB2TWF0aGVtYXRpY2FsOiAndi1tYXRoZW1hdGljYWwnLFxuICB2YWx1ZXM6IDAsXG4gIHZlY3RvckVmZmVjdDogJ3ZlY3Rvci1lZmZlY3QnLFxuICB2ZXJzaW9uOiAwLFxuICB2ZXJ0QWR2WTogJ3ZlcnQtYWR2LXknLFxuICB2ZXJ0T3JpZ2luWDogJ3ZlcnQtb3JpZ2luLXgnLFxuICB2ZXJ0T3JpZ2luWTogJ3ZlcnQtb3JpZ2luLXknLFxuICB2aWV3Qm94OiAndmlld0JveCcsXG4gIHZpZXdUYXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogMCxcbiAgd2lkdGhzOiAwLFxuICB3b3JkU3BhY2luZzogJ3dvcmQtc3BhY2luZycsXG4gIHdyaXRpbmdNb2RlOiAnd3JpdGluZy1tb2RlJyxcbiAgeDogMCxcbiAgeEhlaWdodDogJ3gtaGVpZ2h0JyxcbiAgeDE6IDAsXG4gIHgyOiAwLFxuICB4Q2hhbm5lbFNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhsaW5rQWN0dWF0ZTogJ3hsaW5rOmFjdHVhdGUnLFxuICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcbiAgeGxpbmtIcmVmOiAneGxpbms6aHJlZicsXG4gIHhsaW5rUm9sZTogJ3hsaW5rOnJvbGUnLFxuICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcbiAgeGxpbmtUaXRsZTogJ3hsaW5rOnRpdGxlJyxcbiAgeGxpbmtUeXBlOiAneGxpbms6dHlwZScsXG4gIHhtbEJhc2U6ICd4bWw6YmFzZScsXG4gIHhtbG5zOiAwLFxuICB4bWxuc1hsaW5rOiAneG1sbnM6eGxpbmsnLFxuICB4bWxMYW5nOiAneG1sOmxhbmcnLFxuICB4bWxTcGFjZTogJ3htbDpzcGFjZScsXG4gIHk6IDAsXG4gIHkxOiAwLFxuICB5MjogMCxcbiAgeUNoYW5uZWxTZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAwLFxuICB6b29tQW5kUGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge30sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHt9XG59O1xuXG5PYmplY3Qua2V5cyhBVFRSUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIFNWR0RPTVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXNba2V5XSA9IDA7XG4gIGlmIChBVFRSU1trZXldKSB7XG4gICAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNba2V5XSA9IEFUVFJTW2tleV07XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0RPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAoIWhhc0xpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSAndG9wU2VsZWN0aW9uQ2hhbmdlJzpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25TZWxlY3QnKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRm9jdXNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNEcmFnRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUb3VjaEV2ZW50Jyk7XG52YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzID0ge307XG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge307XG5bJ2Fib3J0JywgJ2FuaW1hdGlvbkVuZCcsICdhbmltYXRpb25JdGVyYXRpb24nLCAnYW5pbWF0aW9uU3RhcnQnLCAnYmx1cicsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b3VjaENhbmNlbCcsICd0b3VjaEVuZCcsICd0b3VjaE1vdmUnLCAndG91Y2hTdGFydCcsICd0cmFuc2l0aW9uRW5kJywgJ3ZvbHVtZUNoYW5nZScsICd3YWl0aW5nJywgJ3doZWVsJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gIHZhciBvbkV2ZW50ID0gJ29uJyArIGNhcGl0YWxpemVkRXZlbnQ7XG4gIHZhciB0b3BFdmVudCA9ICd0b3AnICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF1cbiAgfTtcbiAgZXZlbnRUeXBlc1tldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG52YXIgb25DbGlja0xpc3RlbmVycyA9IHt9O1xuXG5mdW5jdGlvbiBnZXREaWN0aW9uYXJ5S2V5KGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlICd0b3BBYm9ydCc6XG4gICAgICBjYXNlICd0b3BDYW5QbGF5JzpcbiAgICAgIGNhc2UgJ3RvcENhblBsYXlUaHJvdWdoJzpcbiAgICAgIGNhc2UgJ3RvcER1cmF0aW9uQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcEVtcHRpZWQnOlxuICAgICAgY2FzZSAndG9wRW5jcnlwdGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVuZGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVycm9yJzpcbiAgICAgIGNhc2UgJ3RvcElucHV0JzpcbiAgICAgIGNhc2UgJ3RvcEludmFsaWQnOlxuICAgICAgY2FzZSAndG9wTG9hZCc6XG4gICAgICBjYXNlICd0b3BMb2FkZWREYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRlZE1ldGFkYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRTdGFydCc6XG4gICAgICBjYXNlICd0b3BQYXVzZSc6XG4gICAgICBjYXNlICd0b3BQbGF5JzpcbiAgICAgIGNhc2UgJ3RvcFBsYXlpbmcnOlxuICAgICAgY2FzZSAndG9wUHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndG9wUmF0ZUNoYW5nZSc6XG4gICAgICBjYXNlICd0b3BSZXNldCc6XG4gICAgICBjYXNlICd0b3BTZWVrZWQnOlxuICAgICAgY2FzZSAndG9wU2Vla2luZyc6XG4gICAgICBjYXNlICd0b3BTdGFsbGVkJzpcbiAgICAgIGNhc2UgJ3RvcFN1Ym1pdCc6XG4gICAgICBjYXNlICd0b3BTdXNwZW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRpbWVVcGRhdGUnOlxuICAgICAgY2FzZSAndG9wVm9sdW1lQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcFdhaXRpbmcnOlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ2xpY2snOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICBjYXNlICd0b3BNb3VzZU1vdmUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BNb3VzZU91dCc6XG4gICAgICBjYXNlICd0b3BNb3VzZU92ZXInOlxuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BEcmFnJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbmQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VudGVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFeGl0JzpcbiAgICAgIGNhc2UgJ3RvcERyYWdMZWF2ZSc6XG4gICAgICBjYXNlICd0b3BEcmFnT3Zlcic6XG4gICAgICBjYXNlICd0b3BEcmFnU3RhcnQnOlxuICAgICAgY2FzZSAndG9wRHJvcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVG91Y2hDYW5jZWwnOlxuICAgICAgY2FzZSAndG9wVG91Y2hFbmQnOlxuICAgICAgY2FzZSAndG9wVG91Y2hNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25FbmQnOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uSXRlcmF0aW9uJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvblN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRyYW5zaXRpb25FbmQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFNjcm9sbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFdoZWVsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29weSc6XG4gICAgICBjYXNlICd0b3BDdXQnOlxuICAgICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IF9wcm9kSW52YXJpYW50KCc4NicsIHRvcExldmVsVHlwZSkgOiB2b2lkIDA7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gICAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAgIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uQ2xpY2snICYmICFpc0ludGVyYWN0aXZlKGluc3QuX3RhZykpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1trZXldKSB7XG4gICAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XSA9IEV2ZW50TGlzdGVuZXIubGlzdGVuKG5vZGUsICdjbGljaycsIGVtcHR5RnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB3aWxsRGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkNsaWNrJyAmJiAhaXNJbnRlcmFjdGl2ZShpbnN0Ll90YWcpKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2tleV07XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlRXZlbnRQbHVnaW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNBbmltYXRpb25FdmVudCwgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNBbmltYXRpb25FdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRm9jdXNFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKCcuL2dldEV2ZW50S2V5Jyk7XG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudENoYXJDb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRLZXkuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljV2hlZWxFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NQ29udGFpbmVySW5mbyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db250YWluZXJJbmZvJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBST09UX0FUVFJfTkFNRSA9IERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUU7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbnZhciBpbnN0YW5jZXNCeVJlYWN0Um9vdElEID0ge307XG5cbi8qKlxuICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAqIHRoYXQncyBub3QgY29tbW9uIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgd2hlcmUgdGhlIHN0cmluZ3MgZGl2ZXJnZVxuICovXG5mdW5jdGlvbiBmaXJzdERpZmZlcmVuY2VJbmRleChzdHJpbmcxLCBzdHJpbmcyKSB7XG4gIHZhciBtaW5MZW4gPSBNYXRoLm1pbihzdHJpbmcxLmxlbmd0aCwgc3RyaW5nMi5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgaWYgKHN0cmluZzEuY2hhckF0KGkpICE9PSBzdHJpbmcyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmcxLmxlbmd0aCA9PT0gc3RyaW5nMi5sZW5ndGggPyAtMSA6IG1pbkxlbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXG4gKiBhIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7Pyp9IERPTSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgdGhlIHJlYWN0Um9vdCBJRCwgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEdldElEKG5vZGUpIHtcbiAgLy8gSWYgbm9kZSBpcyBzb21ldGhpbmcgbGlrZSBhIHdpbmRvdywgZG9jdW1lbnQsIG9yIHRleHQgbm9kZSwgbm9uZSBvZlxuICAvLyB3aGljaCBzdXBwb3J0IGF0dHJpYnV0ZXMgb3IgYSAuZ2V0QXR0cmlidXRlIG1ldGhvZCwgZ3JhY2VmdWxseSByZXR1cm5cbiAgLy8gdGhlIGVtcHR5IHN0cmluZywgYXMgaWYgdGhlIGF0dHJpYnV0ZSB3ZXJlIG1pc3NpbmcuXG4gIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpIHx8ICcnO1xufVxuXG4vKipcbiAqIE1vdW50cyB0aGlzIGNvbXBvbmVudCBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gbW91bnRDb21wb25lbnRJbnRvTm9kZSh3cmFwcGVySW5zdGFuY2UsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciBtYXJrZXJOYW1lO1xuICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XG4gICAgdmFyIHdyYXBwZWRFbGVtZW50ID0gd3JhcHBlckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5wcm9wcy5jaGlsZDtcbiAgICB2YXIgdHlwZSA9IHdyYXBwZWRFbGVtZW50LnR5cGU7XG4gICAgbWFya2VyTmFtZSA9ICdSZWFjdCBtb3VudDogJyArICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUpO1xuICAgIGNvbnNvbGUudGltZShtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQod3JhcHBlckluc3RhbmNlLCB0cmFuc2FjdGlvbiwgbnVsbCwgUmVhY3RET01Db250YWluZXJJbmZvKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyKSwgY29udGV4dCwgMCAvKiBwYXJlbnREZWJ1Z0lEICovXG4gICk7XG5cbiAgaWYgKG1hcmtlck5hbWUpIHtcbiAgICBjb25zb2xlLnRpbWVFbmQobWFya2VyTmFtZSk7XG4gIH1cblxuICB3cmFwcGVySW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50Ll90b3BMZXZlbFdyYXBwZXIgPSB3cmFwcGVySW5zdGFuY2U7XG4gIFJlYWN0TW91bnQuX21vdW50SW1hZ2VJbnRvTm9kZShtYXJrdXAsIGNvbnRhaW5lciwgd3JhcHBlckluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIEJhdGNoZWQgbW91bnQuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiB1c2VDcmVhdGVFbGVtZW50ICovXG4gICFzaG91bGRSZXVzZU1hcmt1cCAmJiBSZWFjdERPTUZlYXR1cmVGbGFncy51c2VDcmVhdGVFbGVtZW50KTtcbiAgdHJhbnNhY3Rpb24ucGVyZm9ybShtb3VudENvbXBvbmVudEludG9Ob2RlLCBudWxsLCBjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5zdGFuY2UgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gdW5tb3VudCBmcm9tLlxuICogQGZpbmFsXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge1JlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEZyb21Ob2RlKGluc3RhbmNlLCBjb250YWluZXIsIHNhZmVseSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2goKTtcbiAgfVxuICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChpbnN0YW5jZSwgc2FmZWx5KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRGbHVzaCgpO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbXB0eWluZy1hLW5vZGVcbiAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBoYXMgYSBkaXJlY3QgUmVhY3QtcmVuZGVyZWQgY2hpbGQgdGhhdCBpc1xuICogbm90IGEgUmVhY3Qgcm9vdCBlbGVtZW50LiBVc2VmdWwgZm9yIHdhcm5pbmcgaW4gYHJlbmRlcmAsXG4gKiBgdW5tb3VudENvbXBvbmVudEF0Tm9kZWAsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBjb250YWlucyBhIGRpcmVjdCBjaGlsZCB0aGF0IHdhc1xuICogcmVuZGVyZWQgYnkgUmVhY3QgYnV0IGlzIG5vdCBhIHJvb3QgZWxlbWVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICBpZiAocm9vdEVsKSB7XG4gICAgdmFyIGluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICAgIHJldHVybiAhIShpbnN0ICYmIGluc3QuX2hvc3RQYXJlbnQpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSBSZWFjdCBET00gZWxlbWVudCBhbmRcbiAqIGl0IGhhcyBiZWVuIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0XG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbm9kZUlzUmVuZGVyZWRCeU90aGVySW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbCAmJiBpc1JlYWN0Tm9kZShyb290RWwpICYmICFSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSk7XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBSZWFjdCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgUmVhY3QgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNSZWFjdE5vZGUobm9kZSkge1xuICByZXR1cm4gaXNWYWxpZENvbnRhaW5lcihub2RlKSAmJiAobm9kZS5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgdmFyIHByZXZIb3N0SW5zdGFuY2UgPSByb290RWwgJiYgUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcbiAgcmV0dXJuIHByZXZIb3N0SW5zdGFuY2UgJiYgIXByZXZIb3N0SW5zdGFuY2UuX2hvc3RQYXJlbnQgPyBwcmV2SG9zdEluc3RhbmNlIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIHZhciByb290ID0gZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290ID8gcm9vdC5faG9zdENvbnRhaW5lckluZm8uX3RvcExldmVsV3JhcHBlciA6IG51bGw7XG59XG5cbi8qKlxuICogVGVtcG9yYXJ5ICg/KSBoYWNrIHNvIHRoYXQgd2UgY2FuIHN0b3JlIGFsbCB0b3AtbGV2ZWwgcGVuZGluZyB1cGRhdGVzIG9uXG4gKiBjb21wb3NpdGVzIGluc3RlYWQgb2YgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IGRpZmZlcmVudCB0eXBlcyBvZiBjb21wb25lbnRzXG4gKiBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxSb290Q291bnRlciA9IDE7XG52YXIgVG9wTGV2ZWxXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJvb3RJRCA9IHRvcExldmVsUm9vdENvdW50ZXIrKztcbn07XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRvcExldmVsV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdUb3BMZXZlbFdyYXBwZXInO1xufVxuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkO1xufTtcblRvcExldmVsV3JhcHBlci5pc1JlYWN0VG9wTGV2ZWxXcmFwcGVyID0gdHJ1ZTtcblxuLyoqXG4gKiBNb3VudGluZyBpcyB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgYSBSZWFjdCBjb21wb25lbnQgYnkgY3JlYXRpbmcgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlcihcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuXG4gIFRvcExldmVsV3JhcHBlcjogVG9wTGV2ZWxXcmFwcGVyLFxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGRldnRvb2xzLiBUaGUga2V5cyBhcmUgbm90IGltcG9ydGFudC5cbiAgICovXG4gIF9pbnN0YW5jZXNCeVJlYWN0Um9vdElEOiBpbnN0YW5jZXNCeVJlYWN0Um9vdElELFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaG9vayBwcm92aWRlZCB0byBzdXBwb3J0IHJlbmRlcmluZyBSZWFjdCBjb21wb25lbnRzIHdoaWxlXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFwcGFyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiBpdHMgYGNvbnRhaW5lcmAgZG9lcyBub3RcbiAgICogY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBUaGUgYGNvbnRhaW5lcmAgYmVpbmcgcmVuZGVyZWQgaW50by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVuZGVyQ2FsbGJhY2sgVGhpcyBtdXN0IGJlIGNhbGxlZCBvbmNlIHRvIGRvIHRoZSByZW5kZXIuXG4gICAqL1xuICBzY3JvbGxNb25pdG9yOiBmdW5jdGlvbiAoY29udGFpbmVyLCByZW5kZXJDYWxsYmFjaykge1xuICAgIHJlbmRlckNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRha2UgYSBjb21wb25lbnQgdGhhdCdzIGFscmVhZHkgbW91bnRlZCBpbnRvIHRoZSBET00gYW5kIHJlcGxhY2UgaXRzIHByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHByZXZDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIGFscmVhZHkgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqL1xuICBfdXBkYXRlUm9vdENvbXBvbmVudDogZnVuY3Rpb24gKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0TW91bnQuc2Nyb2xsTW9uaXRvcihjb250YWluZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwocHJldkNvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByZXZDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBjb21wb25lbnQgaW50byB0aGUgRE9NLiBIb29rZWQgYnkgaG9va3MhXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBlbGVtZW50IHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBpZiB3ZSBzaG91bGQgc2tpcCB0aGUgbWFya3VwIGluc2VydGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudFxuICAgKi9cbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tICcgKyAncmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ19yZWdpc3RlckNvbXBvbmVudCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM3JykgOiB2b2lkIDA7XG5cbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nKCk7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgZmFsc2UpO1xuXG4gICAgLy8gVGhlIGluaXRpYWwgcmVuZGVyIGlzIHN5bmNocm9ub3VzIGJ1dCBhbnkgdXBkYXRlcyB0aGF0IGhhcHBlbiBkdXJpbmdcbiAgICAvLyByZW5kZXJpbmcsIGluIGNvbXBvbmVudFdpbGxNb3VudCBvciBjb21wb25lbnREaWRNb3VudCwgd2lsbCBiZSBiYXRjaGVkXG4gICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGJhdGNoaW5nIHN0cmF0ZWd5LlxuXG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlLCBjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG5cbiAgICB2YXIgd3JhcHBlcklEID0gY29tcG9uZW50SW5zdGFuY2UuX2luc3RhbmNlLnJvb3RJRDtcbiAgICBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3dyYXBwZXJJRF0gPSBjb21wb25lbnRJbnN0YW5jZTtcblxuICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcGFyZW50Q29tcG9uZW50IFRoZSBjb25jZXB0dWFsIHBhcmVudCBvZiB0aGlzIHJlbmRlciB0cmVlLlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIFJlYWN0SW5zdGFuY2VNYXAuaGFzKHBhcmVudENvbXBvbmVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMzgnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgJ1JlYWN0RE9NLnJlbmRlcicpO1xuICAgICFSZWFjdC5pc1ZhbGlkRWxlbWVudChuZXh0RWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00ucmVuZGVyKCk6IEludmFsaWQgY29tcG9uZW50IGVsZW1lbnQuJXMnLCB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdzdHJpbmcnID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBzdHJpbmcgbGlrZSBcXCdkaXZcXCcsIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KFxcJ2RpdlxcJykgb3IgPGRpdiAvPi4nIDogdHlwZW9mIG5leHRFbGVtZW50ID09PSAnZnVuY3Rpb24nID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBjbGFzcyBsaWtlIEZvbywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vKSBvciA8Rm9vIC8+LicgOlxuICAgIC8vIENoZWNrIGlmIGl0IHF1YWNrcyBsaWtlIGFuIGVsZW1lbnRcbiAgICBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IF9wcm9kSW52YXJpYW50KCczOScsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6IG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogdm9pZCAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBuZXh0V3JhcHBlZEVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFRvcExldmVsV3JhcHBlciwgeyBjaGlsZDogbmV4dEVsZW1lbnQgfSk7XG5cbiAgICB2YXIgbmV4dENvbnRleHQ7XG4gICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgdmFyIHBhcmVudEluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwYXJlbnRDb21wb25lbnQpO1xuICAgICAgbmV4dENvbnRleHQgPSBwYXJlbnRJbnN0Ll9wcm9jZXNzQ2hpbGRDb250ZXh0KHBhcmVudEluc3QuX2NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGVtcHR5T2JqZWN0O1xuICAgIH1cblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKTtcblxuICAgIGlmIChwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJldldyYXBwZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2V3JhcHBlZEVsZW1lbnQucHJvcHMuY2hpbGQ7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICB2YXIgcHVibGljSW5zdCA9IHByZXZDb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgICAgIHZhciB1cGRhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjayAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChwdWJsaWNJbnN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RNb3VudC5fdXBkYXRlUm9vdENvbXBvbmVudChwcmV2Q29tcG9uZW50LCBuZXh0V3JhcHBlZEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIHVwZGF0ZWRDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwdWJsaWNJbnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0Um9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVySGFzUmVhY3RNYXJrdXAgPSByZWFjdFJvb3RFbGVtZW50ICYmICEhaW50ZXJuYWxHZXRJRChyZWFjdFJvb3RFbGVtZW50KTtcbiAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmICghY29udGFpbmVySGFzUmVhY3RNYXJrdXAgfHwgcmVhY3RSb290RWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRTaWJsaW5nID0gcmVhY3RSb290RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHJvb3RFbGVtZW50U2libGluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3RFbGVtZW50U2libGluZyA9IHJvb3RFbGVtZW50U2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaG91bGRSZXVzZU1hcmt1cCA9IGNvbnRhaW5lckhhc1JlYWN0TWFya3VwICYmICFwcmV2Q29tcG9uZW50ICYmICFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZDtcbiAgICB2YXIgY29tcG9uZW50ID0gUmVhY3RNb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudChuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIG5leHRDb250ZXh0KS5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20ucmVuZGVyXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFuZCBkZXN0cm95cyB0aGUgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGluIHRoZSBgY29udGFpbmVyYC5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLnVubW91bnRjb21wb25lbnRhdG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgY29udGFpbmluZyBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGNvbXBvbmVudCB3YXMgZm91bmQgaW4gYW5kIHVubW91bnRlZCBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgIGBjb250YWluZXJgXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoU3RyaWN0bHkgc3BlYWtpbmcsIHVubW91bnRpbmcgd29uJ3QgY2F1c2UgYVxuICAgIC8vIHJlbmRlciBidXQgd2Ugc3RpbGwgZG9uJ3QgZXhwZWN0IHRvIGJlIGluIGEgcmVuZGVyIGNhbGwgaGVyZS4pXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciAnICsgJ2lzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0MCcpIDogdm9pZCAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgJyArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICBpZiAoIXByZXZDb21wb25lbnQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGJlaW5nIHVubW91bnRlZCB3YXMgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCBpc24ndCBhXG4gICAgICAvLyByb290IG5vZGUuXG4gICAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSAmJiBjb250YWluZXIuaGFzQXR0cmlidXRlKFJPT1RfQVRUUl9OQU1FKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgJyArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3ByZXZDb21wb25lbnQuX2luc3RhbmNlLnJvb3RJRF07XG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHVubW91bnRDb21wb25lbnRGcm9tTm9kZSwgcHJldkNvbXBvbmVudCwgY29udGFpbmVyLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogZnVuY3Rpb24gKG1hcmt1cCwgY29udGFpbmVyLCBpbnN0YW5jZSwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKSB7XG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtb3VudENvbXBvbmVudEludG9Ob2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IHZhbGlkLicpIDogX3Byb2RJbnZhcmlhbnQoJzQxJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgaWYgKFJlYWN0TWFya3VwQ2hlY2tzdW0uY2FuUmV1c2VNYXJrdXAobWFya3VwLCByb290RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZShpbnN0YW5jZSwgcm9vdEVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSByb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgICAgICByb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuXG4gICAgICAgIHZhciByb290TWFya3VwID0gcm9vdEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUsIGNoZWNrc3VtKTtcblxuICAgICAgICB2YXIgbm9ybWFsaXplZE1hcmt1cCA9IG1hcmt1cDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBiZWNhdXNlIHJvb3RNYXJrdXAgaXMgcmV0cmlldmVkIGZyb20gdGhlIERPTSwgdmFyaW91cyBub3JtYWxpemF0aW9uc1xuICAgICAgICAgIC8vIHdpbGwgaGF2ZSBvY2N1cnJlZCB3aGljaCB3aWxsIG5vdCBiZSBwcmVzZW50IGluIGBtYXJrdXBgLiBIZXJlLFxuICAgICAgICAgIC8vIGluc2VydCBtYXJrdXAgaW50byBhIDxkaXY+IG9yIDxpZnJhbWU+IGRlcGVuZGluZyBvbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgLy8gdHlwZSB0byBwZXJmb3JtIHRoZSBzYW1lIG5vcm1hbGl6YXRpb25zIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZXI7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuaW5uZXJIVE1MID0gbWFya3VwO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuaW5uZXJIVE1MO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQud3JpdGUobWFya3VwKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZkluZGV4ID0gZmlyc3REaWZmZXJlbmNlSW5kZXgobm9ybWFsaXplZE1hcmt1cCwgcm9vdE1hcmt1cCk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gJyAoY2xpZW50KSAnICsgbm9ybWFsaXplZE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKSArICdcXG4gKHNlcnZlcikgJyArIHJvb3RNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCk7XG5cbiAgICAgICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgYnV0IHRoZSBjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSByZW5kZXJlZCBhIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZSBvciBwcm9wcyBvbiB0aGUgY2xpZW50IGZyb20gdGhlIG9uZSBvbiB0aGUgc2VydmVyLCBvciB5b3VyIHJlbmRlcigpIG1ldGhvZHMgYXJlIGltcHVyZS4gUmVhY3QgY2Fubm90IGhhbmRsZSB0aGlzIGNhc2UgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGJ5IHJlbmRlcmluZyBhdCB0aGUgZG9jdW1lbnQgcm9vdC4gWW91IHNob3VsZCBsb29rIGZvciBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY29kZSBpbiB5b3VyIGNvbXBvbmVudHMgYW5kIGVuc3VyZSB0aGUgcHJvcHMgYXJlIHRoZSBzYW1lIGNsaWVudCBhbmQgc2VydmVyIHNpZGU6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IF9wcm9kSW52YXJpYW50KCc0MicsIGRpZmZlcmVuY2UpIDogdm9pZCAwO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdCBhdHRlbXB0ZWQgdG8gcmV1c2UgbWFya3VwIGluIGEgY29udGFpbmVyIGJ1dCB0aGUgJyArICdjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCB5b3UgYXJlICcgKyAndXNpbmcgc2VydmVyIHJlbmRlcmluZyBhbmQgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlICcgKyAnc2VydmVyIHdhcyBub3Qgd2hhdCB0aGUgY2xpZW50IHdhcyBleHBlY3RpbmcuIFJlYWN0IGluamVjdGVkICcgKyAnbmV3IG1hcmt1cCB0byBjb21wZW5zYXRlIHdoaWNoIHdvcmtzIGJ1dCB5b3UgaGF2ZSBsb3N0IG1hbnkgJyArICdvZiB0aGUgYmVuZWZpdHMgb2Ygc2VydmVyIHJlbmRlcmluZy4gSW5zdGVhZCwgZmlndXJlIG91dCAnICsgJ3doeSB0aGUgbWFya3VwIGJlaW5nIGdlbmVyYXRlZCBpcyBkaWZmZXJlbnQgb24gdGhlIGNsaWVudCAnICsgJ29yIHNlcnZlcjpcXG4lcycsIGRpZmZlcmVuY2UpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IGJ1dCB5b3UgZGlkblxcJ3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFdlIGNhblxcJ3QgZG8gdGhpcyB3aXRob3V0IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IF9wcm9kSW52YXJpYW50KCc0MycpIDogdm9pZCAwO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIERPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUoY29udGFpbmVyLCBtYXJrdXAsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBtYXJrdXApO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZShpbnN0YW5jZSwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaG9zdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICBpZiAoaG9zdE5vZGUuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgaW5zdGFuY2VJRDogaG9zdE5vZGUuX2RlYnVnSUQsXG4gICAgICAgICAgdHlwZTogJ21vdW50JyxcbiAgICAgICAgICBwYXlsb2FkOiBtYXJrdXAudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvUmVhY3RNb3VudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG5cbmZ1bmN0aW9uIFJlYWN0RE9NQ29udGFpbmVySW5mbyh0b3BMZXZlbFdyYXBwZXIsIG5vZGUpIHtcbiAgdmFyIGluZm8gPSB7XG4gICAgX3RvcExldmVsV3JhcHBlcjogdG9wTGV2ZWxXcmFwcGVyLFxuICAgIF9pZENvdW50ZXI6IDEsXG4gICAgX293bmVyRG9jdW1lbnQ6IG5vZGUgPyBub2RlLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFID8gbm9kZSA6IG5vZGUub3duZXJEb2N1bWVudCA6IG51bGwsXG4gICAgX25vZGU6IG5vZGUsXG4gICAgX3RhZzogbm9kZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGwsXG4gICAgX25hbWVzcGFjZVVSSTogbm9kZSA/IG5vZGUubmFtZXNwYWNlVVJJIDogbnVsbFxuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluZm8uX2FuY2VzdG9ySW5mbyA9IG5vZGUgPyB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCBpbmZvLl90YWcsIG51bGwpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbnRhaW5lckluZm87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29udGFpbmVySW5mby5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHtcbiAgdXNlQ3JlYXRlRWxlbWVudDogdHJ1ZSxcbiAgdXNlRmliZXI6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmVhdHVyZUZsYWdzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG5cbnZhciBUQUdfRU5EID0gL1xcLz8+LztcbnZhciBDT01NRU5UX1NUQVJUID0gL148XFwhXFwtXFwtLztcblxudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSB7XG4gIENIRUNLU1VNX0FUVFJfTkFNRTogJ2RhdGEtcmVhY3QtY2hlY2tzdW0nLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCBzdHJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nIHdpdGggY2hlY2tzdW0gYXR0cmlidXRlIGF0dGFjaGVkXG4gICAqL1xuICBhZGRDaGVja3N1bVRvTWFya3VwOiBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIGNoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuXG4gICAgLy8gQWRkIGNoZWNrc3VtIChoYW5kbGUgYm90aCBwYXJlbnQgdGFncywgY29tbWVudHMgYW5kIHNlbGYtY2xvc2luZyB0YWdzKVxuICAgIGlmIChDT01NRU5UX1NUQVJULnRlc3QobWFya3VwKSkge1xuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1hcmt1cC5yZXBsYWNlKFRBR19FTkQsICcgJyArIFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FICsgJz1cIicgKyBjaGVja3N1bSArICdcIiQmJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIHRvIHVzZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgcm9vdCBSZWFjdCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFya3VwIGlzIHRoZSBzYW1lXG4gICAqL1xuICBjYW5SZXVzZU1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCwgZWxlbWVudCkge1xuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiAoYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBTaGVldEpTIHZlcnNpb24pIGhhcyBiZWVuIG9wdGltaXplZFxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgbSA9IGwgJiB+MHgzO1xuICB3aGlsZSAoaSA8IG0pIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKGkgKyA0MDk2LCBtKTtcbiAgICBmb3IgKDsgaSA8IG47IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzE1LjQuMSc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0VmVyc2lvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xuXG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGVsZW1lbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLmZpbmRkb21ub2RlXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudHxET01FbGVtZW50fSBjb21wb25lbnRPckVsZW1lbnRcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cblxuICB2YXIgaW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGNvbXBvbmVudE9yRWxlbWVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgaW5zdCA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpO1xuICAgIHJldHVybiBpbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkgOiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRET01Ob2RlIHdhcyBjYWxsZWQgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0NCcpIDogdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IGFwcGVhcnMgdG8gYmUgbmVpdGhlciBSZWFjdENvbXBvbmVudCBub3IgRE9NTm9kZSAoa2V5czogJXMpJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiBfcHJvZEludmFyaWFudCgnNDUnLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRET01Ob2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9maW5kRE9NTm9kZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcblxuZnVuY3Rpb24gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCkge1xuICB2YXIgdHlwZTtcblxuICB3aGlsZSAoKHR5cGUgPSBpbnN0Ll9yZW5kZXJlZE5vZGVUeXBlKSA9PT0gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFKSB7XG4gICAgaW5zdCA9IGluc3QuX3JlbmRlcmVkQ29tcG9uZW50O1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJlYWN0Tm9kZVR5cGVzLkhPU1QpIHtcbiAgICByZXR1cm4gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LWRvbS9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIHJlZjogdHJ1ZSxcblxuICAgIGF1dG9Gb2N1czogdHJ1ZSxcbiAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgdmFsdWVMaW5rOiB0cnVlLFxuICAgIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxuICAgIGNoZWNrZWRMaW5rOiB0cnVlLFxuICAgIGlubmVySFRNTDogdHJ1ZSxcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgb25Gb2N1c0luOiB0cnVlLFxuICAgIG9uRm9jdXNPdXQ6IHRydWVcbiAgfTtcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVhY3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiByZWFjdFByb3BzW25hbWVdIHx8IHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICBpZiAoc3RhbmRhcmROYW1lICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBET00gcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ3Vlc3Mgd2hpY2ggcHJvcCB0aGUgdXNlciBpbnRlbmRlZC5cbiAgICAgIC8vIEl0IGlzIGxpa2VseSB0aGF0IHRoZSB1c2VyIHdhcyBqdXN0IGJsaW5kbHkgc3ByZWFkaW5nL2ZvcndhcmRpbmcgcHJvcHNcbiAgICAgIC8vIENvbXBvbmVudHMgc2hvdWxkIGJlIGNhcmVmdWwgdG8gb25seSByZW5kZXIgdmFsaWQgcHJvcHMvYXR0cmlidXRlcy5cbiAgICAgIC8vIFdhcm5pbmcgd2lsbCBiZSBpbnZva2VkIGluIHdhcm5Vbmtub3duUHJvcGVydGllcyB0byBhbGxvdyBncm91cGluZy5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KGVsZW1lbnQudHlwZSwga2V5LCBkZWJ1Z0lEKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3AgJXMgb24gPCVzPiB0YWcuIFJlbW92ZSB0aGlzIHByb3AgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoZXNlIHByb3BzIGZyb20gdGhlIGVsZW1lbnQuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVua25vd24tcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUuaW5kZXhPZignLScpID49IDAgfHwgZWxlbWVudC5wcm9wcy5pcykge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXMoZGVidWdJRCwgZWxlbWVudCk7XG59XG5cbnZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUgIT09ICdpbnB1dCcgJiYgZWxlbWVudC50eXBlICE9PSAndGV4dGFyZWEnICYmIGVsZW1lbnQudHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQucHJvcHMgIT0gbnVsbCAmJiBlbGVtZW50LnByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgdGhlIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcblxuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICB9XG59XG5cbnZhciBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1kb20vbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XG4gIGlmICh3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KGVsZW1lbnQudHlwZSwga2V5LCBkZWJ1Z0lEKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC50eXBlLmluZGV4T2YoJy0nKSA+PSAwIHx8IGVsZW1lbnQucHJvcHMuaXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyhkZWJ1Z0lELCBlbGVtZW50KTtcbn1cblxudmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rID0ge1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW52YWxpZEFSSUFIb29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3QtZG9tL2xpYi9SZWFjdERPTUludmFsaWRBUklBSG9vay5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGV4cG9ydHMuaGFzaEhpc3RvcnkgPSBleHBvcnRzLmJyb3dzZXJIaXN0b3J5ID0gZXhwb3J0cy5hcHBseVJvdXRlck1pZGRsZXdhcmUgPSBleHBvcnRzLmZvcm1hdFBhdHRlcm4gPSBleHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBleHBvcnRzLm1hdGNoID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IGV4cG9ydHMuUm91dGVyQ29udGV4dCA9IGV4cG9ydHMuY3JlYXRlUm91dGVzID0gZXhwb3J0cy5Sb3V0ZSA9IGV4cG9ydHMuUmVkaXJlY3QgPSBleHBvcnRzLkluZGV4Um91dGUgPSBleHBvcnRzLkluZGV4UmVkaXJlY3QgPSBleHBvcnRzLndpdGhSb3V0ZXIgPSBleHBvcnRzLkluZGV4TGluayA9IGV4cG9ydHMuTGluayA9IGV4cG9ydHMuUm91dGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVSb3V0ZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXM7XG4gIH1cbn0pO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnbG9jYXRpb25TaGFwZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Qcm9wVHlwZXMubG9jYXRpb25TaGFwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JvdXRlclNoYXBlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZTtcbiAgfVxufSk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRQYXR0ZXJuJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuO1xuICB9XG59KTtcblxudmFyIF9Sb3V0ZXIyID0gcmVxdWlyZSgnLi9Sb3V0ZXInKTtcblxudmFyIF9Sb3V0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyMik7XG5cbnZhciBfTGluazIgPSByZXF1aXJlKCcuL0xpbmsnKTtcblxudmFyIF9MaW5rMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmsyKTtcblxudmFyIF9JbmRleExpbmsyID0gcmVxdWlyZSgnLi9JbmRleExpbmsnKTtcblxudmFyIF9JbmRleExpbmszID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhMaW5rMik7XG5cbnZhciBfd2l0aFJvdXRlcjIgPSByZXF1aXJlKCcuL3dpdGhSb3V0ZXInKTtcblxudmFyIF93aXRoUm91dGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dpdGhSb3V0ZXIyKTtcblxudmFyIF9JbmRleFJlZGlyZWN0MiA9IHJlcXVpcmUoJy4vSW5kZXhSZWRpcmVjdCcpO1xuXG52YXIgX0luZGV4UmVkaXJlY3QzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhSZWRpcmVjdDIpO1xuXG52YXIgX0luZGV4Um91dGUyID0gcmVxdWlyZSgnLi9JbmRleFJvdXRlJyk7XG5cbnZhciBfSW5kZXhSb3V0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJvdXRlMik7XG5cbnZhciBfUmVkaXJlY3QyID0gcmVxdWlyZSgnLi9SZWRpcmVjdCcpO1xuXG52YXIgX1JlZGlyZWN0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0Mik7XG5cbnZhciBfUm91dGUyID0gcmVxdWlyZSgnLi9Sb3V0ZScpO1xuXG52YXIgX1JvdXRlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlMik7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQyKTtcblxudmFyIF9tYXRjaDIgPSByZXF1aXJlKCcuL21hdGNoJyk7XG5cbnZhciBfbWF0Y2gzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2gyKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IHJlcXVpcmUoJy4vdXNlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVySGlzdG9yeTIpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTIgPSByZXF1aXJlKCcuL2FwcGx5Um91dGVyTWlkZGxld2FyZScpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseVJvdXRlck1pZGRsZXdhcmUyKTtcblxudmFyIF9icm93c2VySGlzdG9yeTIgPSByZXF1aXJlKCcuL2Jyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfYnJvd3Nlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJvd3Nlckhpc3RvcnkyKTtcblxudmFyIF9oYXNoSGlzdG9yeTIgPSByZXF1aXJlKCcuL2hhc2hIaXN0b3J5Jyk7XG5cbnZhciBfaGFzaEhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzaEhpc3RvcnkyKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLlJvdXRlciA9IF9Sb3V0ZXIzLmRlZmF1bHQ7IC8qIGNvbXBvbmVudHMgKi9cblxuZXhwb3J0cy5MaW5rID0gX0xpbmszLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4TGluayA9IF9JbmRleExpbmszLmRlZmF1bHQ7XG5leHBvcnRzLndpdGhSb3V0ZXIgPSBfd2l0aFJvdXRlcjMuZGVmYXVsdDtcblxuLyogY29tcG9uZW50cyAoY29uZmlndXJhdGlvbikgKi9cblxuZXhwb3J0cy5JbmRleFJlZGlyZWN0ID0gX0luZGV4UmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4Um91dGUgPSBfSW5kZXhSb3V0ZTMuZGVmYXVsdDtcbmV4cG9ydHMuUmVkaXJlY3QgPSBfUmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlID0gX1JvdXRlMy5kZWZhdWx0O1xuXG4vKiB1dGlscyAqL1xuXG5leHBvcnRzLlJvdXRlckNvbnRleHQgPSBfUm91dGVyQ29udGV4dDMuZGVmYXVsdDtcbmV4cG9ydHMubWF0Y2ggPSBfbWF0Y2gzLmRlZmF1bHQ7XG5leHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBfdXNlUm91dGVySGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuYXBwbHlSb3V0ZXJNaWRkbGV3YXJlID0gX2FwcGx5Um91dGVyTWlkZGxld2FyZTMuZGVmYXVsdDtcblxuLyogaGlzdG9yaWVzICovXG5cbmV4cG9ydHMuYnJvd3Nlckhpc3RvcnkgPSBfYnJvd3Nlckhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmhhc2hIaXN0b3J5ID0gX2hhc2hIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gX2NyZWF0ZU1lbW9yeUhpc3RvcnkzLmRlZmF1bHQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmlzUmVhY3RDaGlsZHJlbiA9IGlzUmVhY3RDaGlsZHJlbjtcbmV4cG9ydHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50ID0gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuO1xuZXhwb3J0cy5jcmVhdGVSb3V0ZXMgPSBjcmVhdGVSb3V0ZXM7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNWYWxpZENoaWxkKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KG9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzUmVhY3RDaGlsZHJlbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzVmFsaWRDaGlsZChvYmplY3QpIHx8IEFycmF5LmlzQXJyYXkob2JqZWN0KSAmJiBvYmplY3QuZXZlcnkoaXNWYWxpZENoaWxkKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGUoZGVmYXVsdFByb3BzLCBwcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRQcm9wcywgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIHJvdXRlID0gY3JlYXRlUm91dGUodHlwZS5kZWZhdWx0UHJvcHMsIGVsZW1lbnQucHJvcHMpO1xuXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgIHZhciBjaGlsZFJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlLmNoaWxkcmVuLCByb3V0ZSk7XG5cbiAgICBpZiAoY2hpbGRSb3V0ZXMubGVuZ3RoKSByb3V0ZS5jaGlsZFJvdXRlcyA9IGNoaWxkUm91dGVzO1xuXG4gICAgZGVsZXRlIHJvdXRlLmNoaWxkcmVuO1xuICB9XG5cbiAgcmV0dXJuIHJvdXRlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSByb3V0ZXMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIFJlYWN0Q2hpbGRyZW4uIEpTWFxuICogcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byB2aXN1YWxpemUgaG93IHJvdXRlcyBpbiB0aGUgaGllcmFyY2h5IGFyZVxuICogbmVzdGVkLlxuICpcbiAqICAgaW1wb3J0IHsgUm91dGUsIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuIH0gZnJvbSAncmVhY3Qtcm91dGVyJ1xuICpcbiAqICAgY29uc3Qgcm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4oXG4gKiAgICAgPFJvdXRlIGNvbXBvbmVudD17QXBwfT5cbiAqICAgICAgIDxSb3V0ZSBwYXRoPVwiaG9tZVwiIGNvbXBvbmVudD17RGFzaGJvYXJkfS8+XG4gKiAgICAgICA8Um91dGUgcGF0aD1cIm5ld3NcIiBjb21wb25lbnQ9e05ld3NGZWVkfS8+XG4gKiAgICAgPC9Sb3V0ZT5cbiAqICAgKVxuICpcbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgdXNlZCB3aGVuIHlvdSBwcm92aWRlIDxSb3V0ZT4gY2hpbGRyZW5cbiAqIHRvIGEgPFJvdXRlcj4gY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Um91dGUpIHtcbiAgdmFyIHJvdXRlcyA9IFtdO1xuXG4gIF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmIChfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIENvbXBvbmVudCBjbGFzc2VzIG1heSBoYXZlIGEgc3RhdGljIGNyZWF0ZSogbWV0aG9kLlxuICAgICAgaWYgKGVsZW1lbnQudHlwZS5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJvdXRlID0gZWxlbWVudC50eXBlLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSk7XG5cbiAgICAgICAgaWYgKHJvdXRlKSByb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXMucHVzaChjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHJvdXRlcyBmcm9tIHRoZSBnaXZlbiBvYmplY3Qgd2hpY2hcbiAqIG1heSBiZSBhIEpTWCByb3V0ZSwgYSBwbGFpbiBvYmplY3Qgcm91dGUsIG9yIGFuIGFycmF5IG9mIGVpdGhlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzKHJvdXRlcykge1xuICBpZiAoaXNSZWFjdENoaWxkcmVuKHJvdXRlcykpIHtcbiAgICByb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihyb3V0ZXMpO1xuICB9IGVsc2UgaWYgKHJvdXRlcyAmJiAhQXJyYXkuaXNBcnJheShyb3V0ZXMpKSB7XG4gICAgcm91dGVzID0gW3JvdXRlc107XG4gIH1cblxuICByZXR1cm4gcm91dGVzO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5sb2NhdGlvblNoYXBlID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIG9iamVjdCA9IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxuICAgIHNoYXBlID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZSxcbiAgICBzdHJpbmcgPSBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZztcbnZhciByb3V0ZXJTaGFwZSA9IGV4cG9ydHMucm91dGVyU2hhcGUgPSBzaGFwZSh7XG4gIHB1c2g6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVwbGFjZTogZnVuYy5pc1JlcXVpcmVkLFxuICBnbzogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0JhY2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29Gb3J3YXJkOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHNldFJvdXRlTGVhdmVIb29rOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGlzQWN0aXZlOiBmdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG52YXIgbG9jYXRpb25TaGFwZSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IHNoYXBlKHtcbiAgcGF0aG5hbWU6IHN0cmluZy5pc1JlcXVpcmVkLFxuICBzZWFyY2g6IHN0cmluZy5pc1JlcXVpcmVkLFxuICBzdGF0ZTogb2JqZWN0LFxuICBhY3Rpb246IHN0cmluZy5pc1JlcXVpcmVkLFxuICBrZXk6IHN0cmluZ1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL1Byb3BUeXBlcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29tcGlsZVBhdHRlcm4gPSBjb21waWxlUGF0dGVybjtcbmV4cG9ydHMubWF0Y2hQYXR0ZXJuID0gbWF0Y2hQYXR0ZXJuO1xuZXhwb3J0cy5nZXRQYXJhbU5hbWVzID0gZ2V0UGFyYW1OYW1lcztcbmV4cG9ydHMuZ2V0UGFyYW1zID0gZ2V0UGFyYW1zO1xuZXhwb3J0cy5mb3JtYXRQYXR0ZXJuID0gZm9ybWF0UGF0dGVybjtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59XG5cbmZ1bmN0aW9uIF9jb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIHZhciByZWdleHBTb3VyY2UgPSAnJztcbiAgdmFyIHBhcmFtTmFtZXMgPSBbXTtcbiAgdmFyIHRva2VucyA9IFtdO1xuXG4gIHZhciBtYXRjaCA9IHZvaWQgMCxcbiAgICAgIGxhc3RJbmRleCA9IDAsXG4gICAgICBtYXRjaGVyID0gLzooW2EtekEtWl8kXVthLXpBLVowLTlfJF0qKXxcXCpcXCp8XFwqfFxcKHxcXCkvZztcbiAgd2hpbGUgKG1hdGNoID0gbWF0Y2hlci5leGVjKHBhdHRlcm4pKSB7XG4gICAgaWYgKG1hdGNoLmluZGV4ICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVJlZ0V4cChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKFteL10rKSc7XG4gICAgICBwYXJhbU5hbWVzLnB1c2gobWF0Y2hbMV0pO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcqKicpIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKC4qKSc7XG4gICAgICBwYXJhbU5hbWVzLnB1c2goJ3NwbGF0Jyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyonKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyguKj8pJztcbiAgICAgIHBhcmFtTmFtZXMucHVzaCgnc3BsYXQnKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKCcpIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKD86JztcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKScpIHtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSAnKT8nO1xuICAgIH1cblxuICAgIHRva2Vucy5wdXNoKG1hdGNoWzBdKTtcblxuICAgIGxhc3RJbmRleCA9IG1hdGNoZXIubGFzdEluZGV4O1xuICB9XG5cbiAgaWYgKGxhc3RJbmRleCAhPT0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgcGF0dGVybi5sZW5ndGgpKTtcbiAgICByZWdleHBTb3VyY2UgKz0gZXNjYXBlUmVnRXhwKHBhdHRlcm4uc2xpY2UobGFzdEluZGV4LCBwYXR0ZXJuLmxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxuICAgIHJlZ2V4cFNvdXJjZTogcmVnZXhwU291cmNlLFxuICAgIHBhcmFtTmFtZXM6IHBhcmFtTmFtZXMsXG4gICAgdG9rZW5zOiB0b2tlbnNcbiAgfTtcbn1cblxudmFyIENvbXBpbGVkUGF0dGVybnNDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgaWYgKCFDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl0pIENvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXSA9IF9jb21waWxlUGF0dGVybihwYXR0ZXJuKTtcblxuICByZXR1cm4gQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dO1xufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIG1hdGNoIGEgcGF0dGVybiBvbiB0aGUgZ2l2ZW4gcGF0aG5hbWUuIFBhdHRlcm5zIG1heSB1c2VcbiAqIHRoZSBmb2xsb3dpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzOlxuICpcbiAqIC0gOnBhcmFtTmFtZSAgICAgTWF0Y2hlcyBhIFVSTCBzZWdtZW50IHVwIHRvIHRoZSBuZXh0IC8sID8sIG9yICMuIFRoZVxuICogICAgICAgICAgICAgICAgICBjYXB0dXJlZCBzdHJpbmcgaXMgY29uc2lkZXJlZCBhIFwicGFyYW1cIlxuICogLSAoKSAgICAgICAgICAgICBXcmFwcyBhIHNlZ21lbnQgb2YgdGhlIFVSTCB0aGF0IGlzIG9wdGlvbmFsXG4gKiAtICogICAgICAgICAgICAgIENvbnN1bWVzIChub24tZ3JlZWR5KSBhbGwgY2hhcmFjdGVycyB1cCB0byB0aGUgbmV4dFxuICogICAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgaW4gdGhlIHBhdHRlcm4sIG9yIHRvIHRoZSBlbmQgb2YgdGhlIFVSTCBpZlxuICogICAgICAgICAgICAgICAgICB0aGVyZSBpcyBub25lXG4gKiAtICoqICAgICAgICAgICAgIENvbnN1bWVzIChncmVlZHkpIGFsbCBjaGFyYWN0ZXJzIHVwIHRvIHRoZSBuZXh0IGNoYXJhY3RlclxuICogICAgICAgICAgICAgICAgICBpbiB0aGUgcGF0dGVybiwgb3IgdG8gdGhlIGVuZCBvZiB0aGUgVVJMIGlmIHRoZXJlIGlzIG5vbmVcbiAqXG4gKiAgVGhlIGZ1bmN0aW9uIGNhbGxzIGNhbGxiYWNrKGVycm9yLCBtYXRjaGVkKSB3aGVuIGZpbmlzaGVkLlxuICogVGhlIHJldHVybiB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSByZW1haW5pbmdQYXRobmFtZVxuICogLSBwYXJhbU5hbWVzXG4gKiAtIHBhcmFtVmFsdWVzXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwYXRobmFtZSkge1xuICAvLyBFbnN1cmUgcGF0dGVybiBzdGFydHMgd2l0aCBsZWFkaW5nIHNsYXNoIGZvciBjb25zaXN0ZW5jeSB3aXRoIHBhdGhuYW1lLlxuICBpZiAocGF0dGVybi5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIHBhdHRlcm4gPSAnLycgKyBwYXR0ZXJuO1xuICB9XG5cbiAgdmFyIF9jb21waWxlUGF0dGVybjIgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKSxcbiAgICAgIHJlZ2V4cFNvdXJjZSA9IF9jb21waWxlUGF0dGVybjIucmVnZXhwU291cmNlLFxuICAgICAgcGFyYW1OYW1lcyA9IF9jb21waWxlUGF0dGVybjIucGFyYW1OYW1lcyxcbiAgICAgIHRva2VucyA9IF9jb21waWxlUGF0dGVybjIudG9rZW5zO1xuXG4gIGlmIChwYXR0ZXJuLmNoYXJBdChwYXR0ZXJuLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gJy8/JzsgLy8gQWxsb3cgb3B0aW9uYWwgcGF0aCBzZXBhcmF0b3IgYXQgZW5kLlxuICB9XG5cbiAgLy8gU3BlY2lhbC1jYXNlIHBhdHRlcm5zIGxpa2UgJyonIGZvciBjYXRjaC1hbGwgcm91dGVzLlxuICBpZiAodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgcmVnZXhwU291cmNlICs9ICckJztcbiAgfVxuXG4gIHZhciBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG5ldyBSZWdFeHAoJ14nICsgcmVnZXhwU291cmNlLCAnaScpKTtcbiAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXRjaGVkUGF0aCA9IG1hdGNoWzBdO1xuICB2YXIgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIobWF0Y2hlZFBhdGgubGVuZ3RoKTtcblxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUpIHtcbiAgICAvLyBSZXF1aXJlIHRoYXQgdGhlIG1hdGNoIGVuZHMgYXQgYSBwYXRoIHNlcGFyYXRvciwgaWYgd2UgZGlkbid0IG1hdGNoXG4gICAgLy8gdGhlIGZ1bGwgcGF0aCwgc28gYW55IHJlbWFpbmluZyBwYXRobmFtZSBpcyBhIG5ldyBwYXRoIHNlZ21lbnQuXG4gICAgaWYgKG1hdGNoZWRQYXRoLmNoYXJBdChtYXRjaGVkUGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJlbWFpbmluZyBwYXRobmFtZSwgdHJlYXQgdGhlIHBhdGggc2VwYXJhdG9yIGFzIHBhcnQgb2ZcbiAgICAvLyB0aGUgcmVtYWluaW5nIHBhdGhuYW1lIGZvciBwcm9wZXJseSBjb250aW51aW5nIHRoZSBtYXRjaC5cbiAgICByZW1haW5pbmdQYXRobmFtZSA9ICcvJyArIHJlbWFpbmluZ1BhdGhuYW1lO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZW1haW5pbmdQYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWUsXG4gICAgcGFyYW1OYW1lczogcGFyYW1OYW1lcyxcbiAgICBwYXJhbVZhbHVlczogbWF0Y2guc2xpY2UoMSkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdiAmJiBkZWNvZGVVUklDb21wb25lbnQodik7XG4gICAgfSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyYW1OYW1lcyhwYXR0ZXJuKSB7XG4gIHJldHVybiBjb21waWxlUGF0dGVybihwYXR0ZXJuKS5wYXJhbU5hbWVzO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbXMocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHBhdGhuYW1lKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhcmFtTmFtZXMgPSBtYXRjaC5wYXJhbU5hbWVzLFxuICAgICAgcGFyYW1WYWx1ZXMgPSBtYXRjaC5wYXJhbVZhbHVlcztcblxuICB2YXIgcGFyYW1zID0ge307XG5cbiAgcGFyYW1OYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbU5hbWUsIGluZGV4KSB7XG4gICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJhbVZhbHVlc1tpbmRleF07XG4gIH0pO1xuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHZlcnNpb24gb2YgdGhlIGdpdmVuIHBhdHRlcm4gd2l0aCBwYXJhbXMgaW50ZXJwb2xhdGVkLiBUaHJvd3NcbiAqIGlmIHRoZXJlIGlzIGEgZHluYW1pYyBzZWdtZW50IG9mIHRoZSBwYXR0ZXJuIGZvciB3aGljaCB0aGVyZSBpcyBubyBwYXJhbS5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0UGF0dGVybihwYXR0ZXJuLCBwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIHZhciBfY29tcGlsZVBhdHRlcm4zID0gY29tcGlsZVBhdHRlcm4ocGF0dGVybiksXG4gICAgICB0b2tlbnMgPSBfY29tcGlsZVBhdHRlcm4zLnRva2VucztcblxuICB2YXIgcGFyZW5Db3VudCA9IDAsXG4gICAgICBwYXRobmFtZSA9ICcnLFxuICAgICAgc3BsYXRJbmRleCA9IDAsXG4gICAgICBwYXJlbkhpc3RvcnkgPSBbXTtcblxuICB2YXIgdG9rZW4gPSB2b2lkIDAsXG4gICAgICBwYXJhbU5hbWUgPSB2b2lkIDAsXG4gICAgICBwYXJhbVZhbHVlID0gdm9pZCAwO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4gPT09ICcqJyB8fCB0b2tlbiA9PT0gJyoqJykge1xuICAgICAgcGFyYW1WYWx1ZSA9IEFycmF5LmlzQXJyYXkocGFyYW1zLnNwbGF0KSA/IHBhcmFtcy5zcGxhdFtzcGxhdEluZGV4KytdIDogcGFyYW1zLnNwbGF0O1xuXG4gICAgICAhKHBhcmFtVmFsdWUgIT0gbnVsbCB8fCBwYXJlbkNvdW50ID4gMCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnTWlzc2luZyBzcGxhdCAjJXMgZm9yIHBhdGggXCIlc1wiJywgc3BsYXRJbmRleCwgcGF0dGVybikgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocGFyYW1WYWx1ZSAhPSBudWxsKSBwYXRobmFtZSArPSBlbmNvZGVVUkkocGFyYW1WYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJygnKSB7XG4gICAgICBwYXJlbkhpc3RvcnlbcGFyZW5Db3VudF0gPSAnJztcbiAgICAgIHBhcmVuQ291bnQgKz0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKScpIHtcbiAgICAgIHZhciBwYXJlblRleHQgPSBwYXJlbkhpc3RvcnkucG9wKCk7XG4gICAgICBwYXJlbkNvdW50IC09IDE7XG5cbiAgICAgIGlmIChwYXJlbkNvdW50KSBwYXJlbkhpc3RvcnlbcGFyZW5Db3VudCAtIDFdICs9IHBhcmVuVGV4dDtlbHNlIHBhdGhuYW1lICs9IHBhcmVuVGV4dDtcbiAgICB9IGVsc2UgaWYgKHRva2VuLmNoYXJBdCgwKSA9PT0gJzonKSB7XG4gICAgICBwYXJhbU5hbWUgPSB0b2tlbi5zdWJzdHJpbmcoMSk7XG4gICAgICBwYXJhbVZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIFwiJXNcIiBwYXJhbWV0ZXIgZm9yIHBhdGggXCIlc1wiJywgcGFyYW1OYW1lLCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHBhcmVuQ291bnQpIHtcbiAgICAgICAgICBwYXJlbkhpc3RvcnlbcGFyZW5Db3VudCAtIDFdID0gJyc7XG5cbiAgICAgICAgICB2YXIgY3VyVG9rZW5JZHggPSB0b2tlbnMuaW5kZXhPZih0b2tlbik7XG4gICAgICAgICAgdmFyIHRva2Vuc1N1YnNldCA9IHRva2Vucy5zbGljZShjdXJUb2tlbklkeCwgdG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgdmFyIG5leHRQYXJlbklkeCA9IC0xO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRva2Vuc1N1YnNldC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGlmICh0b2tlbnNTdWJzZXRbX2ldID09ICcpJykge1xuICAgICAgICAgICAgICBuZXh0UGFyZW5JZHggPSBfaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgIShuZXh0UGFyZW5JZHggPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdQYXRoIFwiJXNcIiBpcyBtaXNzaW5nIGVuZCBwYXJlbiBhdCBzZWdtZW50IFwiJXNcIicsIHBhdHRlcm4sIHRva2Vuc1N1YnNldC5qb2luKCcnKSkgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICAgICAgLy8ganVtcCB0byBlbmRpbmcgcGFyZW5cbiAgICAgICAgICBpID0gY3VyVG9rZW5JZHggKyBuZXh0UGFyZW5JZHggLSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcmVuQ291bnQpIHBhcmVuSGlzdG9yeVtwYXJlbkNvdW50IC0gMV0gKz0gZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtVmFsdWUpO2Vsc2UgcGF0aG5hbWUgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGFyZW5Db3VudCkgcGFyZW5IaXN0b3J5W3BhcmVuQ291bnQgLSAxXSArPSB0b2tlbjtlbHNlIHBhdGhuYW1lICs9IHRva2VuO1xuICAgIH1cbiAgfVxuXG4gICEocGFyZW5Db3VudCA8PSAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdQYXRoIFwiJXNcIiBpcyBtaXNzaW5nIGVuZCBwYXJlbicsIHBhdHRlcm4pIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICByZXR1cm4gcGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCAnLycpO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9QYXR0ZXJuVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9Sb3V0ZXJVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVyVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMsXG4gICAgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYyxcbiAgICBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBIDxSb3V0ZXI+IGlzIGEgaGlnaC1sZXZlbCBBUEkgZm9yIGF1dG9tYXRpY2FsbHkgc2V0dGluZyB1cFxuICogYSByb3V0ZXIgdGhhdCByZW5kZXJzIGEgPFJvdXRlckNvbnRleHQ+IHdpdGggYWxsIHRoZSBwcm9wc1xuICogaXQgbmVlZHMgZWFjaCB0aW1lIHRoZSBVUkwgY2hhbmdlcy5cbiAqL1xuXG52YXIgUm91dGVyID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZXInLFxuXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMucm91dGVzLFxuICAgIHJvdXRlczogX0ludGVybmFsUHJvcFR5cGVzLnJvdXRlcywgLy8gYWxpYXMgZm9yIGNoaWxkcmVuXG4gICAgcmVuZGVyOiBmdW5jLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmMsXG4gICAgb25FcnJvcjogZnVuYyxcbiAgICBvblVwZGF0ZTogZnVuYyxcblxuICAgIC8vIFBSSVZBVEU6IEZvciBjbGllbnQtc2lkZSByZWh5ZHJhdGlvbiBvZiBzZXJ2ZXIgbWF0Y2guXG4gICAgbWF0Y2hDb250ZXh0OiBvYmplY3RcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3V0ZXJDb250ZXh0Mi5kZWZhdWx0LCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uOiBudWxsLFxuICAgICAgcm91dGVzOiBudWxsLFxuICAgICAgcGFyYW1zOiBudWxsLFxuICAgICAgY29tcG9uZW50czogbnVsbFxuICAgIH07XG4gIH0sXG4gIGhhbmRsZUVycm9yOiBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLnByb3BzLm9uRXJyb3IpIHtcbiAgICAgIHRoaXMucHJvcHMub25FcnJvci5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhyb3cgZXJyb3JzIGJ5IGRlZmF1bHQgc28gd2UgZG9uJ3Qgc2lsZW50bHkgc3dhbGxvdyB0aGVtIVxuICAgICAgdGhyb3cgZXJyb3I7IC8vIFRoaXMgZXJyb3IgcHJvYmFibHkgb2NjdXJyZWQgaW4gZ2V0Q2hpbGRSb3V0ZXMgb3IgZ2V0Q29tcG9uZW50cy5cbiAgICB9XG4gIH0sXG4gIGNyZWF0ZVJvdXRlck9iamVjdDogZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0KHN0YXRlKSB7XG4gICAgdmFyIG1hdGNoQ29udGV4dCA9IHRoaXMucHJvcHMubWF0Y2hDb250ZXh0O1xuXG4gICAgaWYgKG1hdGNoQ29udGV4dCkge1xuICAgICAgcmV0dXJuIG1hdGNoQ29udGV4dC5yb3V0ZXI7XG4gICAgfVxuXG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLnByb3BzLmhpc3Rvcnk7XG5cbiAgICByZXR1cm4gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0ZXJPYmplY3QpKGhpc3RvcnksIHRoaXMudHJhbnNpdGlvbk1hbmFnZXIsIHN0YXRlKTtcbiAgfSxcbiAgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI6IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCkge1xuICAgIHZhciBtYXRjaENvbnRleHQgPSB0aGlzLnByb3BzLm1hdGNoQ29udGV4dDtcblxuICAgIGlmIChtYXRjaENvbnRleHQpIHtcbiAgICAgIHJldHVybiBtYXRjaENvbnRleHQudHJhbnNpdGlvbk1hbmFnZXI7XG4gICAgfVxuXG4gICAgdmFyIGhpc3RvcnkgPSB0aGlzLnByb3BzLmhpc3Rvcnk7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIHJvdXRlcyA9IF9wcm9wcy5yb3V0ZXMsXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuO1xuXG5cbiAgICAhaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnWW91IGhhdmUgcHJvdmlkZWQgYSBoaXN0b3J5IG9iamVjdCBjcmVhdGVkIHdpdGggaGlzdG9yeSB2Mi54IG9yICcgKyAnZWFybGllci4gVGhpcyB2ZXJzaW9uIG9mIFJlYWN0IFJvdXRlciBpcyBvbmx5IGNvbXBhdGlibGUgd2l0aCB2MyAnICsgJ2hpc3Rvcnkgb2JqZWN0cy4gUGxlYXNlIHVwZ3JhZGUgdG8gaGlzdG9yeSB2My54LicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHJldHVybiAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMy5kZWZhdWx0KShoaXN0b3J5LCAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShyb3V0ZXMgfHwgY2hpbGRyZW4pKTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvbk1hbmFnZXIgPSB0aGlzLmNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG4gICAgdGhpcy5yb3V0ZXIgPSB0aGlzLmNyZWF0ZVJvdXRlck9iamVjdCh0aGlzLnN0YXRlKTtcblxuICAgIHRoaXMuX3VubGlzdGVuID0gdGhpcy50cmFuc2l0aW9uTWFuYWdlci5saXN0ZW4oZnVuY3Rpb24gKGVycm9yLCBzdGF0ZSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIF90aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEtlZXAgdGhlIGlkZW50aXR5IG9mIHRoaXMucm91dGVyIGJlY2F1c2Ugb2YgYSBjYXZlYXQgaW4gQ29udGV4dFV0aWxzOlxuICAgICAgICAvLyB0aGV5IG9ubHkgd29yayBpZiB0aGUgb2JqZWN0IGlkZW50aXR5IGlzIHByZXNlcnZlZC5cbiAgICAgICAgKDAsIF9Sb3V0ZXJVdGlscy5hc3NpZ25Sb3V0ZXJTdGF0ZSkoX3RoaXMucm91dGVyLCBzdGF0ZSk7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHN0YXRlLCBfdGhpcy5wcm9wcy5vblVwZGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkobmV4dFByb3BzLmhpc3RvcnkgPT09IHRoaXMucHJvcHMuaGlzdG9yeSwgJ1lvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgaGlzdG9yeT47IGl0IHdpbGwgYmUgaWdub3JlZCcpIDogdm9pZCAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoKG5leHRQcm9wcy5yb3V0ZXMgfHwgbmV4dFByb3BzLmNoaWxkcmVuKSA9PT0gKHRoaXMucHJvcHMucm91dGVzIHx8IHRoaXMucHJvcHMuY2hpbGRyZW4pLCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciByb3V0ZXM+OyBpdCB3aWxsIGJlIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLl91bmxpc3RlbikgdGhpcy5fdW5saXN0ZW4oKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9zdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgIGxvY2F0aW9uID0gX3N0YXRlLmxvY2F0aW9uLFxuICAgICAgICByb3V0ZXMgPSBfc3RhdGUucm91dGVzLFxuICAgICAgICBwYXJhbXMgPSBfc3RhdGUucGFyYW1zLFxuICAgICAgICBjb21wb25lbnRzID0gX3N0YXRlLmNvbXBvbmVudHM7XG5cbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQgPSBfcHJvcHMyLmNyZWF0ZUVsZW1lbnQsXG4gICAgICAgIHJlbmRlciA9IF9wcm9wczIucmVuZGVyLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMyLCBbJ2NyZWF0ZUVsZW1lbnQnLCAncmVuZGVyJ10pO1xuXG4gICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHJldHVybiBudWxsOyAvLyBBc3luYyBtYXRjaFxuXG4gICAgLy8gT25seSBmb3J3YXJkIG5vbi1Sb3V0ZXItc3BlY2lmaWMgcHJvcHMgdG8gcm91dGluZyBjb250ZXh0LCBhcyB0aG9zZSBhcmVcbiAgICAvLyB0aGUgb25seSBvbmVzIHRoYXQgbWlnaHQgYmUgY3VzdG9tIHJvdXRpbmcgY29udGV4dCBwcm9wcy5cbiAgICBPYmplY3Qua2V5cyhSb3V0ZXIucHJvcFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wVHlwZSkge1xuICAgICAgcmV0dXJuIGRlbGV0ZSBwcm9wc1twcm9wVHlwZV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVuZGVyKF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgcm91dGVyOiB0aGlzLnJvdXRlcixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHJvdXRlczogcm91dGVzLFxuICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFxuICAgIH0pKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMiA9IHJlcXVpcmUoJy4vY29tcHV0ZUNoYW5nZWRSb3V0ZXMnKTtcblxudmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wdXRlQ2hhbmdlZFJvdXRlczIpO1xuXG52YXIgX1RyYW5zaXRpb25VdGlscyA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvblV0aWxzJyk7XG5cbnZhciBfaXNBY3RpdmUyID0gcmVxdWlyZSgnLi9pc0FjdGl2ZScpO1xuXG52YXIgX2lzQWN0aXZlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQWN0aXZlMik7XG5cbnZhciBfZ2V0Q29tcG9uZW50cyA9IHJlcXVpcmUoJy4vZ2V0Q29tcG9uZW50cycpO1xuXG52YXIgX2dldENvbXBvbmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Q29tcG9uZW50cyk7XG5cbnZhciBfbWF0Y2hSb3V0ZXMgPSByZXF1aXJlKCcuL21hdGNoUm91dGVzJyk7XG5cbnZhciBfbWF0Y2hSb3V0ZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2hSb3V0ZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBoYXNBbnlQcm9wZXJ0aWVzKG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSkgcmV0dXJuIHRydWU7XG4gIH1yZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKGhpc3RvcnksIHJvdXRlcykge1xuICB2YXIgc3RhdGUgPSB7fTtcblxuICAvLyBTaWduYXR1cmUgc2hvdWxkIGJlIChsb2NhdGlvbiwgaW5kZXhPbmx5KSwgYnV0IG5lZWRzIHRvIHN1cHBvcnQgKHBhdGgsXG4gIC8vIHF1ZXJ5LCBpbmRleE9ubHkpXG4gIGZ1bmN0aW9uIGlzQWN0aXZlKGxvY2F0aW9uLCBpbmRleE9ubHkpIHtcbiAgICBsb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24obG9jYXRpb24pO1xuXG4gICAgcmV0dXJuICgwLCBfaXNBY3RpdmUzLmRlZmF1bHQpKGxvY2F0aW9uLCBpbmRleE9ubHksIHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5yb3V0ZXMsIHN0YXRlLnBhcmFtcyk7XG4gIH1cblxuICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiBtYXRjaChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAocGFydGlhbE5leHRTdGF0ZSAmJiBwYXJ0aWFsTmV4dFN0YXRlLmxvY2F0aW9uID09PSBsb2NhdGlvbikge1xuICAgICAgLy8gQ29udGludWUgZnJvbSB3aGVyZSB3ZSBsZWZ0IG9mZi5cbiAgICAgIGZpbmlzaE1hdGNoKHBhcnRpYWxOZXh0U3RhdGUsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKDAsIF9tYXRjaFJvdXRlczIuZGVmYXVsdCkocm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgICAgIGZpbmlzaE1hdGNoKF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHsgbG9jYXRpb246IGxvY2F0aW9uIH0pLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoTWF0Y2gobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAgIHZhciBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMgPSAoMCwgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMy5kZWZhdWx0KShzdGF0ZSwgbmV4dFN0YXRlKSxcbiAgICAgICAgbGVhdmVSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMubGVhdmVSb3V0ZXMsXG4gICAgICAgIGNoYW5nZVJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5jaGFuZ2VSb3V0ZXMsXG4gICAgICAgIGVudGVyUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmVudGVyUm91dGVzO1xuXG4gICAgKDAsIF9UcmFuc2l0aW9uVXRpbHMucnVuTGVhdmVIb29rcykobGVhdmVSb3V0ZXMsIHN0YXRlKTtcblxuICAgIC8vIFRlYXIgZG93biBjb25maXJtYXRpb24gaG9va3MgZm9yIGxlZnQgcm91dGVzXG4gICAgbGVhdmVSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmV0dXJuIGVudGVyUm91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMTtcbiAgICB9KS5mb3JFYWNoKHJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUpO1xuXG4gICAgLy8gY2hhbmdlIGFuZCBlbnRlciBob29rcyBhcmUgcnVuIGluIHNlcmllc1xuICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkNoYW5nZUhvb2tzKShjaGFuZ2VSb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSByZXR1cm4gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pO1xuXG4gICAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5FbnRlckhvb2tzKShlbnRlclJvdXRlcywgbmV4dFN0YXRlLCBmaW5pc2hFbnRlckhvb2tzKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZpbmlzaEVudGVySG9va3MoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykgcmV0dXJuIGhhbmRsZUVycm9yT3JSZWRpcmVjdChlcnJvciwgcmVkaXJlY3RJbmZvKTtcblxuICAgICAgLy8gVE9ETzogRmV0Y2ggY29tcG9uZW50cyBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgICAgKDAsIF9nZXRDb21wb25lbnRzMi5kZWZhdWx0KShuZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgY29tcG9uZW50cykge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogTWFrZSBtYXRjaCBhIHB1cmUgZnVuY3Rpb24gYW5kIGhhdmUgc29tZSBvdGhlciBBUElcbiAgICAgICAgICAvLyBmb3IgXCJtYXRjaCBhbmQgdXBkYXRlIHN0YXRlXCIuXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgbnVsbCwgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbykge1xuICAgICAgaWYgKGVycm9yKSBjYWxsYmFjayhlcnJvcik7ZWxzZSBjYWxsYmFjayhudWxsLCByZWRpcmVjdEluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBSb3V0ZUd1aWQgPSAxO1xuXG4gIGZ1bmN0aW9uIGdldFJvdXRlSUQocm91dGUpIHtcbiAgICB2YXIgY3JlYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIHJldHVybiByb3V0ZS5fX2lkX18gfHwgY3JlYXRlICYmIChyb3V0ZS5fX2lkX18gPSBSb3V0ZUd1aWQrKyk7XG4gIH1cblxuICB2YXIgUm91dGVIb29rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gZ2V0Um91dGVIb29rc0ZvclJvdXRlcyhyb3V0ZXMpIHtcbiAgICByZXR1cm4gcm91dGVzLm1hcChmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJldHVybiBSb3V0ZUhvb2tzW2dldFJvdXRlSUQocm91dGUpXTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgIHJldHVybiBob29rO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkhvb2sobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgKDAsIF9tYXRjaFJvdXRlczIuZGVmYXVsdCkocm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBuZXh0U3RhdGUpIHtcbiAgICAgIGlmIChuZXh0U3RhdGUgPT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBXZSBkaWRuJ3QgYWN0dWFsbHkgbWF0Y2ggYW55dGhpbmcsIGJ1dCBoYW5nXG4gICAgICAgIC8vIG9udG8gZXJyb3IvbmV4dFN0YXRlIHNvIHdlIGRvbid0IGhhdmUgdG8gbWF0Y2hSb3V0ZXNcbiAgICAgICAgLy8gYWdhaW4gaW4gdGhlIGxpc3RlbiBjYWxsYmFjay5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWNoZSBzb21lIHN0YXRlIGhlcmUgc28gd2UgZG9uJ3QgaGF2ZSB0b1xuICAgICAgLy8gbWF0Y2hSb3V0ZXMoKSBhZ2FpbiBpbiB0aGUgbGlzdGVuIGNhbGxiYWNrLlxuICAgICAgcGFydGlhbE5leHRTdGF0ZSA9IF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHsgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuXG4gICAgICB2YXIgaG9va3MgPSBnZXRSb3V0ZUhvb2tzRm9yUm91dGVzKCgwLCBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMzLmRlZmF1bHQpKHN0YXRlLCBwYXJ0aWFsTmV4dFN0YXRlKS5sZWF2ZVJvdXRlcyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyByZXN1bHQgPT0gbnVsbCAmJiBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgLy8gUGFzc2luZyB0aGUgbG9jYXRpb24gYXJnIGhlcmUgaW5kaWNhdGVzIHRvXG4gICAgICAgIC8vIHRoZSB1c2VyIHRoYXQgdGhpcyBpcyBhIHRyYW5zaXRpb24gaG9vay5cbiAgICAgICAgcmVzdWx0ID0gaG9va3NbaV0obG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHVudGVzdGFibGUgd2l0aCBLYXJtYSAqL1xuICBmdW5jdGlvbiBiZWZvcmVVbmxvYWRIb29rKCkge1xuICAgIC8vIFN5bmNocm9ub3VzbHkgY2hlY2sgdG8gc2VlIGlmIGFueSByb3V0ZSBob29rcyB3YW50XG4gICAgLy8gdG8gcHJldmVudCB0aGUgY3VycmVudCB3aW5kb3cvdGFiIGZyb20gY2xvc2luZy5cbiAgICBpZiAoc3RhdGUucm91dGVzKSB7XG4gICAgICB2YXIgaG9va3MgPSBnZXRSb3V0ZUhvb2tzRm9yUm91dGVzKHN0YXRlLnJvdXRlcyk7XG5cbiAgICAgIHZhciBtZXNzYWdlID0gdm9pZCAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvb2tzLmxlbmd0aDsgdHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyBQYXNzaW5nIG5vIGFyZ3MgaW5kaWNhdGVzIHRvIHRoZSB1c2VyIHRoYXQgdGhpcyBpcyBhXG4gICAgICAgIC8vIGJlZm9yZXVubG9hZCBob29rLiBXZSBkb24ndCBrbm93IHRoZSBuZXh0IGxvY2F0aW9uLlxuICAgICAgICBtZXNzYWdlID0gaG9va3NbaV0oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVubGlzdGVuQmVmb3JlID0gdm9pZCAwLFxuICAgICAgdW5saXN0ZW5CZWZvcmVVbmxvYWQgPSB2b2lkIDA7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZShyb3V0ZSkge1xuICAgIHZhciByb3V0ZUlEID0gZ2V0Um91dGVJRChyb3V0ZSk7XG4gICAgaWYgKCFyb3V0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsZXRlIFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcykpIHtcbiAgICAgIC8vIHRlYXJkb3duIHRyYW5zaXRpb24gJiBiZWZvcmV1bmxvYWQgaG9va3NcbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZSkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZVVubG9hZCkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gaG9vayBmdW5jdGlvbiB0byBydW4gYmVmb3JlIGxlYXZpbmcgdGhlIGdpdmVuIHJvdXRlLlxuICAgKlxuICAgKiBEdXJpbmcgYSBub3JtYWwgdHJhbnNpdGlvbiwgdGhlIGhvb2sgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG5leHQgbG9jYXRpb25cbiAgICogYXMgaXRzIG9ubHkgYXJndW1lbnQgYW5kIGNhbiByZXR1cm4gZWl0aGVyIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykgdG8gc2hvdyB0aGUgdXNlcixcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgd2FudCB0byBsZWF2ZSB0aGUgcGFnZTsgb3IgYGZhbHNlYCwgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICogQW55IG90aGVyIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBEdXJpbmcgdGhlIGJlZm9yZXVubG9hZCBldmVudCAoaW4gYnJvd3NlcnMpIHRoZSBob29rIHJlY2VpdmVzIG5vIGFyZ3VtZW50cy5cbiAgICogSW4gdGhpcyBjYXNlIGl0IG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gdW5iaW5kIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgaG9vaykge1xuICAgIHZhciB0aGVyZVdlcmVOb1JvdXRlSG9va3MgPSAhaGFzQW55UHJvcGVydGllcyhSb3V0ZUhvb2tzKTtcbiAgICB2YXIgcm91dGVJRCA9IGdldFJvdXRlSUQocm91dGUsIHRydWUpO1xuXG4gICAgUm91dGVIb29rc1tyb3V0ZUlEXSA9IGhvb2s7XG5cbiAgICBpZiAodGhlcmVXZXJlTm9Sb3V0ZUhvb2tzKSB7XG4gICAgICAvLyBzZXR1cCB0cmFuc2l0aW9uICYgYmVmb3JldW5sb2FkIGhvb2tzXG4gICAgICB1bmxpc3RlbkJlZm9yZSA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKHRyYW5zaXRpb25Ib29rKTtcblxuICAgICAgaWYgKGhpc3RvcnkubGlzdGVuQmVmb3JlVW5sb2FkKSB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IGhpc3RvcnkubGlzdGVuQmVmb3JlVW5sb2FkKGJlZm9yZVVubG9hZEhvb2spO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIEFQSSBmb3Igc3RhdGVmdWwgZW52aXJvbm1lbnRzLiBBcyB0aGUgbG9jYXRpb25cbiAgICogY2hhbmdlcywgd2UgdXBkYXRlIHN0YXRlIGFuZCBjYWxsIHRoZSBsaXN0ZW5lci4gV2UgY2FuIGFsc29cbiAgICogZ3JhY2VmdWxseSBoYW5kbGUgZXJyb3JzIGFuZCByZWRpcmVjdHMuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBmdW5jdGlvbiBoaXN0b3J5TGlzdGVuZXIobG9jYXRpb24pIHtcbiAgICAgIGlmIChzdGF0ZS5sb2NhdGlvbiA9PT0gbG9jYXRpb24pIHtcbiAgICAgICAgbGlzdGVuZXIobnVsbCwgc3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2gobG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWRpcmVjdExvY2F0aW9uKSB7XG4gICAgICAgICAgICBoaXN0b3J5LnJlcGxhY2UocmVkaXJlY3RMb2NhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKG51bGwsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnTG9jYXRpb24gXCIlc1wiIGRpZCBub3QgbWF0Y2ggYW55IHJvdXRlcycsIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCkgOiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBPbmx5IHVzZSBhIHNpbmdsZSBoaXN0b3J5IGxpc3RlbmVyLiBPdGhlcndpc2Ugd2UnbGwgZW5kIHVwIHdpdGhcbiAgICAvLyBtdWx0aXBsZSBjb25jdXJyZW50IGNhbGxzIHRvIG1hdGNoLlxuXG4gICAgLy8gU2V0IHVwIHRoZSBoaXN0b3J5IGxpc3RlbmVyIGZpcnN0IGluIGNhc2UgdGhlIGluaXRpYWwgbWF0Y2ggcmVkaXJlY3RzLlxuICAgIHZhciB1bnN1YnNjcmliZSA9IGhpc3RvcnkubGlzdGVuKGhpc3RvcnlMaXN0ZW5lcik7XG5cbiAgICBpZiAoc3RhdGUubG9jYXRpb24pIHtcbiAgICAgIC8vIFBpY2tpbmcgdXAgb24gYSBtYXRjaENvbnRleHQuXG4gICAgICBsaXN0ZW5lcihudWxsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpc3RvcnlMaXN0ZW5lcihoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlOiBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJvdXRlcldhcm5pbmc7XG5leHBvcnRzLl9yZXNldFdhcm5lZCA9IF9yZXNldFdhcm5lZDtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciB3YXJuZWQgPSB7fTtcblxuZnVuY3Rpb24gcm91dGVyV2FybmluZyhmYWxzZVRvV2FybiwgbWVzc2FnZSkge1xuICAvLyBPbmx5IGlzc3VlIGRlcHJlY2F0aW9uIHdhcm5pbmdzIG9uY2UuXG4gIGlmIChtZXNzYWdlLmluZGV4T2YoJ2RlcHJlY2F0ZWQnKSAhPT0gLTEpIHtcbiAgICBpZiAod2FybmVkW21lc3NhZ2VdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkW21lc3NhZ2VdID0gdHJ1ZTtcbiAgfVxuXG4gIG1lc3NhZ2UgPSAnW3JlYWN0LXJvdXRlcl0gJyArIG1lc3NhZ2U7XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBfd2FybmluZzIuZGVmYXVsdC5hcHBseSh1bmRlZmluZWQsIFtmYWxzZVRvV2FybiwgbWVzc2FnZV0uY29uY2F0KGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gX3Jlc2V0V2FybmVkKCkge1xuICB3YXJuZWQgPSB7fTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvcm91dGVyV2FybmluZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi93YXJuaW5nL2Jyb3dzZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuZnVuY3Rpb24gcm91dGVQYXJhbXNDaGFuZ2VkKHJvdXRlLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSkge1xuICBpZiAoIXJvdXRlLnBhdGgpIHJldHVybiBmYWxzZTtcblxuICB2YXIgcGFyYW1OYW1lcyA9ICgwLCBfUGF0dGVyblV0aWxzLmdldFBhcmFtTmFtZXMpKHJvdXRlLnBhdGgpO1xuXG4gIHJldHVybiBwYXJhbU5hbWVzLnNvbWUoZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgIHJldHVybiBwcmV2U3RhdGUucGFyYW1zW3BhcmFtTmFtZV0gIT09IG5leHRTdGF0ZS5wYXJhbXNbcGFyYW1OYW1lXTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2YgeyBsZWF2ZVJvdXRlcywgY2hhbmdlUm91dGVzLCBlbnRlclJvdXRlcyB9IGRldGVybWluZWQgYnlcbiAqIHRoZSBjaGFuZ2UgZnJvbSBwcmV2U3RhdGUgdG8gbmV4dFN0YXRlLiBXZSBsZWF2ZSByb3V0ZXMgaWYgZWl0aGVyXG4gKiAxKSB0aGV5IGFyZSBub3QgaW4gdGhlIG5leHQgc3RhdGUgb3IgMikgdGhleSBhcmUgaW4gdGhlIG5leHQgc3RhdGVcbiAqIGJ1dCB0aGVpciBwYXJhbXMgaGF2ZSBjaGFuZ2VkIChpLmUuIC91c2Vycy8xMjMgPT4gL3VzZXJzLzQ1NikuXG4gKlxuICogbGVhdmVSb3V0ZXMgYXJlIG9yZGVyZWQgc3RhcnRpbmcgYXQgdGhlIGxlYWYgcm91dGUgb2YgdGhlIHRyZWVcbiAqIHdlJ3JlIGxlYXZpbmcgdXAgdG8gdGhlIGNvbW1vbiBwYXJlbnQgcm91dGUuIGVudGVyUm91dGVzIGFyZSBvcmRlcmVkXG4gKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHRyZWUgd2UncmUgZW50ZXJpbmcgZG93biB0byB0aGUgbGVhZiByb3V0ZS5cbiAqXG4gKiBjaGFuZ2VSb3V0ZXMgYXJlIGFueSByb3V0ZXMgdGhhdCBkaWRuJ3QgbGVhdmUgb3IgZW50ZXIgZHVyaW5nXG4gKiB0aGUgdHJhbnNpdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUNoYW5nZWRSb3V0ZXMocHJldlN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgdmFyIHByZXZSb3V0ZXMgPSBwcmV2U3RhdGUgJiYgcHJldlN0YXRlLnJvdXRlcztcbiAgdmFyIG5leHRSb3V0ZXMgPSBuZXh0U3RhdGUucm91dGVzO1xuXG4gIHZhciBsZWF2ZVJvdXRlcyA9IHZvaWQgMCxcbiAgICAgIGNoYW5nZVJvdXRlcyA9IHZvaWQgMCxcbiAgICAgIGVudGVyUm91dGVzID0gdm9pZCAwO1xuICBpZiAocHJldlJvdXRlcykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50SXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICBsZWF2ZVJvdXRlcyA9IHByZXZSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAocGFyZW50SXNMZWF2aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlzTGVhdmluZyA9IG5leHRSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xIHx8IHJvdXRlUGFyYW1zQ2hhbmdlZChyb3V0ZSwgcHJldlN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgICAgIGlmIChpc0xlYXZpbmcpIHBhcmVudElzTGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGlzTGVhdmluZztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIG9uTGVhdmUgaG9va3Mgc3RhcnQgYXQgdGhlIGxlYWYgcm91dGUuXG4gICAgICBsZWF2ZVJvdXRlcy5yZXZlcnNlKCk7XG5cbiAgICAgIGVudGVyUm91dGVzID0gW107XG4gICAgICBjaGFuZ2VSb3V0ZXMgPSBbXTtcblxuICAgICAgbmV4dFJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICB2YXIgaXNOZXcgPSBwcmV2Um91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMTtcbiAgICAgICAgdmFyIHBhcmFtc0NoYW5nZWQgPSBsZWF2ZVJvdXRlcy5pbmRleE9mKHJvdXRlKSAhPT0gLTE7XG5cbiAgICAgICAgaWYgKGlzTmV3IHx8IHBhcmFtc0NoYW5nZWQpIGVudGVyUm91dGVzLnB1c2gocm91dGUpO2Vsc2UgY2hhbmdlUm91dGVzLnB1c2gocm91dGUpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICBsZWF2ZVJvdXRlcyA9IFtdO1xuICAgIGNoYW5nZVJvdXRlcyA9IFtdO1xuICAgIGVudGVyUm91dGVzID0gbmV4dFJvdXRlcztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGVhdmVSb3V0ZXM6IGxlYXZlUm91dGVzLFxuICAgIGNoYW5nZVJvdXRlczogY2hhbmdlUm91dGVzLFxuICAgIGVudGVyUm91dGVzOiBlbnRlclJvdXRlc1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjb21wdXRlQ2hhbmdlZFJvdXRlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9jb21wdXRlQ2hhbmdlZFJvdXRlcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucnVuRW50ZXJIb29rcyA9IHJ1bkVudGVySG9va3M7XG5leHBvcnRzLnJ1bkNoYW5nZUhvb2tzID0gcnVuQ2hhbmdlSG9va3M7XG5leHBvcnRzLnJ1bkxlYXZlSG9va3MgPSBydW5MZWF2ZUhvb2tzO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFBlbmRpbmdIb29rcyA9IGZ1bmN0aW9uIFBlbmRpbmdIb29rcygpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVuZGluZ0hvb2tzKTtcblxuICB0aGlzLmhvb2tzID0gW107XG5cbiAgdGhpcy5hZGQgPSBmdW5jdGlvbiAoaG9vaykge1xuICAgIHJldHVybiBfdGhpcy5ob29rcy5wdXNoKGhvb2spO1xuICB9O1xuXG4gIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICByZXR1cm4gX3RoaXMuaG9va3MgPSBfdGhpcy5ob29rcy5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICAgIHJldHVybiBoICE9PSBob29rO1xuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuaGFzID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICByZXR1cm4gX3RoaXMuaG9va3MuaW5kZXhPZihob29rKSAhPT0gLTE7XG4gIH07XG5cbiAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXMuaG9va3MgPSBbXTtcbiAgfTtcbn07XG5cbnZhciBlbnRlckhvb2tzID0gbmV3IFBlbmRpbmdIb29rcygpO1xudmFyIGNoYW5nZUhvb2tzID0gbmV3IFBlbmRpbmdIb29rcygpO1xuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uSG9vayhob29rLCByb3V0ZSwgYXN5bmNBcml0eSwgcGVuZGluZ0hvb2tzKSB7XG4gIHZhciBpc1N5bmMgPSBob29rLmxlbmd0aCA8IGFzeW5jQXJpdHk7XG5cbiAgdmFyIHRyYW5zaXRpb25Ib29rID0gZnVuY3Rpb24gdHJhbnNpdGlvbkhvb2soKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaG9vay5hcHBseShyb3V0ZSwgYXJncyk7XG5cbiAgICBpZiAoaXNTeW5jKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAvLyBBc3N1bWUgaG9vayBleGVjdXRlcyBzeW5jaHJvbm91c2x5IGFuZFxuICAgICAgLy8gYXV0b21hdGljYWxseSBjYWxsIHRoZSBjYWxsYmFjay5cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIHBlbmRpbmdIb29rcy5hZGQodHJhbnNpdGlvbkhvb2spO1xuXG4gIHJldHVybiB0cmFuc2l0aW9uSG9vaztcbn1cblxuZnVuY3Rpb24gZ2V0RW50ZXJIb29rcyhyb3V0ZXMpIHtcbiAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xuICAgIGlmIChyb3V0ZS5vbkVudGVyKSBob29rcy5wdXNoKGNyZWF0ZVRyYW5zaXRpb25Ib29rKHJvdXRlLm9uRW50ZXIsIHJvdXRlLCAzLCBlbnRlckhvb2tzKSk7XG4gICAgcmV0dXJuIGhvb2tzO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIGdldENoYW5nZUhvb2tzKHJvdXRlcykge1xuICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XG4gICAgaWYgKHJvdXRlLm9uQ2hhbmdlKSBob29rcy5wdXNoKGNyZWF0ZVRyYW5zaXRpb25Ib29rKHJvdXRlLm9uQ2hhbmdlLCByb3V0ZSwgNCwgY2hhbmdlSG9va3MpKTtcbiAgICByZXR1cm4gaG9va3M7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gcnVuVHJhbnNpdGlvbkhvb2tzKGxlbmd0aCwgaXRlciwgY2FsbGJhY2spIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWRpcmVjdEluZm8gPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICByZWRpcmVjdEluZm8gPSBsb2NhdGlvbjtcbiAgfVxuXG4gICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKGxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgaXRlcihpbmRleCwgcmVwbGFjZSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICAgIGRvbmUoZXJyb3IsIHJlZGlyZWN0SW5mbyk7IC8vIE5vIG5lZWQgdG8gY29udGludWUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIGFsbCBvbkVudGVyIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXJcbiAqIHdpdGggb25FbnRlcihuZXh0U3RhdGUsIHJlcGxhY2UsIGNhbGxiYWNrKSBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdEluZm8pIHdoZW4gZmluaXNoZWQuIFRoZSBmaXJzdCBob29rXG4gKiB0byB1c2UgcmVwbGFjZSBzaG9ydC1jaXJjdWl0cyB0aGUgbG9vcC5cbiAqXG4gKiBJZiBhIGhvb2sgbmVlZHMgdG8gcnVuIGFzeW5jaHJvbm91c2x5LCBpdCBtYXkgdXNlIHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uIEhvd2V2ZXIsIGRvaW5nIHNvIHdpbGwgY2F1c2UgdGhlIHRyYW5zaXRpb24gdG8gcGF1c2UsXG4gKiB3aGljaCBjb3VsZCBsZWFkIHRvIGEgbm9uLXJlc3BvbnNpdmUgVUkgaWYgdGhlIGhvb2sgaXMgc2xvdy5cbiAqL1xuZnVuY3Rpb24gcnVuRW50ZXJIb29rcyhyb3V0ZXMsIG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgZW50ZXJIb29rcy5jbGVhcigpO1xuICB2YXIgaG9va3MgPSBnZXRFbnRlckhvb2tzKHJvdXRlcyk7XG4gIHJldHVybiBydW5UcmFuc2l0aW9uSG9va3MoaG9va3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2UsIG5leHQpIHtcbiAgICB2YXIgd3JhcHBlZE5leHQgPSBmdW5jdGlvbiB3cmFwcGVkTmV4dCgpIHtcbiAgICAgIGlmIChlbnRlckhvb2tzLmhhcyhob29rc1tpbmRleF0pKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgZW50ZXJIb29rcy5yZW1vdmUoaG9va3NbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhvb2tzW2luZGV4XShuZXh0U3RhdGUsIHJlcGxhY2UsIHdyYXBwZWROZXh0KTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgYWxsIG9uQ2hhbmdlIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXJcbiAqIHdpdGggb25DaGFuZ2UocHJldlN0YXRlLCBuZXh0U3RhdGUsIHJlcGxhY2UsIGNhbGxiYWNrKSBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdEluZm8pIHdoZW4gZmluaXNoZWQuIFRoZSBmaXJzdCBob29rXG4gKiB0byB1c2UgcmVwbGFjZSBzaG9ydC1jaXJjdWl0cyB0aGUgbG9vcC5cbiAqXG4gKiBJZiBhIGhvb2sgbmVlZHMgdG8gcnVuIGFzeW5jaHJvbm91c2x5LCBpdCBtYXkgdXNlIHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uIEhvd2V2ZXIsIGRvaW5nIHNvIHdpbGwgY2F1c2UgdGhlIHRyYW5zaXRpb24gdG8gcGF1c2UsXG4gKiB3aGljaCBjb3VsZCBsZWFkIHRvIGEgbm9uLXJlc3BvbnNpdmUgVUkgaWYgdGhlIGhvb2sgaXMgc2xvdy5cbiAqL1xuZnVuY3Rpb24gcnVuQ2hhbmdlSG9va3Mocm91dGVzLCBzdGF0ZSwgbmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICBjaGFuZ2VIb29rcy5jbGVhcigpO1xuICB2YXIgaG9va3MgPSBnZXRDaGFuZ2VIb29rcyhyb3V0ZXMpO1xuICByZXR1cm4gcnVuVHJhbnNpdGlvbkhvb2tzKGhvb2tzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlLCBuZXh0KSB7XG4gICAgdmFyIHdyYXBwZWROZXh0ID0gZnVuY3Rpb24gd3JhcHBlZE5leHQoKSB7XG4gICAgICBpZiAoY2hhbmdlSG9va3MuaGFzKGhvb2tzW2luZGV4XSkpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBjaGFuZ2VIb29rcy5yZW1vdmUoaG9va3NbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhvb2tzW2luZGV4XShzdGF0ZSwgbmV4dFN0YXRlLCByZXBsYWNlLCB3cmFwcGVkTmV4dCk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIGFsbCBvbkxlYXZlIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIHJ1bkxlYXZlSG9va3Mocm91dGVzLCBwcmV2U3RhdGUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChyb3V0ZXNbaV0ub25MZWF2ZSkgcm91dGVzW2ldLm9uTGVhdmUuY2FsbChyb3V0ZXNbaV0sIHByZXZTdGF0ZSk7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvVHJhbnNpdGlvblV0aWxzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvb3BBc3luYyA9IGxvb3BBc3luYztcbmV4cG9ydHMubWFwQXN5bmMgPSBtYXBBc3luYztcbmZ1bmN0aW9uIGxvb3BBc3luYyh0dXJucywgd29yaywgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnRUdXJuID0gMCxcbiAgICAgIGlzRG9uZSA9IGZhbHNlO1xuICB2YXIgc3luYyA9IGZhbHNlLFxuICAgICAgaGFzTmV4dCA9IGZhbHNlLFxuICAgICAgZG9uZUFyZ3MgPSB2b2lkIDA7XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBpc0RvbmUgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgZG9uZUFyZ3MgPSBbXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhc05leHQgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKCFpc0RvbmUgJiYgY3VycmVudFR1cm4gPCB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICB3b3JrLmNhbGwodGhpcywgY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgbG9vcCBmaW5pc2hlZCBzeW5jaHJvbm91c2x5LlxuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgZG9uZUFyZ3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VHVybiA+PSB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG5cbmZ1bmN0aW9uIG1hcEFzeW5jKGFycmF5LCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgdmFsdWVzID0gW107XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHZhbHVlcyk7XG5cbiAgdmFyIGlzRG9uZSA9IGZhbHNlLFxuICAgICAgZG9uZUNvdW50ID0gMDtcblxuICBmdW5jdGlvbiBkb25lKGluZGV4LCBlcnJvciwgdmFsdWUpIHtcbiAgICBpZiAoaXNEb25lKSByZXR1cm47XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgaXNEb25lID0gKytkb25lQ291bnQgPT09IGxlbmd0aDtcblxuICAgICAgaWYgKGlzRG9uZSkgY2FsbGJhY2sobnVsbCwgdmFsdWVzKTtcbiAgICB9XG4gIH1cblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHdvcmsoaXRlbSwgaW5kZXgsIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgIGRvbmUoaW5kZXgsIGVycm9yLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGlzQWN0aXZlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBkZWVwRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSkpID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIHAgaW4gYSkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgcCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhW3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGJbcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChhW3BdLCBiW3BdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHBhdGhuYW1lIG1hdGNoZXMgdGhlIHN1cHBsaWVkIG9uZSwgbmV0IG9mXG4gKiBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaCBub3JtYWxpemF0aW9uLiBUaGlzIGlzIHN1ZmZpY2llbnQgZm9yIGFuXG4gKiBpbmRleE9ubHkgcm91dGUgbWF0Y2guXG4gKi9cbmZ1bmN0aW9uIHBhdGhJc0FjdGl2ZShwYXRobmFtZSwgY3VycmVudFBhdGhuYW1lKSB7XG4gIC8vIE5vcm1hbGl6ZSBsZWFkaW5nIHNsYXNoIGZvciBjb25zaXN0ZW5jeS4gTGVhZGluZyBzbGFzaCBvbiBwYXRobmFtZSBoYXNcbiAgLy8gYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQgaW4gaXNBY3RpdmUuIFNlZSBjYXZlYXQgdGhlcmUuXG4gIGlmIChjdXJyZW50UGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBjdXJyZW50UGF0aG5hbWUgPSAnLycgKyBjdXJyZW50UGF0aG5hbWU7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgdGhlIGVuZCBvZiBib3RoIHBhdGggbmFtZXMgdG9vLiBNYXliZSBgL2Zvby9gIHNob3VsZG4ndCBzaG93XG4gIC8vIGAvZm9vYCBhcyBhY3RpdmUsIGJ1dCBpbiB0aGlzIGNhc2UsIHdlIHdvdWxkIGFscmVhZHkgaGF2ZSBmYWlsZWQgdGhlXG4gIC8vIG1hdGNoLlxuICBpZiAocGF0aG5hbWUuY2hhckF0KHBhdGhuYW1lLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICBwYXRobmFtZSArPSAnLyc7XG4gIH1cbiAgaWYgKGN1cnJlbnRQYXRobmFtZS5jaGFyQXQoY3VycmVudFBhdGhuYW1lLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICBjdXJyZW50UGF0aG5hbWUgKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRQYXRobmFtZSA9PT0gcGF0aG5hbWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXRobmFtZSBtYXRjaGVzIHRoZSBhY3RpdmUgcm91dGVzIGFuZCBwYXJhbXMuXG4gKi9cbmZ1bmN0aW9uIHJvdXRlSXNBY3RpdmUocGF0aG5hbWUsIHJvdXRlcywgcGFyYW1zKSB7XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLFxuICAgICAgcGFyYW1OYW1lcyA9IFtdLFxuICAgICAgcGFyYW1WYWx1ZXMgPSBbXTtcblxuICAvLyBmb3IuLi5vZiB3b3VsZCB3b3JrIGhlcmUgYnV0IGl0J3MgcHJvYmFibHkgc2xvd2VyIHBvc3QtdHJhbnNwaWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpXTtcbiAgICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgICBpZiAocGF0dGVybi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgIHBhcmFtTmFtZXMgPSBbXTtcbiAgICAgIHBhcmFtVmFsdWVzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9PSBudWxsICYmIHBhdHRlcm4pIHtcbiAgICAgIHZhciBtYXRjaGVkID0gKDAsIF9QYXR0ZXJuVXRpbHMubWF0Y2hQYXR0ZXJuKShwYXR0ZXJuLCByZW1haW5pbmdQYXRobmFtZSk7XG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWQucmVtYWluaW5nUGF0aG5hbWU7XG4gICAgICAgIHBhcmFtTmFtZXMgPSBbXS5jb25jYXQocGFyYW1OYW1lcywgbWF0Y2hlZC5wYXJhbU5hbWVzKTtcbiAgICAgICAgcGFyYW1WYWx1ZXMgPSBbXS5jb25jYXQocGFyYW1WYWx1ZXMsIG1hdGNoZWQucGFyYW1WYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09ICcnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYW4gZXhhY3QgbWF0Y2ggb24gdGhlIHJvdXRlLiBKdXN0IGNoZWNrIHRoYXQgYWxsIHRoZSBwYXJhbXNcbiAgICAgICAgLy8gbWF0Y2guXG4gICAgICAgIC8vIEZJWE1FOiBUaGlzIGRvZXNuJ3Qgd29yayBvbiByZXBlYXRlZCBwYXJhbXMuXG4gICAgICAgIHJldHVybiBwYXJhbU5hbWVzLmV2ZXJ5KGZ1bmN0aW9uIChwYXJhbU5hbWUsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbVZhbHVlc1tpbmRleF0pID09PSBTdHJpbmcocGFyYW1zW3BhcmFtTmFtZV0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFsbCBrZXkvdmFsdWUgcGFpcnMgaW4gdGhlIGdpdmVuIHF1ZXJ5IGFyZVxuICogY3VycmVudGx5IGFjdGl2ZS5cbiAqL1xuZnVuY3Rpb24gcXVlcnlJc0FjdGl2ZShxdWVyeSwgYWN0aXZlUXVlcnkpIHtcbiAgaWYgKGFjdGl2ZVF1ZXJ5ID09IG51bGwpIHJldHVybiBxdWVyeSA9PSBudWxsO1xuXG4gIGlmIChxdWVyeSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICByZXR1cm4gZGVlcEVxdWFsKHF1ZXJ5LCBhY3RpdmVRdWVyeSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgPExpbms+IHRvIHRoZSBnaXZlbiBwYXRobmFtZS9xdWVyeSBjb21iaW5hdGlvbiBpc1xuICogY3VycmVudGx5IGFjdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNBY3RpdmUoX3JlZiwgaW5kZXhPbmx5LCBjdXJyZW50TG9jYXRpb24sIHJvdXRlcywgcGFyYW1zKSB7XG4gIHZhciBwYXRobmFtZSA9IF9yZWYucGF0aG5hbWUsXG4gICAgICBxdWVyeSA9IF9yZWYucXVlcnk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVE9ETzogVGhpcyBpcyBhIGJpdCB1Z2x5LiBJdCBrZWVwcyBhcm91bmQgc3VwcG9ydCBmb3IgdHJlYXRpbmcgcGF0aG5hbWVzXG4gIC8vIHdpdGhvdXQgcHJlY2VkaW5nIHNsYXNoZXMgYXMgYWJzb2x1dGUgcGF0aHMsIGJ1dCBwb3NzaWJseSBhbHNvIHdvcmtzXG4gIC8vIGFyb3VuZCB0aGUgc2FtZSBxdWlya3Mgd2l0aCBiYXNlbmFtZXMgYXMgaW4gbWF0Y2hSb3V0ZXMuXG4gIGlmIChwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH1cblxuICBpZiAoIXBhdGhJc0FjdGl2ZShwYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKSkge1xuICAgIC8vIFRoZSBwYXRoIGNoZWNrIGlzIG5lY2Vzc2FyeSBhbmQgc3VmZmljaWVudCBmb3IgaW5kZXhPbmx5LCBidXQgb3RoZXJ3aXNlXG4gICAgLy8gd2Ugc3RpbGwgbmVlZCB0byBjaGVjayB0aGUgcm91dGVzLlxuICAgIGlmIChpbmRleE9ubHkgfHwgIXJvdXRlSXNBY3RpdmUocGF0aG5hbWUsIHJvdXRlcywgcGFyYW1zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBxdWVyeUlzQWN0aXZlKHF1ZXJ5LCBjdXJyZW50TG9jYXRpb24ucXVlcnkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL2lzQWN0aXZlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9Qcm9taXNlVXRpbHMgPSByZXF1aXJlKCcuL1Byb21pc2VVdGlscycpO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzRm9yUm91dGUobmV4dFN0YXRlLCByb3V0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmNvbXBvbmVudCB8fCByb3V0ZS5jb21wb25lbnRzKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgcm91dGUuY29tcG9uZW50IHx8IHJvdXRlLmNvbXBvbmVudHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXRDb21wb25lbnQgPSByb3V0ZS5nZXRDb21wb25lbnQgfHwgcm91dGUuZ2V0Q29tcG9uZW50cztcbiAgaWYgKGdldENvbXBvbmVudCkge1xuICAgIHZhciBjb21wb25lbnRSZXR1cm4gPSBnZXRDb21wb25lbnQuY2FsbChyb3V0ZSwgbmV4dFN0YXRlLCBjYWxsYmFjayk7XG4gICAgaWYgKCgwLCBfUHJvbWlzZVV0aWxzLmlzUHJvbWlzZSkoY29tcG9uZW50UmV0dXJuKSkgY29tcG9uZW50UmV0dXJuLnRoZW4oZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbXBvbmVudCk7XG4gICAgfSwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBmZXRjaGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgdGhlIGdpdmVuIHJvdXRlclxuICogc3RhdGUgYW5kIGNhbGxzIGNhbGxiYWNrKGVycm9yLCBjb21wb25lbnRzKSB3aGVuIGZpbmlzaGVkLlxuICpcbiAqIE5vdGU6IFRoaXMgb3BlcmF0aW9uIG1heSBmaW5pc2ggc3luY2hyb25vdXNseSBpZiBubyByb3V0ZXMgaGF2ZSBhblxuICogYXN5bmNocm9ub3VzIGdldENvbXBvbmVudHMgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgKDAsIF9Bc3luY1V0aWxzLm1hcEFzeW5jKShuZXh0U3RhdGUucm91dGVzLCBmdW5jdGlvbiAocm91dGUsIGluZGV4LCBjYWxsYmFjaykge1xuICAgIGdldENvbXBvbmVudHNGb3JSb3V0ZShuZXh0U3RhdGUsIHJvdXRlLCBjYWxsYmFjayk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0Q29tcG9uZW50cztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRDb21wb25lbnRzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9Qcm9taXNlVXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2hSb3V0ZXM7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX1Byb21pc2VVdGlscyA9IHJlcXVpcmUoJy4vUHJvbWlzZVV0aWxzJyk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldENoaWxkUm91dGVzKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIGlmIChyb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIHJldHVybiBbbnVsbCwgcm91dGUuY2hpbGRSb3V0ZXNdO1xuICB9XG4gIGlmICghcm91dGUuZ2V0Q2hpbGRSb3V0ZXMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgc3luYyA9IHRydWUsXG4gICAgICByZXN1bHQgPSB2b2lkIDA7XG5cbiAgdmFyIHBhcnRpYWxOZXh0U3RhdGUgPSB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICB9O1xuXG4gIHZhciBjaGlsZFJvdXRlc1JldHVybiA9IHJvdXRlLmdldENoaWxkUm91dGVzKHBhcnRpYWxOZXh0U3RhdGUsIGZ1bmN0aW9uIChlcnJvciwgY2hpbGRSb3V0ZXMpIHtcbiAgICBjaGlsZFJvdXRlcyA9ICFlcnJvciAmJiAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShjaGlsZFJvdXRlcyk7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHJlc3VsdCA9IFtlcnJvciwgY2hpbGRSb3V0ZXNdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKGVycm9yLCBjaGlsZFJvdXRlcyk7XG4gIH0pO1xuXG4gIGlmICgoMCwgX1Byb21pc2VVdGlscy5pc1Byb21pc2UpKGNoaWxkUm91dGVzUmV0dXJuKSkgY2hpbGRSb3V0ZXNSZXR1cm4udGhlbihmdW5jdGlvbiAoY2hpbGRSb3V0ZXMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykoY2hpbGRSb3V0ZXMpKTtcbiAgfSwgY2FsbGJhY2spO1xuXG4gIHN5bmMgPSBmYWxzZTtcbiAgcmV0dXJuIHJlc3VsdDsgLy8gTWlnaHQgYmUgdW5kZWZpbmVkLlxufVxuXG5mdW5jdGlvbiBnZXRJbmRleFJvdXRlKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIGlmIChyb3V0ZS5pbmRleFJvdXRlKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgcm91dGUuaW5kZXhSb3V0ZSk7XG4gIH0gZWxzZSBpZiAocm91dGUuZ2V0SW5kZXhSb3V0ZSkge1xuICAgIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gICAgfTtcblxuICAgIHZhciBpbmRleFJvdXRlc1JldHVybiA9IHJvdXRlLmdldEluZGV4Um91dGUocGFydGlhbE5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgIWVycm9yICYmICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKGluZGV4Um91dGUpWzBdKTtcbiAgICB9KTtcblxuICAgIGlmICgoMCwgX1Byb21pc2VVdGlscy5pc1Byb21pc2UpKGluZGV4Um91dGVzUmV0dXJuKSkgaW5kZXhSb3V0ZXNSZXR1cm4udGhlbihmdW5jdGlvbiAoaW5kZXhSb3V0ZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKGluZGV4Um91dGUpWzBdKTtcbiAgICB9LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAocm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGhsZXNzID0gcm91dGUuY2hpbGRSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZFJvdXRlKSB7XG4gICAgICAgIHJldHVybiAhY2hpbGRSb3V0ZS5wYXRoO1xuICAgICAgfSk7XG5cbiAgICAgICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKHBhdGhsZXNzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgICAgIGdldEluZGV4Um91dGUocGF0aGxlc3NbaW5kZXhdLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgIGlmIChlcnJvciB8fCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgICB2YXIgcm91dGVzID0gW3BhdGhsZXNzW2luZGV4XV0uY29uY2F0KEFycmF5LmlzQXJyYXkoaW5kZXhSb3V0ZSkgPyBpbmRleFJvdXRlIDogW2luZGV4Um91dGVdKTtcbiAgICAgICAgICAgIGRvbmUoZXJyb3IsIHJvdXRlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcm91dGVzKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlcyk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduUGFyYW1zKHBhcmFtcywgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpIHtcbiAgcmV0dXJuIHBhcmFtTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtVmFsdWVzICYmIHBhcmFtVmFsdWVzW2luZGV4XTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtc1twYXJhbU5hbWVdKSkge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0ucHVzaChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdID0gW3BhcmFtc1twYXJhbU5hbWVdLCBwYXJhbVZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcykge1xuICByZXR1cm4gYXNzaWduUGFyYW1zKHt9LCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcyk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVEZWVwKHJvdXRlLCBsb2NhdGlvbiwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xuICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZW1haW5pbmdQYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHBhcmFtTmFtZXMgPSBbXTtcbiAgICBwYXJhbVZhbHVlcyA9IFtdO1xuICB9XG5cbiAgLy8gT25seSB0cnkgdG8gbWF0Y2ggdGhlIHBhdGggaWYgdGhlIHJvdXRlIGFjdHVhbGx5IGhhcyBhIHBhdHRlcm4sIGFuZCBpZlxuICAvLyB3ZSdyZSBub3QganVzdCBzZWFyY2hpbmcgZm9yIHBvdGVudGlhbCBuZXN0ZWQgYWJzb2x1dGUgcGF0aHMuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSAhPT0gbnVsbCAmJiBwYXR0ZXJuKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtYXRjaGVkID0gKDAsIF9QYXR0ZXJuVXRpbHMubWF0Y2hQYXR0ZXJuKShwYXR0ZXJuLCByZW1haW5pbmdQYXRobmFtZSk7XG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWQucmVtYWluaW5nUGF0aG5hbWU7XG4gICAgICAgIHBhcmFtTmFtZXMgPSBbXS5jb25jYXQocGFyYW1OYW1lcywgbWF0Y2hlZC5wYXJhbU5hbWVzKTtcbiAgICAgICAgcGFyYW1WYWx1ZXMgPSBbXS5jb25jYXQocGFyYW1WYWx1ZXMsIG1hdGNoZWQucGFyYW1WYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gQnkgYXNzdW1wdGlvbiwgcGF0dGVybiBpcyBub24tZW1wdHkgaGVyZSwgd2hpY2ggaXMgdGhlIHByZXJlcXVpc2l0ZSBmb3JcbiAgICAvLyBhY3R1YWxseSB0ZXJtaW5hdGluZyBhIG1hdGNoLlxuICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gJycpIHtcbiAgICAgIHZhciBfcmV0MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICAgIHJvdXRlczogW3JvdXRlXSxcbiAgICAgICAgICBwYXJhbXM6IGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcylcbiAgICAgICAgfTtcblxuICAgICAgICBnZXRJbmRleFJvdXRlKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleFJvdXRlKSkge1xuICAgICAgICAgICAgICB2YXIgX21hdGNoJHJvdXRlcztcblxuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShpbmRleFJvdXRlLmV2ZXJ5KGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhcm91dGUucGF0aDtcbiAgICAgICAgICAgICAgfSksICdJbmRleCByb3V0ZXMgc2hvdWxkIG5vdCBoYXZlIHBhdGhzJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIChfbWF0Y2gkcm91dGVzID0gbWF0Y2gucm91dGVzKS5wdXNoLmFwcGx5KF9tYXRjaCRyb3V0ZXMsIGluZGV4Um91dGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleFJvdXRlKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKCFpbmRleFJvdXRlLnBhdGgsICdJbmRleCByb3V0ZXMgc2hvdWxkIG5vdCBoYXZlIHBhdGhzJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIG1hdGNoLnJvdXRlcy5wdXNoKGluZGV4Um91dGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYXRjaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfSgpO1xuXG4gICAgICBpZiAoKHR5cGVvZiBfcmV0MiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldDIpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9IG51bGwgfHwgcm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICAvLyBFaXRoZXIgYSkgdGhpcyByb3V0ZSBtYXRjaGVkIGF0IGxlYXN0IHNvbWUgb2YgdGhlIHBhdGggb3IgYilcbiAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIGxvYWQgdGhpcyByb3V0ZSdzIGNoaWxkcmVuIGFzeW5jaHJvbm91c2x5LiBJblxuICAgIC8vIGVpdGhlciBjYXNlIGNvbnRpbnVlIGNoZWNraW5nIGZvciBtYXRjaGVzIGluIHRoZSBzdWJ0cmVlLlxuICAgIHZhciBvbkNoaWxkUm91dGVzID0gZnVuY3Rpb24gb25DaGlsZFJvdXRlcyhlcnJvciwgY2hpbGRSb3V0ZXMpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkUm91dGVzKSB7XG4gICAgICAgIC8vIENoZWNrIHRoZSBjaGlsZCByb3V0ZXMgdG8gc2VlIGlmIGFueSBvZiB0aGVtIG1hdGNoLlxuICAgICAgICBtYXRjaFJvdXRlcyhjaGlsZFJvdXRlcywgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgbWF0Y2gpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBBIGNoaWxkIHJvdXRlIG1hdGNoZWQhIEF1Z21lbnQgdGhlIG1hdGNoIGFuZCBwYXNzIGl0IHVwIHRoZSBzdGFjay5cbiAgICAgICAgICAgIG1hdGNoLnJvdXRlcy51bnNoaWZ0KHJvdXRlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1hdGNoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzdWx0ID0gZ2V0Q2hpbGRSb3V0ZXMocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgb25DaGlsZFJvdXRlcyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgb25DaGlsZFJvdXRlcy5hcHBseSh1bmRlZmluZWQsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBtYXRjaGVzIHRoZSBnaXZlbiBsb2NhdGlvbiB0byBhIHNldCBvZiByb3V0ZXMgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgc3RhdGUpIHdoZW4gZmluaXNoZWQuIFRoZSBzdGF0ZSBvYmplY3Qgd2lsbCBoYXZlIHRoZVxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSByb3V0ZXMgICAgICAgQW4gYXJyYXkgb2Ygcm91dGVzIHRoYXQgbWF0Y2hlZCwgaW4gaGllcmFyY2hpY2FsIG9yZGVyXG4gKiAtIHBhcmFtcyAgICAgICBBbiBvYmplY3Qgb2YgVVJMIHBhcmFtZXRlcnNcbiAqXG4gKiBOb3RlOiBUaGlzIG9wZXJhdGlvbiBtYXkgZmluaXNoIHN5bmNocm9ub3VzbHkgaWYgbm8gcm91dGVzIGhhdmUgYW5cbiAqIGFzeW5jaHJvbm91cyBnZXRDaGlsZFJvdXRlcyBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb24sIGNhbGxiYWNrLCByZW1haW5pbmdQYXRobmFtZSkge1xuICB2YXIgcGFyYW1OYW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogW107XG4gIHZhciBwYXJhbVZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogW107XG5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGEgbGl0dGxlIGJpdCB1Z2x5LCBidXQgaXQgd29ya3MgYXJvdW5kIGEgcXVpcmsgaW4gaGlzdG9yeVxuICAgIC8vIHRoYXQgc3RyaXBzIHRoZSBsZWFkaW5nIHNsYXNoIGZyb20gcGF0aG5hbWVzIHdoZW4gdXNpbmcgYmFzZW5hbWVzIHdpdGhcbiAgICAvLyB0cmFpbGluZyBzbGFzaGVzLlxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6ICcvJyArIGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVtYWluaW5nUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgfVxuXG4gICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKHJvdXRlcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgIG1hdGNoUm91dGVEZWVwKHJvdXRlc1tpbmRleF0sIGxvY2F0aW9uLCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgbWF0Y2gpIHtcbiAgICAgIGlmIChlcnJvciB8fCBtYXRjaCkge1xuICAgICAgICBkb25lKGVycm9yLCBtYXRjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaFJvdXRlcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucm91dGVzID0gZXhwb3J0cy5yb3V0ZSA9IGV4cG9ydHMuY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50ID0gZXhwb3J0cy5oaXN0b3J5ID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5mYWxzeSA9IGZhbHN5O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIGZ1bmMgPSBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMsXG4gICAgb2JqZWN0ID0gX3JlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgYXJyYXlPZiA9IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZixcbiAgICBvbmVPZlR5cGUgPSBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZSxcbiAgICBlbGVtZW50ID0gX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50LFxuICAgIHNoYXBlID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZSxcbiAgICBzdHJpbmcgPSBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZztcbmZ1bmN0aW9uIGZhbHN5KHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICBpZiAocHJvcHNbcHJvcE5hbWVdKSByZXR1cm4gbmV3IEVycm9yKCc8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBzaG91bGQgbm90IGhhdmUgYSBcIicgKyBwcm9wTmFtZSArICdcIiBwcm9wJyk7XG59XG5cbnZhciBoaXN0b3J5ID0gZXhwb3J0cy5oaXN0b3J5ID0gc2hhcGUoe1xuICBsaXN0ZW46IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcHVzaDogZnVuYy5pc1JlcXVpcmVkLFxuICByZXBsYWNlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvQmFjazogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0ZvcndhcmQ6IGZ1bmMuaXNSZXF1aXJlZFxufSk7XG5cbnZhciBjb21wb25lbnQgPSBleHBvcnRzLmNvbXBvbmVudCA9IG9uZU9mVHlwZShbZnVuYywgc3RyaW5nXSk7XG52YXIgY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50cyA9IG9uZU9mVHlwZShbY29tcG9uZW50LCBvYmplY3RdKTtcbnZhciByb3V0ZSA9IGV4cG9ydHMucm91dGUgPSBvbmVPZlR5cGUoW29iamVjdCwgZWxlbWVudF0pO1xudmFyIHJvdXRlcyA9IGV4cG9ydHMucm91dGVzID0gb25lT2ZUeXBlKFtyb3V0ZSwgYXJyYXlPZihyb3V0ZSldKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvSW50ZXJuYWxQcm9wVHlwZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2dldFJvdXRlUGFyYW1zID0gcmVxdWlyZSgnLi9nZXRSb3V0ZVBhcmFtcycpO1xuXG52YXIgX2dldFJvdXRlUGFyYW1zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFJvdXRlUGFyYW1zKTtcblxudmFyIF9Db250ZXh0VXRpbHMgPSByZXF1aXJlKCcuL0NvbnRleHRVdGlscycpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLFxuICAgIGFycmF5ID0gX1JlYWN0JFByb3BUeXBlcy5hcnJheSxcbiAgICBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jLFxuICAgIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEEgPFJvdXRlckNvbnRleHQ+IHJlbmRlcnMgdGhlIGNvbXBvbmVudCB0cmVlIGZvciBhIGdpdmVuIHJvdXRlciBzdGF0ZVxuICogYW5kIHNldHMgdGhlIGhpc3Rvcnkgb2JqZWN0IGFuZCB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiBjb250ZXh0LlxuICovXG5cbnZhciBSb3V0ZXJDb250ZXh0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZXJDb250ZXh0JyxcblxuXG4gIG1peGluczogWygwLCBfQ29udGV4dFV0aWxzLkNvbnRleHRQcm92aWRlcikoJ3JvdXRlcicpXSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICByb3V0ZXI6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGxvY2F0aW9uOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICByb3V0ZXM6IGFycmF5LmlzUmVxdWlyZWQsXG4gICAgcGFyYW1zOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICBjb21wb25lbnRzOiBhcnJheS5pc1JlcXVpcmVkLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVFbGVtZW50OiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudFxuICAgIH07XG4gIH0sXG5cblxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIHJvdXRlcjogb2JqZWN0LmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiB0aGlzLnByb3BzLnJvdXRlclxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcykge1xuICAgIHJldHVybiBjb21wb25lbnQgPT0gbnVsbCA/IG51bGwgOiB0aGlzLnByb3BzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgbG9jYXRpb24gPSBfcHJvcHMubG9jYXRpb24sXG4gICAgICAgIHJvdXRlcyA9IF9wcm9wcy5yb3V0ZXMsXG4gICAgICAgIHBhcmFtcyA9IF9wcm9wcy5wYXJhbXMsXG4gICAgICAgIGNvbXBvbmVudHMgPSBfcHJvcHMuY29tcG9uZW50cyxcbiAgICAgICAgcm91dGVyID0gX3Byb3BzLnJvdXRlcjtcblxuICAgIHZhciBlbGVtZW50ID0gbnVsbDtcblxuICAgIGlmIChjb21wb25lbnRzKSB7XG4gICAgICBlbGVtZW50ID0gY29tcG9uZW50cy5yZWR1Y2VSaWdodChmdW5jdGlvbiAoZWxlbWVudCwgY29tcG9uZW50cywgaW5kZXgpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMgPT0gbnVsbCkgcmV0dXJuIGVsZW1lbnQ7IC8vIERvbid0IGNyZWF0ZSBuZXcgY2hpbGRyZW47IHVzZSB0aGUgZ3JhbmRjaGlsZHJlbi5cblxuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcm91dGVQYXJhbXMgPSAoMCwgX2dldFJvdXRlUGFyYW1zMi5kZWZhdWx0KShyb3V0ZSwgcGFyYW1zKTtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICByb3V0ZTogcm91dGUsXG4gICAgICAgICAgcm91dGVyOiByb3V0ZXIsXG4gICAgICAgICAgcm91dGVQYXJhbXM6IHJvdXRlUGFyYW1zLFxuICAgICAgICAgIHJvdXRlczogcm91dGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCgwLCBfUm91dGVVdGlscy5pc1JlYWN0Q2hpbGRyZW4pKGVsZW1lbnQpKSB7XG4gICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWxlbWVudCwgcHJvcCkpIHByb3BzW3Byb3BdID0gZWxlbWVudFtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHR5cGVvZiBjb21wb25lbnRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb21wb25lbnRzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9uZW50cykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb21wb25lbnRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUga2V5IGFzIGEgcHJvcCB0byBjcmVhdGVFbGVtZW50IHRvIGFsbG93XG4gICAgICAgICAgICAgIC8vIGN1c3RvbSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9ucyB0byBrbm93IHdoaWNoIG5hbWVkIGNvbXBvbmVudFxuICAgICAgICAgICAgICAvLyB0aGV5J3JlIHJlbmRlcmluZywgZm9yIGUuZy4gbWF0Y2hpbmcgdXAgdG8gZmV0Y2hlZCBkYXRhLlxuICAgICAgICAgICAgICBlbGVtZW50c1trZXldID0gX3RoaXMuY3JlYXRlRWxlbWVudChjb21wb25lbnRzW2tleV0sIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSB9LCBwcm9wcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMsIHByb3BzKTtcbiAgICAgIH0sIGVsZW1lbnQpO1xuICAgIH1cblxuICAgICEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSB8fCBfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RoZSByb290IHJvdXRlIG11c3QgcmVuZGVyIGEgc2luZ2xlIGVsZW1lbnQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlckNvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG4vKipcbiAqIEV4dHJhY3RzIGFuIG9iamVjdCBvZiBwYXJhbXMgdGhlIGdpdmVuIHJvdXRlIGNhcmVzIGFib3V0IGZyb21cbiAqIHRoZSBnaXZlbiBwYXJhbXMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRSb3V0ZVBhcmFtcyhyb3V0ZSwgcGFyYW1zKSB7XG4gIHZhciByb3V0ZVBhcmFtcyA9IHt9O1xuXG4gIGlmICghcm91dGUucGF0aCkgcmV0dXJuIHJvdXRlUGFyYW1zO1xuXG4gICgwLCBfUGF0dGVyblV0aWxzLmdldFBhcmFtTmFtZXMpKHJvdXRlLnBhdGgpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcCkpIHtcbiAgICAgIHJvdXRlUGFyYW1zW3BdID0gcGFyYW1zW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlUGFyYW1zO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRSb3V0ZVBhcmFtcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5Db250ZXh0U3Vic2NyaWJlciA9IENvbnRleHRTdWJzY3JpYmVyO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLy8gV29ya3MgYXJvdW5kIGlzc3VlcyB3aXRoIGNvbnRleHQgdXBkYXRlcyBmYWlsaW5nIHRvIHByb3BhZ2F0ZS5cbi8vIENhdmVhdDogdGhlIGNvbnRleHQgdmFsdWUgaXMgZXhwZWN0ZWQgdG8gbmV2ZXIgY2hhbmdlIGl0cyBpZGVudGl0eS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjUxN1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy80NzBcblxudmFyIGNvbnRleHRQcm92aWRlclNoYXBlID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZSh7XG4gIHN1YnNjcmliZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIGV2ZW50SW5kZXg6IF9yZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbn0pO1xuXG5mdW5jdGlvbiBtYWtlQ29udGV4dE5hbWUobmFtZSkge1xuICByZXR1cm4gJ0BAY29udGV4dFN1YnNjcmliZXIvJyArIG5hbWU7XG59XG5cbmZ1bmN0aW9uIENvbnRleHRQcm92aWRlcihuYW1lKSB7XG4gIHZhciBfY2hpbGRDb250ZXh0VHlwZXMsIF9yZWYyO1xuXG4gIHZhciBjb250ZXh0TmFtZSA9IG1ha2VDb250ZXh0TmFtZShuYW1lKTtcbiAgdmFyIGxpc3RlbmVyc0tleSA9IGNvbnRleHROYW1lICsgJy9saXN0ZW5lcnMnO1xuICB2YXIgZXZlbnRJbmRleEtleSA9IGNvbnRleHROYW1lICsgJy9ldmVudEluZGV4JztcbiAgdmFyIHN1YnNjcmliZUtleSA9IGNvbnRleHROYW1lICsgJy9zdWJzY3JpYmUnO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogKF9jaGlsZENvbnRleHRUeXBlcyA9IHt9LCBfY2hpbGRDb250ZXh0VHlwZXNbY29udGV4dE5hbWVdID0gY29udGV4dFByb3ZpZGVyU2hhcGUuaXNSZXF1aXJlZCwgX2NoaWxkQ29udGV4dFR5cGVzKSxcblxuICAgIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbY29udGV4dE5hbWVdID0ge1xuICAgICAgICBldmVudEluZGV4OiB0aGlzW2V2ZW50SW5kZXhLZXldLFxuICAgICAgICBzdWJzY3JpYmU6IHRoaXNbc3Vic2NyaWJlS2V5XVxuICAgICAgfSwgX3JlZjtcbiAgICB9LFxuICAgIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgdGhpc1tsaXN0ZW5lcnNLZXldID0gW107XG4gICAgICB0aGlzW2V2ZW50SW5kZXhLZXldID0gMDtcbiAgICB9LFxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKSB7XG4gICAgICB0aGlzW2V2ZW50SW5kZXhLZXldKys7XG4gICAgfSxcbiAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXNbbGlzdGVuZXJzS2V5XS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoX3RoaXNbZXZlbnRJbmRleEtleV0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBfcmVmMltzdWJzY3JpYmVLZXldID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAvLyBObyBuZWVkIHRvIGltbWVkaWF0ZWx5IGNhbGwgbGlzdGVuZXIgaGVyZS5cbiAgICB0aGlzW2xpc3RlbmVyc0tleV0ucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyW2xpc3RlbmVyc0tleV0gPSBfdGhpczJbbGlzdGVuZXJzS2V5XS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgX3JlZjI7XG59XG5cbmZ1bmN0aW9uIENvbnRleHRTdWJzY3JpYmVyKG5hbWUpIHtcbiAgdmFyIF9jb250ZXh0VHlwZXMsIF9yZWY0O1xuXG4gIHZhciBjb250ZXh0TmFtZSA9IG1ha2VDb250ZXh0TmFtZShuYW1lKTtcbiAgdmFyIGxhc3RSZW5kZXJlZEV2ZW50SW5kZXhLZXkgPSBjb250ZXh0TmFtZSArICcvbGFzdFJlbmRlcmVkRXZlbnRJbmRleCc7XG4gIHZhciBoYW5kbGVDb250ZXh0VXBkYXRlS2V5ID0gY29udGV4dE5hbWUgKyAnL2hhbmRsZUNvbnRleHRVcGRhdGUnO1xuICB2YXIgdW5zdWJzY3JpYmVLZXkgPSBjb250ZXh0TmFtZSArICcvdW5zdWJzY3JpYmUnO1xuXG4gIHJldHVybiBfcmVmNCA9IHtcbiAgICBjb250ZXh0VHlwZXM6IChfY29udGV4dFR5cGVzID0ge30sIF9jb250ZXh0VHlwZXNbY29udGV4dE5hbWVdID0gY29udGV4dFByb3ZpZGVyU2hhcGUsIF9jb250ZXh0VHlwZXMpLFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgICB2YXIgX3JlZjM7XG5cbiAgICAgIGlmICghdGhpcy5jb250ZXh0W2NvbnRleHROYW1lXSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVmMyA9IHt9LCBfcmVmM1tsYXN0UmVuZGVyZWRFdmVudEluZGV4S2V5XSA9IHRoaXMuY29udGV4dFtjb250ZXh0TmFtZV0uZXZlbnRJbmRleCwgX3JlZjM7XG4gICAgfSxcbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dFtjb250ZXh0TmFtZV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzW3Vuc3Vic2NyaWJlS2V5XSA9IHRoaXMuY29udGV4dFtjb250ZXh0TmFtZV0uc3Vic2NyaWJlKHRoaXNbaGFuZGxlQ29udGV4dFVwZGF0ZUtleV0pO1xuICAgIH0sXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcbiAgICAgIHZhciBfc2V0U3RhdGU7XG5cbiAgICAgIGlmICghdGhpcy5jb250ZXh0W2NvbnRleHROYW1lXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoKF9zZXRTdGF0ZSA9IHt9LCBfc2V0U3RhdGVbbGFzdFJlbmRlcmVkRXZlbnRJbmRleEtleV0gPSB0aGlzLmNvbnRleHRbY29udGV4dE5hbWVdLmV2ZW50SW5kZXgsIF9zZXRTdGF0ZSkpO1xuICAgIH0sXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKCF0aGlzW3Vuc3Vic2NyaWJlS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXNbdW5zdWJzY3JpYmVLZXldKCk7XG4gICAgICB0aGlzW3Vuc3Vic2NyaWJlS2V5XSA9IG51bGw7XG4gICAgfVxuICB9LCBfcmVmNFtoYW5kbGVDb250ZXh0VXBkYXRlS2V5XSA9IGZ1bmN0aW9uIChldmVudEluZGV4KSB7XG4gICAgaWYgKGV2ZW50SW5kZXggIT09IHRoaXMuc3RhdGVbbGFzdFJlbmRlcmVkRXZlbnRJbmRleEtleV0pIHtcbiAgICAgIHZhciBfc2V0U3RhdGUyO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKChfc2V0U3RhdGUyID0ge30sIF9zZXRTdGF0ZTJbbGFzdFJlbmRlcmVkRXZlbnRJbmRleEtleV0gPSBldmVudEluZGV4LCBfc2V0U3RhdGUyKSk7XG4gICAgfVxuICB9LCBfcmVmNDtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvQ29udGV4dFV0aWxzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuY3JlYXRlUm91dGVyT2JqZWN0ID0gY3JlYXRlUm91dGVyT2JqZWN0O1xuZXhwb3J0cy5hc3NpZ25Sb3V0ZXJTdGF0ZSA9IGFzc2lnblJvdXRlclN0YXRlO1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0KGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyLCBzdGF0ZSkge1xuICB2YXIgcm91dGVyID0gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBzZXRSb3V0ZUxlYXZlSG9vazogdHJhbnNpdGlvbk1hbmFnZXIubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlLFxuICAgIGlzQWN0aXZlOiB0cmFuc2l0aW9uTWFuYWdlci5pc0FjdGl2ZVxuICB9KTtcblxuICByZXR1cm4gYXNzaWduUm91dGVyU3RhdGUocm91dGVyLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnblJvdXRlclN0YXRlKHJvdXRlciwgX3JlZikge1xuICB2YXIgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgcGFyYW1zID0gX3JlZi5wYXJhbXMsXG4gICAgICByb3V0ZXMgPSBfcmVmLnJvdXRlcztcblxuICByb3V0ZXIubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgcm91dGVyLnBhcmFtcyA9IHBhcmFtcztcbiAgcm91dGVyLnJvdXRlcyA9IHJvdXRlcztcblxuICByZXR1cm4gcm91dGVyO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJVdGlscy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbnZhciBfQ29udGV4dFV0aWxzID0gcmVxdWlyZSgnLi9Db250ZXh0VXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMsXG4gICAgYm9vbCA9IF9SZWFjdCRQcm9wVHlwZXMuYm9vbCxcbiAgICBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdCxcbiAgICBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZyxcbiAgICBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jLFxuICAgIG9uZU9mVHlwZSA9IF9SZWFjdCRQcm9wVHlwZXMub25lT2ZUeXBlO1xuXG5cbmZ1bmN0aW9uIGlzTGVmdENsaWNrRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxuLy8gVE9ETzogRGUtZHVwbGljYXRlIGFnYWluc3QgaGFzQW55UHJvcGVydGllcyBpbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqZWN0KSB7XG4gIGZvciAodmFyIHAgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHApKSByZXR1cm4gZmFsc2U7XG4gIH1yZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRvTG9jYXRpb24odG8sIHJvdXRlcikge1xuICByZXR1cm4gdHlwZW9mIHRvID09PSAnZnVuY3Rpb24nID8gdG8ocm91dGVyLmxvY2F0aW9uKSA6IHRvO1xufVxuXG4vKipcbiAqIEEgPExpbms+IGlzIHVzZWQgdG8gY3JlYXRlIGFuIDxhPiBlbGVtZW50IHRoYXQgbGlua3MgdG8gYSByb3V0ZS5cbiAqIFdoZW4gdGhhdCByb3V0ZSBpcyBhY3RpdmUsIHRoZSBsaW5rIGdldHMgdGhlIHZhbHVlIG9mIGl0c1xuICogYWN0aXZlQ2xhc3NOYW1lIHByb3AuXG4gKlxuICogRm9yIGV4YW1wbGUsIGFzc3VtaW5nIHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgcm91dGU6XG4gKlxuICogICA8Um91dGUgcGF0aD1cIi9wb3N0cy86cG9zdElEXCIgY29tcG9uZW50PXtQb3N0fSAvPlxuICpcbiAqIFlvdSBjb3VsZCB1c2UgdGhlIGZvbGxvd2luZyBjb21wb25lbnQgdG8gbGluayB0byB0aGF0IHJvdXRlOlxuICpcbiAqICAgPExpbmsgdG89e2AvcG9zdHMvJHtwb3N0LmlkfWB9IC8+XG4gKlxuICogTGlua3MgbWF5IHBhc3MgYWxvbmcgbG9jYXRpb24gc3RhdGUgYW5kL29yIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzXG4gKiBpbiB0aGUgc3RhdGUvcXVlcnkgcHJvcHMsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiAgIDxMaW5rIC4uLiBxdWVyeT17eyBzaG93OiB0cnVlIH19IHN0YXRlPXt7IHRoZTogJ3N0YXRlJyB9fSAvPlxuICovXG52YXIgTGluayA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnTGluaycsXG5cblxuICBtaXhpbnM6IFsoMCwgX0NvbnRleHRVdGlscy5Db250ZXh0U3Vic2NyaWJlcikoJ3JvdXRlcicpXSxcblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICByb3V0ZXI6IF9Qcm9wVHlwZXMucm91dGVyU2hhcGVcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0bzogb25lT2ZUeXBlKFtzdHJpbmcsIG9iamVjdCwgZnVuY10pLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgaGFzaDogc3RyaW5nLFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgYWN0aXZlU3R5bGU6IG9iamVjdCxcbiAgICBhY3RpdmVDbGFzc05hbWU6IHN0cmluZyxcbiAgICBvbmx5QWN0aXZlT25JbmRleDogYm9vbC5pc1JlcXVpcmVkLFxuICAgIG9uQ2xpY2s6IGZ1bmMsXG4gICAgdGFyZ2V0OiBzdHJpbmdcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25seUFjdGl2ZU9uSW5kZXg6IGZhbHNlLFxuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgfSxcbiAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25DbGljaykgdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcblxuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcjtcblxuICAgICFyb3V0ZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPExpbms+cyByZW5kZXJlZCBvdXRzaWRlIG9mIGEgcm91dGVyIGNvbnRleHQgY2Fubm90IG5hdmlnYXRlLicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmIChpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHx8ICFpc0xlZnRDbGlja0V2ZW50KGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgLy8gSWYgdGFyZ2V0IHByb3AgaXMgc2V0IChlLmcuIHRvIFwiX2JsYW5rXCIpLCBsZXQgYnJvd3NlciBoYW5kbGUgbGluay5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHVudGVzdGFibGUgd2l0aCBLYXJtYSAqL1xuICAgIGlmICh0aGlzLnByb3BzLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIHJvdXRlci5wdXNoKHJlc29sdmVUb0xvY2F0aW9uKHRoaXMucHJvcHMudG8sIHJvdXRlcikpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgdG8gPSBfcHJvcHMudG8sXG4gICAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9wcm9wcy5hY3RpdmVDbGFzc05hbWUsXG4gICAgICAgIGFjdGl2ZVN0eWxlID0gX3Byb3BzLmFjdGl2ZVN0eWxlLFxuICAgICAgICBvbmx5QWN0aXZlT25JbmRleCA9IF9wcm9wcy5vbmx5QWN0aXZlT25JbmRleCxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ3RvJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdhY3RpdmVTdHlsZScsICdvbmx5QWN0aXZlT25JbmRleCddKTtcblxuICAgIC8vIElnbm9yZSBpZiByZW5kZXJlZCBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIHJvdXRlciB0byBzaW1wbGlmeSB1bml0IHRlc3RpbmcuXG5cblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLmNvbnRleHQucm91dGVyO1xuXG5cbiAgICBpZiAocm91dGVyKSB7XG4gICAgICAvLyBJZiB1c2VyIGRvZXMgbm90IHNwZWNpZnkgYSBgdG9gIHByb3AsIHJldHVybiBhbiBlbXB0eSBhbmNob3IgdGFnLlxuICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdhJywgcHJvcHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9Mb2NhdGlvbiA9IHJlc29sdmVUb0xvY2F0aW9uKHRvLCByb3V0ZXIpO1xuICAgICAgcHJvcHMuaHJlZiA9IHJvdXRlci5jcmVhdGVIcmVmKHRvTG9jYXRpb24pO1xuXG4gICAgICBpZiAoYWN0aXZlQ2xhc3NOYW1lIHx8IGFjdGl2ZVN0eWxlICE9IG51bGwgJiYgIWlzRW1wdHlPYmplY3QoYWN0aXZlU3R5bGUpKSB7XG4gICAgICAgIGlmIChyb3V0ZXIuaXNBY3RpdmUodG9Mb2NhdGlvbiwgb25seUFjdGl2ZU9uSW5kZXgpKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZUNsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICBwcm9wcy5jbGFzc05hbWUgKz0gJyAnICsgYWN0aXZlQ2xhc3NOYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lID0gYWN0aXZlQ2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3RpdmVTdHlsZSkgcHJvcHMuc3R5bGUgPSBfZXh0ZW5kcyh7fSwgcHJvcHMuc3R5bGUsIGFjdGl2ZVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYScsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrIH0pKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExpbms7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvTGluay5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX0xpbmsgPSByZXF1aXJlKCcuL0xpbmsnKTtcblxudmFyIF9MaW5rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmspO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEFuIDxJbmRleExpbms+IGlzIHVzZWQgdG8gbGluayB0byBhbiA8SW5kZXhSb3V0ZT4uXG4gKi9cbnZhciBJbmRleExpbmsgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0luZGV4TGluaycsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfTGluazIuZGVmYXVsdCwgX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHsgb25seUFjdGl2ZU9uSW5kZXg6IHRydWUgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhMaW5rO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4TGluay5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gd2l0aFJvdXRlcjtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzID0gcmVxdWlyZSgnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnKTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ob2lzdE5vblJlYWN0U3RhdGljcyk7XG5cbnZhciBfQ29udGV4dFV0aWxzID0gcmVxdWlyZSgnLi9Db250ZXh0VXRpbHMnKTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSB7XG4gIHJldHVybiBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jztcbn1cblxuZnVuY3Rpb24gd2l0aFJvdXRlcihXcmFwcGVkQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIHZhciB3aXRoUmVmID0gb3B0aW9ucyAmJiBvcHRpb25zLndpdGhSZWY7XG5cbiAgdmFyIFdpdGhSb3V0ZXIgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICAgIGRpc3BsYXlOYW1lOiAnV2l0aFJvdXRlcicsXG5cbiAgICBtaXhpbnM6IFsoMCwgX0NvbnRleHRVdGlscy5Db250ZXh0U3Vic2NyaWJlcikoJ3JvdXRlcicpXSxcblxuICAgIGNvbnRleHRUeXBlczogeyByb3V0ZXI6IF9Qcm9wVHlwZXMucm91dGVyU2hhcGUgfSxcbiAgICBwcm9wVHlwZXM6IHsgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlIH0sXG5cbiAgICBnZXRXcmFwcGVkSW5zdGFuY2U6IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICF3aXRoUmVmID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgeW91IG5lZWQgdG8gc3BlY2lmeSAnICsgJ2B7IHdpdGhSZWY6IHRydWUgfWAgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgd2l0aFJvdXRlcigpIGNhbGwuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5zdGFuY2U7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnByb3BzLnJvdXRlciB8fCB0aGlzLmNvbnRleHQucm91dGVyO1xuICAgICAgdmFyIHBhcmFtcyA9IHJvdXRlci5wYXJhbXMsXG4gICAgICAgICAgbG9jYXRpb24gPSByb3V0ZXIubG9jYXRpb24sXG4gICAgICAgICAgcm91dGVzID0gcm91dGVyLnJvdXRlcztcblxuICAgICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHsgcm91dGVyOiByb3V0ZXIsIHBhcmFtczogcGFyYW1zLCBsb2NhdGlvbjogbG9jYXRpb24sIHJvdXRlczogcm91dGVzIH0pO1xuXG4gICAgICBpZiAod2l0aFJlZikge1xuICAgICAgICBwcm9wcy5yZWYgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIF90aGlzLndyYXBwZWRJbnN0YW5jZSA9IGM7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBwcm9wcyk7XG4gICAgfVxuICB9KTtcblxuICBXaXRoUm91dGVyLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgJyknO1xuICBXaXRoUm91dGVyLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuXG4gIHJldHVybiAoMCwgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMi5kZWZhdWx0KShXaXRoUm91dGVyLCBXcmFwcGVkQ29tcG9uZW50KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcmVhY3Qtcm91dGVyL2xpYi93aXRoUm91dGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgYXJndW1lbnRzOiB0cnVlLFxuICAgIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUgPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgY3VzdG9tU3RhdGljcykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFSRUFDVF9TVEFUSUNTW2tleXNbaV1dICYmICFLTk9XTl9TVEFUSUNTW2tleXNbaV1dICYmICghY3VzdG9tU3RhdGljcyB8fCAhY3VzdG9tU3RhdGljc1trZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21wb25lbnRba2V5c1tpXV0gPSBzb3VyY2VDb21wb25lbnRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JlZGlyZWN0ID0gcmVxdWlyZSgnLi9SZWRpcmVjdCcpO1xuXG52YXIgX1JlZGlyZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0KTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLFxuICAgIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEFuIDxJbmRleFJlZGlyZWN0PiBpcyB1c2VkIHRvIHJlZGlyZWN0IGZyb20gYW4gaW5kZXhSb3V0ZS5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcmVxdWlyZS1yZW5kZXItcmV0dXJuICovXG5cbnZhciBJbmRleFJlZGlyZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdJbmRleFJlZGlyZWN0JyxcblxuXG4gIHN0YXRpY3M6IHtcbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHNhbml0eSBjaGVjayAqL1xuICAgICAgaWYgKHBhcmVudFJvdXRlKSB7XG4gICAgICAgIHBhcmVudFJvdXRlLmluZGV4Um91dGUgPSBfUmVkaXJlY3QyLmRlZmF1bHQuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBbiA8SW5kZXhSZWRpcmVjdD4gZG9lcyBub3QgbWFrZSBzZW5zZSBhdCB0aGUgcm9vdCBvZiB5b3VyIHJvdXRlIGNvbmZpZycpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICB0bzogc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBzdGF0ZTogb2JqZWN0LFxuICAgIG9uRW50ZXI6IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeSxcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5XG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPEluZGV4UmVkaXJlY3Q+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4UmVkaXJlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMsXG4gICAgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8UmVkaXJlY3Q+IGlzIHVzZWQgdG8gZGVjbGFyZSBhbm90aGVyIFVSTCBwYXRoIGEgY2xpZW50IHNob3VsZFxuICogYmUgc2VudCB0byB3aGVuIHRoZXkgcmVxdWVzdCBhIGdpdmVuIFVSTC5cbiAqXG4gKiBSZWRpcmVjdHMgYXJlIHBsYWNlZCBhbG9uZ3NpZGUgcm91dGVzIGluIHRoZSByb3V0ZSBjb25maWd1cmF0aW9uXG4gKiBhbmQgYXJlIHRyYXZlcnNlZCBpbiB0aGUgc2FtZSBtYW5uZXIuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3JlcXVpcmUtcmVuZGVyLXJldHVybiAqL1xuXG52YXIgUmVkaXJlY3QgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlZGlyZWN0JyxcblxuXG4gIHN0YXRpY3M6IHtcbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgcm91dGUgPSAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KShlbGVtZW50KTtcblxuICAgICAgaWYgKHJvdXRlLmZyb20pIHJvdXRlLnBhdGggPSByb3V0ZS5mcm9tO1xuXG4gICAgICByb3V0ZS5vbkVudGVyID0gZnVuY3Rpb24gKG5leHRTdGF0ZSwgcmVwbGFjZSkge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBuZXh0U3RhdGUubG9jYXRpb24sXG4gICAgICAgICAgICBwYXJhbXMgPSBuZXh0U3RhdGUucGFyYW1zO1xuXG5cbiAgICAgICAgdmFyIHBhdGhuYW1lID0gdm9pZCAwO1xuICAgICAgICBpZiAocm91dGUudG8uY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfUGF0dGVyblV0aWxzLmZvcm1hdFBhdHRlcm4pKHJvdXRlLnRvLCBwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFyb3V0ZS50bykge1xuICAgICAgICAgIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvdXRlSW5kZXggPSBuZXh0U3RhdGUucm91dGVzLmluZGV4T2Yocm91dGUpO1xuICAgICAgICAgIHZhciBwYXJlbnRQYXR0ZXJuID0gUmVkaXJlY3QuZ2V0Um91dGVQYXR0ZXJuKG5leHRTdGF0ZS5yb3V0ZXMsIHJvdXRlSW5kZXggLSAxKTtcbiAgICAgICAgICB2YXIgcGF0dGVybiA9IHBhcmVudFBhdHRlcm4ucmVwbGFjZSgvXFwvKiQvLCAnLycpICsgcm91dGUudG87XG4gICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuKShwYXR0ZXJuLCBwYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVwbGFjZSh7XG4gICAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgICAgICAgIHF1ZXJ5OiByb3V0ZS5xdWVyeSB8fCBsb2NhdGlvbi5xdWVyeSxcbiAgICAgICAgICBzdGF0ZTogcm91dGUuc3RhdGUgfHwgbG9jYXRpb24uc3RhdGVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcm91dGU7XG4gICAgfSxcbiAgICBnZXRSb3V0ZVBhdHRlcm46IGZ1bmN0aW9uIGdldFJvdXRlUGF0dGVybihyb3V0ZXMsIHJvdXRlSW5kZXgpIHtcbiAgICAgIHZhciBwYXJlbnRQYXR0ZXJuID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSByb3V0ZUluZGV4OyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXNbaV07XG4gICAgICAgIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICAgICAgICBwYXJlbnRQYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyBwYXJlbnRQYXR0ZXJuO1xuXG4gICAgICAgIGlmIChwYXR0ZXJuLmluZGV4T2YoJy8nKSA9PT0gMCkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnLycgKyBwYXJlbnRQYXR0ZXJuO1xuICAgIH1cbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZnJvbTogc3RyaW5nLCAvLyBBbGlhcyBmb3IgcGF0aFxuICAgIHRvOiBzdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBxdWVyeTogb2JqZWN0LFxuICAgIHN0YXRlOiBvYmplY3QsXG4gICAgb25FbnRlcjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3lcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8UmVkaXJlY3Q+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlZGlyZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL1JlZGlyZWN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnVuYyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMuZnVuYztcblxuLyoqXG4gKiBBbiA8SW5kZXhSb3V0ZT4gaXMgdXNlZCB0byBzcGVjaWZ5IGl0cyBwYXJlbnQncyA8Um91dGUgaW5kZXhSb3V0ZT4gaW5cbiAqIGEgSlNYIHJvdXRlIGNvbmZpZy5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcmVxdWlyZS1yZW5kZXItcmV0dXJuICovXG5cbnZhciBJbmRleFJvdXRlID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdJbmRleFJvdXRlJyxcblxuXG4gIHN0YXRpY3M6IHtcbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHNhbml0eSBjaGVjayAqL1xuICAgICAgaWYgKHBhcmVudFJvdXRlKSB7XG4gICAgICAgIHBhcmVudFJvdXRlLmluZGV4Um91dGUgPSAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KShlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQW4gPEluZGV4Um91dGU+IGRvZXMgbm90IG1ha2Ugc2Vuc2UgYXQgdGhlIHJvb3Qgb2YgeW91ciByb3V0ZSBjb25maWcnKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxuICAgIGNvbXBvbmVudDogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzOiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50cyxcbiAgICBnZXRDb21wb25lbnQ6IGZ1bmMsXG4gICAgZ2V0Q29tcG9uZW50czogZnVuY1xuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxJbmRleFJvdXRlPiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleFJvdXRlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4Um91dGUuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcyxcbiAgICBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZyxcbiAgICBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xuXG4vKipcbiAqIEEgPFJvdXRlPiBpcyB1c2VkIHRvIGRlY2xhcmUgd2hpY2ggY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgdG8gdGhlXG4gKiBwYWdlIHdoZW4gdGhlIFVSTCBtYXRjaGVzIGEgZ2l2ZW4gcGF0dGVybi5cbiAqXG4gKiBSb3V0ZXMgYXJlIGFycmFuZ2VkIGluIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlLiBXaGVuIGEgbmV3IFVSTCBpc1xuICogcmVxdWVzdGVkLCB0aGUgdHJlZSBpcyBzZWFyY2hlZCBkZXB0aC1maXJzdCB0byBmaW5kIGEgcm91dGUgd2hvc2VcbiAqIHBhdGggbWF0Y2hlcyB0aGUgVVJMLiAgV2hlbiBvbmUgaXMgZm91bmQsIGFsbCByb3V0ZXMgaW4gdGhlIHRyZWVcbiAqIHRoYXQgbGVhZCB0byBpdCBhcmUgY29uc2lkZXJlZCBcImFjdGl2ZVwiIGFuZCB0aGVpciBjb21wb25lbnRzIGFyZVxuICogcmVuZGVyZWQgaW50byB0aGUgRE9NLCBuZXN0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgaW4gdGhlIHRyZWUuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3JlcXVpcmUtcmVuZGVyLXJldHVybiAqL1xuXG52YXIgUm91dGUgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRlJyxcblxuXG4gIHN0YXRpY3M6IHtcbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudFxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IHN0cmluZyxcbiAgICBjb21wb25lbnQ6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnQsXG4gICAgY29tcG9uZW50czogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudHMsXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jLFxuICAgIGdldENvbXBvbmVudHM6IGZ1bmNcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8Um91dGU+IGVsZW1lbnRzIGFyZSBmb3Igcm91dGVyIGNvbmZpZ3VyYXRpb24gb25seSBhbmQgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9BY3Rpb25zJyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9Sb3V0ZXJVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVyVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIEEgaGlnaC1sZXZlbCBBUEkgdG8gYmUgdXNlZCBmb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF0Y2hlcyBhIGxvY2F0aW9uIHRvIGEgc2V0IG9mIHJvdXRlcyBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCByZW5kZXJQcm9wcykgd2hlbiBmaW5pc2hlZC5cbiAqXG4gKiBOb3RlOiBZb3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byB1c2UgdGhpcyBpbiBhIGJyb3dzZXIgdW5sZXNzIHlvdSdyZSB1c2luZ1xuICogc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdpdGggYXN5bmMgcm91dGVzLlxuICovXG5mdW5jdGlvbiBtYXRjaChfcmVmLCBjYWxsYmFjaykge1xuICB2YXIgaGlzdG9yeSA9IF9yZWYuaGlzdG9yeSxcbiAgICAgIHJvdXRlcyA9IF9yZWYucm91dGVzLFxuICAgICAgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2hpc3RvcnknLCAncm91dGVzJywgJ2xvY2F0aW9uJ10pO1xuXG4gICEoaGlzdG9yeSB8fCBsb2NhdGlvbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnbWF0Y2ggbmVlZHMgYSBoaXN0b3J5IG9yIGEgbG9jYXRpb24nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgaGlzdG9yeSA9IGhpc3RvcnkgPyBoaXN0b3J5IDogKDAsIF9jcmVhdGVNZW1vcnlIaXN0b3J5Mi5kZWZhdWx0KShvcHRpb25zKTtcbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoaGlzdG9yeSwgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykocm91dGVzKSk7XG5cbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgLy8gQWxsb3cgbWF0Y2goeyBsb2NhdGlvbjogJy90aGUvcGF0aCcsIC4uLiB9KVxuICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24gPSBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpO1xuICB9XG5cbiAgdHJhbnNpdGlvbk1hbmFnZXIubWF0Y2gobG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlKSB7XG4gICAgdmFyIHJlbmRlclByb3BzID0gdm9pZCAwO1xuXG4gICAgaWYgKG5leHRTdGF0ZSkge1xuICAgICAgdmFyIHJvdXRlciA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGVyT2JqZWN0KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlciwgbmV4dFN0YXRlKTtcbiAgICAgIHJlbmRlclByb3BzID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xuICAgICAgICByb3V0ZXI6IHJvdXRlcixcbiAgICAgICAgbWF0Y2hDb250ZXh0OiB7IHRyYW5zaXRpb25NYW5hZ2VyOiB0cmFuc2l0aW9uTWFuYWdlciwgcm91dGVyOiByb3V0ZXIgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24gJiYgaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihyZWRpcmVjdExvY2F0aW9uLCBfQWN0aW9ucy5SRVBMQUNFKSwgcmVuZGVyUHJvcHMpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2guanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5wdXNoLlxuICovXG52YXIgUFVTSCA9IGV4cG9ydHMuUFVTSCA9ICdQVVNIJztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgYSBjYWxsIHRvIGhpc3RvcnkucmVwbGFjZS5cbiAqL1xudmFyIFJFUExBQ0UgPSBleHBvcnRzLlJFUExBQ0UgPSAnUkVQTEFDRSc7XG5cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IHNvbWUgb3RoZXIgYWN0aW9uIHN1Y2hcbiAqIGFzIHVzaW5nIGEgYnJvd3NlcidzIGJhY2svZm9yd2FyZCBidXR0b25zIGFuZC9vciBtYW51YWxseSBtYW5pcHVsYXRpbmdcbiAqIHRoZSBVUkwgaW4gYSBicm93c2VyJ3MgbG9jYXRpb24gYmFyLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93RXZlbnRIYW5kbGVycy9vbnBvcHN0YXRlXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIFBPUCA9IGV4cG9ydHMuUE9QID0gJ1BPUCc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi9BY3Rpb25zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlTWVtb3J5SGlzdG9yeTtcblxudmFyIF91c2VRdWVyaWVzID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlUXVlcmllcycpO1xuXG52YXIgX3VzZVF1ZXJpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUXVlcmllcyk7XG5cbnZhciBfdXNlQmFzZW5hbWUgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VCYXNlbmFtZScpO1xuXG52YXIgX3VzZUJhc2VuYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZUJhc2VuYW1lKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3Rvcnkob3B0aW9ucykge1xuICAvLyBzaWduYXR1cmVzIGFuZCB0eXBlIGNoZWNraW5nIGRpZmZlciBiZXR3ZWVuIGB1c2VRdWVyaWVzYCBhbmRcbiAgLy8gYGNyZWF0ZU1lbW9yeUhpc3RvcnlgLCBoYXZlIHRvIGNyZWF0ZSBgbWVtb3J5SGlzdG9yeWAgZmlyc3QgYmVjYXVzZVxuICAvLyBgdXNlUXVlcmllc2AgZG9lc24ndCB1bmRlcnN0YW5kIHRoZSBzaWduYXR1cmVcbiAgdmFyIG1lbW9yeUhpc3RvcnkgPSAoMCwgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyLmRlZmF1bHQpKG9wdGlvbnMpO1xuICB2YXIgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XG4gICAgcmV0dXJuIG1lbW9yeUhpc3Rvcnk7XG4gIH07XG4gIHZhciBoaXN0b3J5ID0gKDAsIF91c2VRdWVyaWVzMi5kZWZhdWx0KSgoMCwgX3VzZUJhc2VuYW1lMi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSkob3B0aW9ucyk7XG4gIHJldHVybiBoaXN0b3J5O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeS1zdHJpbmcnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBkZWZhdWx0U3RyaW5naWZ5UXVlcnkgPSBmdW5jdGlvbiBkZWZhdWx0U3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgcmV0dXJuICgwLCBfcXVlcnlTdHJpbmcuc3RyaW5naWZ5KShxdWVyeSkucmVwbGFjZSgvJTIwL2csICcrJyk7XG59O1xuXG52YXIgZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcucGFyc2U7XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjcmVhdGVIaXN0b3J5IGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGhvdyB0byBoYW5kbGUgVVJMIHF1ZXJpZXMuXG4gKi9cbnZhciB1c2VRdWVyaWVzID0gZnVuY3Rpb24gdXNlUXVlcmllcyhjcmVhdGVIaXN0b3J5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciBoaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShvcHRpb25zKTtcbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBvcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gb3B0aW9ucy5wYXJzZVF1ZXJ5U3RyaW5nO1xuXG5cbiAgICBpZiAodHlwZW9mIHN0cmluZ2lmeVF1ZXJ5ICE9PSAnZnVuY3Rpb24nKSBzdHJpbmdpZnlRdWVyeSA9IGRlZmF1bHRTdHJpbmdpZnlRdWVyeTtcblxuICAgIGlmICh0eXBlb2YgcGFyc2VRdWVyeVN0cmluZyAhPT0gJ2Z1bmN0aW9uJykgcGFyc2VRdWVyeVN0cmluZyA9IGRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nO1xuXG4gICAgdmFyIGRlY29kZVF1ZXJ5ID0gZnVuY3Rpb24gZGVjb2RlUXVlcnkobG9jYXRpb24pIHtcbiAgICAgIGlmICghbG9jYXRpb24pIHJldHVybiBsb2NhdGlvbjtcblxuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5ID09IG51bGwpIGxvY2F0aW9uLnF1ZXJ5ID0gcGFyc2VRdWVyeVN0cmluZyhsb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpKTtcblxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH07XG5cbiAgICB2YXIgZW5jb2RlUXVlcnkgPSBmdW5jdGlvbiBlbmNvZGVRdWVyeShsb2NhdGlvbiwgcXVlcnkpIHtcbiAgICAgIGlmIChxdWVyeSA9PSBudWxsKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICAgIHZhciBvYmplY3QgPSB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShsb2NhdGlvbikgOiBsb2NhdGlvbjtcbiAgICAgIHZhciBxdWVyeVN0cmluZyA9IHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KTtcbiAgICAgIHZhciBzZWFyY2ggPSBxdWVyeVN0cmluZyA/ICc/JyArIHF1ZXJ5U3RyaW5nIDogJyc7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgb2JqZWN0LCB7XG4gICAgICAgIHNlYXJjaDogc2VhcmNoXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZGVjb2RlUXVlcnkoaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuQmVmb3JlKGZ1bmN0aW9uIChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuICgwLCBfcnVuVHJhbnNpdGlvbkhvb2syLmRlZmF1bHQpKGhvb2ssIGRlY29kZVF1ZXJ5KGxvY2F0aW9uKSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKGRlY29kZVF1ZXJ5KGxvY2F0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHdyaXRlIG1ldGhvZHMgd2l0aCBxdWVyeS1hd2FyZSB2ZXJzaW9ucy5cbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LnB1c2goZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfTtcblxuICAgIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkucmVwbGFjZShlbmNvZGVRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKGVuY29kZVF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYoZW5jb2RlUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdMb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW2VuY29kZVF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSldLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgIGlmIChsb2NhdGlvbi5xdWVyeSkgbmV3TG9jYXRpb24ucXVlcnkgPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlUXVlcnkpKGxvY2F0aW9uLnF1ZXJ5KTtcblxuICAgICAgcmV0dXJuIGRlY29kZVF1ZXJ5KG5ld0xvY2F0aW9uKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uXG4gICAgfSk7XG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB1c2VRdWVyaWVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vaGlzdG9yeS9saWIvdXNlUXVlcmllcy5qcyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJpY3RVcmlFbmNvZGUgPSByZXF1aXJlKCdzdHJpY3QtdXJpLWVuY29kZScpO1xudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCBvcHRzKSB7XG5cdGlmIChvcHRzLmVuY29kZSkge1xuXHRcdHJldHVybiBvcHRzLnN0cmljdCA/IHN0cmljdFVyaUVuY29kZSh2YWx1ZSkgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBzdHIuc3BsaXQoJz8nKVsxXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdC8vIENyZWF0ZSBhbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGVcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvaXNzdWVzLzQ3XG5cdHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cblx0aWYgKCFzdHIpIHtcblx0XHRyZXR1cm4gcmV0O1xuXHR9XG5cblx0c3RyLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcblx0XHR2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuXHRcdC8vIEZpcmVmb3ggKHByZSA0MCkgZGVjb2RlcyBgJTNEYCB0byBgPWBcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9wdWxsLzM3XG5cdFx0dmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cy5qb2luKCc9JykgOiB1bmRlZmluZWQ7XG5cblx0XHRrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcblxuXHRcdC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG5cdFx0Ly8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuXHRcdHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG5cdFx0aWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldFtrZXldID0gdmFsO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcblx0XHRcdHJldFtrZXldLnB1c2godmFsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG5cdHZhciBkZWZhdWx0cyA9IHtcblx0XHRlbmNvZGU6IHRydWUsXG5cdFx0c3RyaWN0OiB0cnVlXG5cdH07XG5cblx0b3B0cyA9IG9iamVjdEFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG5cblx0cmV0dXJuIG9iaiA/IE9iamVjdC5rZXlzKG9iaikuc29ydCgpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHZhbCA9IG9ialtrZXldO1xuXG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShrZXksIG9wdHMpO1xuXHRcdH1cblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRcdHZhciByZXN1bHQgPSBbXTtcblxuXHRcdFx0dmFsLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAodmFsMikge1xuXHRcdFx0XHRpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHZhbDIgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXN1bHQucHVzaChlbmNvZGUoa2V5LCBvcHRzKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goZW5jb2RlKGtleSwgb3B0cykgKyAnPScgKyBlbmNvZGUodmFsMiwgb3B0cykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdC5qb2luKCcmJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVuY29kZShrZXksIG9wdHMpICsgJz0nICsgZW5jb2RlKHZhbCwgb3B0cyk7XG5cdH0pLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4Lmxlbmd0aCA+IDA7XG5cdH0pLmpvaW4oJyYnKSA6ICcnO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vcXVlcnktc3RyaW5nL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0fSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBydW5UcmFuc2l0aW9uSG9vayA9IGZ1bmN0aW9uIHJ1blRyYW5zaXRpb25Ib29rKGhvb2ssIGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICB2YXIgcmVzdWx0ID0gaG9vayhsb2NhdGlvbiwgY2FsbGJhY2spO1xuXG4gIGlmIChob29rLmxlbmd0aCA8IDIpIHtcbiAgICAvLyBBc3N1bWUgdGhlIGhvb2sgcnVucyBzeW5jaHJvbm91c2x5IGFuZCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcmV0dXJuIHZhbHVlLlxuICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkocmVzdWx0ID09PSB1bmRlZmluZWQsICdZb3Ugc2hvdWxkIG5vdCBcInJldHVyblwiIGluIGEgdHJhbnNpdGlvbiBob29rIHdpdGggYSBjYWxsYmFjayBhcmd1bWVudDsgJyArICdjYWxsIHRoZSBjYWxsYmFjayBpbnN0ZWFkJykgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJ1blRyYW5zaXRpb25Ib29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvY2F0aW9uc0FyZUVxdWFsID0gZXhwb3J0cy5zdGF0ZXNBcmVFcXVhbCA9IGV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSBleHBvcnRzLmNyZWF0ZVF1ZXJ5ID0gdW5kZWZpbmVkO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVRdWVyeSA9IGV4cG9ydHMuY3JlYXRlUXVlcnkgPSBmdW5jdGlvbiBjcmVhdGVRdWVyeShwcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoT2JqZWN0LmNyZWF0ZShudWxsKSwgcHJvcHMpO1xufTtcblxudmFyIGNyZWF0ZUxvY2F0aW9uID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKCkge1xuICB2YXIgaW5wdXQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnLycgOiBhcmd1bWVudHNbMF07XG4gIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfQWN0aW9ucy5QT1AgOiBhcmd1bWVudHNbMV07XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBvYmplY3QgPSB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShpbnB1dCkgOiBpbnB1dDtcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghb2JqZWN0LnBhdGgsICdMb2NhdGlvbiBkZXNjcmlwdG9yIG9iamVjdHMgc2hvdWxkIGhhdmUgYSBgcGF0aG5hbWVgLCBub3QgYSBgcGF0aGAuJykgOiB2b2lkIDA7XG5cbiAgdmFyIHBhdGhuYW1lID0gb2JqZWN0LnBhdGhuYW1lIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9IG9iamVjdC5zZWFyY2ggfHwgJyc7XG4gIHZhciBoYXNoID0gb2JqZWN0Lmhhc2ggfHwgJyc7XG4gIHZhciBzdGF0ZSA9IG9iamVjdC5zdGF0ZTtcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoLFxuICAgIHN0YXRlOiBzdGF0ZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBrZXk6IGtleVxuICB9O1xufTtcblxudmFyIGlzRGF0ZSA9IGZ1bmN0aW9uIGlzRGF0ZShvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG52YXIgc3RhdGVzQXJlRXF1YWwgPSBleHBvcnRzLnN0YXRlc0FyZUVxdWFsID0gZnVuY3Rpb24gc3RhdGVzQXJlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHR5cGVvZkEgPSB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSk7XG4gIHZhciB0eXBlb2ZCID0gdHlwZW9mIGIgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGIpO1xuXG4gIGlmICh0eXBlb2ZBICE9PSB0eXBlb2ZCKSByZXR1cm4gZmFsc2U7XG5cbiAgISh0eXBlb2ZBICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdZb3UgbXVzdCBub3Qgc3RvcmUgZnVuY3Rpb25zIGluIGxvY2F0aW9uIHN0YXRlJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gIC8vIE5vdCB0aGUgc2FtZSBvYmplY3QsIGJ1dCBzYW1lIHR5cGUuXG4gIGlmICh0eXBlb2ZBID09PSAnb2JqZWN0Jykge1xuICAgICEhKGlzRGF0ZShhKSAmJiBpc0RhdGUoYikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBtdXN0IG5vdCBzdG9yZSBEYXRlIG9iamVjdHMgaW4gbG9jYXRpb24gc3RhdGUnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIHZhciBrZXlzb2ZBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICB2YXIga2V5c29mQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgcmV0dXJuIGtleXNvZkEubGVuZ3RoID09PSBrZXlzb2ZCLmxlbmd0aCAmJiBrZXlzb2ZBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlc0FyZUVxdWFsKGFba2V5XSwgYltrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHN0YXRlc0FyZUVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFsbCBvdGhlciBzZXJpYWxpemFibGUgdHlwZXMgKHN0cmluZywgbnVtYmVyLCBib29sZWFuKVxuICAvLyBzaG91bGQgYmUgc3RyaWN0IGVxdWFsLlxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgbG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLmxvY2F0aW9uc0FyZUVxdWFsID0gZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5rZXkgPT09IGIua2V5ICYmXG4gIC8vIGEuYWN0aW9uID09PSBiLmFjdGlvbiAmJiAvLyBEaWZmZXJlbnQgYWN0aW9uICE9PSBsb2NhdGlvbiBjaGFuZ2UuXG4gIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoICYmIHN0YXRlc0FyZUVxdWFsKGEuc3RhdGUsIGIuc3RhdGUpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL0xvY2F0aW9uVXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZVBhdGggPSBleHBvcnRzLnBhcnNlUGF0aCA9IGV4cG9ydHMuZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZXhwb3J0cy5zdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCA9IGV4cG9ydHMuYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aCA9IHVuZGVmaW5lZDtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoID0gZXhwb3J0cy5hZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoID0gZnVuY3Rpb24gYWRkUXVlcnlTdHJpbmdWYWx1ZVRvUGF0aChwYXRoLCBrZXksIHZhbHVlKSB7XG4gIHZhciBfcGFyc2VQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuXG4gIHZhciBwYXRobmFtZSA9IF9wYXJzZVBhdGgucGF0aG5hbWU7XG4gIHZhciBzZWFyY2ggPSBfcGFyc2VQYXRoLnNlYXJjaDtcbiAgdmFyIGhhc2ggPSBfcGFyc2VQYXRoLmhhc2g7XG5cblxuICByZXR1cm4gY3JlYXRlUGF0aCh7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoICsgKHNlYXJjaC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIGtleSArICc9JyArIHZhbHVlLFxuICAgIGhhc2g6IGhhc2hcbiAgfSk7XG59O1xuXG52YXIgc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBleHBvcnRzLnN0cmlwUXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZnVuY3Rpb24gc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwga2V5KSB7XG4gIHZhciBfcGFyc2VQYXRoMiA9IHBhcnNlUGF0aChwYXRoKTtcblxuICB2YXIgcGF0aG5hbWUgPSBfcGFyc2VQYXRoMi5wYXRobmFtZTtcbiAgdmFyIHNlYXJjaCA9IF9wYXJzZVBhdGgyLnNlYXJjaDtcbiAgdmFyIGhhc2ggPSBfcGFyc2VQYXRoMi5oYXNoO1xuXG5cbiAgcmV0dXJuIGNyZWF0ZVBhdGgoe1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaC5yZXBsYWNlKG5ldyBSZWdFeHAoJyhbPyZdKScgKyBrZXkgKyAnPVthLXpBLVowLTldKygmPyknKSwgZnVuY3Rpb24gKG1hdGNoLCBwcmVmaXgsIHN1ZmZpeCkge1xuICAgICAgcmV0dXJuIHByZWZpeCA9PT0gJz8nID8gcHJlZml4IDogc3VmZml4O1xuICAgIH0pLFxuICAgIGhhc2g6IGhhc2hcbiAgfSk7XG59O1xuXG52YXIgZ2V0UXVlcnlTdHJpbmdWYWx1ZUZyb21QYXRoID0gZXhwb3J0cy5nZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGggPSBmdW5jdGlvbiBnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwga2V5KSB7XG4gIHZhciBfcGFyc2VQYXRoMyA9IHBhcnNlUGF0aChwYXRoKTtcblxuICB2YXIgc2VhcmNoID0gX3BhcnNlUGF0aDMuc2VhcmNoO1xuXG4gIHZhciBtYXRjaCA9IHNlYXJjaC5tYXRjaChuZXcgUmVnRXhwKCdbPyZdJyArIGtleSArICc9KFthLXpBLVowLTldKyknKSk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn07XG5cbnZhciBleHRyYWN0UGF0aCA9IGZ1bmN0aW9uIGV4dHJhY3RQYXRoKHN0cmluZykge1xuICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oaHR0cHM/Oik/XFwvXFwvW15cXC9dKi8pO1xuICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IHN0cmluZyA6IHN0cmluZy5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbn07XG5cbnZhciBwYXJzZVBhdGggPSBleHBvcnRzLnBhcnNlUGF0aCA9IGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IGV4dHJhY3RQYXRoKHBhdGgpO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkocGF0aCA9PT0gcGF0aG5hbWUsICdBIHBhdGggbXVzdCBiZSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2ggb25seSwgbm90IGEgZnVsbCBVUkwgbGlrZSBcIiVzXCInLCBwYXRoKSA6IHZvaWQgMDtcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICBpZiAocGF0aG5hbWUgPT09ICcnKSBwYXRobmFtZSA9ICcvJztcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoXG4gIH07XG59O1xuXG52YXIgY3JlYXRlUGF0aCA9IGV4cG9ydHMuY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgaWYgKGxvY2F0aW9uID09IG51bGwgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHZhciBiYXNlbmFtZSA9IGxvY2F0aW9uLmJhc2VuYW1lO1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG4gIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lO1xuXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoO1xuXG4gIGlmIChoYXNoKSBwYXRoICs9IGhhc2g7XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vaGlzdG9yeS9saWIvUGF0aFV0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdXNlQmFzZW5hbWUgPSBmdW5jdGlvbiB1c2VCYXNlbmFtZShjcmVhdGVIaXN0b3J5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciBoaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShvcHRpb25zKTtcbiAgICB2YXIgYmFzZW5hbWUgPSBvcHRpb25zLmJhc2VuYW1lO1xuXG5cbiAgICB2YXIgYWRkQmFzZW5hbWUgPSBmdW5jdGlvbiBhZGRCYXNlbmFtZShsb2NhdGlvbikge1xuICAgICAgaWYgKCFsb2NhdGlvbikgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICBpZiAoYmFzZW5hbWUgJiYgbG9jYXRpb24uYmFzZW5hbWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlbmFtZSkgPT09IDApIHtcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cmluZyhiYXNlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgIGxvY2F0aW9uLmJhc2VuYW1lID0gYmFzZW5hbWU7XG5cbiAgICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09ICcnKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9O1xuXG4gICAgdmFyIHByZXBlbmRCYXNlbmFtZSA9IGZ1bmN0aW9uIHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikge1xuICAgICAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICB2YXIgb2JqZWN0ID0gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJyA/ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkobG9jYXRpb24pIDogbG9jYXRpb247XG4gICAgICB2YXIgcG5hbWUgPSBvYmplY3QucGF0aG5hbWU7XG4gICAgICB2YXIgbm9ybWFsaXplZEJhc2VuYW1lID0gYmFzZW5hbWUuc2xpY2UoLTEpID09PSAnLycgPyBiYXNlbmFtZSA6IGJhc2VuYW1lICsgJy8nO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRQYXRobmFtZSA9IHBuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gcG5hbWUuc2xpY2UoMSkgOiBwbmFtZTtcbiAgICAgIHZhciBwYXRobmFtZSA9IG5vcm1hbGl6ZWRCYXNlbmFtZSArIG5vcm1hbGl6ZWRQYXRobmFtZTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBvYmplY3QsIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIGJhc2VuYW1lLWF3YXJlIHZlcnNpb25zLlxuICAgIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gYWRkQmFzZW5hbWUoaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW5CZWZvcmUgPSBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuQmVmb3JlKGZ1bmN0aW9uIChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuICgwLCBfcnVuVHJhbnNpdGlvbkhvb2syLmRlZmF1bHQpKGhvb2ssIGFkZEJhc2VuYW1lKGxvY2F0aW9uKSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyKGFkZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHdyaXRlIG1ldGhvZHMgd2l0aCBiYXNlbmFtZS1hd2FyZSB2ZXJzaW9ucy5cbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LnB1c2gocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfTtcblxuICAgIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkucmVwbGFjZShwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGRCYXNlbmFtZShoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uLmFwcGx5KGhpc3RvcnksIFtwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pXS5jb25jYXQoYXJncykpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uXG4gICAgfSk7XG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB1c2VCYXNlbmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVTdGF0ZVN0b3JhZ2UgPSBmdW5jdGlvbiBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcykge1xuICByZXR1cm4gZW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnN0YXRlO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGVudHJ5KSB7XG4gICAgbWVtb1tlbnRyeS5rZXldID0gZW50cnkuc3RhdGU7XG4gICAgcmV0dXJuIG1lbW87XG4gIH0sIHt9KTtcbn07XG5cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IG9wdGlvbnMgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0geyBlbnRyaWVzOiBbb3B0aW9uc10gfTtcbiAgfVxuXG4gIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tjdXJyZW50XTtcbiAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGVudHJ5KTtcblxuICAgIHZhciBrZXkgPSB2b2lkIDAsXG4gICAgICAgIHN0YXRlID0gdm9pZCAwO1xuICAgIGlmIChlbnRyeS5rZXkpIHtcbiAgICAgIGtleSA9IGVudHJ5LmtleTtcbiAgICAgIHN0YXRlID0gcmVhZFN0YXRlKGtleSk7XG4gICAgfVxuXG4gICAgdmFyIGluaXQgPSAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKHBhdGgpO1xuXG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoX2V4dGVuZHMoe30sIGluaXQsIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNhbkdvID0gZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBpbmRleCA9IGN1cnJlbnQgKyBuO1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGlmICghbikgcmV0dXJuO1xuXG4gICAgaWYgKCFjYW5HbyhuKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdDYW5ub3QgZ28oJXMpIHRoZXJlIGlzIG5vdCBlbm91Z2ggaGlzdG9yeScsIG4pIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudCArPSBuO1xuICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24oKTtcblxuICAgIC8vIENoYW5nZSBhY3Rpb24gdG8gUE9QXG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oX2V4dGVuZHMoe30sIGN1cnJlbnRMb2NhdGlvbiwgeyBhY3Rpb246IF9BY3Rpb25zLlBPUCB9KSk7XG4gIH07XG5cbiAgdmFyIHB1c2hMb2NhdGlvbiA9IGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIGN1cnJlbnQgKz0gMTtcblxuICAgIGlmIChjdXJyZW50IDwgZW50cmllcy5sZW5ndGgpIGVudHJpZXMuc3BsaWNlKGN1cnJlbnQpO1xuXG4gICAgZW50cmllcy5wdXNoKGxvY2F0aW9uKTtcblxuICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZUxvY2F0aW9uID0gZnVuY3Rpb24gcmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgZW50cmllc1tjdXJyZW50XSA9IGxvY2F0aW9uO1xuICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9ICgwLCBfY3JlYXRlSGlzdG9yeTIuZGVmYXVsdCkoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBwdXNoTG9jYXRpb246IHB1c2hMb2NhdGlvbixcbiAgICByZXBsYWNlTG9jYXRpb246IHJlcGxhY2VMb2NhdGlvbixcbiAgICBnbzogZ29cbiAgfSkpO1xuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnM7XG4gIHZhciBlbnRyaWVzID0gX29wdGlvbnMuZW50cmllcztcbiAgdmFyIGN1cnJlbnQgPSBfb3B0aW9ucy5jdXJyZW50O1xuXG5cbiAgaWYgKHR5cGVvZiBlbnRyaWVzID09PSAnc3RyaW5nJykge1xuICAgIGVudHJpZXMgPSBbZW50cmllc107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcbiAgICBlbnRyaWVzID0gWycvJ107XG4gIH1cblxuICBlbnRyaWVzID0gZW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoZW50cnkpO1xuICB9KTtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgY3VycmVudCA9IGVudHJpZXMubGVuZ3RoIC0gMTtcbiAgfSBlbHNlIHtcbiAgICAhKGN1cnJlbnQgPj0gMCAmJiBjdXJyZW50IDwgZW50cmllcy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ0N1cnJlbnQgaW5kZXggbXVzdCBiZSA+PSAwIGFuZCA8ICVzLCB3YXMgJXMnLCBlbnRyaWVzLmxlbmd0aCwgY3VycmVudCkgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgdmFyIHN0b3JhZ2UgPSBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcyk7XG5cbiAgdmFyIHNhdmVTdGF0ZSA9IGZ1bmN0aW9uIHNhdmVTdGF0ZShrZXksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0b3JhZ2Vba2V5XSA9IHN0YXRlO1xuICB9O1xuXG4gIHZhciByZWFkU3RhdGUgPSBmdW5jdGlvbiByZWFkU3RhdGUoa2V5KSB7XG4gICAgcmV0dXJuIHN0b3JhZ2Vba2V5XTtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBjYW5HbzogY2FuR29cbiAgfSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gb3B0aW9ucy5nZXRDdXJyZW50TG9jYXRpb247XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gb3B0aW9ucy5nZXRVc2VyQ29uZmlybWF0aW9uO1xuICB2YXIgcHVzaExvY2F0aW9uID0gb3B0aW9ucy5wdXNoTG9jYXRpb247XG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBvcHRpb25zLnJlcGxhY2VMb2NhdGlvbjtcbiAgdmFyIGdvID0gb3B0aW9ucy5nbztcbiAgdmFyIGtleUxlbmd0aCA9IG9wdGlvbnMua2V5TGVuZ3RoO1xuXG5cbiAgdmFyIGN1cnJlbnRMb2NhdGlvbiA9IHZvaWQgMDtcbiAgdmFyIHBlbmRpbmdMb2NhdGlvbiA9IHZvaWQgMDtcbiAgdmFyIGJlZm9yZUxpc3RlbmVycyA9IFtdO1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBhbGxLZXlzID0gW107XG5cbiAgdmFyIGdldEN1cnJlbnRJbmRleCA9IGZ1bmN0aW9uIGdldEN1cnJlbnRJbmRleCgpIHtcbiAgICBpZiAocGVuZGluZ0xvY2F0aW9uICYmIHBlbmRpbmdMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihwZW5kaW5nTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChjdXJyZW50TG9jYXRpb24pIHJldHVybiBhbGxLZXlzLmluZGV4T2YoY3VycmVudExvY2F0aW9uLmtleSk7XG5cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gdXBkYXRlTG9jYXRpb24obmV4dExvY2F0aW9uKSB7XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xuXG4gICAgY3VycmVudExvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuXG4gICAgaWYgKGN1cnJlbnRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgIGFsbEtleXMgPSBbXS5jb25jYXQoYWxsS2V5cy5zbGljZSgwLCBjdXJyZW50SW5kZXggKyAxKSwgW2N1cnJlbnRMb2NhdGlvbi5rZXldKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlJFUExBQ0UpIHtcbiAgICAgIGFsbEtleXNbY3VycmVudEluZGV4XSA9IGN1cnJlbnRMb2NhdGlvbi5rZXk7XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIoY3VycmVudExvY2F0aW9uKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuQmVmb3JlID0gZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgYmVmb3JlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiZWZvcmVMaXN0ZW5lcnMgPSBiZWZvcmVMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjb25maXJtVHJhbnNpdGlvblRvID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShiZWZvcmVMaXN0ZW5lcnMubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICAgICgwLCBfcnVuVHJhbnNpdGlvbkhvb2syLmRlZmF1bHQpKGJlZm9yZUxpc3RlbmVyc1tpbmRleF0sIGxvY2F0aW9uLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IGRvbmUocmVzdWx0KSA6IG5leHQoKTtcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBpZiAoZ2V0VXNlckNvbmZpcm1hdGlvbiAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sob2sgIT09IGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhtZXNzYWdlICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25UbyhuZXh0TG9jYXRpb24pIHtcbiAgICBpZiAoY3VycmVudExvY2F0aW9uICYmICgwLCBfTG9jYXRpb25VdGlscy5sb2NhdGlvbnNBcmVFcXVhbCkoY3VycmVudExvY2F0aW9uLCBuZXh0TG9jYXRpb24pIHx8IHBlbmRpbmdMb2NhdGlvbiAmJiAoMCwgX0xvY2F0aW9uVXRpbHMubG9jYXRpb25zQXJlRXF1YWwpKHBlbmRpbmdMb2NhdGlvbiwgbmV4dExvY2F0aW9uKSkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvXG5cbiAgICBwZW5kaW5nTG9jYXRpb24gPSBuZXh0TG9jYXRpb247XG5cbiAgICBjb25maXJtVHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAocGVuZGluZ0xvY2F0aW9uICE9PSBuZXh0TG9jYXRpb24pIHJldHVybjsgLy8gVHJhbnNpdGlvbiB3YXMgaW50ZXJydXB0ZWQgZHVyaW5nIGNvbmZpcm1hdGlvblxuXG4gICAgICBwZW5kaW5nTG9jYXRpb24gPSBudWxsO1xuXG4gICAgICBpZiAob2spIHtcbiAgICAgICAgLy8gVHJlYXQgUFVTSCB0byBzYW1lIHBhdGggbGlrZSBSRVBMQUNFIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBicm93c2Vyc1xuICAgICAgICBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGN1cnJlbnRMb2NhdGlvbik7XG4gICAgICAgICAgdmFyIG5leHRQYXRoID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobmV4dExvY2F0aW9uKTtcblxuICAgICAgICAgIGlmIChuZXh0UGF0aCA9PT0gcHJldlBhdGggJiYgKDAsIF9Mb2NhdGlvblV0aWxzLnN0YXRlc0FyZUVxdWFsKShjdXJyZW50TG9jYXRpb24uc3RhdGUsIG5leHRMb2NhdGlvbi5zdGF0ZSkpIG5leHRMb2NhdGlvbi5hY3Rpb24gPSBfQWN0aW9ucy5SRVBMQUNFO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkge1xuICAgICAgICAgIHVwZGF0ZUxvY2F0aW9uKG5leHRMb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgICAgIGlmIChwdXNoTG9jYXRpb24obmV4dExvY2F0aW9uKSAhPT0gZmFsc2UpIHVwZGF0ZUxvY2F0aW9uKG5leHRMb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dExvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUkVQTEFDRSkge1xuICAgICAgICAgIGlmIChyZXBsYWNlTG9jYXRpb24obmV4dExvY2F0aW9uKSAhPT0gZmFsc2UpIHVwZGF0ZUxvY2F0aW9uKG5leHRMb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudExvY2F0aW9uICYmIG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkge1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGN1cnJlbnRMb2NhdGlvbi5rZXkpO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gYWxsS2V5cy5pbmRleE9mKG5leHRMb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xICYmIG5leHRJbmRleCAhPT0gLTEpIGdvKHByZXZJbmRleCAtIG5leHRJbmRleCk7IC8vIFJlc3RvcmUgdGhlIFVSTFxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChpbnB1dCkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uVG8oY3JlYXRlTG9jYXRpb24oaW5wdXQsIF9BY3Rpb25zLlBVU0gpKTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UoaW5wdXQpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGlucHV0LCBfQWN0aW9ucy5SRVBMQUNFKSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGggfHwgNik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgYWN0aW9uKSB7XG4gICAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGNyZWF0ZUtleSgpIDogYXJndW1lbnRzWzJdO1xuICAgIHJldHVybiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGxvY2F0aW9uLCBhY3Rpb24sIGtleSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICB0cmFuc2l0aW9uVG86IHRyYW5zaXRpb25UbyxcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNyZWF0ZUtleTogY3JlYXRlS2V5LFxuICAgIGNyZWF0ZVBhdGg6IF9QYXRoVXRpbHMuY3JlYXRlUGF0aCxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvblxuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlSGlzdG9yeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL2NyZWF0ZUhpc3RvcnkuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBsb29wQXN5bmMgPSBleHBvcnRzLmxvb3BBc3luYyA9IGZ1bmN0aW9uIGxvb3BBc3luYyh0dXJucywgd29yaywgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnRUdXJuID0gMCxcbiAgICAgIGlzRG9uZSA9IGZhbHNlO1xuICB2YXIgaXNTeW5jID0gZmFsc2UsXG4gICAgICBoYXNOZXh0ID0gZmFsc2UsXG4gICAgICBkb25lQXJncyA9IHZvaWQgMDtcblxuICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaXNEb25lID0gdHJ1ZTtcblxuICAgIGlmIChpc1N5bmMpIHtcbiAgICAgIC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG4gICAgICBkb25lQXJncyA9IGFyZ3M7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgfTtcblxuICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKGlzRG9uZSkgcmV0dXJuO1xuXG4gICAgaGFzTmV4dCA9IHRydWU7XG5cbiAgICBpZiAoaXNTeW5jKSByZXR1cm47IC8vIEl0ZXJhdGUgaW5zdGVhZCBvZiByZWN1cnNpbmcgaWYgcG9zc2libGUuXG5cbiAgICBpc1N5bmMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKCFpc0RvbmUgJiYgY3VycmVudFR1cm4gPCB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICB3b3JrKGN1cnJlbnRUdXJuKyssIG5leHQsIGRvbmUpO1xuICAgIH1cblxuICAgIGlzU3luYyA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgbG9vcCBmaW5pc2hlZCBzeW5jaHJvbm91c2x5LlxuICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBkb25lQXJncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRUdXJuID49IHR1cm5zICYmIGhhc05leHQpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICBuZXh0KCk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVzZVJvdXRlckhpc3Rvcnk7XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX3VzZUJhc2VuYW1lID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUnKTtcblxudmFyIF91c2VCYXNlbmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VCYXNlbmFtZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHVzZVJvdXRlckhpc3RvcnkoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoKDAsIF91c2VCYXNlbmFtZTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkpKG9wdGlvbnMpO1xuICAgIHJldHVybiBoaXN0b3J5O1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlckhpc3RvcnkuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0ID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaChmdW5jdGlvbiAobWlkZGxld2FyZSwgaW5kZXgpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKG1pZGRsZXdhcmUucmVuZGVyUm91dGVyQ29udGV4dCB8fCBtaWRkbGV3YXJlLnJlbmRlclJvdXRlQ29tcG9uZW50LCAnVGhlIG1pZGRsZXdhcmUgc3BlY2lmaWVkIGF0IGluZGV4ICcgKyBpbmRleCArICcgZG9lcyBub3QgYXBwZWFyIHRvIGJlICcgKyAnYSB2YWxpZCBSZWFjdCBSb3V0ZXIgbWlkZGxld2FyZS4nKSA6IHZvaWQgMDtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3aXRoQ29udGV4dCA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgIHJldHVybiBtaWRkbGV3YXJlLnJlbmRlclJvdXRlckNvbnRleHQ7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgdmFyIHdpdGhDb21wb25lbnQgPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICByZXR1cm4gbWlkZGxld2FyZS5yZW5kZXJSb3V0ZUNvbXBvbmVudDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIHZhciBtYWtlQ3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIG1ha2VDcmVhdGVFbGVtZW50KCkge1xuICAgIHZhciBiYXNlQ3JlYXRlRWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogX3JlYWN0LmNyZWF0ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChDb21wb25lbnQsIHByb3BzKSB7XG4gICAgICByZXR1cm4gd2l0aENvbXBvbmVudC5yZWR1Y2VSaWdodChmdW5jdGlvbiAocHJldmlvdXMsIHJlbmRlclJvdXRlQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiByZW5kZXJSb3V0ZUNvbXBvbmVudChwcmV2aW91cywgcHJvcHMpO1xuICAgICAgfSwgYmFzZUNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBwcm9wcykpO1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiB3aXRoQ29udGV4dC5yZWR1Y2VSaWdodChmdW5jdGlvbiAocHJldmlvdXMsIHJlbmRlclJvdXRlckNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZW5kZXJSb3V0ZXJDb250ZXh0KHByZXZpb3VzLCByZW5kZXJQcm9wcyk7XG4gICAgfSwgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIF9leHRlbmRzKHt9LCByZW5kZXJQcm9wcywge1xuICAgICAgY3JlYXRlRWxlbWVudDogbWFrZUNyZWF0ZUVsZW1lbnQocmVuZGVyUHJvcHMuY3JlYXRlRWxlbWVudClcbiAgICB9KSkpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL2FwcGx5Um91dGVyTWlkZGxld2FyZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZUJyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlQnJvd3Nlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQnJvd3Nlckhpc3RvcnkpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2NyZWF0ZVJvdXRlckhpc3RvcnkyLmRlZmF1bHQpKF9jcmVhdGVCcm93c2VySGlzdG9yeTIuZGVmYXVsdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L3JlYWN0LXJvdXRlci9saWIvYnJvd3Nlckhpc3RvcnkuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfQnJvd3NlclByb3RvY29sID0gcmVxdWlyZSgnLi9Ccm93c2VyUHJvdG9jb2wnKTtcblxudmFyIEJyb3dzZXJQcm90b2NvbCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9Ccm93c2VyUHJvdG9jb2wpO1xuXG52YXIgX1JlZnJlc2hQcm90b2NvbCA9IHJlcXVpcmUoJy4vUmVmcmVzaFByb3RvY29sJyk7XG5cbnZhciBSZWZyZXNoUHJvdG9jb2wgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfUmVmcmVzaFByb3RvY29sKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIEhUTUw1J3MgaGlzdG9yeSBBUElcbiAqIChwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudCkgdG8gbWFuYWdlIGhpc3RvcnkuXG4gKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCBtZXRob2Qgb2YgbWFuYWdpbmcgaGlzdG9yeSBpbiBicm93c2VycyBiZWNhdXNlXG4gKiBpdCBwcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqXG4gKiBOb3RlOiBJbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBmdWxsXG4gKiBwYWdlIHJlbG9hZHMgd2lsbCBiZSB1c2VkIHRvIHByZXNlcnZlIGNsZWFuIFVSTHMuIFlvdSBjYW4gZm9yY2UgdGhpc1xuICogYmVoYXZpb3IgdXNpbmcgeyBmb3JjZVJlZnJlc2g6IHRydWUgfSBpbiBvcHRpb25zLlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgdmFyIHVzZVJlZnJlc2ggPSBvcHRpb25zLmZvcmNlUmVmcmVzaCB8fCAhKDAsIF9ET01VdGlscy5zdXBwb3J0c0hpc3RvcnkpKCk7XG4gIHZhciBQcm90b2NvbCA9IHVzZVJlZnJlc2ggPyBSZWZyZXNoUHJvdG9jb2wgOiBCcm93c2VyUHJvdG9jb2w7XG5cbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBQcm90b2NvbC5nZXRVc2VyQ29uZmlybWF0aW9uO1xuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gUHJvdG9jb2wuZ2V0Q3VycmVudExvY2F0aW9uO1xuICB2YXIgcHVzaExvY2F0aW9uID0gUHJvdG9jb2wucHVzaExvY2F0aW9uO1xuICB2YXIgcmVwbGFjZUxvY2F0aW9uID0gUHJvdG9jb2wucmVwbGFjZUxvY2F0aW9uO1xuICB2YXIgZ28gPSBQcm90b2NvbC5nbztcblxuXG4gIHZhciBoaXN0b3J5ID0gKDAsIF9jcmVhdGVIaXN0b3J5Mi5kZWZhdWx0KShfZXh0ZW5kcyh7XG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogZ2V0VXNlckNvbmZpcm1hdGlvbiB9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgcHVzaExvY2F0aW9uOiBwdXNoTG9jYXRpb24sXG4gICAgcmVwbGFjZUxvY2F0aW9uOiByZXBsYWNlTG9jYXRpb24sXG4gICAgZ286IGdvXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wTGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgdmFyIHN0YXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCBiZWZvcmUpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wTGlzdGVuZXIgPSBCcm93c2VyUHJvdG9jb2wuc3RhcnRMaXN0ZW5lcihoaXN0b3J5LnRyYW5zaXRpb25Ubyk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBiZWZvcmUgPyBoaXN0b3J5Lmxpc3RlbkJlZm9yZShsaXN0ZW5lcikgOiBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcExpc3RlbmVyKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuQmVmb3JlID0gZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIHRydWUpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgZmFsc2UpO1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH0pO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBjYW5Vc2VET00gPSBleHBvcnRzLmNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZ28gPSBleHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZXhwb3J0cy5zdGFydExpc3RlbmVyID0gZXhwb3J0cy5nZXRVc2VyQ29uZmlybWF0aW9uID0gZXhwb3J0cy5nZXRDdXJyZW50TG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIG5lZWRzSGFzaGNoYW5nZUxpc3RlbmVyID0gX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAhKDAsIF9ET01VdGlscy5zdXBwb3J0c1BvcHN0YXRlT25IYXNoY2hhbmdlKSgpO1xuXG52YXIgX2NyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gX2NyZWF0ZUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICB2YXIga2V5ID0gaGlzdG9yeVN0YXRlICYmIGhpc3RvcnlTdGF0ZS5rZXk7XG5cbiAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoe1xuICAgIHBhdGhuYW1lOiB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgc2VhcmNoOiB3aW5kb3cubG9jYXRpb24uc2VhcmNoLFxuICAgIGhhc2g6IHdpbmRvdy5sb2NhdGlvbi5oYXNoLFxuICAgIHN0YXRlOiBrZXkgPyAoMCwgX0RPTVN0YXRlU3RvcmFnZS5yZWFkU3RhdGUpKGtleSkgOiB1bmRlZmluZWRcbiAgfSwgdW5kZWZpbmVkLCBrZXkpO1xufTtcblxudmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICB2YXIgaGlzdG9yeVN0YXRlID0gdm9pZCAwO1xuICB0cnkge1xuICAgIGhpc3RvcnlTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIGhpc3RvcnlTdGF0ZSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVMb2NhdGlvbihoaXN0b3J5U3RhdGUpO1xufTtcblxudmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBleHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjYWxsYmFjayh3aW5kb3cuY29uZmlybShtZXNzYWdlKSk7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG5cbnZhciBzdGFydExpc3RlbmVyID0gZXhwb3J0cy5zdGFydExpc3RlbmVyID0gZnVuY3Rpb24gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIGlmIChldmVudC5zdGF0ZSAhPT0gdW5kZWZpbmVkKSAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0XG4gICAgICBsaXN0ZW5lcihfY3JlYXRlTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gIHZhciBoYW5kbGVVbnBvcHBlZEhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVVbnBvcHBlZEhhc2hDaGFuZ2UoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyKGdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfTtcblxuICBpZiAobmVlZHNIYXNoY2hhbmdlTGlzdGVuZXIpIHtcbiAgICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVVbnBvcHBlZEhhc2hDaGFuZ2UpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgaWYgKG5lZWRzSGFzaGNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVVbnBvcHBlZEhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciB1cGRhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB1cGRhdGVTdGF0ZSkge1xuICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgdmFyIGtleSA9IGxvY2F0aW9uLmtleTtcblxuXG4gIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSAoMCwgX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGUpKGtleSwgc3RhdGUpO1xuXG4gIHVwZGF0ZVN0YXRlKHsga2V5OiBrZXkgfSwgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcbn07XG5cbnZhciBwdXNoTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGZ1bmN0aW9uIHB1c2hMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIGZ1bmN0aW9uIChzdGF0ZSwgcGF0aCkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIG51bGwsIHBhdGgpO1xuICB9KTtcbn07XG5cbnZhciByZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnJlcGxhY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIHJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gdXBkYXRlTG9jYXRpb24obG9jYXRpb24sIGZ1bmN0aW9uIChzdGF0ZSwgcGF0aCkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIG51bGwsIHBhdGgpO1xuICB9KTtcbn07XG5cbnZhciBnbyA9IGV4cG9ydHMuZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gIGlmIChuKSB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9oaXN0b3J5L2xpYi9Ccm93c2VyUHJvdG9jb2wuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxudmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID8gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpcyBzdXBwb3J0ZWQuIFRha2VuIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gKiBjaGFuZ2VkIHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcyBmb3IgV2luZG93cyBQaG9uZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cbnZhciBzdXBwb3J0c0hpc3RvcnkgPSBleHBvcnRzLnN1cHBvcnRzSGlzdG9yeSA9IGZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHVzaW5nIGdvKG4pIHdpdGggaGFzaCBoaXN0b3J5IGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQuXG4gKi9cbnZhciBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGV4cG9ydHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBmdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBicm93c2VyIGZpcmVzIHBvcHN0YXRlIG9uIGhhc2ggY2hhbmdlLlxuICogSUUxMCBhbmQgSUUxMSBkbyBub3QuXG4gKi9cbnZhciBzdXBwb3J0c1BvcHN0YXRlT25IYXNoY2hhbmdlID0gZXhwb3J0cy5zdXBwb3J0c1BvcHN0YXRlT25IYXNoY2hhbmdlID0gZnVuY3Rpb24gc3VwcG9ydHNQb3BzdGF0ZU9uSGFzaGNoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJlYWRTdGF0ZSA9IGV4cG9ydHMuc2F2ZVN0YXRlID0gdW5kZWZpbmVkO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFF1b3RhRXhjZWVkZWRFcnJvcnMgPSB7XG4gIFF1b3RhRXhjZWVkZWRFcnJvcjogdHJ1ZSxcbiAgUVVPVEFfRVhDRUVERURfRVJSOiB0cnVlXG59O1xuXG52YXIgU2VjdXJpdHlFcnJvcnMgPSB7XG4gIFNlY3VyaXR5RXJyb3I6IHRydWVcbn07XG5cbnZhciBLZXlQcmVmaXggPSAnQEBIaXN0b3J5Lyc7XG5cbnZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoa2V5KSB7XG4gIHJldHVybiBLZXlQcmVmaXggKyBrZXk7XG59O1xuXG52YXIgc2F2ZVN0YXRlID0gZXhwb3J0cy5zYXZlU3RhdGUgPSBmdW5jdGlvbiBzYXZlU3RhdGUoa2V5LCBzdGF0ZSkge1xuICBpZiAoIXdpbmRvdy5zZXNzaW9uU3RvcmFnZSkge1xuICAgIC8vIFNlc3Npb24gc3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIG9yIGhpZGRlbi5cbiAgICAvLyBzZXNzaW9uU3RvcmFnZSBpcyB1bmRlZmluZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgd2hlbiBzZXJ2ZWQgdmlhIGZpbGUgcHJvdG9jb2wuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUnKSA6IHZvaWQgMDtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlID09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGNyZWF0ZUtleShrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oY3JlYXRlS2V5KGtleSksIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChTZWN1cml0eUVycm9yc1tlcnJvci5uYW1lXSkge1xuICAgICAgLy8gQmxvY2tpbmcgY29va2llcyBpbiBDaHJvbWUvRmlyZWZveC9TYWZhcmkgdGhyb3dzIFNlY3VyaXR5RXJyb3Igb24gYW55XG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChRdW90YUV4Y2VlZGVkRXJyb3JzW2Vycm9yLm5hbWVdICYmIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFNhZmFyaSBcInByaXZhdGUgbW9kZVwiIHRocm93cyBRdW90YUV4Y2VlZGVkRXJyb3IuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gc2F2ZSBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBpbiBTYWZhcmkgcHJpdmF0ZSBtb2RlJykgOiB2b2lkIDA7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxudmFyIHJlYWRTdGF0ZSA9IGV4cG9ydHMucmVhZFN0YXRlID0gZnVuY3Rpb24gcmVhZFN0YXRlKGtleSkge1xuICB2YXIganNvbiA9IHZvaWQgMDtcbiAgdHJ5IHtcbiAgICBqc29uID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChTZWN1cml0eUVycm9yc1tlcnJvci5uYW1lXSkge1xuICAgICAgLy8gQmxvY2tpbmcgY29va2llcyBpbiBDaHJvbWUvRmlyZWZveC9TYWZhcmkgdGhyb3dzIFNlY3VyaXR5RXJyb3Igb24gYW55XG4gICAgICAvLyBhdHRlbXB0IHRvIGFjY2VzcyB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gcmVhZCBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBpZiAoanNvbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWdub3JlIGludmFsaWQgSlNPTi5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL0RPTVN0YXRlU3RvcmFnZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5wdXNoTG9jYXRpb24gPSBleHBvcnRzLmdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ28gPSBleHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSB1bmRlZmluZWQ7XG5cbnZhciBfQnJvd3NlclByb3RvY29sID0gcmVxdWlyZSgnLi9Ccm93c2VyUHJvdG9jb2wnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnZXRVc2VyQ29uZmlybWF0aW9uJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX0Jyb3dzZXJQcm90b2NvbC5nZXRVc2VyQ29uZmlybWF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZ28nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQnJvd3NlclByb3RvY29sLmdvO1xuICB9XG59KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKSh3aW5kb3cubG9jYXRpb24pO1xufTtcblxudmFyIHB1c2hMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pO1xuICByZXR1cm4gZmFsc2U7IC8vIERvbid0IHVwZGF0ZSBsb2NhdGlvblxufTtcblxudmFyIHJlcGxhY2VMb2NhdGlvbiA9IGV4cG9ydHMucmVwbGFjZUxvY2F0aW9uID0gZnVuY3Rpb24gcmVwbGFjZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKSk7XG4gIHJldHVybiBmYWxzZTsgLy8gRG9uJ3QgdXBkYXRlIGxvY2F0aW9uXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL34vaGlzdG9yeS9saWIvUmVmcmVzaFByb3RvY29sLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY3JlYXRlSGlzdG9yeSkge1xuICB2YXIgaGlzdG9yeSA9IHZvaWQgMDtcbiAgaWYgKGNhblVzZURPTSkgaGlzdG9yeSA9ICgwLCBfdXNlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkoKTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkgPSByZXF1aXJlKCcuL3VzZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVJvdXRlckhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVJvdXRlckhpc3RvcnkuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhhc2hIaXN0b3J5KTtcblxudmFyIF9jcmVhdGVSb3V0ZXJIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVSb3V0ZXJIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVSb3V0ZXJIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9jcmVhdGVSb3V0ZXJIaXN0b3J5Mi5kZWZhdWx0KShfY3JlYXRlSGFzaEhpc3RvcnkyLmRlZmF1bHQpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvfi9yZWFjdC1yb3V0ZXIvbGliL2hhc2hIaXN0b3J5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9IYXNoUHJvdG9jb2wgPSByZXF1aXJlKCcuL0hhc2hQcm90b2NvbCcpO1xuXG52YXIgSGFzaFByb3RvY29sID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX0hhc2hQcm90b2NvbCk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBEZWZhdWx0UXVlcnlLZXkgPSAnX2snO1xuXG52YXIgYWRkTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbn07XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchJyArIHBhdGg7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGg7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH1cbn07XG5cbnZhciBjcmVhdGVIYXNoSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICB2YXIgcXVlcnlLZXkgPSBvcHRpb25zLnF1ZXJ5S2V5O1xuICB2YXIgaGFzaFR5cGUgPSBvcHRpb25zLmhhc2hUeXBlO1xuXG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfd2FybmluZzIuZGVmYXVsdCkocXVlcnlLZXkgIT09IGZhbHNlLCAnVXNpbmcgeyBxdWVyeUtleTogZmFsc2UgfSBubyBsb25nZXIgd29ya3MuIEluc3RlYWQsIGp1c3QgZG9uXFwndCAnICsgJ3VzZSBsb2NhdGlvbiBzdGF0ZSBpZiB5b3UgZG9uXFwndCB3YW50IGEga2V5IGluIHlvdXIgVVJMIHF1ZXJ5IHN0cmluZycpIDogdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgcXVlcnlLZXkgIT09ICdzdHJpbmcnKSBxdWVyeUtleSA9IERlZmF1bHRRdWVyeUtleTtcblxuICBpZiAoaGFzaFR5cGUgPT0gbnVsbCkgaGFzaFR5cGUgPSAnc2xhc2gnO1xuXG4gIGlmICghKGhhc2hUeXBlIGluIEhhc2hQYXRoQ29kZXJzKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnSW52YWxpZCBoYXNoIHR5cGU6ICVzJywgaGFzaFR5cGUpIDogdm9pZCAwO1xuXG4gICAgaGFzaFR5cGUgPSAnc2xhc2gnO1xuICB9XG5cbiAgdmFyIHBhdGhDb2RlciA9IEhhc2hQYXRoQ29kZXJzW2hhc2hUeXBlXTtcblxuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IEhhc2hQcm90b2NvbC5nZXRVc2VyQ29uZmlybWF0aW9uO1xuXG5cbiAgdmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbigpIHtcbiAgICByZXR1cm4gSGFzaFByb3RvY29sLmdldEN1cnJlbnRMb2NhdGlvbihwYXRoQ29kZXIsIHF1ZXJ5S2V5KTtcbiAgfTtcblxuICB2YXIgcHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIEhhc2hQcm90b2NvbC5wdXNoTG9jYXRpb24obG9jYXRpb24sIHBhdGhDb2RlciwgcXVlcnlLZXkpO1xuICB9O1xuXG4gIHZhciByZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gSGFzaFByb3RvY29sLnJlcGxhY2VMb2NhdGlvbihsb2NhdGlvbiwgcGF0aENvZGVyLCBxdWVyeUtleSk7XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSAoMCwgX2NyZWF0ZUhpc3RvcnkyLmRlZmF1bHQpKF9leHRlbmRzKHtcbiAgICBnZXRVc2VyQ29uZmlybWF0aW9uOiBnZXRVc2VyQ29uZmlybWF0aW9uIH0sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBwdXNoTG9jYXRpb246IHB1c2hMb2NhdGlvbixcbiAgICByZXBsYWNlTG9jYXRpb246IHJlcGxhY2VMb2NhdGlvbixcbiAgICBnbzogSGFzaFByb3RvY29sLmdvXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wTGlzdGVuZXIgPSB2b2lkIDA7XG5cbiAgdmFyIHN0YXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCBiZWZvcmUpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wTGlzdGVuZXIgPSBIYXNoUHJvdG9jb2wuc3RhcnRMaXN0ZW5lcihoaXN0b3J5LnRyYW5zaXRpb25UbywgcGF0aENvZGVyLCBxdWVyeUtleSk7XG5cbiAgICB2YXIgdW5saXN0ZW4gPSBiZWZvcmUgPyBoaXN0b3J5Lmxpc3RlbkJlZm9yZShsaXN0ZW5lcikgOiBoaXN0b3J5Lmxpc3RlbihsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oKTtcblxuICAgICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcExpc3RlbmVyKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuQmVmb3JlID0gZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHN0YXJ0TGlzdGVuZXIobGlzdGVuZXIsIHRydWUpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gc3RhcnRMaXN0ZW5lcihsaXN0ZW5lciwgZmFsc2UpO1xuICB9O1xuXG4gIHZhciBnb0lzU3VwcG9ydGVkV2l0aG91dFJlbG9hZCA9ICgwLCBfRE9NVXRpbHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2gpKCk7XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJykgOiB2b2lkIDA7XG5cbiAgICBoaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihwYXRoKSB7XG4gICAgcmV0dXJuICcjJyArIHBhdGhDb2Rlci5lbmNvZGVQYXRoKGhpc3RvcnkuY3JlYXRlSHJlZihwYXRoKSk7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgZ286IGdvLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWZcbiAgfSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVIYXNoSGlzdG9yeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBleHBvcnRzLnB1c2hMb2NhdGlvbiA9IGV4cG9ydHMuc3RhcnRMaXN0ZW5lciA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZXhwb3J0cy5nbyA9IGV4cG9ydHMuZ2V0VXNlckNvbmZpcm1hdGlvbiA9IHVuZGVmaW5lZDtcblxudmFyIF9Ccm93c2VyUHJvdG9jb2wgPSByZXF1aXJlKCcuL0Jyb3dzZXJQcm90b2NvbCcpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2dldFVzZXJDb25maXJtYXRpb24nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfQnJvd3NlclByb3RvY29sLmdldFVzZXJDb25maXJtYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdnbycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9Ccm93c2VyUHJvdG9jb2wuZ287XG4gIH1cbn0pO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfRE9NU3RhdGVTdG9yYWdlID0gcmVxdWlyZSgnLi9ET01TdGF0ZVN0b3JhZ2UnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGdldEN1cnJlbnRMb2NhdGlvbiA9IGV4cG9ydHMuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKHBhdGhDb2RlciwgcXVlcnlLZXkpIHtcbiAgdmFyIHBhdGggPSBwYXRoQ29kZXIuZGVjb2RlUGF0aChnZXRIYXNoUGF0aCgpKTtcbiAgdmFyIGtleSA9ICgwLCBfUGF0aFV0aWxzLmdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCkocGF0aCwgcXVlcnlLZXkpO1xuXG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgaWYgKGtleSkge1xuICAgIHBhdGggPSAoMCwgX1BhdGhVdGlscy5zdHJpcFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aCkocGF0aCwgcXVlcnlLZXkpO1xuICAgIHN0YXRlID0gKDAsIF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKShrZXkpO1xuICB9XG5cbiAgdmFyIGluaXQgPSAoMCwgX1BhdGhVdGlscy5wYXJzZVBhdGgpKHBhdGgpO1xuICBpbml0LnN0YXRlID0gc3RhdGU7XG5cbiAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoaW5pdCwgdW5kZWZpbmVkLCBrZXkpO1xufTtcblxudmFyIHByZXZMb2NhdGlvbiA9IHZvaWQgMDtcblxudmFyIHN0YXJ0TGlzdGVuZXIgPSBleHBvcnRzLnN0YXJ0TGlzdGVuZXIgPSBmdW5jdGlvbiBzdGFydExpc3RlbmVyKGxpc3RlbmVyLCBwYXRoQ29kZXIsIHF1ZXJ5S2V5KSB7XG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gICAgdmFyIGVuY29kZWRQYXRoID0gcGF0aENvZGVyLmVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEFsd2F5cyBiZSBzdXJlIHdlIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VycmVudExvY2F0aW9uID0gZ2V0Q3VycmVudExvY2F0aW9uKHBhdGhDb2RlciwgcXVlcnlLZXkpO1xuXG4gICAgICBpZiAocHJldkxvY2F0aW9uICYmIGN1cnJlbnRMb2NhdGlvbi5rZXkgJiYgcHJldkxvY2F0aW9uLmtleSA9PT0gY3VycmVudExvY2F0aW9uLmtleSkgcmV0dXJuOyAvLyBJZ25vcmUgZXh0cmFuZW91cyBoYXNoY2hhbmdlIGV2ZW50c1xuXG4gICAgICBwcmV2TG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XG5cbiAgICAgIGxpc3RlbmVyKGN1cnJlbnRMb2NhdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5LlxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IHBhdGhDb2Rlci5lbmNvZGVQYXRoKHBhdGgpO1xuXG4gIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgfTtcbn07XG5cbnZhciB1cGRhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBwYXRoQ29kZXIsIHF1ZXJ5S2V5LCB1cGRhdGVIYXNoKSB7XG4gIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xuXG5cbiAgdmFyIHBhdGggPSBwYXRoQ29kZXIuZW5jb2RlUGF0aCgoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbikpO1xuXG4gIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgpKHBhdGgsIHF1ZXJ5S2V5LCBrZXkpO1xuICAgICgwLCBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZSkoa2V5LCBzdGF0ZSk7XG4gIH1cblxuICBwcmV2TG9jYXRpb24gPSBsb2NhdGlvbjtcblxuICB1cGRhdGVIYXNoKHBhdGgpO1xufTtcblxudmFyIHB1c2hMb2NhdGlvbiA9IGV4cG9ydHMucHVzaExvY2F0aW9uID0gZnVuY3Rpb24gcHVzaExvY2F0aW9uKGxvY2F0aW9uLCBwYXRoQ29kZXIsIHF1ZXJ5S2V5KSB7XG4gIHJldHVybiB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbiwgcGF0aENvZGVyLCBxdWVyeUtleSwgZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoZ2V0SGFzaFBhdGgoKSAhPT0gcGF0aCkge1xuICAgICAgcHVzaEhhc2hQYXRoKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1lvdSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoIHVzaW5nIGhhc2ggaGlzdG9yeScpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgcmVwbGFjZUxvY2F0aW9uID0gZXhwb3J0cy5yZXBsYWNlTG9jYXRpb24gPSBmdW5jdGlvbiByZXBsYWNlTG9jYXRpb24obG9jYXRpb24sIHBhdGhDb2RlciwgcXVlcnlLZXkpIHtcbiAgcmV0dXJuIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBwYXRoQ29kZXIsIHF1ZXJ5S2V5LCBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChnZXRIYXNoUGF0aCgpICE9PSBwYXRoKSByZXBsYWNlSGFzaFBhdGgocGF0aCk7XG4gIH0pO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2hpc3RvcnkvbGliL0hhc2hQcm90b2NvbC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgTmF2IGZyb20gJy4vTmF2JztcclxuXHJcblxyXG5jb25zdCBNYWluID0gKHByb3BzKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxOYXYgLz5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sdW1uIHNtYWxsLWNlbnRlcmVkIG1lZGl1bS02IGxhcmdlLTRcIj5cclxuICAgICAgICAgICAgICAgICAgICB7cHJvcHMuY2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWFpbjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvYXBwL2NvbXBvbmVudHMvTWFpbi5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IEluZGV4TGluaywgTGluayB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XHJcblxyXG5jb25zdCBOYXYgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidG9wLWJhclwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRvcC1iYXItbGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm1lbnVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibWVudS10ZXh0XCI+UmVhY3QgVGltZXIgQXBwPC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8bGk+PEluZGV4TGluayB0bz1cIi9cIiBhY3RpdmVDbGFzc05hbWU9XCJhY3RpdmUtbGlua1wiPlRpbWVyPC9JbmRleExpbms+PC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8bGk+PExpbmsgdG89XCIvY291bnRkb3duXCIgYWN0aXZlQ2xhc3NOYW1lPVwiYWN0aXZlLWxpbmtcIj5Db3VudGRvd248L0xpbms+PC9saT5cclxuICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRvcC1iYXItcmlnaHRcIj5cclxuICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJtZW51XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm1lbnUtdGV4dFwiPjxhPkhlbGxvPC9hPjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOYXY7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL2FwcC9jb21wb25lbnRzL05hdi5qcyIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5jbGFzcyBUaW1lciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxwPlRpbWVyPC9wPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUaW1lcjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvYXBwL2NvbXBvbmVudHMvVGltZXIuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IENsb2NrIGZyb20gJy4vQ2xvY2snO1xyXG5pbXBvcnQgQ291bnRkb3duRm9ybSBmcm9tICcuL0NvdW50ZG93bkZvcm0nO1xyXG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnLi9Db250cm9scyc7XHJcblxyXG5jbGFzcyBDb3VudGRvd24gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBjb3VudDogMCxcclxuICAgICAgICAgICAgY291bnRkb3duU3RhdHVzOiAnc3RvcHBlZCdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY291bnRkb3duU3RhdHVzICE9PSBwcmV2U3RhdGUuY291bnRkb3duU3RhdHVzKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5jb3VudGRvd25TdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0ZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3RvcHBlZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvdW50OiAwIH0pO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncGF1c2VkJzpcclxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGFydFRpbWVyKCkge1xyXG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvdW50ID0gdGhpcy5zdGF0ZS5jb3VudCAtIDE7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjb3VudDogbmV3Q291bnQgPj0gMCA/IG5ld0NvdW50IDogMCB9KTtcclxuICAgICAgICB9LCAxMDAwKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVTZXRDb3VudGRvd24oc2Vjb25kcykge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBjb3VudDogc2Vjb25kcyxcclxuICAgICAgICAgICAgY291bnRkb3duU3RhdHVzOiAnc3RhcnRlZCdcclxuICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlU3RhdHVzQ2hhbmdlKG5ld1N0YXR1cykge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBjb3VudGRvd25TdGF0dXM6IG5ld1N0YXR1cyB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgY29uc3QgeyBjb3VudCwgY291bnRkb3duU3RhdHVzIH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlckNvbnRyb2xBcmVhID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY291bnRkb3duU3RhdHVzICE9PSAnc3RvcHBlZCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8Q29udHJvbHMgY291bnRkb3duU3RhdHVzPXtjb3VudGRvd25TdGF0dXN9IG9uU3RhdHVzQ2hhbmdlPXt0aGlzLmhhbmRsZVN0YXR1c0NoYW5nZS5iaW5kKHRoaXMpfSAvPjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gPENvdW50ZG93bkZvcm0gb25TZXRDb3VudGRvd249e3RoaXMuaGFuZGxlU2V0Q291bnRkb3duLmJpbmQodGhpcyl9IC8+O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPENsb2NrIHRvdGFsU2Vjb25kcz17Y291bnR9IC8+XHJcbiAgICAgICAgICAgICAgICB7cmVuZGVyQ29udHJvbEFyZWEoKX1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ291bnRkb3duO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9hcHAvY29tcG9uZW50cy9Db3VudGRvd24uanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuY2xhc3MgQ2xvY2sgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cclxuICAgIGZvcm1hdFNlY29uZHModG90YWxTZWNvbmRzKSB7XHJcbiAgICAgICAgbGV0IHNlY29uZHMgPSB0b3RhbFNlY29uZHMgJSA2MDtcclxuICAgICAgICBsZXQgbWludXRlcyA9IE1hdGguZmxvb3IodG90YWxTZWNvbmRzIC8gNjApO1xyXG5cclxuICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyA8IDEwID8gJzAnICsgc2Vjb25kcyA6IHNlY29uZHM7XHJcbiAgICAgICAgbWludXRlcyA9IG1pbnV0ZXMgPCAxMCA/ICcwJyArIG1pbnV0ZXMgOiBtaW51dGVzO1xyXG5cclxuICAgICAgICByZXR1cm4gbWludXRlcyArICc6JyArIHNlY29uZHM7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIGNvbnN0IHsgdG90YWxTZWNvbmRzIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2xvY2tcIj5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNsb2NrLXRleHRcIj5cclxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5mb3JtYXRTZWNvbmRzKHRvdGFsU2Vjb25kcyl9XHJcbiAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkNsb2NrLnByb3BUeXBlcyA9IHtcclxuICAgIHRvdGFsU2Vjb25kczogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxyXG59O1xyXG5cclxuQ2xvY2suZGVmYXVsdFByb3BzID0ge1xyXG4gICAgdG90YWxTZWNvbmRzOiAwXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDbG9jaztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvUGFyYWdvbi9EZXNrdG9wL3Byb2plY3RzL3JlYWN0L1JlYWN0VGltZXIvYXBwL2NvbXBvbmVudHMvQ2xvY2suanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xyXG5cclxuY2xhc3MgQ291bnRkb3duRm9ybSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBvblN1Ym1pdChlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGxldCBzdHJTZWNvbmRzID0gdGhpcy5yZWZzLnNlY29uZHMudmFsdWU7XHJcblxyXG4gICAgICAgIGlmIChzdHJTZWNvbmRzLm1hdGNoKC9eWzAtOV0qJC8pKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcy5zZWNvbmRzLnZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TZXRDb3VudGRvd24ocGFyc2VJbnQoc3RyU2Vjb25kcywgMTApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxmb3JtIHJlZj1cImZvcm1cIiBvblN1Ym1pdD17dGhpcy5vblN1Ym1pdC5iaW5kKHRoaXMpfSBjbGFzc05hbWU9XCJjb3VudGRvd24tZm9ybVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIHJlZj1cInNlY29uZHNcIiBwbGFjZWhvbGRlcj1cIkVudGVyIHRpbWUgaW4gc2Vjb25kc1wiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidXR0b24gZXhwYW5kZWRcIj5TdGFydDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9mb3JtPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb3VudGRvd25Gb3JtO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9hcHAvY29tcG9uZW50cy9Db3VudGRvd25Gb3JtLmpzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2ZvdW5kYXRpb24ubWluLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vZm91bmRhdGlvbi5taW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9mb3VuZGF0aW9uLm1pbi5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXIhLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKiEgbm9ybWFsaXplLmNzcyB2My4wLjMgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovaHRtbHtmb250LWZhbWlseTpzYW5zLXNlcmlmOy1tcy10ZXh0LXNpemUtYWRqdXN0OjEwMCU7LXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OjEwMCV9Ym9keXttYXJnaW46MH1hcnRpY2xlLGFzaWRlLGRldGFpbHMsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsbWFpbixtZW51LG5hdixzZWN0aW9uLHN1bW1hcnl7ZGlzcGxheTpibG9ja31hdWRpbyxjYW52YXMscHJvZ3Jlc3MsdmlkZW97ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9YXVkaW86bm90KFtjb250cm9sc10pe2Rpc3BsYXk6bm9uZTtoZWlnaHQ6MH1baGlkZGVuXSx0ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9YXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fWE6YWN0aXZlLGE6aG92ZXJ7b3V0bGluZTowfWFiYnJbdGl0bGVde2JvcmRlci1ib3R0b206MXB4IGRvdHRlZH1iLHN0cm9uZ3tmb250LXdlaWdodDo3MDB9ZGZue2ZvbnQtc3R5bGU6aXRhbGljfWgxe2ZvbnQtc2l6ZToyZW07bWFyZ2luOi42N2VtIDB9bWFya3tiYWNrZ3JvdW5kOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1cHt0b3A6LS41ZW19c3Vie2JvdHRvbTotLjI1ZW19aW1ne2JvcmRlcjowfXN2Zzpub3QoOnJvb3Qpe292ZXJmbG93OmhpZGRlbn1maWd1cmV7bWFyZ2luOjFlbSA0MHB4fWhye2JveC1zaXppbmc6Y29udGVudC1ib3g7aGVpZ2h0OjB9cHJle292ZXJmbG93OmF1dG99Y29kZSxrYmQscHJlLHNhbXB7Zm9udC1mYW1pbHk6bW9ub3NwYWNlLG1vbm9zcGFjZTtmb250LXNpemU6MWVtfWJ1dHRvbixpbnB1dCxvcHRncm91cCxzZWxlY3QsdGV4dGFyZWF7Y29sb3I6aW5oZXJpdDtmb250OmluaGVyaXQ7bWFyZ2luOjB9YnV0dG9ue292ZXJmbG93OnZpc2libGV9YnV0dG9uLHNlbGVjdHt0ZXh0LXRyYW5zZm9ybTpub25lfWJ1dHRvbixodG1sIGlucHV0W3R5cGU9YnV0dG9uXSxpbnB1dFt0eXBlPXJlc2V0XSxpbnB1dFt0eXBlPXN1Ym1pdF17LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbjtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRdLGh0bWwgaW5wdXRbZGlzYWJsZWRde2N1cnNvcjpub3QtYWxsb3dlZH1idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsaW5wdXQ6Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyOjA7cGFkZGluZzowfWlucHV0e2xpbmUtaGVpZ2h0Om5vcm1hbH1pbnB1dFt0eXBlPWNoZWNrYm94XSxpbnB1dFt0eXBlPXJhZGlvXXtib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzowfWlucHV0W3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixpbnB1dFt0eXBlPW51bWJlcl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b257aGVpZ2h0OmF1dG99aW5wdXRbdHlwZT1zZWFyY2hdey13ZWJraXQtYXBwZWFyYW5jZTp0ZXh0ZmllbGQ7Ym94LXNpemluZzpjb250ZW50LWJveH1pbnB1dFt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24saW5wdXRbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uey13ZWJraXQtYXBwZWFyYW5jZTpub25lfWxlZ2VuZHtib3JkZXI6MDtwYWRkaW5nOjB9dGV4dGFyZWF7b3ZlcmZsb3c6YXV0b31vcHRncm91cHtmb250LXdlaWdodDo3MDB9dGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjB9dGQsdGh7cGFkZGluZzowfS5mb3VuZGF0aW9uLW1xe2ZvbnQtZmFtaWx5OlxcXCJzbWFsbD0wZW0mbWVkaXVtPTQwZW0mbGFyZ2U9NjRlbSZ4bGFyZ2U9NzVlbSZ4eGxhcmdlPTkwZW1cXFwifWh0bWx7Zm9udC1zaXplOjEwMCU7Ym94LXNpemluZzpib3JkZXItYm94fSosOmFmdGVyLDpiZWZvcmV7Ym94LXNpemluZzppbmhlcml0fWJvZHl7cGFkZGluZzowO21hcmdpbjowO2ZvbnQtZmFtaWx5OkhlbHZldGljYSBOZXVlLEhlbHZldGljYSxSb2JvdG8sQXJpYWwsc2Fucy1zZXJpZjtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS41O2NvbG9yOiMwYTBhMGE7YmFja2dyb3VuZDojZmVmZWZlOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlfWltZ3ttYXgtd2lkdGg6MTAwJTtoZWlnaHQ6YXV0bzstbXMtaW50ZXJwb2xhdGlvbi1tb2RlOmJpY3ViaWM7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlfXRleHRhcmVhe2hlaWdodDphdXRvO21pbi1oZWlnaHQ6NTBweDtib3JkZXItcmFkaXVzOjB9c2VsZWN0e3dpZHRoOjEwMCU7Ym9yZGVyLXJhZGl1czowfSNtYXBfY2FudmFzIGVtYmVkLCNtYXBfY2FudmFzIGltZywjbWFwX2NhbnZhcyBvYmplY3QsLm1hcF9jYW52YXMgZW1iZWQsLm1hcF9jYW52YXMgaW1nLC5tYXBfY2FudmFzIG9iamVjdCwubXFhLWRpc3BsYXkgZW1iZWQsLm1xYS1kaXNwbGF5IGltZywubXFhLWRpc3BsYXkgb2JqZWN0e21heC13aWR0aDpub25lIWltcG9ydGFudH1idXR0b257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7LW1vei1hcHBlYXJhbmNlOm5vbmU7YmFja2dyb3VuZDp0cmFuc3BhcmVudDtwYWRkaW5nOjA7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czowO2xpbmUtaGVpZ2h0OjF9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSBidXR0b257b3V0bGluZTowfS5pcy12aXNpYmxle2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50fS5pcy1oaWRkZW57ZGlzcGxheTpub25lIWltcG9ydGFudH0ucm93e21heC13aWR0aDo3NXJlbTttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5yb3c6YWZ0ZXIsLnJvdzpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZX0ucm93OmFmdGVye2NsZWFyOmJvdGh9LnJvdy5jb2xsYXBzZT4uY29sdW1uLC5yb3cuY29sbGFwc2U+LmNvbHVtbnN7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowfS5yb3cgLnJvd3ttYXJnaW4tbGVmdDotLjYyNXJlbTttYXJnaW4tcmlnaHQ6LS42MjVyZW19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucm93IC5yb3d7bWFyZ2luLWxlZnQ6LS45Mzc1cmVtO21hcmdpbi1yaWdodDotLjkzNzVyZW19fS5yb3cgLnJvdy5jb2xsYXBzZXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5yb3cuZXhwYW5kZWR7bWF4LXdpZHRoOm5vbmV9LnJvdy5leHBhbmRlZCAucm93e21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99LmNvbHVtbiwuY29sdW1uc3t3aWR0aDoxMDAlO2Zsb2F0OmxlZnQ7cGFkZGluZy1sZWZ0Oi42MjVyZW07cGFkZGluZy1yaWdodDouNjI1cmVtfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LmNvbHVtbiwuY29sdW1uc3twYWRkaW5nLWxlZnQ6LjkzNzVyZW07cGFkZGluZy1yaWdodDouOTM3NXJlbX19LmNvbHVtbjpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpLC5jb2x1bW5zOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCl7ZmxvYXQ6cmlnaHR9LmNvbHVtbi5lbmQ6bGFzdC1jaGlsZDpsYXN0LWNoaWxkLC5lbmQuY29sdW1uczpsYXN0LWNoaWxkOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uY29sdW1uLnJvdy5yb3csLnJvdy5yb3cuY29sdW1uc3tmbG9hdDpub25lfS5yb3cgLmNvbHVtbi5yb3cucm93LC5yb3cgLnJvdy5yb3cuY29sdW1uc3twYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjA7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0uc21hbGwtMXt3aWR0aDo4LjMzMzMzJX0uc21hbGwtcHVzaC0xe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6OC4zMzMzMyV9LnNtYWxsLXB1bGwtMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi04LjMzMzMzJX0uc21hbGwtb2Zmc2V0LTB7bWFyZ2luLWxlZnQ6MH0uc21hbGwtMnt3aWR0aDoxNi42NjY2NyV9LnNtYWxsLXB1c2gtMntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjE2LjY2NjY3JX0uc21hbGwtcHVsbC0ye3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTE2LjY2NjY3JX0uc21hbGwtb2Zmc2V0LTF7bWFyZ2luLWxlZnQ6OC4zMzMzMyV9LnNtYWxsLTN7d2lkdGg6MjUlfS5zbWFsbC1wdXNoLTN7cG9zaXRpb246cmVsYXRpdmU7bGVmdDoyNSV9LnNtYWxsLXB1bGwtM3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0yNSV9LnNtYWxsLW9mZnNldC0ye21hcmdpbi1sZWZ0OjE2LjY2NjY3JX0uc21hbGwtNHt3aWR0aDozMy4zMzMzMyV9LnNtYWxsLXB1c2gtNHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjMzLjMzMzMzJX0uc21hbGwtcHVsbC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTMzLjMzMzMzJX0uc21hbGwtb2Zmc2V0LTN7bWFyZ2luLWxlZnQ6MjUlfS5zbWFsbC01e3dpZHRoOjQxLjY2NjY3JX0uc21hbGwtcHVzaC01e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NDEuNjY2NjclfS5zbWFsbC1wdWxsLTV7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNDEuNjY2NjclfS5zbWFsbC1vZmZzZXQtNHttYXJnaW4tbGVmdDozMy4zMzMzMyV9LnNtYWxsLTZ7d2lkdGg6NTAlfS5zbWFsbC1wdXNoLTZ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo1MCV9LnNtYWxsLXB1bGwtNntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi01MCV9LnNtYWxsLW9mZnNldC01e21hcmdpbi1sZWZ0OjQxLjY2NjY3JX0uc21hbGwtN3t3aWR0aDo1OC4zMzMzMyV9LnNtYWxsLXB1c2gtN3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjU4LjMzMzMzJX0uc21hbGwtcHVsbC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTU4LjMzMzMzJX0uc21hbGwtb2Zmc2V0LTZ7bWFyZ2luLWxlZnQ6NTAlfS5zbWFsbC04e3dpZHRoOjY2LjY2NjY3JX0uc21hbGwtcHVzaC04e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NjYuNjY2NjclfS5zbWFsbC1wdWxsLTh7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNjYuNjY2NjclfS5zbWFsbC1vZmZzZXQtN3ttYXJnaW4tbGVmdDo1OC4zMzMzMyV9LnNtYWxsLTl7d2lkdGg6NzUlfS5zbWFsbC1wdXNoLTl7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo3NSV9LnNtYWxsLXB1bGwtOXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi03NSV9LnNtYWxsLW9mZnNldC04e21hcmdpbi1sZWZ0OjY2LjY2NjY3JX0uc21hbGwtMTB7d2lkdGg6ODMuMzMzMzMlfS5zbWFsbC1wdXNoLTEwe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6ODMuMzMzMzMlfS5zbWFsbC1wdWxsLTEwe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTgzLjMzMzMzJX0uc21hbGwtb2Zmc2V0LTl7bWFyZ2luLWxlZnQ6NzUlfS5zbWFsbC0xMXt3aWR0aDo5MS42NjY2NyV9LnNtYWxsLXB1c2gtMTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo5MS42NjY2NyV9LnNtYWxsLXB1bGwtMTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotOTEuNjY2NjclfS5zbWFsbC1vZmZzZXQtMTB7bWFyZ2luLWxlZnQ6ODMuMzMzMzMlfS5zbWFsbC0xMnt3aWR0aDoxMDAlfS5zbWFsbC1vZmZzZXQtMTF7bWFyZ2luLWxlZnQ6OTEuNjY2NjclfS5zbWFsbC11cC0xPi5jb2x1bW4sLnNtYWxsLXVwLTE+LmNvbHVtbnN7d2lkdGg6MTAwJTtmbG9hdDpsZWZ0fS5zbWFsbC11cC0xPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC0xPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC0xPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4rMSksLnNtYWxsLXVwLTE+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtMT4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTE+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC11cC0yPi5jb2x1bW4sLnNtYWxsLXVwLTI+LmNvbHVtbnN7d2lkdGg6NTAlO2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTI+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLnNtYWxsLXVwLTI+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LnNtYWxsLXVwLTI+LmNvbHVtbjpudGgtb2YtdHlwZSgybisxKSwuc21hbGwtdXAtMj4uY29sdW1uczpudGgtb2YtdHlwZSgybisxKXtjbGVhcjpib3RofS5zbWFsbC11cC0yPi5jb2x1bW46bGFzdC1jaGlsZCwuc21hbGwtdXAtMj4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTM+LmNvbHVtbiwuc21hbGwtdXAtMz4uY29sdW1uc3t3aWR0aDozMy4zMzMzMyU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtMz4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtMz4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtMz4uY29sdW1uOm50aC1vZi10eXBlKDNuKzEpLC5zbWFsbC11cC0zPi5jb2x1bW5zOm50aC1vZi10eXBlKDNuKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTM+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC0zPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtND4uY29sdW1uLC5zbWFsbC11cC00Pi5jb2x1bW5ze3dpZHRoOjI1JTtmbG9hdDpsZWZ0fS5zbWFsbC11cC00Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC00Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC00Pi5jb2x1bW46bnRoLW9mLXR5cGUoNG4rMSksLnNtYWxsLXVwLTQ+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNG4rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtND4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTQ+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC11cC01Pi5jb2x1bW4sLnNtYWxsLXVwLTU+LmNvbHVtbnN7d2lkdGg6MjAlO2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTU+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLnNtYWxsLXVwLTU+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LnNtYWxsLXVwLTU+LmNvbHVtbjpudGgtb2YtdHlwZSg1bisxKSwuc21hbGwtdXAtNT4uY29sdW1uczpudGgtb2YtdHlwZSg1bisxKXtjbGVhcjpib3RofS5zbWFsbC11cC01Pi5jb2x1bW46bGFzdC1jaGlsZCwuc21hbGwtdXAtNT4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTY+LmNvbHVtbiwuc21hbGwtdXAtNj4uY29sdW1uc3t3aWR0aDoxNi42NjY2NyU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtNj4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtNj4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtNj4uY29sdW1uOm50aC1vZi10eXBlKDZuKzEpLC5zbWFsbC11cC02Pi5jb2x1bW5zOm50aC1vZi10eXBlKDZuKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTY+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC02Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtNz4uY29sdW1uLC5zbWFsbC11cC03Pi5jb2x1bW5ze3dpZHRoOjE0LjI4NTcxJTtmbG9hdDpsZWZ0fS5zbWFsbC11cC03Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC03Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC03Pi5jb2x1bW46bnRoLW9mLXR5cGUoN24rMSksLnNtYWxsLXVwLTc+LmNvbHVtbnM6bnRoLW9mLXR5cGUoN24rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtNz4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTc+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC11cC04Pi5jb2x1bW4sLnNtYWxsLXVwLTg+LmNvbHVtbnN7d2lkdGg6MTIuNSU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtOD4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtOD4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtOD4uY29sdW1uOm50aC1vZi10eXBlKDhuKzEpLC5zbWFsbC11cC04Pi5jb2x1bW5zOm50aC1vZi10eXBlKDhuKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTg+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC04Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtY29sbGFwc2U+LmNvbHVtbiwuc21hbGwtY29sbGFwc2U+LmNvbHVtbnN7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowfS5leHBhbmRlZC5yb3cgLnNtYWxsLWNvbGxhcHNlLnJvdywuc21hbGwtY29sbGFwc2UgLnJvd3ttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5zbWFsbC11bmNvbGxhcHNlPi5jb2x1bW4sLnNtYWxsLXVuY29sbGFwc2U+LmNvbHVtbnN7cGFkZGluZy1sZWZ0Oi42MjVyZW07cGFkZGluZy1yaWdodDouNjI1cmVtfS5zbWFsbC1jZW50ZXJlZHttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5zbWFsbC1jZW50ZXJlZCwuc21hbGwtY2VudGVyZWQ6bGFzdC1jaGlsZDpub3QoOmZpcnN0LWNoaWxkKXtmbG9hdDpub25lO2NsZWFyOmJvdGh9LnNtYWxsLXB1bGwtMCwuc21hbGwtcHVzaC0wLC5zbWFsbC11bmNlbnRlcmVke3Bvc2l0aW9uOnN0YXRpYzttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO2Zsb2F0OmxlZnR9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsubWVkaXVtLTF7d2lkdGg6OC4zMzMzMyV9Lm1lZGl1bS1wdXNoLTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4LjMzMzMzJX0ubWVkaXVtLXB1bGwtMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi04LjMzMzMzJX0ubWVkaXVtLW9mZnNldC0we21hcmdpbi1sZWZ0OjB9Lm1lZGl1bS0ye3dpZHRoOjE2LjY2NjY3JX0ubWVkaXVtLXB1c2gtMntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjE2LjY2NjY3JX0ubWVkaXVtLXB1bGwtMntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0xNi42NjY2NyV9Lm1lZGl1bS1vZmZzZXQtMXttYXJnaW4tbGVmdDo4LjMzMzMzJX0ubWVkaXVtLTN7d2lkdGg6MjUlfS5tZWRpdW0tcHVzaC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MjUlfS5tZWRpdW0tcHVsbC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTI1JX0ubWVkaXVtLW9mZnNldC0ye21hcmdpbi1sZWZ0OjE2LjY2NjY3JX0ubWVkaXVtLTR7d2lkdGg6MzMuMzMzMzMlfS5tZWRpdW0tcHVzaC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MzMuMzMzMzMlfS5tZWRpdW0tcHVsbC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTMzLjMzMzMzJX0ubWVkaXVtLW9mZnNldC0ze21hcmdpbi1sZWZ0OjI1JX0ubWVkaXVtLTV7d2lkdGg6NDEuNjY2NjclfS5tZWRpdW0tcHVzaC01e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NDEuNjY2NjclfS5tZWRpdW0tcHVsbC01e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTQxLjY2NjY3JX0ubWVkaXVtLW9mZnNldC00e21hcmdpbi1sZWZ0OjMzLjMzMzMzJX0ubWVkaXVtLTZ7d2lkdGg6NTAlfS5tZWRpdW0tcHVzaC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTAlfS5tZWRpdW0tcHVsbC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTUwJX0ubWVkaXVtLW9mZnNldC01e21hcmdpbi1sZWZ0OjQxLjY2NjY3JX0ubWVkaXVtLTd7d2lkdGg6NTguMzMzMzMlfS5tZWRpdW0tcHVzaC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTguMzMzMzMlfS5tZWRpdW0tcHVsbC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTU4LjMzMzMzJX0ubWVkaXVtLW9mZnNldC02e21hcmdpbi1sZWZ0OjUwJX0ubWVkaXVtLTh7d2lkdGg6NjYuNjY2NjclfS5tZWRpdW0tcHVzaC04e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NjYuNjY2NjclfS5tZWRpdW0tcHVsbC04e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTY2LjY2NjY3JX0ubWVkaXVtLW9mZnNldC03e21hcmdpbi1sZWZ0OjU4LjMzMzMzJX0ubWVkaXVtLTl7d2lkdGg6NzUlfS5tZWRpdW0tcHVzaC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NzUlfS5tZWRpdW0tcHVsbC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTc1JX0ubWVkaXVtLW9mZnNldC04e21hcmdpbi1sZWZ0OjY2LjY2NjY3JX0ubWVkaXVtLTEwe3dpZHRoOjgzLjMzMzMzJX0ubWVkaXVtLXB1c2gtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4My4zMzMzMyV9Lm1lZGl1bS1wdWxsLTEwe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTgzLjMzMzMzJX0ubWVkaXVtLW9mZnNldC05e21hcmdpbi1sZWZ0Ojc1JX0ubWVkaXVtLTExe3dpZHRoOjkxLjY2NjY3JX0ubWVkaXVtLXB1c2gtMTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo5MS42NjY2NyV9Lm1lZGl1bS1wdWxsLTExe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTkxLjY2NjY3JX0ubWVkaXVtLW9mZnNldC0xMHttYXJnaW4tbGVmdDo4My4zMzMzMyV9Lm1lZGl1bS0xMnt3aWR0aDoxMDAlfS5tZWRpdW0tb2Zmc2V0LTExe21hcmdpbi1sZWZ0OjkxLjY2NjY3JX0ubWVkaXVtLXVwLTE+LmNvbHVtbiwubWVkaXVtLXVwLTE+LmNvbHVtbnN7d2lkdGg6MTAwJTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtMT4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTE+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC0xPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4rMSksLm1lZGl1bS11cC0xPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC0xPi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTE+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtMj4uY29sdW1uLC5tZWRpdW0tdXAtMj4uY29sdW1uc3t3aWR0aDo1MCU7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTI+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLm1lZGl1bS11cC0yPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5tZWRpdW0tdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDJuKzEpLC5tZWRpdW0tdXAtMj4uY29sdW1uczpudGgtb2YtdHlwZSgybisxKXtjbGVhcjpib3RofS5tZWRpdW0tdXAtMj4uY29sdW1uOmxhc3QtY2hpbGQsLm1lZGl1bS11cC0yPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTM+LmNvbHVtbiwubWVkaXVtLXVwLTM+LmNvbHVtbnN7d2lkdGg6MzMuMzMzMzMlO2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5tZWRpdW0tdXAtMz4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubWVkaXVtLXVwLTM+LmNvbHVtbjpudGgtb2YtdHlwZSgzbisxKSwubWVkaXVtLXVwLTM+LmNvbHVtbnM6bnRoLW9mLXR5cGUoM24rMSl7Y2xlYXI6Ym90aH0ubWVkaXVtLXVwLTM+LmNvbHVtbjpsYXN0LWNoaWxkLC5tZWRpdW0tdXAtMz4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC00Pi5jb2x1bW4sLm1lZGl1bS11cC00Pi5jb2x1bW5ze3dpZHRoOjI1JTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtND4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTQ+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC00Pi5jb2x1bW46bnRoLW9mLXR5cGUoNG4rMSksLm1lZGl1bS11cC00Pi5jb2x1bW5zOm50aC1vZi10eXBlKDRuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC00Pi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTQ+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtNT4uY29sdW1uLC5tZWRpdW0tdXAtNT4uY29sdW1uc3t3aWR0aDoyMCU7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTU+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLm1lZGl1bS11cC01Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5tZWRpdW0tdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDVuKzEpLC5tZWRpdW0tdXAtNT4uY29sdW1uczpudGgtb2YtdHlwZSg1bisxKXtjbGVhcjpib3RofS5tZWRpdW0tdXAtNT4uY29sdW1uOmxhc3QtY2hpbGQsLm1lZGl1bS11cC01Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTY+LmNvbHVtbiwubWVkaXVtLXVwLTY+LmNvbHVtbnN7d2lkdGg6MTYuNjY2NjclO2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5tZWRpdW0tdXAtNj4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubWVkaXVtLXVwLTY+LmNvbHVtbjpudGgtb2YtdHlwZSg2bisxKSwubWVkaXVtLXVwLTY+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNm4rMSl7Y2xlYXI6Ym90aH0ubWVkaXVtLXVwLTY+LmNvbHVtbjpsYXN0LWNoaWxkLC5tZWRpdW0tdXAtNj4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC03Pi5jb2x1bW4sLm1lZGl1bS11cC03Pi5jb2x1bW5ze3dpZHRoOjE0LjI4NTcxJTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtNz4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTc+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC03Pi5jb2x1bW46bnRoLW9mLXR5cGUoN24rMSksLm1lZGl1bS11cC03Pi5jb2x1bW5zOm50aC1vZi10eXBlKDduKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC03Pi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTc+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtOD4uY29sdW1uLC5tZWRpdW0tdXAtOD4uY29sdW1uc3t3aWR0aDoxMi41JTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtOD4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTg+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoOG4rMSksLm1lZGl1bS11cC04Pi5jb2x1bW5zOm50aC1vZi10eXBlKDhuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC04Pi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTg+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tY29sbGFwc2U+LmNvbHVtbiwubWVkaXVtLWNvbGxhcHNlPi5jb2x1bW5ze3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MH0uZXhwYW5kZWQucm93IC5tZWRpdW0tY29sbGFwc2Uucm93LC5tZWRpdW0tY29sbGFwc2UgLnJvd3ttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5tZWRpdW0tdW5jb2xsYXBzZT4uY29sdW1uLC5tZWRpdW0tdW5jb2xsYXBzZT4uY29sdW1uc3twYWRkaW5nLWxlZnQ6LjkzNzVyZW07cGFkZGluZy1yaWdodDouOTM3NXJlbX0ubWVkaXVtLWNlbnRlcmVke21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99Lm1lZGl1bS1jZW50ZXJlZCwubWVkaXVtLWNlbnRlcmVkOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCl7ZmxvYXQ6bm9uZTtjbGVhcjpib3RofS5tZWRpdW0tcHVsbC0wLC5tZWRpdW0tcHVzaC0wLC5tZWRpdW0tdW5jZW50ZXJlZHtwb3NpdGlvbjpzdGF0aWM7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDtmbG9hdDpsZWZ0fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5sYXJnZS0xe3dpZHRoOjguMzMzMzMlfS5sYXJnZS1wdXNoLTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4LjMzMzMzJX0ubGFyZ2UtcHVsbC0xe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTguMzMzMzMlfS5sYXJnZS1vZmZzZXQtMHttYXJnaW4tbGVmdDowfS5sYXJnZS0ye3dpZHRoOjE2LjY2NjY3JX0ubGFyZ2UtcHVzaC0ye3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MTYuNjY2NjclfS5sYXJnZS1wdWxsLTJ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMTYuNjY2NjclfS5sYXJnZS1vZmZzZXQtMXttYXJnaW4tbGVmdDo4LjMzMzMzJX0ubGFyZ2UtM3t3aWR0aDoyNSV9LmxhcmdlLXB1c2gtM3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjI1JX0ubGFyZ2UtcHVsbC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTI1JX0ubGFyZ2Utb2Zmc2V0LTJ7bWFyZ2luLWxlZnQ6MTYuNjY2NjclfS5sYXJnZS00e3dpZHRoOjMzLjMzMzMzJX0ubGFyZ2UtcHVzaC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MzMuMzMzMzMlfS5sYXJnZS1wdWxsLTR7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMzMuMzMzMzMlfS5sYXJnZS1vZmZzZXQtM3ttYXJnaW4tbGVmdDoyNSV9LmxhcmdlLTV7d2lkdGg6NDEuNjY2NjclfS5sYXJnZS1wdXNoLTV7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo0MS42NjY2NyV9LmxhcmdlLXB1bGwtNXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi00MS42NjY2NyV9LmxhcmdlLW9mZnNldC00e21hcmdpbi1sZWZ0OjMzLjMzMzMzJX0ubGFyZ2UtNnt3aWR0aDo1MCV9LmxhcmdlLXB1c2gtNntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjUwJX0ubGFyZ2UtcHVsbC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTUwJX0ubGFyZ2Utb2Zmc2V0LTV7bWFyZ2luLWxlZnQ6NDEuNjY2NjclfS5sYXJnZS03e3dpZHRoOjU4LjMzMzMzJX0ubGFyZ2UtcHVzaC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTguMzMzMzMlfS5sYXJnZS1wdWxsLTd7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNTguMzMzMzMlfS5sYXJnZS1vZmZzZXQtNnttYXJnaW4tbGVmdDo1MCV9LmxhcmdlLTh7d2lkdGg6NjYuNjY2NjclfS5sYXJnZS1wdXNoLTh7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo2Ni42NjY2NyV9LmxhcmdlLXB1bGwtOHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi02Ni42NjY2NyV9LmxhcmdlLW9mZnNldC03e21hcmdpbi1sZWZ0OjU4LjMzMzMzJX0ubGFyZ2UtOXt3aWR0aDo3NSV9LmxhcmdlLXB1c2gtOXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Ojc1JX0ubGFyZ2UtcHVsbC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTc1JX0ubGFyZ2Utb2Zmc2V0LTh7bWFyZ2luLWxlZnQ6NjYuNjY2NjclfS5sYXJnZS0xMHt3aWR0aDo4My4zMzMzMyV9LmxhcmdlLXB1c2gtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4My4zMzMzMyV9LmxhcmdlLXB1bGwtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotODMuMzMzMzMlfS5sYXJnZS1vZmZzZXQtOXttYXJnaW4tbGVmdDo3NSV9LmxhcmdlLTExe3dpZHRoOjkxLjY2NjY3JX0ubGFyZ2UtcHVzaC0xMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjkxLjY2NjY3JX0ubGFyZ2UtcHVsbC0xMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi05MS42NjY2NyV9LmxhcmdlLW9mZnNldC0xMHttYXJnaW4tbGVmdDo4My4zMzMzMyV9LmxhcmdlLTEye3dpZHRoOjEwMCV9LmxhcmdlLW9mZnNldC0xMXttYXJnaW4tbGVmdDo5MS42NjY2NyV9LmxhcmdlLXVwLTE+LmNvbHVtbiwubGFyZ2UtdXAtMT4uY29sdW1uc3t3aWR0aDoxMDAlO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTE+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTE+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTE+LmNvbHVtbjpudGgtb2YtdHlwZSgxbisxKSwubGFyZ2UtdXAtMT4uY29sdW1uczpudGgtb2YtdHlwZSgxbisxKXtjbGVhcjpib3RofS5sYXJnZS11cC0xPi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtMT4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTI+LmNvbHVtbiwubGFyZ2UtdXAtMj4uY29sdW1uc3t3aWR0aDo1MCU7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubGFyZ2UtdXAtMj4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubGFyZ2UtdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDJuKzEpLC5sYXJnZS11cC0yPi5jb2x1bW5zOm50aC1vZi10eXBlKDJuKzEpe2NsZWFyOmJvdGh9LmxhcmdlLXVwLTI+LmNvbHVtbjpsYXN0LWNoaWxkLC5sYXJnZS11cC0yPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtMz4uY29sdW1uLC5sYXJnZS11cC0zPi5jb2x1bW5ze3dpZHRoOjMzLjMzMzMzJTtmbG9hdDpsZWZ0fS5sYXJnZS11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC0zPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoM24rMSksLmxhcmdlLXVwLTM+LmNvbHVtbnM6bnRoLW9mLXR5cGUoM24rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtMz4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTM+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS11cC00Pi5jb2x1bW4sLmxhcmdlLXVwLTQ+LmNvbHVtbnN7d2lkdGg6MjUlO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTQ+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTQ+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTQ+LmNvbHVtbjpudGgtb2YtdHlwZSg0bisxKSwubGFyZ2UtdXAtND4uY29sdW1uczpudGgtb2YtdHlwZSg0bisxKXtjbGVhcjpib3RofS5sYXJnZS11cC00Pi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtND4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTU+LmNvbHVtbiwubGFyZ2UtdXAtNT4uY29sdW1uc3t3aWR0aDoyMCU7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubGFyZ2UtdXAtNT4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubGFyZ2UtdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDVuKzEpLC5sYXJnZS11cC01Pi5jb2x1bW5zOm50aC1vZi10eXBlKDVuKzEpe2NsZWFyOmJvdGh9LmxhcmdlLXVwLTU+LmNvbHVtbjpsYXN0LWNoaWxkLC5sYXJnZS11cC01Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtNj4uY29sdW1uLC5sYXJnZS11cC02Pi5jb2x1bW5ze3dpZHRoOjE2LjY2NjY3JTtmbG9hdDpsZWZ0fS5sYXJnZS11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC02Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoNm4rMSksLmxhcmdlLXVwLTY+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNm4rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtNj4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTY+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS11cC03Pi5jb2x1bW4sLmxhcmdlLXVwLTc+LmNvbHVtbnN7d2lkdGg6MTQuMjg1NzElO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTc+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTc+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTc+LmNvbHVtbjpudGgtb2YtdHlwZSg3bisxKSwubGFyZ2UtdXAtNz4uY29sdW1uczpudGgtb2YtdHlwZSg3bisxKXtjbGVhcjpib3RofS5sYXJnZS11cC03Pi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtNz4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTg+LmNvbHVtbiwubGFyZ2UtdXAtOD4uY29sdW1uc3t3aWR0aDoxMi41JTtmbG9hdDpsZWZ0fS5sYXJnZS11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC04Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoOG4rMSksLmxhcmdlLXVwLTg+LmNvbHVtbnM6bnRoLW9mLXR5cGUoOG4rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtOD4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTg+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS1jb2xsYXBzZT4uY29sdW1uLC5sYXJnZS1jb2xsYXBzZT4uY29sdW1uc3twYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjB9LmV4cGFuZGVkLnJvdyAubGFyZ2UtY29sbGFwc2Uucm93LC5sYXJnZS1jb2xsYXBzZSAucm93e21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjB9LmxhcmdlLXVuY29sbGFwc2U+LmNvbHVtbiwubGFyZ2UtdW5jb2xsYXBzZT4uY29sdW1uc3twYWRkaW5nLWxlZnQ6LjkzNzVyZW07cGFkZGluZy1yaWdodDouOTM3NXJlbX0ubGFyZ2UtY2VudGVyZWR7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0b30ubGFyZ2UtY2VudGVyZWQsLmxhcmdlLWNlbnRlcmVkOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCl7ZmxvYXQ6bm9uZTtjbGVhcjpib3RofS5sYXJnZS1wdWxsLTAsLmxhcmdlLXB1c2gtMCwubGFyZ2UtdW5jZW50ZXJlZHtwb3NpdGlvbjpzdGF0aWM7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDtmbG9hdDpsZWZ0fX1ibG9ja3F1b3RlLGRkLGRpdixkbCxkdCxmb3JtLGgxLGgyLGgzLGg0LGg1LGg2LGxpLG9sLHAscHJlLHRkLHRoLHVse21hcmdpbjowO3BhZGRpbmc6MH1we2ZvbnQtc2l6ZTppbmhlcml0O2xpbmUtaGVpZ2h0OjEuNjttYXJnaW4tYm90dG9tOjFyZW07dGV4dC1yZW5kZXJpbmc6b3B0aW1pemVMZWdpYmlsaXR5fWVtLGl7Zm9udC1zdHlsZTppdGFsaWN9YixlbSxpLHN0cm9uZ3tsaW5lLWhlaWdodDppbmhlcml0fWIsc3Ryb25ne2ZvbnQtd2VpZ2h0OjcwMH1zbWFsbHtmb250LXNpemU6ODAlO2xpbmUtaGVpZ2h0OmluaGVyaXR9aDEsaDIsaDMsaDQsaDUsaDZ7Zm9udC1mYW1pbHk6SGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLFJvYm90byxBcmlhbCxzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbDtjb2xvcjppbmhlcml0O3RleHQtcmVuZGVyaW5nOm9wdGltaXplTGVnaWJpbGl0eTttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTouNXJlbTtsaW5lLWhlaWdodDoxLjR9aDEgc21hbGwsaDIgc21hbGwsaDMgc21hbGwsaDQgc21hbGwsaDUgc21hbGwsaDYgc21hbGx7Y29sb3I6I2NhY2FjYTtsaW5lLWhlaWdodDowfWgxe2ZvbnQtc2l6ZToxLjVyZW19aDJ7Zm9udC1zaXplOjEuMjVyZW19aDN7Zm9udC1zaXplOjEuMTg3NXJlbX1oNHtmb250LXNpemU6MS4xMjVyZW19aDV7Zm9udC1zaXplOjEuMDYyNXJlbX1oNntmb250LXNpemU6MXJlbX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pe2gxe2ZvbnQtc2l6ZTozcmVtfWgye2ZvbnQtc2l6ZToyLjVyZW19aDN7Zm9udC1zaXplOjEuOTM3NXJlbX1oNHtmb250LXNpemU6MS41NjI1cmVtfWg1e2ZvbnQtc2l6ZToxLjI1cmVtfWg2e2ZvbnQtc2l6ZToxcmVtfX1he2NvbG9yOiMyMTk5ZTg7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6aW5oZXJpdDtjdXJzb3I6cG9pbnRlcn1hOmZvY3VzLGE6aG92ZXJ7Y29sb3I6IzE1ODVjZn1hIGltZ3tib3JkZXI6MH1ocnttYXgtd2lkdGg6NzVyZW07aGVpZ2h0OjA7Ym9yZGVyLXJpZ2h0OjA7Ym9yZGVyLXRvcDowO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNjYWNhY2E7Ym9yZGVyLWxlZnQ6MDttYXJnaW46MS4yNXJlbSBhdXRvO2NsZWFyOmJvdGh9ZGwsb2wsdWx7bGluZS1oZWlnaHQ6MS42O21hcmdpbi1ib3R0b206MXJlbTtsaXN0LXN0eWxlLXBvc2l0aW9uOm91dHNpZGV9bGl7Zm9udC1zaXplOmluaGVyaXR9dWx7bGlzdC1zdHlsZS10eXBlOmRpc2N9b2wsdWx7bWFyZ2luLWxlZnQ6MS4yNXJlbX1vbCBvbCxvbCB1bCx1bCBvbCx1bCB1bHttYXJnaW4tbGVmdDoxLjI1cmVtO21hcmdpbi1ib3R0b206MH1kbHttYXJnaW4tYm90dG9tOjFyZW19ZGwgZHR7bWFyZ2luLWJvdHRvbTouM3JlbTtmb250LXdlaWdodDo3MDB9YmxvY2txdW90ZXttYXJnaW46MCAwIDFyZW07cGFkZGluZzouNTYyNXJlbSAxLjI1cmVtIDAgMS4xODc1cmVtO2JvcmRlci1sZWZ0OjFweCBzb2xpZCAjY2FjYWNhfWJsb2NrcXVvdGUsYmxvY2txdW90ZSBwe2xpbmUtaGVpZ2h0OjEuNjtjb2xvcjojOGE4YThhfWNpdGV7ZGlzcGxheTpibG9jaztmb250LXNpemU6LjgxMjVyZW07Y29sb3I6IzhhOGE4YX1jaXRlOmJlZm9yZXtjb250ZW50OidcXFxcMjAxNCAgICAnfWFiYnJ7Y29sb3I6IzBhMGEwYTtjdXJzb3I6aGVscDtib3JkZXItYm90dG9tOjFweCBkb3R0ZWQgIzBhMGEwYX1jb2Rle2ZvbnQtd2VpZ2h0OjQwMDtib3JkZXI6MXB4IHNvbGlkICNjYWNhY2E7cGFkZGluZzouMTI1cmVtIC4zMTI1cmVtIC4wNjI1cmVtfWNvZGUsa2Jke2ZvbnQtZmFtaWx5OkNvbnNvbGFzLExpYmVyYXRpb24gTW9ubyxDb3VyaWVyLG1vbm9zcGFjZTtjb2xvcjojMGEwYTBhO2JhY2tncm91bmQtY29sb3I6I2U2ZTZlNn1rYmR7cGFkZGluZzouMTI1cmVtIC4yNXJlbSAwO21hcmdpbjowfS5zdWJoZWFkZXJ7bWFyZ2luLXRvcDouMnJlbTttYXJnaW4tYm90dG9tOi41cmVtO2ZvbnQtd2VpZ2h0OjQwMDtsaW5lLWhlaWdodDoxLjQ7Y29sb3I6IzhhOGE4YX0ubGVhZHtmb250LXNpemU6MTI1JTtsaW5lLWhlaWdodDoxLjZ9LnN0YXR7Zm9udC1zaXplOjIuNXJlbTtsaW5lLWhlaWdodDoxfXArLnN0YXR7bWFyZ2luLXRvcDotMXJlbX0ubm8tYnVsbGV0e21hcmdpbi1sZWZ0OjA7bGlzdC1zdHlsZTpub25lfS50ZXh0LWxlZnR7dGV4dC1hbGlnbjpsZWZ0fS50ZXh0LXJpZ2h0e3RleHQtYWxpZ246cmlnaHR9LnRleHQtY2VudGVye3RleHQtYWxpZ246Y2VudGVyfS50ZXh0LWp1c3RpZnl7dGV4dC1hbGlnbjpqdXN0aWZ5fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7Lm1lZGl1bS10ZXh0LWxlZnR7dGV4dC1hbGlnbjpsZWZ0fS5tZWRpdW0tdGV4dC1yaWdodHt0ZXh0LWFsaWduOnJpZ2h0fS5tZWRpdW0tdGV4dC1jZW50ZXJ7dGV4dC1hbGlnbjpjZW50ZXJ9Lm1lZGl1bS10ZXh0LWp1c3RpZnl7dGV4dC1hbGlnbjpqdXN0aWZ5fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5sYXJnZS10ZXh0LWxlZnR7dGV4dC1hbGlnbjpsZWZ0fS5sYXJnZS10ZXh0LXJpZ2h0e3RleHQtYWxpZ246cmlnaHR9LmxhcmdlLXRleHQtY2VudGVye3RleHQtYWxpZ246Y2VudGVyfS5sYXJnZS10ZXh0LWp1c3RpZnl7dGV4dC1hbGlnbjpqdXN0aWZ5fX0uc2hvdy1mb3ItcHJpbnR7ZGlzcGxheTpub25lIWltcG9ydGFudH1AbWVkaWEgcHJpbnR7KntiYWNrZ3JvdW5kOnRyYW5zcGFyZW50IWltcG9ydGFudDtjb2xvcjojMDAwIWltcG9ydGFudDtib3gtc2hhZG93Om5vbmUhaW1wb3J0YW50O3RleHQtc2hhZG93Om5vbmUhaW1wb3J0YW50fS5zaG93LWZvci1wcmludHtkaXNwbGF5OmJsb2NrIWltcG9ydGFudH0uaGlkZS1mb3ItcHJpbnR7ZGlzcGxheTpub25lIWltcG9ydGFudH10YWJsZS5zaG93LWZvci1wcmludHtkaXNwbGF5OnRhYmxlIWltcG9ydGFudH10aGVhZC5zaG93LWZvci1wcmludHtkaXNwbGF5OnRhYmxlLWhlYWRlci1ncm91cCFpbXBvcnRhbnR9dGJvZHkuc2hvdy1mb3ItcHJpbnR7ZGlzcGxheTp0YWJsZS1yb3ctZ3JvdXAhaW1wb3J0YW50fXRyLnNob3ctZm9yLXByaW50e2Rpc3BsYXk6dGFibGUtcm93IWltcG9ydGFudH10ZC5zaG93LWZvci1wcmludCx0aC5zaG93LWZvci1wcmludHtkaXNwbGF5OnRhYmxlLWNlbGwhaW1wb3J0YW50fWEsYTp2aXNpdGVke3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9YVtocmVmXTphZnRlcntjb250ZW50OlxcXCIgKFxcXCIgYXR0cihocmVmKSBcXFwiKVxcXCJ9LmlyIGE6YWZ0ZXIsYVtocmVmXj0nIyddOmFmdGVyLGFbaHJlZl49J2phdmFzY3JpcHQ6J106YWZ0ZXJ7Y29udGVudDonJ31hYmJyW3RpdGxlXTphZnRlcntjb250ZW50OlxcXCIgKFxcXCIgYXR0cih0aXRsZSkgXFxcIilcXFwifWJsb2NrcXVvdGUscHJle2JvcmRlcjoxcHggc29saWQgIzhhOGE4YTtwYWdlLWJyZWFrLWluc2lkZTphdm9pZH10aGVhZHtkaXNwbGF5OnRhYmxlLWhlYWRlci1ncm91cH1pbWcsdHJ7cGFnZS1icmVhay1pbnNpZGU6YXZvaWR9aW1ne21heC13aWR0aDoxMDAlIWltcG9ydGFudH1AcGFnZXttYXJnaW46LjVjbX1oMixoMyxwe29ycGhhbnM6Mzt3aWRvd3M6M31oMixoM3twYWdlLWJyZWFrLWFmdGVyOmF2b2lkfX1bdHlwZT1jb2xvcl0sW3R5cGU9ZGF0ZV0sW3R5cGU9ZGF0ZXRpbWUtbG9jYWxdLFt0eXBlPWRhdGV0aW1lXSxbdHlwZT1lbWFpbF0sW3R5cGU9bW9udGhdLFt0eXBlPW51bWJlcl0sW3R5cGU9cGFzc3dvcmRdLFt0eXBlPXNlYXJjaF0sW3R5cGU9dGVsXSxbdHlwZT10ZXh0XSxbdHlwZT10aW1lXSxbdHlwZT11cmxdLFt0eXBlPXdlZWtdLHRleHRhcmVhe2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOjEwMCU7aGVpZ2h0OjIuNDM3NXJlbTtwYWRkaW5nOi41cmVtO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTttYXJnaW46MCAwIDFyZW07Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6MXJlbTtjb2xvcjojMGEwYTBhO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDJweCBoc2xhKDAsMCUsNCUsLjEpO2JvcmRlci1yYWRpdXM6MDstd2Via2l0LXRyYW5zaXRpb246LXdlYmtpdC1ib3gtc2hhZG93IC41cyxib3JkZXItY29sb3IgLjI1cyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOmJveC1zaGFkb3cgLjVzLGJvcmRlci1jb2xvciAuMjVzIGVhc2UtaW4tb3V0Oy13ZWJraXQtYXBwZWFyYW5jZTpub25lOy1tb3otYXBwZWFyYW5jZTpub25lfVt0eXBlPWNvbG9yXTpmb2N1cyxbdHlwZT1kYXRlXTpmb2N1cyxbdHlwZT1kYXRldGltZS1sb2NhbF06Zm9jdXMsW3R5cGU9ZGF0ZXRpbWVdOmZvY3VzLFt0eXBlPWVtYWlsXTpmb2N1cyxbdHlwZT1tb250aF06Zm9jdXMsW3R5cGU9bnVtYmVyXTpmb2N1cyxbdHlwZT1wYXNzd29yZF06Zm9jdXMsW3R5cGU9c2VhcmNoXTpmb2N1cyxbdHlwZT10ZWxdOmZvY3VzLFt0eXBlPXRleHRdOmZvY3VzLFt0eXBlPXRpbWVdOmZvY3VzLFt0eXBlPXVybF06Zm9jdXMsW3R5cGU9d2Vla106Zm9jdXMsdGV4dGFyZWE6Zm9jdXN7Ym9yZGVyOjFweCBzb2xpZCAjOGE4YThhO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZTtvdXRsaW5lOm5vbmU7Ym94LXNoYWRvdzowIDAgNXB4ICNjYWNhY2E7LXdlYmtpdC10cmFuc2l0aW9uOi13ZWJraXQtYm94LXNoYWRvdyAuNXMsYm9yZGVyLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbjpib3gtc2hhZG93IC41cyxib3JkZXItY29sb3IgLjI1cyBlYXNlLWluLW91dH10ZXh0YXJlYXttYXgtd2lkdGg6MTAwJX10ZXh0YXJlYVtyb3dzXXtoZWlnaHQ6YXV0b31pbnB1dDo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcix0ZXh0YXJlYTo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojY2FjYWNhfWlucHV0OjotbW96LXBsYWNlaG9sZGVyLHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVye2NvbG9yOiNjYWNhY2F9aW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVyLHRleHRhcmVhOi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojY2FjYWNhfWlucHV0OjpwbGFjZWhvbGRlcix0ZXh0YXJlYTo6cGxhY2Vob2xkZXJ7Y29sb3I6I2NhY2FjYX1pbnB1dDpkaXNhYmxlZCxpbnB1dFtyZWFkb25seV0sdGV4dGFyZWE6ZGlzYWJsZWQsdGV4dGFyZWFbcmVhZG9ubHlde2JhY2tncm91bmQtY29sb3I6I2U2ZTZlNjtjdXJzb3I6bm90LWFsbG93ZWR9W3R5cGU9YnV0dG9uXSxbdHlwZT1zdWJtaXRde2JvcmRlci1yYWRpdXM6MDstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTstbW96LWFwcGVhcmFuY2U6bm9uZX1pbnB1dFt0eXBlPXNlYXJjaF17Ym94LXNpemluZzpib3JkZXItYm94fVt0eXBlPWNoZWNrYm94XSxbdHlwZT1maWxlXSxbdHlwZT1yYWRpb117bWFyZ2luOjAgMCAxcmVtfVt0eXBlPWNoZWNrYm94XStsYWJlbCxbdHlwZT1yYWRpb10rbGFiZWx7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWxlZnQ6LjVyZW07bWFyZ2luLXJpZ2h0OjFyZW07bWFyZ2luLWJvdHRvbTowO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfVt0eXBlPWNoZWNrYm94XStsYWJlbFtmb3JdLFt0eXBlPXJhZGlvXStsYWJlbFtmb3Jde2N1cnNvcjpwb2ludGVyfWxhYmVsPlt0eXBlPWNoZWNrYm94XSxsYWJlbD5bdHlwZT1yYWRpb117bWFyZ2luLXJpZ2h0Oi41cmVtfVt0eXBlPWZpbGVde3dpZHRoOjEwMCV9bGFiZWx7ZGlzcGxheTpibG9jazttYXJnaW46MDtmb250LXNpemU6Ljg3NXJlbTtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS44O2NvbG9yOiMwYTBhMGF9bGFiZWwubWlkZGxle21hcmdpbjowIDAgMXJlbTtwYWRkaW5nOi41NjI1cmVtIDB9LmhlbHAtdGV4dHttYXJnaW4tdG9wOi0uNXJlbTtmb250LXNpemU6LjgxMjVyZW07Zm9udC1zdHlsZTppdGFsaWM7Y29sb3I6IzBhMGEwYX0uaW5wdXQtZ3JvdXB7ZGlzcGxheTp0YWJsZTt3aWR0aDoxMDAlO21hcmdpbi1ib3R0b206MXJlbX0uaW5wdXQtZ3JvdXA+OmZpcnN0LWNoaWxkLC5pbnB1dC1ncm91cD46bGFzdC1jaGlsZD4qe2JvcmRlci1yYWRpdXM6MCAwIDAgMH0uaW5wdXQtZ3JvdXAtYnV0dG9uLC5pbnB1dC1ncm91cC1maWVsZCwuaW5wdXQtZ3JvdXAtbGFiZWx7bWFyZ2luOjA7d2hpdGUtc3BhY2U6bm93cmFwO2Rpc3BsYXk6dGFibGUtY2VsbDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmlucHV0LWdyb3VwLWxhYmVse3RleHQtYWxpZ246Y2VudGVyO3BhZGRpbmc6MCAxcmVtO2JhY2tncm91bmQ6I2U2ZTZlNjtjb2xvcjojMGEwYTBhO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MSU7aGVpZ2h0OjEwMCV9LmlucHV0LWdyb3VwLWxhYmVsOmZpcnN0LWNoaWxke2JvcmRlci1yaWdodDowfS5pbnB1dC1ncm91cC1sYWJlbDpsYXN0LWNoaWxke2JvcmRlci1sZWZ0OjB9LmlucHV0LWdyb3VwLWZpZWxke2JvcmRlci1yYWRpdXM6MDtoZWlnaHQ6Mi41cmVtfS5pbnB1dC1ncm91cC1idXR0b257cGFkZGluZy10b3A6MDtwYWRkaW5nLWJvdHRvbTowO3RleHQtYWxpZ246Y2VudGVyO2hlaWdodDoxMDAlO3dpZHRoOjElfS5pbnB1dC1ncm91cC1idXR0b24gYSwuaW5wdXQtZ3JvdXAtYnV0dG9uIGJ1dHRvbiwuaW5wdXQtZ3JvdXAtYnV0dG9uIGlucHV0e21hcmdpbjowfS5pbnB1dC1ncm91cCAuaW5wdXQtZ3JvdXAtYnV0dG9ue2Rpc3BsYXk6dGFibGUtY2VsbH1maWVsZHNldHtib3JkZXI6MDtwYWRkaW5nOjA7bWFyZ2luOjB9bGVnZW5ke21hcmdpbi1ib3R0b206LjVyZW07bWF4LXdpZHRoOjEwMCV9LmZpZWxkc2V0e2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTtwYWRkaW5nOjEuMjVyZW07bWFyZ2luOjEuMTI1cmVtIDB9LmZpZWxkc2V0IGxlZ2VuZHtiYWNrZ3JvdW5kOiNmZWZlZmU7cGFkZGluZzowIC4xODc1cmVtO21hcmdpbjowO21hcmdpbi1sZWZ0Oi0uMTg3NXJlbX1zZWxlY3R7aGVpZ2h0OjIuNDM3NXJlbTtwYWRkaW5nOi41cmVtO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTttYXJnaW46MCAwIDFyZW07Zm9udC1zaXplOjFyZW07Zm9udC1mYW1pbHk6aW5oZXJpdDtsaW5lLWhlaWdodDpub3JtYWw7Y29sb3I6IzBhMGEwYTtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmU7Ym9yZGVyLXJhZGl1czowOy13ZWJraXQtYXBwZWFyYW5jZTpub25lOy1tb3otYXBwZWFyYW5jZTpub25lO2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgdmVyc2lvbj0nMS4xJyB3aWR0aD0nMzInIGhlaWdodD0nMjQnIHZpZXdCb3g9JzAgMCAzMiAyNCc+PHBvbHlnb24gcG9pbnRzPScwLDAgMzIsMCAxNiwyNCcgc3R5bGU9J2ZpbGw6IHJnYiUyODEzOCwgMTM4LCAxMzglMjknPjwvcG9seWdvbj48L3N2Zz5cXFwiKTtiYWNrZ3JvdW5kLXNpemU6OXB4IDZweDtiYWNrZ3JvdW5kLXBvc2l0aW9uOnJpZ2h0IC0xcmVtIGNlbnRlcjtiYWNrZ3JvdW5kLW9yaWdpbjpjb250ZW50LWJveDtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7cGFkZGluZy1yaWdodDoxLjVyZW19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDowXFxcXDApe3NlbGVjdHtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFZQ0FZQUFBQ2JVLzgwQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFJcEpSRUZVZU5yRWtja05nREFNQkJmUmtFdDBPYlJCQmRzR1hVRGdtUWZLNFhoSDJtOGN6UUFBeTI3UjN0c3c0UWZlMng4dU9PNm9ZTGI2R2xPb3IzR0Yrc3dVUkFPbVVKK1J3dEVKczlXdlRHRVl4QlhxSTFNUUFaaENmVVFLUnpETVZqK1R3ckFJVjZqdlNVRWtZQXIxTFNrY3lUQmIvVitLWWZYN3hBZXVzcTNzTER0R0gza0VHQUNQV0lmbE5aZmhSUUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpfX1zZWxlY3Q6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2N1cnNvcjpub3QtYWxsb3dlZH1zZWxlY3Q6Oi1tcy1leHBhbmR7ZGlzcGxheTpub25lfXNlbGVjdFttdWx0aXBsZV17aGVpZ2h0OmF1dG87YmFja2dyb3VuZC1pbWFnZTpub25lfS5pcy1pbnZhbGlkLWlucHV0Om5vdCg6Zm9jdXMpe2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzYsODgsNjQsLjEpO2JvcmRlci1jb2xvcjojZWM1ODQwfS5mb3JtLWVycm9yLC5pcy1pbnZhbGlkLWxhYmVse2NvbG9yOiNlYzU4NDB9LmZvcm0tZXJyb3J7ZGlzcGxheTpub25lO21hcmdpbi10b3A6LS41cmVtO21hcmdpbi1ib3R0b206MXJlbTtmb250LXNpemU6Ljc1cmVtO2ZvbnQtd2VpZ2h0OjcwMH0uZm9ybS1lcnJvci5pcy12aXNpYmxle2Rpc3BsYXk6YmxvY2t9LmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmNlbnRlcjtsaW5lLWhlaWdodDoxO2N1cnNvcjpwb2ludGVyOy13ZWJraXQtYXBwZWFyYW5jZTpub25lOy13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4yNXMgZWFzZS1vdXQsY29sb3IgLjI1cyBlYXNlLW91dDt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjI1cyBlYXNlLW91dCxjb2xvciAuMjVzIGVhc2Utb3V0O3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6MDtwYWRkaW5nOi44NWVtIDFlbTttYXJnaW46MCAwIDFyZW07Zm9udC1zaXplOi45cmVtO2JhY2tncm91bmQtY29sb3I6IzIxOTllODtjb2xvcjojZmVmZWZlfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLmJ1dHRvbntvdXRsaW5lOjB9LmJ1dHRvbjpmb2N1cywuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzE1ODNjYztjb2xvcjojZmVmZWZlfS5idXR0b24udGlueXtmb250LXNpemU6LjZyZW19LmJ1dHRvbi5zbWFsbHtmb250LXNpemU6Ljc1cmVtfS5idXR0b24ubGFyZ2V7Zm9udC1zaXplOjEuMjVyZW19LmJ1dHRvbi5leHBhbmRlZHtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0uYnV0dG9uLnByaW1hcnl7YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5wcmltYXJ5OmZvY3VzLC5idXR0b24ucHJpbWFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxNDdjYzA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLnNlY29uZGFyeXtiYWNrZ3JvdW5kLWNvbG9yOiM3Nzc7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLnNlY29uZGFyeTpmb2N1cywuYnV0dG9uLnNlY29uZGFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiM1ZjVmNWY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLnN1Y2Nlc3N7YmFja2dyb3VuZC1jb2xvcjojM2FkYjc2O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5zdWNjZXNzOmZvY3VzLC5idXR0b24uc3VjY2Vzczpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMyMmJiNWI7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLndhcm5pbmd7YmFja2dyb3VuZC1jb2xvcjojZmZhZTAwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi53YXJuaW5nOmZvY3VzLC5idXR0b24ud2FybmluZzpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNjYzhiMDA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmFsZXJ0e2JhY2tncm91bmQtY29sb3I6I2VjNTg0MDtjb2xvcjojZmVmZWZlfS5idXR0b24uYWxlcnQ6Zm9jdXMsLmJ1dHRvbi5hbGVydDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNkYTMxMTY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmhvbGxvd3tib3JkZXI6MXB4IHNvbGlkICMyMTk5ZTg7Y29sb3I6IzIxOTllOH0uYnV0dG9uLmhvbGxvdywuYnV0dG9uLmhvbGxvdzpmb2N1cywuYnV0dG9uLmhvbGxvdzpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS5idXR0b24uaG9sbG93OmZvY3VzLC5idXR0b24uaG9sbG93OmhvdmVye2JvcmRlci1jb2xvcjojMGM0ZDc4O2NvbG9yOiMwYzRkNzh9LmJ1dHRvbi5ob2xsb3cucHJpbWFyeXtib3JkZXI6MXB4IHNvbGlkICMyMTk5ZTg7Y29sb3I6IzIxOTllOH0uYnV0dG9uLmhvbGxvdy5wcmltYXJ5OmZvY3VzLC5idXR0b24uaG9sbG93LnByaW1hcnk6aG92ZXJ7Ym9yZGVyLWNvbG9yOiMwYzRkNzg7Y29sb3I6IzBjNGQ3OH0uYnV0dG9uLmhvbGxvdy5zZWNvbmRhcnl7Ym9yZGVyOjFweCBzb2xpZCAjNzc3O2NvbG9yOiM3Nzd9LmJ1dHRvbi5ob2xsb3cuc2Vjb25kYXJ5OmZvY3VzLC5idXR0b24uaG9sbG93LnNlY29uZGFyeTpob3Zlcntib3JkZXItY29sb3I6IzNjM2MzYztjb2xvcjojM2MzYzNjfS5idXR0b24uaG9sbG93LnN1Y2Nlc3N7Ym9yZGVyOjFweCBzb2xpZCAjM2FkYjc2O2NvbG9yOiMzYWRiNzZ9LmJ1dHRvbi5ob2xsb3cuc3VjY2Vzczpmb2N1cywuYnV0dG9uLmhvbGxvdy5zdWNjZXNzOmhvdmVye2JvcmRlci1jb2xvcjojMTU3NTM5O2NvbG9yOiMxNTc1Mzl9LmJ1dHRvbi5ob2xsb3cud2FybmluZ3tib3JkZXI6MXB4IHNvbGlkICNmZmFlMDA7Y29sb3I6I2ZmYWUwMH0uYnV0dG9uLmhvbGxvdy53YXJuaW5nOmZvY3VzLC5idXR0b24uaG9sbG93Lndhcm5pbmc6aG92ZXJ7Ym9yZGVyLWNvbG9yOiM4MDU3MDA7Y29sb3I6IzgwNTcwMH0uYnV0dG9uLmhvbGxvdy5hbGVydHtib3JkZXI6MXB4IHNvbGlkICNlYzU4NDA7Y29sb3I6I2VjNTg0MH0uYnV0dG9uLmhvbGxvdy5hbGVydDpmb2N1cywuYnV0dG9uLmhvbGxvdy5hbGVydDpob3Zlcntib3JkZXItY29sb3I6Izg4MWYwZTtjb2xvcjojODgxZjBlfS5idXR0b24uZGlzYWJsZWQsLmJ1dHRvbltkaXNhYmxlZF17b3BhY2l0eTouMjU7Y3Vyc29yOm5vdC1hbGxvd2VkfS5idXR0b24uZGlzYWJsZWQ6Zm9jdXMsLmJ1dHRvbi5kaXNhYmxlZDpob3ZlciwuYnV0dG9uW2Rpc2FibGVkXTpmb2N1cywuYnV0dG9uW2Rpc2FibGVkXTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMyMTk5ZTg7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmRpc2FibGVkLnByaW1hcnksLmJ1dHRvbltkaXNhYmxlZF0ucHJpbWFyeXtvcGFjaXR5Oi4yNTtjdXJzb3I6bm90LWFsbG93ZWR9LmJ1dHRvbi5kaXNhYmxlZC5wcmltYXJ5OmZvY3VzLC5idXR0b24uZGlzYWJsZWQucHJpbWFyeTpob3ZlciwuYnV0dG9uW2Rpc2FibGVkXS5wcmltYXJ5OmZvY3VzLC5idXR0b25bZGlzYWJsZWRdLnByaW1hcnk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5kaXNhYmxlZC5zZWNvbmRhcnksLmJ1dHRvbltkaXNhYmxlZF0uc2Vjb25kYXJ5e29wYWNpdHk6LjI1O2N1cnNvcjpub3QtYWxsb3dlZH0uYnV0dG9uLmRpc2FibGVkLnNlY29uZGFyeTpmb2N1cywuYnV0dG9uLmRpc2FibGVkLnNlY29uZGFyeTpob3ZlciwuYnV0dG9uW2Rpc2FibGVkXS5zZWNvbmRhcnk6Zm9jdXMsLmJ1dHRvbltkaXNhYmxlZF0uc2Vjb25kYXJ5OmhvdmVye2JhY2tncm91bmQtY29sb3I6Izc3Nztjb2xvcjojZmVmZWZlfS5idXR0b24uZGlzYWJsZWQuc3VjY2VzcywuYnV0dG9uW2Rpc2FibGVkXS5zdWNjZXNze29wYWNpdHk6LjI1O2N1cnNvcjpub3QtYWxsb3dlZH0uYnV0dG9uLmRpc2FibGVkLnN1Y2Nlc3M6Zm9jdXMsLmJ1dHRvbi5kaXNhYmxlZC5zdWNjZXNzOmhvdmVyLC5idXR0b25bZGlzYWJsZWRdLnN1Y2Nlc3M6Zm9jdXMsLmJ1dHRvbltkaXNhYmxlZF0uc3VjY2Vzczpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMzYWRiNzY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmRpc2FibGVkLndhcm5pbmcsLmJ1dHRvbltkaXNhYmxlZF0ud2FybmluZ3tvcGFjaXR5Oi4yNTtjdXJzb3I6bm90LWFsbG93ZWR9LmJ1dHRvbi5kaXNhYmxlZC53YXJuaW5nOmZvY3VzLC5idXR0b24uZGlzYWJsZWQud2FybmluZzpob3ZlciwuYnV0dG9uW2Rpc2FibGVkXS53YXJuaW5nOmZvY3VzLC5idXR0b25bZGlzYWJsZWRdLndhcm5pbmc6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZhZTAwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5kaXNhYmxlZC5hbGVydCwuYnV0dG9uW2Rpc2FibGVkXS5hbGVydHtvcGFjaXR5Oi4yNTtjdXJzb3I6bm90LWFsbG93ZWR9LmJ1dHRvbi5kaXNhYmxlZC5hbGVydDpmb2N1cywuYnV0dG9uLmRpc2FibGVkLmFsZXJ0OmhvdmVyLC5idXR0b25bZGlzYWJsZWRdLmFsZXJ0OmZvY3VzLC5idXR0b25bZGlzYWJsZWRdLmFsZXJ0OmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VjNTg0MDtjb2xvcjojZmVmZWZlfS5idXR0b24uZHJvcGRvd246YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOi40ZW0gaW5zZXQ7Ym9yZGVyLWNvbG9yOiNmZWZlZmUgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZDtib3JkZXItYm90dG9tLXdpZHRoOjA7cG9zaXRpb246cmVsYXRpdmU7dG9wOi40ZW07ZmxvYXQ6cmlnaHQ7bWFyZ2luLWxlZnQ6MWVtO2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5idXR0b24uYXJyb3ctb25seTphZnRlcnttYXJnaW4tbGVmdDowO2Zsb2F0Om5vbmU7dG9wOi0uMWVtfS5hY2NvcmRpb257bGlzdC1zdHlsZS10eXBlOm5vbmU7YmFja2dyb3VuZDojZmVmZWZlO21hcmdpbi1sZWZ0OjB9LmFjY29yZGlvbi1pdGVtOmZpcnN0LWNoaWxkPjpmaXJzdC1jaGlsZCwuYWNjb3JkaW9uLWl0ZW06bGFzdC1jaGlsZD46bGFzdC1jaGlsZHtib3JkZXItcmFkaXVzOjAgMCAwIDB9LmFjY29yZGlvbi10aXRsZXtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6MS4yNXJlbSAxcmVtO2xpbmUtaGVpZ2h0OjE7Zm9udC1zaXplOi43NXJlbTtjb2xvcjojMjE5OWU4O3Bvc2l0aW9uOnJlbGF0aXZlO2JvcmRlcjoxcHggc29saWQgI2U2ZTZlNjtib3JkZXItYm90dG9tOjB9Omxhc3QtY2hpbGQ6bm90KC5pcy1hY3RpdmUpPi5hY2NvcmRpb24tdGl0bGV7Ym9yZGVyLXJhZGl1czowIDAgMCAwO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlNmU2ZTZ9LmFjY29yZGlvbi10aXRsZTpmb2N1cywuYWNjb3JkaW9uLXRpdGxlOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2U2ZTZlNn0uYWNjb3JkaW9uLXRpdGxlOmJlZm9yZXtjb250ZW50OicrJztwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDoxcmVtO3RvcDo1MCU7bWFyZ2luLXRvcDotLjVyZW19LmlzLWFjdGl2ZT4uYWNjb3JkaW9uLXRpdGxlOmJlZm9yZXtjb250ZW50OidcXFxcMjAxMyd9LmFjY29yZGlvbi1jb250ZW50e3BhZGRpbmc6MXJlbTtkaXNwbGF5Om5vbmU7Ym9yZGVyOjFweCBzb2xpZCAjZTZlNmU2O2JvcmRlci1ib3R0b206MDtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmU7Y29sb3I6IzBhMGEwYX06bGFzdC1jaGlsZD4uYWNjb3JkaW9uLWNvbnRlbnQ6bGFzdC1jaGlsZHtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZTZlNmU2fS5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQ+YXtwb3NpdGlvbjpyZWxhdGl2ZX0uaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjZweCBpbnNldDtib3JkZXItY29sb3I6IzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO21hcmdpbi10b3A6LTRweDtyaWdodDoxcmVtfS5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnRbYXJpYS1leHBhbmRlZD10cnVlXT5hOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjo1MCUgNTAlO3RyYW5zZm9ybS1vcmlnaW46NTAlIDUwJTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVkoLTEpO3RyYW5zZm9ybTpzY2FsZVkoLTEpfS5iYWRnZXtkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOi4zZW07bWluLXdpZHRoOjIuMWVtO2ZvbnQtc2l6ZTouNnJlbTt0ZXh0LWFsaWduOmNlbnRlcjtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kOiMyMTk5ZTg7Y29sb3I6I2ZlZmVmZX0uYmFkZ2Uuc2Vjb25kYXJ5e2JhY2tncm91bmQ6Izc3Nztjb2xvcjojZmVmZWZlfS5iYWRnZS5zdWNjZXNze2JhY2tncm91bmQ6IzNhZGI3Njtjb2xvcjojZmVmZWZlfS5iYWRnZS53YXJuaW5ne2JhY2tncm91bmQ6I2ZmYWUwMDtjb2xvcjojZmVmZWZlfS5iYWRnZS5hbGVydHtiYWNrZ3JvdW5kOiNlYzU4NDA7Y29sb3I6I2ZlZmVmZX0uYnJlYWRjcnVtYnN7bGlzdC1zdHlsZTpub25lO21hcmdpbjowIDAgMXJlbX0uYnJlYWRjcnVtYnM6YWZ0ZXIsLmJyZWFkY3J1bWJzOmJlZm9yZXtjb250ZW50OicgJztkaXNwbGF5OnRhYmxlfS5icmVhZGNydW1iczphZnRlcntjbGVhcjpib3RofS5icmVhZGNydW1icyBsaXtmbG9hdDpsZWZ0O2NvbG9yOiMwYTBhMGE7Zm9udC1zaXplOi42ODc1cmVtO2N1cnNvcjpkZWZhdWx0O3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZX0uYnJlYWRjcnVtYnMgbGk6bm90KDpsYXN0LWNoaWxkKTphZnRlcntjb2xvcjojY2FjYWNhO2NvbnRlbnQ6XFxcIi9cXFwiO21hcmdpbjowIC43NXJlbTtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6MXB4O29wYWNpdHk6MX0uYnJlYWRjcnVtYnMgYXtjb2xvcjojMjE5OWU4fS5icmVhZGNydW1icyBhOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LmJyZWFkY3J1bWJzIC5kaXNhYmxlZHtjb2xvcjojY2FjYWNhO2N1cnNvcjpub3QtYWxsb3dlZH0uYnV0dG9uLWdyb3Vwe21hcmdpbi1ib3R0b206MXJlbTtmb250LXNpemU6MH0uYnV0dG9uLWdyb3VwOmFmdGVyLC5idXR0b24tZ3JvdXA6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGV9LmJ1dHRvbi1ncm91cDphZnRlcntjbGVhcjpib3RofS5idXR0b24tZ3JvdXAgLmJ1dHRvbnttYXJnaW46MDttYXJnaW4tcmlnaHQ6MXB4O21hcmdpbi1ib3R0b206MXB4O2ZvbnQtc2l6ZTouOXJlbX0uYnV0dG9uLWdyb3VwIC5idXR0b246bGFzdC1jaGlsZHttYXJnaW4tcmlnaHQ6MH0uYnV0dG9uLWdyb3VwLnRpbnkgLmJ1dHRvbntmb250LXNpemU6LjZyZW19LmJ1dHRvbi1ncm91cC5zbWFsbCAuYnV0dG9ue2ZvbnQtc2l6ZTouNzVyZW19LmJ1dHRvbi1ncm91cC5sYXJnZSAuYnV0dG9ue2ZvbnQtc2l6ZToxLjI1cmVtfS5idXR0b24tZ3JvdXAuZXhwYW5kZWR7bWFyZ2luLXJpZ2h0Oi0xcHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZDphZnRlciwuYnV0dG9uLWdyb3VwLmV4cGFuZGVkOmJlZm9yZXtkaXNwbGF5Om5vbmV9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDIpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoNTAlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKX4uYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDIpOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0Oi02cHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDMpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMzMuMzMzMzMlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKX4uYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDMpOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0Oi02cHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMjUlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KX4uYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0Oi02cHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDUpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMjAlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KX4uYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDUpOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0Oi02cHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDYpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMTYuNjY2NjclIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KX4uYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDYpOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0Oi02cHh9LmJ1dHRvbi1ncm91cC5wcmltYXJ5IC5idXR0b257YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5wcmltYXJ5IC5idXR0b246Zm9jdXMsLmJ1dHRvbi1ncm91cC5wcmltYXJ5IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTQ3Y2MwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5zZWNvbmRhcnkgLmJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOiM3Nzc7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLnNlY29uZGFyeSAuYnV0dG9uOmZvY3VzLC5idXR0b24tZ3JvdXAuc2Vjb25kYXJ5IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojNWY1ZjVmO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5zdWNjZXNzIC5idXR0b257YmFja2dyb3VuZC1jb2xvcjojM2FkYjc2O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5zdWNjZXNzIC5idXR0b246Zm9jdXMsLmJ1dHRvbi1ncm91cC5zdWNjZXNzIC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMjJiYjViO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC53YXJuaW5nIC5idXR0b257YmFja2dyb3VuZC1jb2xvcjojZmZhZTAwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC53YXJuaW5nIC5idXR0b246Zm9jdXMsLmJ1dHRvbi1ncm91cC53YXJuaW5nIC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojY2M4YjAwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5hbGVydCAuYnV0dG9ue2JhY2tncm91bmQtY29sb3I6I2VjNTg0MDtjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAuYWxlcnQgLmJ1dHRvbjpmb2N1cywuYnV0dG9uLWdyb3VwLmFsZXJ0IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZGEzMTE2O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1tZWRpdW0gLmJ1dHRvbiwuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsIC5idXR0b24sLmJ1dHRvbi1ncm91cC5zdGFja2VkIC5idXR0b257d2lkdGg6MTAwJX0uYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLW1lZGl1bSAuYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1zbWFsbCAuYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5zdGFja2VkIC5idXR0b246bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsIC5idXR0b257d2lkdGg6YXV0bzttYXJnaW4tYm90dG9tOjB9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NjRlbSl7LmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1tZWRpdW0gLmJ1dHRvbnt3aWR0aDphdXRvO21hcmdpbi1ib3R0b206MH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3Itc21hbGwuZXhwYW5kZWR7ZGlzcGxheTpibG9ja30uYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsLmV4cGFuZGVkIC5idXR0b257ZGlzcGxheTpibG9jazttYXJnaW4tcmlnaHQ6MH19LmNhbGxvdXR7bWFyZ2luOjAgMCAxcmVtO3BhZGRpbmc6MXJlbTtib3JkZXI6MXB4IHNvbGlkIGhzbGEoMCwwJSw0JSwuMjUpO2JvcmRlci1yYWRpdXM6MDtwb3NpdGlvbjpyZWxhdGl2ZTtjb2xvcjojMGEwYTBhO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uY2FsbG91dD46Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDowfS5jYWxsb3V0PjpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH0uY2FsbG91dC5wcmltYXJ5e2JhY2tncm91bmQtY29sb3I6I2RlZjBmY30uY2FsbG91dC5zZWNvbmRhcnl7YmFja2dyb3VuZC1jb2xvcjojZWJlYmVifS5jYWxsb3V0LnN1Y2Nlc3N7YmFja2dyb3VuZC1jb2xvcjojZTFmYWVhfS5jYWxsb3V0Lndhcm5pbmd7YmFja2dyb3VuZC1jb2xvcjojZmZmM2Q5fS5jYWxsb3V0LmFsZXJ0e2JhY2tncm91bmQtY29sb3I6I2ZjZTZlMn0uY2FsbG91dC5zbWFsbHtwYWRkaW5nOi41cmVtfS5jYWxsb3V0Lmxhcmdle3BhZGRpbmc6M3JlbX0uY2xvc2UtYnV0dG9ue3Bvc2l0aW9uOmFic29sdXRlO2NvbG9yOiM4YThhOGE7cmlnaHQ6MXJlbTt0b3A6LjVyZW07Zm9udC1zaXplOjJlbTtsaW5lLWhlaWdodDoxO2N1cnNvcjpwb2ludGVyfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLmNsb3NlLWJ1dHRvbntvdXRsaW5lOjB9LmNsb3NlLWJ1dHRvbjpmb2N1cywuY2xvc2UtYnV0dG9uOmhvdmVye2NvbG9yOiMwYTBhMGF9Lm1lbnV7bWFyZ2luOjA7bGlzdC1zdHlsZS10eXBlOm5vbmV9Lm1lbnU+bGl7ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX1bZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5tZW51Pmxpe291dGxpbmU6MH0ubWVudT5saT5he2Rpc3BsYXk6YmxvY2s7cGFkZGluZzouN3JlbSAxcmVtO2xpbmUtaGVpZ2h0OjF9Lm1lbnUgYSwubWVudSBidXR0b24sLm1lbnUgaW5wdXR7bWFyZ2luLWJvdHRvbTowfS5tZW51PmxpPmEgaSwubWVudT5saT5hIGkrc3BhbiwubWVudT5saT5hIGltZywubWVudT5saT5hIGltZytzcGFuLC5tZW51PmxpPmEgc3ZnLC5tZW51PmxpPmEgc3ZnK3NwYW57dmVydGljYWwtYWxpZ246bWlkZGxlfS5tZW51PmxpPmEgaSwubWVudT5saT5hIGltZywubWVudT5saT5hIHN2Z3ttYXJnaW4tcmlnaHQ6LjI1cmVtO2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5tZW51Pmxpe2Rpc3BsYXk6dGFibGUtY2VsbH0ubWVudS52ZXJ0aWNhbD5saXtkaXNwbGF5OmJsb2NrfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7Lm1lbnUubWVkaXVtLWhvcml6b250YWw+bGl7ZGlzcGxheTp0YWJsZS1jZWxsfS5tZW51Lm1lZGl1bS12ZXJ0aWNhbD5saXtkaXNwbGF5OmJsb2NrfX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5tZW51LmxhcmdlLWhvcml6b250YWw+bGl7ZGlzcGxheTp0YWJsZS1jZWxsfS5tZW51LmxhcmdlLXZlcnRpY2FsPmxpe2Rpc3BsYXk6YmxvY2t9fS5tZW51LnNpbXBsZSBsaXtsaW5lLWhlaWdodDoxO2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1yaWdodDoxcmVtfS5tZW51LnNpbXBsZSBhe3BhZGRpbmc6MH0ubWVudS5hbGlnbi1yaWdodDphZnRlciwubWVudS5hbGlnbi1yaWdodDpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZX0ubWVudS5hbGlnbi1yaWdodDphZnRlcntjbGVhcjpib3RofS5tZW51LmFsaWduLXJpZ2h0Pmxpe2Zsb2F0OnJpZ2h0fS5tZW51LmV4cGFuZGVke3dpZHRoOjEwMCU7ZGlzcGxheTp0YWJsZTt0YWJsZS1sYXlvdXQ6Zml4ZWR9Lm1lbnUuZXhwYW5kZWQ+bGk6Zmlyc3QtY2hpbGQ6bGFzdC1jaGlsZHt3aWR0aDoxMDAlfS5tZW51Lmljb24tdG9wPmxpPmF7dGV4dC1hbGlnbjpjZW50ZXJ9Lm1lbnUuaWNvbi10b3A+bGk+YSBpLC5tZW51Lmljb24tdG9wPmxpPmEgaW1nLC5tZW51Lmljb24tdG9wPmxpPmEgc3Zne2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjAgYXV0byAuMjVyZW19Lm1lbnUubmVzdGVke21hcmdpbi1sZWZ0OjFyZW19Lm1lbnUgLmFjdGl2ZT5he2NvbG9yOiNmZWZlZmU7YmFja2dyb3VuZDojMjE5OWU4fS5tZW51LXRleHR7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOmluaGVyaXQ7bGluZS1oZWlnaHQ6MTtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7cGFkZGluZzouN3JlbSAxcmVtfS5tZW51LWNlbnRlcmVke3RleHQtYWxpZ246Y2VudGVyfS5tZW51LWNlbnRlcmVkPi5tZW51e2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5uby1qcyBbZGF0YS1yZXNwb25zaXZlLW1lbnVdIHVse2Rpc3BsYXk6bm9uZX0ubWVudS1pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtjdXJzb3I6cG9pbnRlcjt3aWR0aDoyMHB4O2hlaWdodDoxNnB4fS5tZW51LWljb246YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OjJweDtiYWNrZ3JvdW5kOiNmZWZlZmU7dG9wOjA7bGVmdDowO2JveC1zaGFkb3c6MCA3cHggMCAjZmVmZWZlLDAgMTRweCAwICNmZWZlZmV9Lm1lbnUtaWNvbjpob3ZlcjphZnRlcntiYWNrZ3JvdW5kOiNjYWNhY2E7Ym94LXNoYWRvdzowIDdweCAwICNjYWNhY2EsMCAxNHB4IDAgI2NhY2FjYX0ubWVudS1pY29uLmRhcmt7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO2N1cnNvcjpwb2ludGVyO3dpZHRoOjIwcHg7aGVpZ2h0OjE2cHh9Lm1lbnUtaWNvbi5kYXJrOmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO2hlaWdodDoycHg7YmFja2dyb3VuZDojMGEwYTBhO3RvcDowO2xlZnQ6MDtib3gtc2hhZG93OjAgN3B4IDAgIzBhMGEwYSwwIDE0cHggMCAjMGEwYTBhfS5tZW51LWljb24uZGFyazpob3ZlcjphZnRlcntiYWNrZ3JvdW5kOiM4YThhOGE7Ym94LXNoYWRvdzowIDdweCAwICM4YThhOGEsMCAxNHB4IDAgIzhhOGE4YX0uaXMtZHJpbGxkb3due3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbn0uaXMtZHJpbGxkb3duIGxpe2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50fS5pcy1kcmlsbGRvd24tc3VibWVudXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjEwMCU7ei1pbmRleDotMTt3aWR0aDoxMDAlO2JhY2tncm91bmQ6I2ZlZmVmZTstd2Via2l0LXRyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gLjE1cyBsaW5lYXI7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjE1cyBsaW5lYXJ9LmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWFjdGl2ZXt6LWluZGV4OjE7ZGlzcGxheTpibG9jazstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSl9LmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWNsb3Npbmd7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgxMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgxMDAlKX0uaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50PmF7cG9zaXRpb246cmVsYXRpdmV9LmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo2cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7Ym9yZGVyLWxlZnQtc3R5bGU6c29saWQ7Ym9yZGVyLXJpZ2h0LXdpZHRoOjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTttYXJnaW4tdG9wOi02cHg7cmlnaHQ6MXJlbX0uanMtZHJpbGxkb3duLWJhY2s+YTpiZWZvcmV7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjZweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtc3R5bGU6c29saWQ7Ym9yZGVyLWxlZnQtd2lkdGg6MDtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7bWFyZ2luLXJpZ2h0Oi43NXJlbX0uZHJvcGRvd24tcGFuZXtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmU7Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhO2JvcmRlci1yYWRpdXM6MDtkaXNwbGF5OmJsb2NrO2ZvbnQtc2l6ZToxcmVtO3BhZGRpbmc6MXJlbTtwb3NpdGlvbjphYnNvbHV0ZTt2aXNpYmlsaXR5OmhpZGRlbjt3aWR0aDozMDBweDt6LWluZGV4OjEwfS5kcm9wZG93bi1wYW5lLmlzLW9wZW57dmlzaWJpbGl0eTp2aXNpYmxlfS5kcm9wZG93bi1wYW5lLnRpbnl7d2lkdGg6MTAwcHh9LmRyb3Bkb3duLXBhbmUuc21hbGx7d2lkdGg6MjAwcHh9LmRyb3Bkb3duLXBhbmUubGFyZ2V7d2lkdGg6NDAwcHh9LmRyb3Bkb3duLm1lbnU+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudT5saS5vcGVucy1yaWdodD4uaXMtZHJvcGRvd24tc3VibWVudXtyaWdodDphdXRvO2xlZnQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudT5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5he3BhZGRpbmctcmlnaHQ6MS41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5kcm9wZG93bi5tZW51PmxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6IzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDtyaWdodDo1cHg7bWFyZ2luLXRvcDotMnB4fVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLmRyb3Bkb3duLm1lbnUgYXtvdXRsaW5lOjB9Lm5vLWpzIC5kcm9wZG93bi5tZW51IHVse2Rpc3BsYXk6bm9uZX0uZHJvcGRvd24ubWVudS52ZXJ0aWNhbD5saSAuaXMtZHJvcGRvd24tc3VibWVudXt0b3A6MH0uZHJvcGRvd24ubWVudS52ZXJ0aWNhbD5saS5vcGVucy1sZWZ0Pi5pcy1kcm9wZG93bi1zdWJtZW51e2xlZnQ6YXV0bztyaWdodDoxMDAlfS5kcm9wZG93bi5tZW51LnZlcnRpY2FsPmxpLm9wZW5zLXJpZ2h0Pi5pcy1kcm9wZG93bi1zdWJtZW51e3JpZ2h0OmF1dG87bGVmdDoxMDAlfS5kcm9wZG93bi5tZW51LnZlcnRpY2FsPmxpPmE6YWZ0ZXJ7cmlnaHQ6MTRweDttYXJnaW4tdG9wOi0zcHh9LmRyb3Bkb3duLm1lbnUudmVydGljYWw+bGkub3BlbnMtbGVmdD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50ICMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LXN0eWxlOnNvbGlkO2JvcmRlci1sZWZ0LXdpZHRoOjB9LmRyb3Bkb3duLm1lbnUudmVydGljYWw+bGkub3BlbnMtcmlnaHQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMjE5OWU4O2JvcmRlci1sZWZ0LXN0eWxlOnNvbGlkO2JvcmRlci1yaWdodC13aWR0aDowfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LmRyb3Bkb3duLm1lbnUubWVkaXVtLWhvcml6b250YWw+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbD5saS5vcGVucy1yaWdodD4uaXMtZHJvcGRvd24tc3VibWVudXtyaWdodDphdXRvO2xlZnQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbD5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5he3BhZGRpbmctcmlnaHQ6MS41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5kcm9wZG93bi5tZW51Lm1lZGl1bS1ob3Jpem9udGFsPmxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6IzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDtyaWdodDo1cHg7bWFyZ2luLXRvcDotMnB4fS5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbD5saSAuaXMtZHJvcGRvd24tc3VibWVudXt0b3A6MH0uZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWw+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MTAwJX0uZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWw+bGkub3BlbnMtcmlnaHQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjEwMCV9LmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsPmxpPmE6YWZ0ZXJ7cmlnaHQ6MTRweDttYXJnaW4tdG9wOi0zcHh9LmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsPmxpLm9wZW5zLWxlZnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowfS5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbD5saS5vcGVucy1yaWdodD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7Ym9yZGVyLWxlZnQtc3R5bGU6c29saWQ7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NjRlbSl7LmRyb3Bkb3duLm1lbnUubGFyZ2UtaG9yaXpvbnRhbD5saS5vcGVucy1sZWZ0Pi5pcy1kcm9wZG93bi1zdWJtZW51e2xlZnQ6YXV0bztyaWdodDowO3RvcDoxMDAlfS5kcm9wZG93bi5tZW51LmxhcmdlLWhvcml6b250YWw+bGkub3BlbnMtcmlnaHQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjA7dG9wOjEwMCV9LmRyb3Bkb3duLm1lbnUubGFyZ2UtaG9yaXpvbnRhbD5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5he3BhZGRpbmctcmlnaHQ6MS41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5kcm9wZG93bi5tZW51LmxhcmdlLWhvcml6b250YWw+bGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjojMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci10b3Atc3R5bGU6c29saWQ7Ym9yZGVyLWJvdHRvbS13aWR0aDowO3JpZ2h0OjVweDttYXJnaW4tdG9wOi0ycHh9LmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWw+bGkgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7dG9wOjB9LmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWw+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MTAwJX0uZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbD5saS5vcGVucy1yaWdodD4uaXMtZHJvcGRvd24tc3VibWVudXtyaWdodDphdXRvO2xlZnQ6MTAwJX0uZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbD5saT5hOmFmdGVye3JpZ2h0OjE0cHg7bWFyZ2luLXRvcDotM3B4fS5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsPmxpLm9wZW5zLWxlZnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowfS5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsPmxpLm9wZW5zLXJpZ2h0PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzIxOTllODtib3JkZXItbGVmdC1zdHlsZTpzb2xpZDtib3JkZXItcmlnaHQtd2lkdGg6MH19LmRyb3Bkb3duLm1lbnUuYWxpZ24tcmlnaHQgLmlzLWRyb3Bkb3duLXN1Ym1lbnUuZmlyc3Qtc3Vie3RvcDoxMDAlO2xlZnQ6YXV0bztyaWdodDowfS5pcy1kcm9wZG93bi1tZW51LnZlcnRpY2Fse3dpZHRoOjEwMHB4fS5pcy1kcm9wZG93bi1tZW51LnZlcnRpY2FsLmFsaWduLXJpZ2h0e2Zsb2F0OnJpZ2h0fS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudHtwb3NpdGlvbjpyZWxhdGl2ZX0uaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQgYTphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO3JpZ2h0OjVweDttYXJnaW4tdG9wOi0ycHh9LmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Lm9wZW5zLWlubmVyPi5pcy1kcm9wZG93bi1zdWJtZW51e3RvcDoxMDAlO2xlZnQ6YXV0b30uaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MTAwJX0uaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQub3BlbnMtcmlnaHQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjEwMCV9LmlzLWRyb3Bkb3duLXN1Ym1lbnV7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MTAwJTttaW4td2lkdGg6MjAwcHg7ei1pbmRleDoxO2JhY2tncm91bmQ6I2ZlZmVmZTtib3JkZXI6MXB4IHNvbGlkICNjYWNhY2F9LmlzLWRyb3Bkb3duLXN1Ym1lbnUgLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7cmlnaHQ6MTRweDttYXJnaW4tdG9wOi0zcHh9LmlzLWRyb3Bkb3duLXN1Ym1lbnUgLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Lm9wZW5zLWxlZnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowfS5pcy1kcm9wZG93bi1zdWJtZW51IC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudC5vcGVucy1yaWdodD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7Ym9yZGVyLWxlZnQtc3R5bGU6c29saWQ7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9LmlzLWRyb3Bkb3duLXN1Ym1lbnUgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7bWFyZ2luLXRvcDotMXB4fS5pcy1kcm9wZG93bi1zdWJtZW51Pmxpe3dpZHRoOjEwMCV9LmlzLWRyb3Bkb3duLXN1Ym1lbnUuanMtZHJvcGRvd24tYWN0aXZle2Rpc3BsYXk6YmxvY2t9LmZsZXgtdmlkZW97cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0OjA7cGFkZGluZy1ib3R0b206NzUlO21hcmdpbi1ib3R0b206MXJlbTtvdmVyZmxvdzpoaWRkZW59LmZsZXgtdmlkZW8gZW1iZWQsLmZsZXgtdmlkZW8gaWZyYW1lLC5mbGV4LXZpZGVvIG9iamVjdCwuZmxleC12aWRlbyB2aWRlb3twb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uZmxleC12aWRlby53aWRlc2NyZWVue3BhZGRpbmctYm90dG9tOjU2LjI1JX0uZmxleC12aWRlby52aW1lb3twYWRkaW5nLXRvcDowfS5sYWJlbHtkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOi4zMzMzM3JlbSAuNXJlbTtmb250LXNpemU6LjhyZW07bGluZS1oZWlnaHQ6MTt3aGl0ZS1zcGFjZTpub3dyYXA7Y3Vyc29yOmRlZmF1bHQ7Ym9yZGVyLXJhZGl1czowO2JhY2tncm91bmQ6IzIxOTllODtjb2xvcjojZmVmZWZlfS5sYWJlbC5zZWNvbmRhcnl7YmFja2dyb3VuZDojNzc3O2NvbG9yOiNmZWZlZmV9LmxhYmVsLnN1Y2Nlc3N7YmFja2dyb3VuZDojM2FkYjc2O2NvbG9yOiNmZWZlZmV9LmxhYmVsLndhcm5pbmd7YmFja2dyb3VuZDojZmZhZTAwO2NvbG9yOiNmZWZlZmV9LmxhYmVsLmFsZXJ0e2JhY2tncm91bmQ6I2VjNTg0MDtjb2xvcjojZmVmZWZlfS5tZWRpYS1vYmplY3R7bWFyZ2luLWJvdHRvbToxcmVtO2Rpc3BsYXk6YmxvY2t9Lm1lZGlhLW9iamVjdCBpbWd7bWF4LXdpZHRoOm5vbmV9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5tZWRpYS1vYmplY3Quc3RhY2stZm9yLXNtYWxsIC5tZWRpYS1vYmplY3Qtc2VjdGlvbntwYWRkaW5nOjA7cGFkZGluZy1ib3R0b206MXJlbTtkaXNwbGF5OmJsb2NrfS5tZWRpYS1vYmplY3Quc3RhY2stZm9yLXNtYWxsIC5tZWRpYS1vYmplY3Qtc2VjdGlvbiBpbWd7d2lkdGg6MTAwJX19Lm1lZGlhLW9iamVjdC1zZWN0aW9ue2Rpc3BsYXk6dGFibGUtY2VsbDt2ZXJ0aWNhbC1hbGlnbjp0b3B9Lm1lZGlhLW9iamVjdC1zZWN0aW9uOmZpcnN0LWNoaWxke3BhZGRpbmctcmlnaHQ6MXJlbX0ubWVkaWEtb2JqZWN0LXNlY3Rpb246bGFzdC1jaGlsZDpub3QoOm50aC1jaGlsZCgyKSl7cGFkZGluZy1sZWZ0OjFyZW19Lm1lZGlhLW9iamVjdC1zZWN0aW9uPjpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH0ubWVkaWEtb2JqZWN0LXNlY3Rpb24ubWlkZGxle3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWVkaWEtb2JqZWN0LXNlY3Rpb24uYm90dG9te3ZlcnRpY2FsLWFsaWduOmJvdHRvbX1ib2R5LGh0bWx7aGVpZ2h0OjEwMCV9Lm9mZi1jYW52YXMtd3JhcHBlcnt3aWR0aDoxMDAlO292ZXJmbG93LXg6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47YmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6YXV0b30ub2ZmLWNhbnZhcy13cmFwcGVyLWlubmVye3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7bWluLWhlaWdodDoxMDAlOy13ZWJraXQtdHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuNXMgZWFzZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNXMgZWFzZX0ub2ZmLWNhbnZhcy13cmFwcGVyLWlubmVyOmFmdGVyLC5vZmYtY2FudmFzLXdyYXBwZXItaW5uZXI6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGV9Lm9mZi1jYW52YXMtd3JhcHBlci1pbm5lcjphZnRlcntjbGVhcjpib3RofS5vZmYtY2FudmFzLWNvbnRlbnR7bWluLWhlaWdodDoxMDAlO2JhY2tncm91bmQ6I2ZlZmVmZTstd2Via2l0LXRyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gLjVzIGVhc2U7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjVzIGVhc2U7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjtiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjt6LWluZGV4OjE7cGFkZGluZy1ib3R0b206LjFweDtib3gtc2hhZG93OjAgMCAxMHB4IGhzbGEoMCwwJSw0JSwuNSl9LmpzLW9mZi1jYW52YXMtZXhpdHtkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZDpoc2xhKDAsMCUsMTAwJSwuMjUpO2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kIC41cyBlYXNlO3RyYW5zaXRpb246YmFja2dyb3VuZCAuNXMgZWFzZX0ub2ZmLWNhbnZhc3twb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOiNlNmU2ZTY7ei1pbmRleDotMTttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3cteTphdXRvOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAub2ZmLWNhbnZhc3tvdXRsaW5lOjB9Lm9mZi1jYW52YXMucG9zaXRpb24tbGVmdHtsZWZ0Oi0yNTBweDt0b3A6MDt3aWR0aDoyNTBweH0uaXMtb3Blbi1sZWZ0ey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMjUwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDI1MHB4KX0ub2ZmLWNhbnZhcy5wb3NpdGlvbi1yaWdodHtyaWdodDotMjUwcHg7dG9wOjA7d2lkdGg6MjUwcHh9LmlzLW9wZW4tcmlnaHR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMjUwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0yNTBweCl9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucG9zaXRpb24tbGVmdC5yZXZlYWwtZm9yLW1lZGl1bXtsZWZ0OjA7ei1pbmRleDphdXRvO3Bvc2l0aW9uOmZpeGVkfS5wb3NpdGlvbi1sZWZ0LnJldmVhbC1mb3ItbWVkaXVtfi5vZmYtY2FudmFzLWNvbnRlbnR7bWFyZ2luLWxlZnQ6MjUwcHh9LnBvc2l0aW9uLXJpZ2h0LnJldmVhbC1mb3ItbWVkaXVte3JpZ2h0OjA7ei1pbmRleDphdXRvO3Bvc2l0aW9uOmZpeGVkfS5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLW1lZGl1bX4ub2ZmLWNhbnZhcy1jb250ZW50e21hcmdpbi1yaWdodDoyNTBweH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsucG9zaXRpb24tbGVmdC5yZXZlYWwtZm9yLWxhcmdle2xlZnQ6MDt6LWluZGV4OmF1dG87cG9zaXRpb246Zml4ZWR9LnBvc2l0aW9uLWxlZnQucmV2ZWFsLWZvci1sYXJnZX4ub2ZmLWNhbnZhcy1jb250ZW50e21hcmdpbi1sZWZ0OjI1MHB4fS5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLWxhcmdle3JpZ2h0OjA7ei1pbmRleDphdXRvO3Bvc2l0aW9uOmZpeGVkfS5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLWxhcmdlfi5vZmYtY2FudmFzLWNvbnRlbnR7bWFyZ2luLXJpZ2h0OjI1MHB4fX0ub3JiaXQsLm9yYml0LWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZX0ub3JiaXQtY29udGFpbmVye21hcmdpbjowO292ZXJmbG93OmhpZGRlbjtsaXN0LXN0eWxlOm5vbmV9Lm9yYml0LXNsaWRle3dpZHRoOjEwMCU7bWF4LWhlaWdodDoxMDAlfS5vcmJpdC1zbGlkZS5uby1tb3Rpb251aS5pcy1hY3RpdmV7dG9wOjA7bGVmdDowfS5vcmJpdC1maWd1cmV7bWFyZ2luOjB9Lm9yYml0LWltYWdle21hcmdpbjowO3dpZHRoOjEwMCU7bWF4LXdpZHRoOjEwMCV9Lm9yYml0LWNhcHRpb257Ym90dG9tOjA7d2lkdGg6MTAwJTttYXJnaW4tYm90dG9tOjA7YmFja2dyb3VuZC1jb2xvcjpoc2xhKDAsMCUsNCUsLjUpfS5vcmJpdC1jYXB0aW9uLC5vcmJpdC1uZXh0LC5vcmJpdC1wcmV2aW91c3twb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjFyZW07Y29sb3I6I2ZlZmVmZX0ub3JiaXQtbmV4dCwub3JiaXQtcHJldmlvdXN7dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3otaW5kZXg6MTB9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAub3JiaXQtbmV4dCxbZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5vcmJpdC1wcmV2aW91c3tvdXRsaW5lOjB9Lm9yYml0LW5leHQ6YWN0aXZlLC5vcmJpdC1uZXh0OmZvY3VzLC5vcmJpdC1uZXh0OmhvdmVyLC5vcmJpdC1wcmV2aW91czphY3RpdmUsLm9yYml0LXByZXZpb3VzOmZvY3VzLC5vcmJpdC1wcmV2aW91czpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMCwwJSw0JSwuNSl9Lm9yYml0LXByZXZpb3Vze2xlZnQ6MH0ub3JiaXQtbmV4dHtsZWZ0OmF1dG87cmlnaHQ6MH0ub3JiaXQtYnVsbGV0c3twb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tdG9wOi44cmVtO21hcmdpbi1ib3R0b206LjhyZW07dGV4dC1hbGlnbjpjZW50ZXJ9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAub3JiaXQtYnVsbGV0c3tvdXRsaW5lOjB9Lm9yYml0LWJ1bGxldHMgYnV0dG9ue3dpZHRoOjEuMnJlbTtoZWlnaHQ6MS4ycmVtO21hcmdpbjouMXJlbTtiYWNrZ3JvdW5kLWNvbG9yOiNjYWNhY2E7Ym9yZGVyLXJhZGl1czo1MCV9Lm9yYml0LWJ1bGxldHMgYnV0dG9uLmlzLWFjdGl2ZSwub3JiaXQtYnVsbGV0cyBidXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojOGE4YThhfS5wYWdpbmF0aW9ue21hcmdpbi1sZWZ0OjA7bWFyZ2luLWJvdHRvbToxcmVtfS5wYWdpbmF0aW9uOmFmdGVyLC5wYWdpbmF0aW9uOmJlZm9yZXtjb250ZW50OicgJztkaXNwbGF5OnRhYmxlfS5wYWdpbmF0aW9uOmFmdGVye2NsZWFyOmJvdGh9LnBhZ2luYXRpb24gbGl7Zm9udC1zaXplOi44NzVyZW07bWFyZ2luLXJpZ2h0Oi4wNjI1cmVtO2JvcmRlci1yYWRpdXM6MDtkaXNwbGF5Om5vbmV9LnBhZ2luYXRpb24gbGk6Zmlyc3QtY2hpbGQsLnBhZ2luYXRpb24gbGk6bGFzdC1jaGlsZHtkaXNwbGF5OmlubGluZS1ibG9ja31AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5wYWdpbmF0aW9uIGxpe2Rpc3BsYXk6aW5saW5lLWJsb2NrfX0ucGFnaW5hdGlvbiBhLC5wYWdpbmF0aW9uIGJ1dHRvbntjb2xvcjojMGEwYTBhO2Rpc3BsYXk6YmxvY2s7cGFkZGluZzouMTg3NXJlbSAuNjI1cmVtO2JvcmRlci1yYWRpdXM6MH0ucGFnaW5hdGlvbiBhOmhvdmVyLC5wYWdpbmF0aW9uIGJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kOiNlNmU2ZTZ9LnBhZ2luYXRpb24gLmN1cnJlbnR7cGFkZGluZzouMTg3NXJlbSAuNjI1cmVtO2JhY2tncm91bmQ6IzIxOTllODtjb2xvcjojZmVmZWZlO2N1cnNvcjpkZWZhdWx0fS5wYWdpbmF0aW9uIC5kaXNhYmxlZHtwYWRkaW5nOi4xODc1cmVtIC42MjVyZW07Y29sb3I6I2NhY2FjYTtjdXJzb3I6bm90LWFsbG93ZWR9LnBhZ2luYXRpb24gLmRpc2FibGVkOmhvdmVye2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9LnBhZ2luYXRpb24gLmVsbGlwc2lzOmFmdGVye2NvbnRlbnQ6J1xcXFwyMDI2JztwYWRkaW5nOi4xODc1cmVtIC42MjVyZW07Y29sb3I6IzBhMGEwYX0ucGFnaW5hdGlvbi1wcmV2aW91cy5kaXNhYmxlZDpiZWZvcmUsLnBhZ2luYXRpb24tcHJldmlvdXMgYTpiZWZvcmV7Y29udGVudDonXFxcXEFCJztkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tcmlnaHQ6LjVyZW19LnBhZ2luYXRpb24tbmV4dC5kaXNhYmxlZDphZnRlciwucGFnaW5hdGlvbi1uZXh0IGE6YWZ0ZXJ7Y29udGVudDonXFxcXEJCJztkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tbGVmdDouNXJlbX0ucHJvZ3Jlc3N7YmFja2dyb3VuZC1jb2xvcjojY2FjYWNhO2hlaWdodDoxcmVtO21hcmdpbi1ib3R0b206MXJlbTtib3JkZXItcmFkaXVzOjB9LnByb2dyZXNzLnByaW1hcnkgLnByb2dyZXNzLW1ldGVye2JhY2tncm91bmQtY29sb3I6IzIxOTllOH0ucHJvZ3Jlc3Muc2Vjb25kYXJ5IC5wcm9ncmVzcy1tZXRlcntiYWNrZ3JvdW5kLWNvbG9yOiM3Nzd9LnByb2dyZXNzLnN1Y2Nlc3MgLnByb2dyZXNzLW1ldGVye2JhY2tncm91bmQtY29sb3I6IzNhZGI3Nn0ucHJvZ3Jlc3Mud2FybmluZyAucHJvZ3Jlc3MtbWV0ZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZhZTAwfS5wcm9ncmVzcy5hbGVydCAucHJvZ3Jlc3MtbWV0ZXJ7YmFja2dyb3VuZC1jb2xvcjojZWM1ODQwfS5wcm9ncmVzcy1tZXRlcntwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4fS5wcm9ncmVzcy1tZXRlci10ZXh0e3RvcDo1MCU7bGVmdDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLC01MCUpO3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbjowO2ZvbnQtc2l6ZTouNzVyZW07Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiNmZWZlZmU7d2hpdGUtc3BhY2U6bm93cmFwfS5zbGlkZXJ7cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0Oi41cmVtO21hcmdpbi10b3A6MS4yNXJlbTttYXJnaW4tYm90dG9tOjIuMjVyZW07YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTstbXMtdG91Y2gtYWN0aW9uOm5vbmU7dG91Y2gtYWN0aW9uOm5vbmV9LnNsaWRlci1maWxse3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtkaXNwbGF5OmlubGluZS1ibG9jazttYXgtd2lkdGg6MTAwJTtoZWlnaHQ6LjVyZW07YmFja2dyb3VuZC1jb2xvcjojY2FjYWNhOy13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjJzIGVhc2UtaW4tb3V0O3RyYW5zaXRpb246YWxsIC4ycyBlYXNlLWluLW91dH0uc2xpZGVyLWZpbGwuaXMtZHJhZ2dpbmd7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAwcyBsaW5lYXI7dHJhbnNpdGlvbjphbGwgMHMgbGluZWFyfS5zbGlkZXItaGFuZGxle3RvcDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7ei1pbmRleDoxO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjEuNHJlbTtoZWlnaHQ6MS40cmVtO2JhY2tncm91bmQtY29sb3I6IzIxOTllODstd2Via2l0LXRyYW5zaXRpb246YWxsIC4ycyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOmFsbCAuMnMgZWFzZS1pbi1vdXQ7LW1zLXRvdWNoLWFjdGlvbjptYW5pcHVsYXRpb247dG91Y2gtYWN0aW9uOm1hbmlwdWxhdGlvbjtib3JkZXItcmFkaXVzOjB9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAuc2xpZGVyLWhhbmRsZXtvdXRsaW5lOjB9LnNsaWRlci1oYW5kbGU6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTU4M2NjfS5zbGlkZXItaGFuZGxlLmlzLWRyYWdnaW5ney13ZWJraXQtdHJhbnNpdGlvbjphbGwgMHMgbGluZWFyO3RyYW5zaXRpb246YWxsIDBzIGxpbmVhcn0uc2xpZGVyLmRpc2FibGVkLC5zbGlkZXJbZGlzYWJsZWRde29wYWNpdHk6LjI1O2N1cnNvcjpub3QtYWxsb3dlZH0uc2xpZGVyLnZlcnRpY2Fse2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOi41cmVtO2hlaWdodDoxMi41cmVtO21hcmdpbjowIDEuMjVyZW07LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVZKC0xKTt0cmFuc2Zvcm06c2NhbGVZKC0xKX0uc2xpZGVyLnZlcnRpY2FsIC5zbGlkZXItZmlsbHt0b3A6MDt3aWR0aDouNXJlbTttYXgtaGVpZ2h0OjEwMCV9LnNsaWRlci52ZXJ0aWNhbCAuc2xpZGVyLWhhbmRsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjUwJTt3aWR0aDoxLjRyZW07aGVpZ2h0OjEuNHJlbTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfS5zdGlja3ktY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlfS5zdGlja3l7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9LnN0aWNreS5pcy1zdHVja3twb3NpdGlvbjpmaXhlZDt6LWluZGV4OjV9LnN0aWNreS5pcy1zdHVjay5pcy1hdC10b3B7dG9wOjB9LnN0aWNreS5pcy1zdHVjay5pcy1hdC1ib3R0b217Ym90dG9tOjB9LnN0aWNreS5pcy1hbmNob3JlZHtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OmF1dG87cmlnaHQ6YXV0b30uc3RpY2t5LmlzLWFuY2hvcmVkLmlzLWF0LWJvdHRvbXtib3R0b206MH1ib2R5LmlzLXJldmVhbC1vcGVue292ZXJmbG93OmhpZGRlbn1odG1sLmlzLXJldmVhbC1vcGVuLGh0bWwuaXMtcmV2ZWFsLW9wZW4gYm9keXttaW4taGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0ucmV2ZWFsLW92ZXJsYXl7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmZpeGVkO3RvcDowO2JvdHRvbTowO2xlZnQ6MDtyaWdodDowO3otaW5kZXg6MTAwNTtiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMCwwJSw0JSwuNDUpO292ZXJmbG93LXk6c2Nyb2xsfS5yZXZlYWx7ZGlzcGxheTpub25lO3otaW5kZXg6MTAwNjtwYWRkaW5nOjFyZW07Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZTtib3JkZXItcmFkaXVzOjA7cG9zaXRpb246cmVsYXRpdmU7dG9wOjEwMHB4O21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG87b3ZlcmZsb3cteTphdXRvfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLnJldmVhbHtvdXRsaW5lOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFse21pbi1oZWlnaHQ6MH19LnJldmVhbCAuY29sdW1uLC5yZXZlYWwgLmNvbHVtbnN7bWluLXdpZHRoOjB9LnJldmVhbD46bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFse3dpZHRoOjYwMHB4O21heC13aWR0aDo3NXJlbX19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFsIC5yZXZlYWx7bGVmdDphdXRvO3JpZ2h0OmF1dG87bWFyZ2luOjAgYXV0b319LnJldmVhbC5jb2xsYXBzZXtwYWRkaW5nOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFsLnRpbnl7d2lkdGg6MzAlO21heC13aWR0aDo3NXJlbX19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFsLnNtYWxse3dpZHRoOjUwJTttYXgtd2lkdGg6NzVyZW19fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LnJldmVhbC5sYXJnZXt3aWR0aDo5MCU7bWF4LXdpZHRoOjc1cmVtfX0ucmV2ZWFsLmZ1bGx7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7aGVpZ2h0OjEwMHZoO21pbi1oZWlnaHQ6MTAwdmg7bWF4LXdpZHRoOm5vbmU7bWFyZ2luLWxlZnQ6MDtib3JkZXI6MDtib3JkZXItcmFkaXVzOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5yZXZlYWx7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7aGVpZ2h0OjEwMHZoO21pbi1oZWlnaHQ6MTAwdmg7bWF4LXdpZHRoOm5vbmU7bWFyZ2luLWxlZnQ6MDtib3JkZXI6MDtib3JkZXItcmFkaXVzOjB9fS5yZXZlYWwud2l0aG91dC1vdmVybGF5e3Bvc2l0aW9uOmZpeGVkfS5zd2l0Y2h7aGVpZ2h0OjJyZW07bWFyZ2luLWJvdHRvbToxcmVtO291dGxpbmU6MDtwb3NpdGlvbjpyZWxhdGl2ZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7Y29sb3I6I2ZlZmVmZTtmb250LXdlaWdodDo3MDA7Zm9udC1zaXplOi44NzVyZW19LnN3aXRjaC1pbnB1dHtvcGFjaXR5OjA7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLWJvdHRvbTowfS5zd2l0Y2gtcGFkZGxle2JhY2tncm91bmQ6I2NhY2FjYTtjdXJzb3I6cG9pbnRlcjtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjRyZW07aGVpZ2h0OjJyZW07LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMjVzIGVhc2Utb3V0O3RyYW5zaXRpb246YWxsIC4yNXMgZWFzZS1vdXQ7Ym9yZGVyLXJhZGl1czowO2NvbG9yOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdH1pbnB1dCsuc3dpdGNoLXBhZGRsZXttYXJnaW46MH0uc3dpdGNoLXBhZGRsZTphZnRlcntiYWNrZ3JvdW5kOiNmZWZlZmU7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxLjVyZW07bGVmdDouMjVyZW07dG9wOi4yNXJlbTt3aWR0aDoxLjVyZW07LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMjVzIGVhc2Utb3V0O3RyYW5zaXRpb246YWxsIC4yNXMgZWFzZS1vdXQ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWigwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKTtib3JkZXItcmFkaXVzOjB9aW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZXtiYWNrZ3JvdW5kOiMyMTk5ZTh9aW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZTphZnRlcntsZWZ0OjIuMjVyZW19W2RhdGEtd2hhdGlucHV0PW1vdXNlXSBpbnB1dDpmb2N1c34uc3dpdGNoLXBhZGRsZXtvdXRsaW5lOjB9LnN3aXRjaC1hY3RpdmUsLnN3aXRjaC1pbmFjdGl2ZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9LnN3aXRjaC1hY3RpdmV7bGVmdDo4JTtkaXNwbGF5Om5vbmV9aW5wdXQ6Y2hlY2tlZCtsYWJlbD4uc3dpdGNoLWFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5zd2l0Y2gtaW5hY3RpdmV7cmlnaHQ6MTUlfWlucHV0OmNoZWNrZWQrbGFiZWw+LnN3aXRjaC1pbmFjdGl2ZXtkaXNwbGF5Om5vbmV9LnN3aXRjaC50aW55e2hlaWdodDoxLjVyZW19LnN3aXRjaC50aW55IC5zd2l0Y2gtcGFkZGxle3dpZHRoOjNyZW07aGVpZ2h0OjEuNXJlbTtmb250LXNpemU6LjYyNXJlbX0uc3dpdGNoLnRpbnkgLnN3aXRjaC1wYWRkbGU6YWZ0ZXJ7d2lkdGg6MXJlbTtoZWlnaHQ6MXJlbX0uc3dpdGNoLnRpbnkgaW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZTphZnRlcntsZWZ0OjEuNzVyZW19LnN3aXRjaC5zbWFsbHtoZWlnaHQ6MS43NXJlbX0uc3dpdGNoLnNtYWxsIC5zd2l0Y2gtcGFkZGxle3dpZHRoOjMuNXJlbTtoZWlnaHQ6MS43NXJlbTtmb250LXNpemU6Ljc1cmVtfS5zd2l0Y2guc21hbGwgLnN3aXRjaC1wYWRkbGU6YWZ0ZXJ7d2lkdGg6MS4yNXJlbTtoZWlnaHQ6MS4yNXJlbX0uc3dpdGNoLnNtYWxsIGlucHV0OmNoZWNrZWR+LnN3aXRjaC1wYWRkbGU6YWZ0ZXJ7bGVmdDoycmVtfS5zd2l0Y2gubGFyZ2V7aGVpZ2h0OjIuNXJlbX0uc3dpdGNoLmxhcmdlIC5zd2l0Y2gtcGFkZGxle3dpZHRoOjVyZW07aGVpZ2h0OjIuNXJlbTtmb250LXNpemU6MXJlbX0uc3dpdGNoLmxhcmdlIC5zd2l0Y2gtcGFkZGxlOmFmdGVye3dpZHRoOjJyZW07aGVpZ2h0OjJyZW19LnN3aXRjaC5sYXJnZSBpbnB1dDpjaGVja2Vkfi5zd2l0Y2gtcGFkZGxlOmFmdGVye2xlZnQ6Mi43NXJlbX10YWJsZXt3aWR0aDoxMDAlO21hcmdpbi1ib3R0b206MXJlbTtib3JkZXItcmFkaXVzOjB9dGFibGUgdGJvZHksdGFibGUgdGZvb3QsdGFibGUgdGhlYWR7Ym9yZGVyOjFweCBzb2xpZCAjZjFmMWYxO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZX10YWJsZSBjYXB0aW9ue2ZvbnQtd2VpZ2h0OjcwMDtwYWRkaW5nOi41cmVtIC42MjVyZW0gLjYyNXJlbX10YWJsZSB0aGVhZHtiYWNrZ3JvdW5kOiNmOGY4Zjg7Y29sb3I6IzBhMGEwYX10YWJsZSB0Zm9vdHtiYWNrZ3JvdW5kOiNmMWYxZjE7Y29sb3I6IzBhMGEwYX10YWJsZSB0Zm9vdCB0cix0YWJsZSB0aGVhZCB0cntiYWNrZ3JvdW5kOnRyYW5zcGFyZW50fXRhYmxlIHRmb290IHRkLHRhYmxlIHRmb290IHRoLHRhYmxlIHRoZWFkIHRkLHRhYmxlIHRoZWFkIHRoe3BhZGRpbmc6LjVyZW0gLjYyNXJlbSAuNjI1cmVtO2ZvbnQtd2VpZ2h0OjcwMDt0ZXh0LWFsaWduOmxlZnR9dGFibGUgdGJvZHkgdHI6bnRoLWNoaWxkKGV2ZW4pe2JhY2tncm91bmQtY29sb3I6I2YxZjFmMX10YWJsZSB0Ym9keSB0ZCx0YWJsZSB0Ym9keSB0aHtwYWRkaW5nOi41cmVtIC42MjVyZW0gLjYyNXJlbX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjYzLjkzNzVlbSl7dGFibGUuc3RhY2sgdGZvb3QsdGFibGUuc3RhY2sgdGhlYWR7ZGlzcGxheTpub25lfXRhYmxlLnN0YWNrIHRkLHRhYmxlLnN0YWNrIHRoLHRhYmxlLnN0YWNrIHRye2Rpc3BsYXk6YmxvY2t9dGFibGUuc3RhY2sgdGR7Ym9yZGVyLXRvcDowfX10YWJsZS5zY3JvbGx7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO292ZXJmbG93LXg6YXV0b310YWJsZS5ob3ZlciB0aGVhZCB0cjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmM2YzZjN9dGFibGUuaG92ZXIgdGZvb3QgdHI6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZWNlY2VjfXRhYmxlLmhvdmVyIHRib2R5IHRyOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2Y5ZjlmOX10YWJsZS5ob3ZlciB0Ym9keSB0cjpudGgtb2YtdHlwZShldmVuKTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlY2VjZWN9LnRhYmxlLXNjcm9sbHtvdmVyZmxvdy14OmF1dG99LnRhYmxlLXNjcm9sbCB0YWJsZXt3aWR0aDphdXRvfS50YWJze21hcmdpbjowO2xpc3Qtc3R5bGUtdHlwZTpub25lO2JhY2tncm91bmQ6I2ZlZmVmZTtib3JkZXI6MXB4IHNvbGlkICNlNmU2ZTZ9LnRhYnM6YWZ0ZXIsLnRhYnM6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGV9LnRhYnM6YWZ0ZXJ7Y2xlYXI6Ym90aH0udGFicy52ZXJ0aWNhbD5saXt3aWR0aDphdXRvO2Zsb2F0Om5vbmU7ZGlzcGxheTpibG9ja30udGFicy5zaW1wbGU+bGk+YXtwYWRkaW5nOjB9LnRhYnMuc2ltcGxlPmxpPmE6aG92ZXJ7YmFja2dyb3VuZDp0cmFuc3BhcmVudH0udGFicy5wcmltYXJ5e2JhY2tncm91bmQ6IzIxOTllOH0udGFicy5wcmltYXJ5PmxpPmF7Y29sb3I6I2ZlZmVmZX0udGFicy5wcmltYXJ5PmxpPmE6Zm9jdXMsLnRhYnMucHJpbWFyeT5saT5hOmhvdmVye2JhY2tncm91bmQ6IzE4OTNlNH0udGFicy10aXRsZXtmbG9hdDpsZWZ0fS50YWJzLXRpdGxlPmF7ZGlzcGxheTpibG9jaztwYWRkaW5nOjEuMjVyZW0gMS41cmVtO2xpbmUtaGVpZ2h0OjE7Zm9udC1zaXplOi43NXJlbX0udGFicy10aXRsZT5hOmhvdmVye2JhY2tncm91bmQ6I2ZlZmVmZX0udGFicy10aXRsZT5hOmZvY3VzLC50YWJzLXRpdGxlPmFbYXJpYS1zZWxlY3RlZD10cnVlXXtiYWNrZ3JvdW5kOiNlNmU2ZTZ9LnRhYnMtY29udGVudHtiYWNrZ3JvdW5kOiNmZWZlZmU7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuNXMgZWFzZTt0cmFuc2l0aW9uOmFsbCAuNXMgZWFzZTtib3JkZXI6MXB4IHNvbGlkICNlNmU2ZTY7Ym9yZGVyLXRvcDowfS50YWJzLWNvbnRlbnQudmVydGljYWx7Ym9yZGVyOjFweCBzb2xpZCAjZTZlNmU2O2JvcmRlci1sZWZ0OjB9LnRhYnMtcGFuZWx7ZGlzcGxheTpub25lO3BhZGRpbmc6MXJlbX0udGFicy1wYW5lbC5pcy1hY3RpdmV7ZGlzcGxheTpibG9ja30udGh1bWJuYWlse2JvcmRlcjo0cHggc29saWQgI2ZlZmVmZTtib3gtc2hhZG93OjAgMCAwIDFweCBoc2xhKDAsMCUsNCUsLjIpO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xpbmUtaGVpZ2h0OjA7bWF4LXdpZHRoOjEwMCU7LXdlYmtpdC10cmFuc2l0aW9uOi13ZWJraXQtYm94LXNoYWRvdyAuMnMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpib3gtc2hhZG93IC4ycyBlYXNlLW91dDtib3JkZXItcmFkaXVzOjA7bWFyZ2luLWJvdHRvbToxcmVtfS50aHVtYm5haWw6Zm9jdXMsLnRodW1ibmFpbDpob3Zlcntib3gtc2hhZG93OjAgMCA2cHggMXB4IHJnYmEoMzMsMTUzLDIzMiwuNSl9LnRpdGxlLWJhcntiYWNrZ3JvdW5kOiMwYTBhMGE7Y29sb3I6I2ZlZmVmZTtwYWRkaW5nOi41cmVtfS50aXRsZS1iYXI6YWZ0ZXIsLnRpdGxlLWJhcjpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZX0udGl0bGUtYmFyOmFmdGVye2NsZWFyOmJvdGh9LnRpdGxlLWJhciAubWVudS1pY29ue21hcmdpbi1sZWZ0Oi4yNXJlbTttYXJnaW4tcmlnaHQ6LjI1cmVtfS50aXRsZS1iYXItbGVmdHtmbG9hdDpsZWZ0fS50aXRsZS1iYXItcmlnaHR7ZmxvYXQ6cmlnaHQ7dGV4dC1hbGlnbjpyaWdodH0udGl0bGUtYmFyLXRpdGxle3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0uaGFzLXRpcCwudGl0bGUtYmFyLXRpdGxle2ZvbnQtd2VpZ2h0OjcwMDtkaXNwbGF5OmlubGluZS1ibG9ja30uaGFzLXRpcHtib3JkZXItYm90dG9tOjFweCBkb3R0ZWQgIzhhOGE4YTtwb3NpdGlvbjpyZWxhdGl2ZTtjdXJzb3I6aGVscH0udG9vbHRpcHtiYWNrZ3JvdW5kLWNvbG9yOiMwYTBhMGE7Y29sb3I6I2ZlZmVmZTtmb250LXNpemU6ODAlO3BhZGRpbmc6Ljc1cmVtO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTA7dG9wOmNhbGMoMTAwJSArIC42NDk1cmVtKTttYXgtd2lkdGg6MTByZW0haW1wb3J0YW50O2JvcmRlci1yYWRpdXM6MH0udG9vbHRpcDpiZWZvcmV7Ym9yZGVyOi43NXJlbSBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzBhMGEwYTtib3JkZXItYm90dG9tLXN0eWxlOnNvbGlkO2JvcmRlci10b3Atd2lkdGg6MDtib3R0b206MTAwJTtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfS50b29sdGlwLnRvcDpiZWZvcmUsLnRvb2x0aXA6YmVmb3Jle2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowfS50b29sdGlwLnRvcDpiZWZvcmV7Ym9yZGVyOi43NXJlbSBpbnNldDtib3JkZXItY29sb3I6IzBhMGEwYSB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDt0b3A6MTAwJTtib3R0b206YXV0b30udG9vbHRpcC5sZWZ0OmJlZm9yZXtib3JkZXI6Ljc1cmVtIGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMGEwYTBhO2JvcmRlci1sZWZ0LXN0eWxlOnNvbGlkO2JvcmRlci1yaWdodC13aWR0aDowO2xlZnQ6MTAwJX0udG9vbHRpcC5sZWZ0OmJlZm9yZSwudG9vbHRpcC5yaWdodDpiZWZvcmV7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym90dG9tOmF1dG87dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfS50b29sdGlwLnJpZ2h0OmJlZm9yZXtib3JkZXI6Ljc1cmVtIGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMGEwYTBhIHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowO2xlZnQ6YXV0bztyaWdodDoxMDAlfS50b3AtYmFye3BhZGRpbmc6LjVyZW19LnRvcC1iYXI6YWZ0ZXIsLnRvcC1iYXI6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGV9LnRvcC1iYXI6YWZ0ZXJ7Y2xlYXI6Ym90aH0udG9wLWJhciwudG9wLWJhciB1bHtiYWNrZ3JvdW5kLWNvbG9yOiNlNmU2ZTZ9LnRvcC1iYXIgaW5wdXR7bWF4LXdpZHRoOjIwMHB4O21hcmdpbi1yaWdodDoxcmVtfS50b3AtYmFyIC5pbnB1dC1ncm91cC1maWVsZHt3aWR0aDoxMDAlO21hcmdpbi1yaWdodDowfS50b3AtYmFyIGlucHV0LmJ1dHRvbnt3aWR0aDphdXRvfS50b3AtYmFyIC50b3AtYmFyLWxlZnQsLnRvcC1iYXIgLnRvcC1iYXItcmlnaHR7d2lkdGg6MTAwJX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey50b3AtYmFyIC50b3AtYmFyLWxlZnQsLnRvcC1iYXIgLnRvcC1iYXItcmlnaHR7d2lkdGg6YXV0b319QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pey50b3AtYmFyLnN0YWNrZWQtZm9yLW1lZGl1bSAudG9wLWJhci1sZWZ0LC50b3AtYmFyLnN0YWNrZWQtZm9yLW1lZGl1bSAudG9wLWJhci1yaWdodHt3aWR0aDoxMDAlfX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjc0LjkzNzVlbSl7LnRvcC1iYXIuc3RhY2tlZC1mb3ItbGFyZ2UgLnRvcC1iYXItbGVmdCwudG9wLWJhci5zdGFja2VkLWZvci1sYXJnZSAudG9wLWJhci1yaWdodHt3aWR0aDoxMDAlfX0udG9wLWJhci10aXRsZXtmbG9hdDpsZWZ0O21hcmdpbi1yaWdodDoxcmVtfS50b3AtYmFyLWxlZnR7ZmxvYXQ6bGVmdH0udG9wLWJhci1yaWdodHtmbG9hdDpyaWdodH0uaGlkZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fS5pbnZpc2libGV7dmlzaWJpbGl0eTpoaWRkZW59QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5oaWRlLWZvci1zbWFsbC1vbmx5e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MGVtKSxzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LnNob3ctZm9yLXNtYWxsLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsuaGlkZS1mb3ItbWVkaXVte2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MzkuOTM3NWVtKXsuc2hvdy1mb3ItbWVkaXVte2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSkgYW5kIChtYXgtd2lkdGg6NjMuOTM3NWVtKXsuaGlkZS1mb3ItbWVkaXVtLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pLHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsuc2hvdy1mb3ItbWVkaXVtLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsuaGlkZS1mb3ItbGFyZ2V7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pey5zaG93LWZvci1sYXJnZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pIGFuZCAobWF4LXdpZHRoOjc0LjkzNzVlbSl7LmhpZGUtZm9yLWxhcmdlLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pLHNjcmVlbiBhbmQgKG1pbi13aWR0aDo3NWVtKXsuc2hvdy1mb3ItbGFyZ2Utb25seXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX0uc2hvdy1mb3Itc3IsLnNob3ctb24tZm9jdXN7cG9zaXRpb246YWJzb2x1dGUhaW1wb3J0YW50O3dpZHRoOjFweDtoZWlnaHQ6MXB4O292ZXJmbG93OmhpZGRlbjtjbGlwOnJlY3QoMCwwLDAsMCl9LnNob3ctb24tZm9jdXM6YWN0aXZlLC5zaG93LW9uLWZvY3VzOmZvY3Vze3Bvc2l0aW9uOnN0YXRpYyFpbXBvcnRhbnQ7aGVpZ2h0OmF1dG87d2lkdGg6YXV0bztvdmVyZmxvdzp2aXNpYmxlO2NsaXA6YXV0b30uaGlkZS1mb3ItcG9ydHJhaXQsLnNob3ctZm9yLWxhbmRzY2FwZXtkaXNwbGF5OmJsb2NrIWltcG9ydGFudH1AbWVkaWEgc2NyZWVuIGFuZCAob3JpZW50YXRpb246bGFuZHNjYXBlKXsuaGlkZS1mb3ItcG9ydHJhaXQsLnNob3ctZm9yLWxhbmRzY2FwZXtkaXNwbGF5OmJsb2NrIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOnBvcnRyYWl0KXsuaGlkZS1mb3ItcG9ydHJhaXQsLnNob3ctZm9yLWxhbmRzY2FwZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX0uaGlkZS1mb3ItbGFuZHNjYXBlLC5zaG93LWZvci1wb3J0cmFpdHtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fUBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjpsYW5kc2NhcGUpey5oaWRlLWZvci1sYW5kc2NhcGUsLnNob3ctZm9yLXBvcnRyYWl0e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjpwb3J0cmFpdCl7LmhpZGUtZm9yLWxhbmRzY2FwZSwuc2hvdy1mb3ItcG9ydHJhaXR7ZGlzcGxheTpibG9jayFpbXBvcnRhbnR9fS5mbG9hdC1sZWZ0e2Zsb2F0OmxlZnQhaW1wb3J0YW50fS5mbG9hdC1yaWdodHtmbG9hdDpyaWdodCFpbXBvcnRhbnR9LmZsb2F0LWNlbnRlcntkaXNwbGF5OmJsb2NrO21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99LmNsZWFyZml4OmFmdGVyLC5jbGVhcmZpeDpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZX0uY2xlYXJmaXg6YWZ0ZXJ7Y2xlYXI6Ym90aH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMjQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9QYXJhZ29uL0Rlc2t0b3AvcHJvamVjdHMvcmVhY3QvUmVhY3RUaW1lci9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanMhLi9hcHAuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXIhLi9hcHAvc3R5bGVzL2FwcC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudG9wLWJhciwgLnRvcC1iYXIgdWwge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzMzMzsgfVxcblxcbi50b3AtYmFyIC5tZW51LXRleHQge1xcbiAgY29sb3I6IHdoaXRlOyB9XFxuXFxuLnRvcC1iYXIgLm1lbnUgPiAubWVudS10ZXh0ID4gYSB7XFxuICBkaXNwbGF5OiBpbmxpbmU7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxuLnRvcC1iYXIgLmFjdGl2ZS1saW5rIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkOyB9XFxuXFxuLmNsb2NrIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjYjVkMGUyO1xcbiAgYm9yZGVyOiAycHggc29saWQgIzIwODhlODtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBoZWlnaHQ6IDE0cmVtO1xcbiAgd2lkdGg6IDE0cmVtO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBtYXJnaW46IDRyZW0gYXV0bzsgfVxcblxcbi5jbG9jay10ZXh0IHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGZvbnQtc2l6ZTogMi4yNXJlbTtcXG4gIGZvbnQtd2VpZ2h0OiAzMDA7IH1cXG5cXG4uY29udHJvbHMge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyOyB9XFxuICAuY29udHJvbHMgLmJ1dHRvbiB7XFxuICAgIHBhZGRpbmc6IC43NXJlbSwgM3JlbTtcXG4gICAgbWFyZ2luOiAwIC43NXJlbSAwIC43NXJlbTsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyIS4vfi9zYXNzLWxvYWRlciEuL2FwcC9zdHlsZXMvYXBwLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDI1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuY2xhc3MgQ29udHJvbHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG4gICAgLy8gY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgIC8vICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgcmVuZGVyU3RhcnRTdG9wQnV0dG9uKCkge1xyXG4gICAgICAgIGNvbnN0IHsgY291bnRkb3duU3RhdHVzIH0gPSB0aGlzLnByb3BzO1xuXHJcbiAgICAgICAgaWYgKGNvdW50ZG93blN0YXR1cyA9PT0gJ3N0YXJ0ZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA8YnV0dG9uIGNsYXNzTmFtZT1cImJ1dHRvbiBzZWNvbmRhcnlcIiBvbkNsaWNrPXsoKSA9PiB0aGlzLm9uU3RhdHVzQ2hhbmdlKCdwYXVzZWQnKX0+UGF1c2U8L2J1dHRvbj47XHJcbiAgICAgICAgfSBlbHNlIGlmIChjb3VudGRvd25TdGF0dXMgPT09ICdwYXVzZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA8YnV0dG9uIGNsYXNzTmFtZT1cImJ1dHRvbiBwcmltYXJ5XCIgb25DbGljaz17KCkgPT4gdGhpcy5vblN0YXR1c0NoYW5nZSgnc3RhcnRlZCcpfT5TdGFydDwvYnV0dG9uPjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25TdGF0dXNDaGFuZ2UobmV3U3RhdHVzKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5vblN0YXR1c0NoYW5nZShuZXdTdGF0dXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XHJcbiAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJTdGFydFN0b3BCdXR0b24oKX1cclxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnV0dG9uIGFsZXJ0IGhvbGxvd1wiIG9uQ2xpY2s9eygpID0+IHRoaXMub25TdGF0dXNDaGFuZ2UoJ3N0b3BwZWQnKX0+Q2xlYXI8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuQ29udHJvbHMucHJvcFR5cGVzID0ge1xyXG4gICAgY291bnRkb3duU3RhdHVzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgICBvblN0YXR1c0NoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29udHJvbHM7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0M6L1VzZXJzL1BhcmFnb24vRGVza3RvcC9wcm9qZWN0cy9yZWFjdC9SZWFjdFRpbWVyL2FwcC9jb21wb25lbnRzL0NvbnRyb2xzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==